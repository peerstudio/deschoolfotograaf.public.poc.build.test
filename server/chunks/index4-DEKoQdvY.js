import * as path from 'node:path';
import { fileURLToPath } from 'node:url';
import * as runtime from '@prisma/client/runtime/client';
import { g as getAugmentedNamespace, c as commonjsGlobal, a as getDefaultExportFromCjs } from './_commonjsHelpers-Bi63GUIs.js';
import { createRequire } from 'node:module';
import require$$1$1 from 'tty';
import require$$5$1 from 'util';
import require$$0$4 from 'os';
import require$$0$5 from 'events';
import require$$4$1 from 'timers';
import require$$0$6 from 'stream';
import crypto$1 from 'crypto';
import require$$1$3 from 'tls';
import require$$0$9 from 'net';
import require$$0$b from 'dns';
import require$$5$3 from 'constants';
import require$$0$8 from 'http';
import require$$1$2 from 'https';
import require$$0$7 from 'buffer';
import require$$6$1 from 'fs';
import require$$7$1 from 'path';
import require$$2$2 from 'assert';
import require$$5$2 from 'url';
import require$$3$1 from 'child_process';
import require$$0$a from 'dgram';
import require$$1$4 from 'string_decoder';
import { b as private_env } from './shared-server-hveoYw5P.js';

var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// ../../node_modules/.pnpm/kleur@4.1.5/node_modules/kleur/colors.mjs
var colors_exports = {};
__export(colors_exports, {
  $: () => $,
  bgBlack: () => bgBlack,
  bgBlue: () => bgBlue,
  bgCyan: () => bgCyan,
  bgGreen: () => bgGreen,
  bgMagenta: () => bgMagenta,
  bgRed: () => bgRed,
  bgWhite: () => bgWhite,
  bgYellow: () => bgYellow,
  black: () => black,
  blue: () => blue,
  bold: () => bold,
  cyan: () => cyan,
  dim: () => dim,
  gray: () => gray,
  green: () => green,
  grey: () => grey,
  hidden: () => hidden,
  inverse: () => inverse,
  italic: () => italic,
  magenta: () => magenta,
  red: () => red,
  reset: () => reset,
  strikethrough: () => strikethrough,
  underline: () => underline,
  white: () => white,
  yellow: () => yellow
});
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY)
};
function init$1(x, y) {
  let rgx = new RegExp(`\\x1b\\[${y}m`, "g");
  let open = `\x1B[${x}m`, close = `\x1B[${y}m`;
  return function(txt) {
    if (!$.enabled || txt == null) return txt;
    return open + (!!~("" + txt).indexOf(close) ? txt.replace(rgx, close + open) : txt) + close;
  };
}
var reset = init$1(0, 0);
var bold = init$1(1, 22);
var dim = init$1(2, 22);
var italic = init$1(3, 23);
var underline = init$1(4, 24);
var inverse = init$1(7, 27);
var hidden = init$1(8, 28);
var strikethrough = init$1(9, 29);
var black = init$1(30, 39);
var red = init$1(31, 39);
var green = init$1(32, 39);
var yellow = init$1(33, 39);
var blue = init$1(34, 39);
var magenta = init$1(35, 39);
var cyan = init$1(36, 39);
var white = init$1(37, 39);
var gray = init$1(90, 39);
var grey = init$1(90, 39);
var bgBlack = init$1(40, 49);
var bgRed = init$1(41, 49);
var bgGreen = init$1(42, 49);
var bgYellow = init$1(43, 49);
var bgBlue = init$1(44, 49);
var bgMagenta = init$1(45, 49);
var bgCyan = init$1(46, 49);
var bgWhite = init$1(47, 49);

// src/index.ts
var MAX_ARGS_HISTORY = 100;
var COLORS = ["green", "yellow", "blue", "magenta", "cyan", "red"];
var argsHistory = [];
var lastTimestamp = Date.now();
var lastColor = 0;
var processEnv = typeof process !== "undefined" ? process.env : {};
globalThis.DEBUG ??= processEnv.DEBUG ?? "";
globalThis.DEBUG_COLORS ??= processEnv.DEBUG_COLORS ? processEnv.DEBUG_COLORS === "true" : true;
var topProps = {
  enable(namespace) {
    if (typeof namespace === "string") {
      globalThis.DEBUG = namespace;
    }
  },
  disable() {
    const prev = globalThis.DEBUG;
    globalThis.DEBUG = "";
    return prev;
  },
  // this is the core logic to check if logging should happen or not
  enabled(namespace) {
    const listenedNamespaces = globalThis.DEBUG.split(",").map((s) => {
      return s.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
    });
    const isListened = listenedNamespaces.some((listenedNamespace) => {
      if (listenedNamespace === "" || listenedNamespace[0] === "-") return false;
      return namespace.match(RegExp(listenedNamespace.split("*").join(".*") + "$"));
    });
    const isExcluded = listenedNamespaces.some((listenedNamespace) => {
      if (listenedNamespace === "" || listenedNamespace[0] !== "-") return false;
      return namespace.match(RegExp(listenedNamespace.slice(1).split("*").join(".*") + "$"));
    });
    return isListened && !isExcluded;
  },
  log: (...args) => {
    const [namespace, format, ...rest] = args;
    const logWithFormatting = console.warn ?? console.log;
    logWithFormatting(`${namespace} ${format}`, ...rest);
  },
  formatters: {}
  // not implemented
};
function debugCreate(namespace) {
  const instanceProps = {
    color: COLORS[lastColor++ % COLORS.length],
    enabled: topProps.enabled(namespace),
    namespace,
    log: topProps.log,
    extend: () => {
    }
    // not implemented
  };
  const debugCall = (...args) => {
    const { enabled, namespace: namespace2, color, log } = instanceProps;
    if (args.length !== 0) {
      argsHistory.push([namespace2, ...args]);
    }
    if (argsHistory.length > MAX_ARGS_HISTORY) {
      argsHistory.shift();
    }
    if (topProps.enabled(namespace2) || enabled) {
      const stringArgs = args.map((arg) => {
        if (typeof arg === "string") {
          return arg;
        }
        return safeStringify(arg);
      });
      const ms = `+${Date.now() - lastTimestamp}ms`;
      lastTimestamp = Date.now();
      if (globalThis.DEBUG_COLORS) {
        log(colors_exports[color](bold(namespace2)), ...stringArgs, colors_exports[color](ms));
      } else {
        log(namespace2, ...stringArgs, ms);
      }
    }
  };
  return new Proxy(debugCall, {
    get: (_, prop) => instanceProps[prop],
    set: (_, prop, value) => instanceProps[prop] = value
  });
}
var Debug = new Proxy(debugCreate, {
  get: (_, prop) => topProps[prop],
  set: (_, prop, value) => topProps[prop] = value
});
function safeStringify(value, indent = 2) {
  const cache = /* @__PURE__ */ new Set();
  return JSON.stringify(
    value,
    (key, value2) => {
      if (typeof value2 === "object" && value2 !== null) {
        if (cache.has(value2)) {
          return `[Circular *]`;
        }
        cache.add(value2);
      } else if (typeof value2 === "bigint") {
        return value2.toString();
      }
      return value2;
    },
    indent
  );
}

// src/debug.ts

// src/error.ts
var DriverAdapterError = class extends Error {
  name = "DriverAdapterError";
  cause;
  constructor(payload) {
    super(typeof payload["message"] === "string" ? payload["message"] : payload.kind);
    this.cause = payload;
  }
};

// src/binder.ts
Debug("driver-adapter-utils");

// src/const.ts
var ColumnTypeEnum = {
  // Scalars
  Int32: 0,
  Int64: 1,
  Float: 2,
  Double: 3,
  Numeric: 4,
  Boolean: 5,
  Text: 7,
  Date: 8,
  Time: 9,
  DateTime: 10,
  Bytes: 13,
  Uuid: 15};

const E_CANCELED = new Error('request for lock canceled');

var __awaiter$2 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Semaphore {
    constructor(_value, _cancelError = E_CANCELED) {
        this._value = _value;
        this._cancelError = _cancelError;
        this._queue = [];
        this._weightedWaiters = [];
    }
    acquire(weight = 1, priority = 0) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        return new Promise((resolve, reject) => {
            const task = { resolve, reject, weight, priority };
            const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
            if (i === -1 && weight <= this._value) {
                // Needs immediate dispatch, skip the queue
                this._dispatchItem(task);
            }
            else {
                this._queue.splice(i + 1, 0, task);
            }
        });
    }
    runExclusive(callback_1) {
        return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
            const [value, release] = yield this.acquire(weight, priority);
            try {
                return yield callback(value);
            }
            finally {
                release();
            }
        });
    }
    waitForUnlock(weight = 1, priority = 0) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        if (this._couldLockImmediately(weight, priority)) {
            return Promise.resolve();
        }
        else {
            return new Promise((resolve) => {
                if (!this._weightedWaiters[weight - 1])
                    this._weightedWaiters[weight - 1] = [];
                insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
            });
        }
    }
    isLocked() {
        return this._value <= 0;
    }
    getValue() {
        return this._value;
    }
    setValue(value) {
        this._value = value;
        this._dispatchQueue();
    }
    release(weight = 1) {
        if (weight <= 0)
            throw new Error(`invalid weight ${weight}: must be positive`);
        this._value += weight;
        this._dispatchQueue();
    }
    cancel() {
        this._queue.forEach((entry) => entry.reject(this._cancelError));
        this._queue = [];
    }
    _dispatchQueue() {
        this._drainUnlockWaiters();
        while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
            this._dispatchItem(this._queue.shift());
            this._drainUnlockWaiters();
        }
    }
    _dispatchItem(item) {
        const previousValue = this._value;
        this._value -= item.weight;
        item.resolve([previousValue, this._newReleaser(item.weight)]);
    }
    _newReleaser(weight) {
        let called = false;
        return () => {
            if (called)
                return;
            called = true;
            this.release(weight);
        };
    }
    _drainUnlockWaiters() {
        if (this._queue.length === 0) {
            for (let weight = this._value; weight > 0; weight--) {
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters)
                    continue;
                waiters.forEach((waiter) => waiter.resolve());
                this._weightedWaiters[weight - 1] = [];
            }
        }
        else {
            const queuedPriority = this._queue[0].priority;
            for (let weight = this._value; weight > 0; weight--) {
                const waiters = this._weightedWaiters[weight - 1];
                if (!waiters)
                    continue;
                const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
                (i === -1 ? waiters : waiters.splice(0, i))
                    .forEach((waiter => waiter.resolve()));
            }
        }
    }
    _couldLockImmediately(weight, priority) {
        return (this._queue.length === 0 || this._queue[0].priority < priority) &&
            weight <= this._value;
    }
}
function insertSorted(a, v) {
    const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
    a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
    for (let i = a.length - 1; i >= 0; i--) {
        if (predicate(a[i])) {
            return i;
        }
    }
    return -1;
}

var __awaiter$1 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Mutex {
    constructor(cancelError) {
        this._semaphore = new Semaphore(1, cancelError);
    }
    acquire() {
        return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
            const [, releaser] = yield this._semaphore.acquire(1, priority);
            return releaser;
        });
    }
    runExclusive(callback, priority = 0) {
        return this._semaphore.runExclusive(() => callback(), 1, priority);
    }
    isLocked() {
        return this._semaphore.isLocked();
    }
    waitForUnlock(priority = 0) {
        return this._semaphore.waitForUnlock(1, priority);
    }
    release() {
        if (this._semaphore.isLocked())
            this._semaphore.release();
    }
    cancel() {
        return this._semaphore.cancel();
    }
}

var tedious$1 = {exports: {}};

var base = {exports: {}};

const require$c = createRequire(import.meta.url);
function __require$b() { return require$c("node:events"); }

var src = {exports: {}};

var browser = {exports: {}};

/**
 * Helpers.
 */

var ms;
var hasRequiredMs;

function requireMs () {
	if (hasRequiredMs) return ms;
	hasRequiredMs = 1;
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;

	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */

	ms = function (val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};

	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */

	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}

	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}

	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */

	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}

	/**
	 * Pluralization helper.
	 */

	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}
	return ms;
}

var common;
var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */

	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = requireMs();
		createDebug.destroy = destroy;

		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});

		/**
		* The currently active debug mode names, and names to skip.
		*/

		createDebug.names = [];
		createDebug.skips = [];

		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};

		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;

			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}

			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;

		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
			let namespacesCache;
			let enabledCache;

			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}

				const self = debug;

				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;

				args[0] = createDebug.coerce(args[0]);

				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}

				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);

						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});

				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);

				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}

			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => {
					if (enableOverride !== null) {
						return enableOverride;
					}
					if (namespacesCache !== createDebug.namespaces) {
						namespacesCache = createDebug.namespaces;
						enabledCache = createDebug.enabled(namespace);
					}

					return enabledCache;
				},
				set: v => {
					enableOverride = v;
				}
			});

			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}

			return debug;
		}

		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}

		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
			createDebug.namespaces = namespaces;

			createDebug.names = [];
			createDebug.skips = [];

			const split = (typeof namespaces === 'string' ? namespaces : '')
				.trim()
				.replace(/\s+/g, ',')
				.split(',')
				.filter(Boolean);

			for (const ns of split) {
				if (ns[0] === '-') {
					createDebug.skips.push(ns.slice(1));
				} else {
					createDebug.names.push(ns);
				}
			}
		}

		/**
		 * Checks if the given string matches a namespace template, honoring
		 * asterisks as wildcards.
		 *
		 * @param {String} search
		 * @param {String} template
		 * @return {Boolean}
		 */
		function matchesTemplate(search, template) {
			let searchIndex = 0;
			let templateIndex = 0;
			let starIndex = -1;
			let matchIndex = 0;

			while (searchIndex < search.length) {
				if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
					// Match character or proceed with wildcard
					if (template[templateIndex] === '*') {
						starIndex = templateIndex;
						matchIndex = searchIndex;
						templateIndex++; // Skip the '*'
					} else {
						searchIndex++;
						templateIndex++;
					}
				} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
					// Backtrack to the last '*' and try to match more characters
					templateIndex = starIndex + 1;
					matchIndex++;
					searchIndex = matchIndex;
				} else {
					return false; // No match
				}
			}

			// Handle trailing '*' in template
			while (templateIndex < template.length && template[templateIndex] === '*') {
				templateIndex++;
			}

			return templateIndex === template.length;
		}

		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names,
				...createDebug.skips.map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}

		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			for (const skip of createDebug.skips) {
				if (matchesTemplate(name, skip)) {
					return false;
				}
			}

			for (const ns of createDebug.names) {
				if (matchesTemplate(name, ns)) {
					return true;
				}
			}

			return false;
		}

		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}

		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}

		createDebug.enable(createDebug.load());

		return createDebug;
	}

	common = setup;
	return common;
}

/* eslint-env browser */

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser.exports;
	hasRequiredBrowser = 1;
	(function (module, exports$1) {
		/**
		 * This is the web browser implementation of `debug()`.
		 */

		exports$1.formatArgs = formatArgs;
		exports$1.save = save;
		exports$1.load = load;
		exports$1.useColors = useColors;
		exports$1.storage = localstorage();
		exports$1.destroy = (() => {
			let warned = false;

			return () => {
				if (!warned) {
					warned = true;
					console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
				}
			};
		})();

		/**
		 * Colors.
		 */

		exports$1.colors = [
			'#0000CC',
			'#0000FF',
			'#0033CC',
			'#0033FF',
			'#0066CC',
			'#0066FF',
			'#0099CC',
			'#0099FF',
			'#00CC00',
			'#00CC33',
			'#00CC66',
			'#00CC99',
			'#00CCCC',
			'#00CCFF',
			'#3300CC',
			'#3300FF',
			'#3333CC',
			'#3333FF',
			'#3366CC',
			'#3366FF',
			'#3399CC',
			'#3399FF',
			'#33CC00',
			'#33CC33',
			'#33CC66',
			'#33CC99',
			'#33CCCC',
			'#33CCFF',
			'#6600CC',
			'#6600FF',
			'#6633CC',
			'#6633FF',
			'#66CC00',
			'#66CC33',
			'#9900CC',
			'#9900FF',
			'#9933CC',
			'#9933FF',
			'#99CC00',
			'#99CC33',
			'#CC0000',
			'#CC0033',
			'#CC0066',
			'#CC0099',
			'#CC00CC',
			'#CC00FF',
			'#CC3300',
			'#CC3333',
			'#CC3366',
			'#CC3399',
			'#CC33CC',
			'#CC33FF',
			'#CC6600',
			'#CC6633',
			'#CC9900',
			'#CC9933',
			'#CCCC00',
			'#CCCC33',
			'#FF0000',
			'#FF0033',
			'#FF0066',
			'#FF0099',
			'#FF00CC',
			'#FF00FF',
			'#FF3300',
			'#FF3333',
			'#FF3366',
			'#FF3399',
			'#FF33CC',
			'#FF33FF',
			'#FF6600',
			'#FF6633',
			'#FF9900',
			'#FF9933',
			'#FFCC00',
			'#FFCC33'
		];

		/**
		 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
		 * and the Firebug extension (any Firefox version) are known
		 * to support "%c" CSS customizations.
		 *
		 * TODO: add a `localStorage` variable to explicitly enable/disable colors
		 */

		// eslint-disable-next-line complexity
		function useColors() {
			// NB: In an Electron preload script, document will be defined but not fully
			// initialized. Since we know we're in Chrome, we'll just detect this case
			// explicitly
			if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
				return true;
			}

			// Internet Explorer and Edge do not support colors.
			if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
				return false;
			}

			let m;

			// Is webkit? http://stackoverflow.com/a/16459606/376773
			// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
			// eslint-disable-next-line no-return-assign
			return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
				// Is firebug? http://stackoverflow.com/a/398120/376773
				(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
				// Is firefox >= v31?
				// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
				(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
				// Double check webkit in userAgent just in case we are in a worker
				(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
		}

		/**
		 * Colorize log arguments if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			args[0] = (this.useColors ? '%c' : '') +
				this.namespace +
				(this.useColors ? ' %c' : ' ') +
				args[0] +
				(this.useColors ? '%c ' : ' ') +
				'+' + module.exports.humanize(this.diff);

			if (!this.useColors) {
				return;
			}

			const c = 'color: ' + this.color;
			args.splice(1, 0, c, 'color: inherit');

			// The final "%c" is somewhat tricky, because there could be other
			// arguments passed either before or after the %c, so we need to
			// figure out the correct index to insert the CSS into
			let index = 0;
			let lastC = 0;
			args[0].replace(/%[a-zA-Z%]/g, match => {
				if (match === '%%') {
					return;
				}
				index++;
				if (match === '%c') {
					// We only are interested in the *last* %c
					// (the user may have provided their own)
					lastC = index;
				}
			});

			args.splice(lastC, 0, c);
		}

		/**
		 * Invokes `console.debug()` when available.
		 * No-op when `console.debug` is not a "function".
		 * If `console.debug` is not available, falls back
		 * to `console.log`.
		 *
		 * @api public
		 */
		exports$1.log = console.debug || console.log || (() => {});

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			try {
				if (namespaces) {
					exports$1.storage.setItem('debug', namespaces);
				} else {
					exports$1.storage.removeItem('debug');
				}
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */
		function load() {
			let r;
			try {
				r = exports$1.storage.getItem('debug') || exports$1.storage.getItem('DEBUG') ;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}

			// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
			if (!r && typeof process !== 'undefined' && 'env' in process) {
				r = process.env.DEBUG;
			}

			return r;
		}

		/**
		 * Localstorage attempts to return the localstorage.
		 *
		 * This is necessary because safari throws
		 * when a user disables cookies/localstorage
		 * and you attempt to access it.
		 *
		 * @return {LocalStorage}
		 * @api private
		 */

		function localstorage() {
			try {
				// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
				// The Browser also has localStorage in the global context.
				return localStorage;
			} catch (error) {
				// Swallow
				// XXX (@Qix-) should we be logging these?
			}
		}

		module.exports = requireCommon()(exports$1);

		const {formatters} = module.exports;

		/**
		 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
		 */

		formatters.j = function (v) {
			try {
				return JSON.stringify(v);
			} catch (error) {
				return '[UnexpectedJSONParseError]: ' + error.message;
			}
		}; 
	} (browser, browser.exports));
	return browser.exports;
}

var node = {exports: {}};

var hasFlag;
var hasRequiredHasFlag;

function requireHasFlag () {
	if (hasRequiredHasFlag) return hasFlag;
	hasRequiredHasFlag = 1;

	hasFlag = (flag, argv = process.argv) => {
		const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
		const position = argv.indexOf(prefix + flag);
		const terminatorPosition = argv.indexOf('--');
		return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
	};
	return hasFlag;
}

var supportsColor_1;
var hasRequiredSupportsColor;

function requireSupportsColor () {
	if (hasRequiredSupportsColor) return supportsColor_1;
	hasRequiredSupportsColor = 1;
	const os = require$$0$4;
	const tty = require$$1$1;
	const hasFlag = requireHasFlag();

	const {env} = process;

	let forceColor;
	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false') ||
		hasFlag('color=never')) {
		forceColor = 0;
	} else if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		forceColor = 1;
	}

	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			forceColor = 1;
		} else if (env.FORCE_COLOR === 'false') {
			forceColor = 0;
		} else {
			forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
		}
	}

	function translateLevel(level) {
		if (level === 0) {
			return false;
		}

		return {
			level,
			hasBasic: true,
			has256: level >= 2,
			has16m: level >= 3
		};
	}

	function supportsColor(haveStream, streamIsTTY) {
		if (forceColor === 0) {
			return 0;
		}

		if (hasFlag('color=16m') ||
			hasFlag('color=full') ||
			hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}

		if (haveStream && !streamIsTTY && forceColor === undefined) {
			return 0;
		}

		const min = forceColor || 0;

		if (env.TERM === 'dumb') {
			return min;
		}

		if (process.platform === 'win32') {
			// Windows 10 build 10586 is the first Windows release that supports 256 colors.
			// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
			const osRelease = os.release().split('.');
			if (
				Number(osRelease[0]) >= 10 &&
				Number(osRelease[2]) >= 10586
			) {
				return Number(osRelease[2]) >= 14931 ? 3 : 2;
			}

			return 1;
		}

		if ('CI' in env) {
			if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
				return 1;
			}

			return min;
		}

		if ('TEAMCITY_VERSION' in env) {
			return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
		}

		if (env.COLORTERM === 'truecolor') {
			return 3;
		}

		if ('TERM_PROGRAM' in env) {
			const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

			switch (env.TERM_PROGRAM) {
				case 'iTerm.app':
					return version >= 3 ? 3 : 2;
				case 'Apple_Terminal':
					return 2;
				// No default
			}
		}

		if (/-256(color)?$/i.test(env.TERM)) {
			return 2;
		}

		if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
			return 1;
		}

		if ('COLORTERM' in env) {
			return 1;
		}

		return min;
	}

	function getSupportLevel(stream) {
		const level = supportsColor(stream, stream && stream.isTTY);
		return translateLevel(level);
	}

	supportsColor_1 = {
		supportsColor: getSupportLevel,
		stdout: translateLevel(supportsColor(true, tty.isatty(1))),
		stderr: translateLevel(supportsColor(true, tty.isatty(2)))
	};
	return supportsColor_1;
}

/**
 * Module dependencies.
 */

var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node.exports;
	hasRequiredNode = 1;
	(function (module, exports$1) {
		const tty = require$$1$1;
		const util = require$$5$1;

		/**
		 * This is the Node.js implementation of `debug()`.
		 */

		exports$1.init = init;
		exports$1.log = log;
		exports$1.formatArgs = formatArgs;
		exports$1.save = save;
		exports$1.load = load;
		exports$1.useColors = useColors;
		exports$1.destroy = util.deprecate(
			() => {},
			'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
		);

		/**
		 * Colors.
		 */

		exports$1.colors = [6, 2, 3, 4, 5, 1];

		try {
			// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
			// eslint-disable-next-line import/no-extraneous-dependencies
			const supportsColor = requireSupportsColor();

			if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
				exports$1.colors = [
					20,
					21,
					26,
					27,
					32,
					33,
					38,
					39,
					40,
					41,
					42,
					43,
					44,
					45,
					56,
					57,
					62,
					63,
					68,
					69,
					74,
					75,
					76,
					77,
					78,
					79,
					80,
					81,
					92,
					93,
					98,
					99,
					112,
					113,
					128,
					129,
					134,
					135,
					148,
					149,
					160,
					161,
					162,
					163,
					164,
					165,
					166,
					167,
					168,
					169,
					170,
					171,
					172,
					173,
					178,
					179,
					184,
					185,
					196,
					197,
					198,
					199,
					200,
					201,
					202,
					203,
					204,
					205,
					206,
					207,
					208,
					209,
					214,
					215,
					220,
					221
				];
			}
		} catch (error) {
			// Swallow - we only care if `supports-color` is available; it doesn't have to be.
		}

		/**
		 * Build up the default `inspectOpts` object from the environment variables.
		 *
		 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
		 */

		exports$1.inspectOpts = Object.keys(process.env).filter(key => {
			return /^debug_/i.test(key);
		}).reduce((obj, key) => {
			// Camel-case
			const prop = key
				.substring(6)
				.toLowerCase()
				.replace(/_([a-z])/g, (_, k) => {
					return k.toUpperCase();
				});

			// Coerce string value into JS value
			let val = process.env[key];
			if (/^(yes|on|true|enabled)$/i.test(val)) {
				val = true;
			} else if (/^(no|off|false|disabled)$/i.test(val)) {
				val = false;
			} else if (val === 'null') {
				val = null;
			} else {
				val = Number(val);
			}

			obj[prop] = val;
			return obj;
		}, {});

		/**
		 * Is stdout a TTY? Colored output is enabled when `true`.
		 */

		function useColors() {
			return 'colors' in exports$1.inspectOpts ?
				Boolean(exports$1.inspectOpts.colors) :
				tty.isatty(process.stderr.fd);
		}

		/**
		 * Adds ANSI color escape codes if enabled.
		 *
		 * @api public
		 */

		function formatArgs(args) {
			const {namespace: name, useColors} = this;

			if (useColors) {
				const c = this.color;
				const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
				const prefix = `  ${colorCode};1m${name} \u001B[0m`;

				args[0] = prefix + args[0].split('\n').join('\n' + prefix);
				args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
			} else {
				args[0] = getDate() + name + ' ' + args[0];
			}
		}

		function getDate() {
			if (exports$1.inspectOpts.hideDate) {
				return '';
			}
			return new Date().toISOString() + ' ';
		}

		/**
		 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
		 */

		function log(...args) {
			return process.stderr.write(util.formatWithOptions(exports$1.inspectOpts, ...args) + '\n');
		}

		/**
		 * Save `namespaces`.
		 *
		 * @param {String} namespaces
		 * @api private
		 */
		function save(namespaces) {
			if (namespaces) {
				process.env.DEBUG = namespaces;
			} else {
				// If you set a process.env field to null or undefined, it gets cast to the
				// string 'null' or 'undefined'. Just delete instead.
				delete process.env.DEBUG;
			}
		}

		/**
		 * Load `namespaces`.
		 *
		 * @return {String} returns the previously persisted debug modes
		 * @api private
		 */

		function load() {
			return process.env.DEBUG;
		}

		/**
		 * Init logic for `debug` instances.
		 *
		 * Create a new `inspectOpts` object in case `useColors` is set
		 * differently for a particular `debug` instance.
		 */

		function init(debug) {
			debug.inspectOpts = {};

			const keys = Object.keys(exports$1.inspectOpts);
			for (let i = 0; i < keys.length; i++) {
				debug.inspectOpts[keys[i]] = exports$1.inspectOpts[keys[i]];
			}
		}

		module.exports = requireCommon()(exports$1);

		const {formatters} = module.exports;

		/**
		 * Map %o to `util.inspect()`, all on a single line.
		 */

		formatters.o = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts)
				.split('\n')
				.map(str => str.trim())
				.join(' ');
		};

		/**
		 * Map %O to `util.inspect()`, allowing multiple lines if needed.
		 */

		formatters.O = function (v) {
			this.inspectOpts.colors = this.useColors;
			return util.inspect(v, this.inspectOpts);
		}; 
	} (node, node.exports));
	return node.exports;
}

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

var hasRequiredSrc;

function requireSrc () {
	if (hasRequiredSrc) return src.exports;
	hasRequiredSrc = 1;
	if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
		src.exports = requireBrowser();
	} else {
		src.exports = requireNode();
	}
	return src.exports;
}

var lib$2 = {};

var connectionString = {};

var hasRequiredConnectionString;

function requireConnectionString () {
	if (hasRequiredConnectionString) return connectionString;
	hasRequiredConnectionString = 1;
	Object.defineProperty(connectionString, "__esModule", { value: true });
	var CollectionMode;
	(function (CollectionMode) {
	    CollectionMode[CollectionMode["key"] = 0] = "key";
	    CollectionMode[CollectionMode["value"] = 1] = "value";
	})(CollectionMode || (CollectionMode = {}));
	const CONFIG = Object.freeze({
	    key: {
	        terminator: '=',
	        quotes: {},
	    },
	    value: {
	        terminator: ';',
	        quotes: {
	            '"': '"',
	            "'": "'",
	            '{': '}',
	        },
	    },
	});
	function connectionStringParser(connectionString, parserConfig = CONFIG) {
	    const parsed = {};
	    let collectionMode = CollectionMode.key;
	    let started = false;
	    let finished = false;
	    let quoted = false;
	    let quote = '';
	    let buffer = '';
	    let currentKey = '';
	    let pointer = 0;
	    function start() {
	        started = true;
	    }
	    function finish() {
	        finished = true;
	    }
	    function reset() {
	        started = false;
	        finished = false;
	        quoted = false;
	        quote = '';
	        buffer = '';
	    }
	    function config() {
	        return collectionMode === CollectionMode.key ? parserConfig.key : parserConfig.value;
	    }
	    function isTerminator(char) {
	        return config().terminator === char;
	    }
	    function isStartQuote(char) {
	        return Object.keys(config().quotes).some((val) => char === val);
	    }
	    function isEndQuote(char) {
	        return quoted && char === config().quotes[quote];
	    }
	    function push(char) {
	        buffer += char;
	    }
	    function collect() {
	        if (!quoted) {
	            buffer = buffer.trim();
	        }
	        switch (collectionMode) {
	            case CollectionMode.key:
	                currentKey = buffer.toLowerCase();
	                collectionMode = CollectionMode.value;
	                break;
	            case CollectionMode.value:
	                collectionMode = CollectionMode.key;
	                parsed[currentKey] = buffer;
	                currentKey = '';
	                break;
	        }
	        reset();
	    }
	    while (pointer < connectionString.length) {
	        const current = connectionString.charAt(pointer);
	        if (!finished) {
	            if (!started) {
	                if (current.trim()) {
	                    start();
	                    if (isStartQuote(current)) {
	                        quoted = true;
	                        quote = current;
	                    }
	                    else {
	                        push(current);
	                    }
	                }
	            }
	            else {
	                if (quoted && isEndQuote(current)) {
	                    const next = connectionString.charAt(pointer + 1);
	                    if (current === next) {
	                        push(current);
	                        pointer++;
	                    }
	                    else {
	                        finish();
	                    }
	                }
	                else if (!quoted && isTerminator(current)) {
	                    const next = connectionString.charAt(pointer + 1);
	                    if (current === next) {
	                        push(current);
	                        pointer++;
	                    }
	                    else {
	                        collect();
	                    }
	                }
	                else {
	                    push(current);
	                }
	            }
	        }
	        else if (isTerminator(current)) {
	            collect();
	        }
	        else if (current.trim()) {
	            throw new Error('Malformed connection string');
	        }
	        pointer++;
	    }
	    if (quoted && !finished) {
	        throw new Error('Connection string terminated unexpectedly');
	    }
	    else {
	        collect();
	    }
	    return parsed;
	}
	connectionString.default = connectionStringParser;
	
	return connectionString;
}

var sqlConnectionString = {};

var hasRequiredSqlConnectionString;

function requireSqlConnectionString () {
	if (hasRequiredSqlConnectionString) return sqlConnectionString;
	hasRequiredSqlConnectionString = 1;
	(function (exports$1) {
		var __importDefault = (sqlConnectionString && sqlConnectionString.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.SCHEMA = exports$1.SchemaTypes = void 0;
		const connection_string_1 = __importDefault(requireConnectionString());
		var SchemaTypes;
		(function (SchemaTypes) {
		    SchemaTypes[SchemaTypes["BOOL"] = 0] = "BOOL";
		    SchemaTypes[SchemaTypes["STRING"] = 1] = "STRING";
		    SchemaTypes[SchemaTypes["NUMBER"] = 2] = "NUMBER";
		})(SchemaTypes = exports$1.SchemaTypes || (exports$1.SchemaTypes = {}));
		// schema for MSSQL connection strings (https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection.connectionstring)
		exports$1.SCHEMA = {
		    'Application Name': {
		        type: SchemaTypes.STRING,
		        aliases: ['App'],
		        validator(val) {
		            return typeof val === 'string' && val.length <= 128;
		        },
		    },
		    'ApplicationIntent': {
		        type: SchemaTypes.STRING,
		        allowedValues: ['ReadOnly', 'ReadWrite'],
		        default: 'ReadWrite',
		    },
		    'Asynchronous Processing': {
		        type: SchemaTypes.BOOL,
		        default: false,
		        aliases: ['Async'],
		    },
		    'AttachDBFilename': {
		        type: SchemaTypes.STRING,
		        aliases: ['Extended Properties', 'Initial File Name'],
		    },
		    'Authentication': {
		        type: SchemaTypes.STRING,
		        allowedValues: ['Active Directory Integrated', 'Active Directory Password', 'Sql Password'],
		    },
		    'Column Encryption Setting': {
		        type: SchemaTypes.STRING,
		    },
		    'Connection Timeout': {
		        type: SchemaTypes.NUMBER,
		        aliases: ['Connect Timeout', 'Timeout'],
		        default: 15,
		    },
		    'Connection Lifetime': {
		        type: SchemaTypes.NUMBER,
		        aliases: ['Load Balance Timeout'],
		        default: 0,
		    },
		    'ConnectRetryCount': {
		        type: SchemaTypes.NUMBER,
		        default: 1,
		        validator(val) {
		            return val > 0 && val <= 255;
		        },
		    },
		    'ConnectRetryInterval': {
		        type: SchemaTypes.NUMBER,
		        default: 10,
		    },
		    'Context Connection': {
		        type: SchemaTypes.BOOL,
		        default: false,
		    },
		    'Current Language': {
		        aliases: ['Language'],
		        type: SchemaTypes.STRING,
		        validator(val) {
		            return typeof val === 'string' && val.length <= 128;
		        },
		    },
		    'Data Source': {
		        aliases: ['Addr', 'Address', 'Server', 'Network Address'],
		        type: SchemaTypes.STRING,
		    },
		    'Encrypt': {
		        type: SchemaTypes.BOOL,
		        default: false,
		    },
		    'Enlist': {
		        type: SchemaTypes.BOOL,
		        default: true,
		    },
		    'Failover Partner': {
		        type: SchemaTypes.STRING,
		    },
		    'Initial Catalog': {
		        type: SchemaTypes.STRING,
		        aliases: ['Database'],
		        validator(val) {
		            return typeof val === 'string' && val.length <= 128;
		        },
		    },
		    'Integrated Security': {
		        type: SchemaTypes.BOOL,
		        aliases: ['Trusted_Connection'],
		        coerce(val) {
		            return val === 'sspi' || null;
		        },
		    },
		    'Max Pool Size': {
		        type: SchemaTypes.NUMBER,
		        default: 100,
		        validator(val) {
		            return val >= 1;
		        },
		    },
		    'Min Pool Size': {
		        type: SchemaTypes.NUMBER,
		        default: 0,
		        validator(val) {
		            return val >= 0;
		        },
		    },
		    'MultipleActiveResultSets': {
		        type: SchemaTypes.BOOL,
		        default: false,
		    },
		    'MultiSubnetFailover': {
		        type: SchemaTypes.BOOL,
		        default: false,
		    },
		    'Network Library': {
		        type: SchemaTypes.STRING,
		        aliases: ['Network', 'Net'],
		        allowedValues: ['dbnmpntw', 'dbmsrpcn', 'dbmsadsn', 'dbmsgnet', 'dbmslpcn', 'dbmsspxn', 'dbmssocn', 'Dbmsvinn'],
		    },
		    'Packet Size': {
		        type: SchemaTypes.NUMBER,
		        default: 8000,
		        validator(val) {
		            return val >= 512 && val <= 32768;
		        },
		    },
		    'Password': {
		        type: SchemaTypes.STRING,
		        aliases: ['PWD'],
		        validator(val) {
		            return typeof val === 'string' && val.length <= 128;
		        },
		    },
		    'Persist Security Info': {
		        type: SchemaTypes.BOOL,
		        aliases: ['PersistSecurityInfo'],
		        default: false,
		    },
		    'PoolBlockingPeriod': {
		        type: SchemaTypes.NUMBER,
		        default: 0,
		        coerce(val) {
		            if (typeof val !== 'string') {
		                return null;
		            }
		            switch (val.toLowerCase()) {
		                case 'alwaysblock':
		                    return 1;
		                case 'auto':
		                    return 0;
		                case 'neverblock':
		                    return 2;
		            }
		            return null;
		        },
		    },
		    'Pooling': {
		        type: SchemaTypes.BOOL,
		        default: true,
		    },
		    'Replication': {
		        type: SchemaTypes.BOOL,
		        default: false,
		    },
		    'Transaction Binding': {
		        type: SchemaTypes.STRING,
		        allowedValues: ['Implicit Unbind', 'Explicit Unbind'],
		        default: 'Implicit Unbind',
		    },
		    'TransparentNetworkIPResolution': {
		        type: SchemaTypes.BOOL,
		        default: true,
		    },
		    'TrustServerCertificate': {
		        type: SchemaTypes.BOOL,
		        default: false,
		    },
		    'Type System Version': {
		        type: SchemaTypes.STRING,
		        allowedValues: ['SQL Server 2012', 'SQL Server 2008', 'SQL Server 2005', 'Latest'],
		    },
		    'User ID': {
		        type: SchemaTypes.STRING,
		        aliases: ['UID'],
		        validator(val) {
		            return typeof val === 'string' && val.length <= 128;
		        },
		    },
		    'User Instance': {
		        type: SchemaTypes.BOOL,
		        default: false,
		    },
		    'Workstation ID': {
		        type: SchemaTypes.STRING,
		        aliases: ['WSID'],
		        validator(val) {
		            return typeof val === 'string' && val.length <= 128;
		        },
		    },
		};
		function guessType(value) {
		    if (value.trim() === '') {
		        return SchemaTypes.STRING;
		    }
		    const asNum = parseInt(value, 10);
		    if (!Number.isNaN(asNum) && asNum.toString() === value) {
		        return SchemaTypes.NUMBER;
		    }
		    if (['true', 'false', 'yes', 'no'].includes(value.toLowerCase())) {
		        return SchemaTypes.BOOL;
		    }
		    return SchemaTypes.STRING;
		}
		function coerce(value, type, coercer) {
		    if (coercer) {
		        const coerced = coercer(value);
		        if (coerced !== null) {
		            return coerced;
		        }
		    }
		    switch (type) {
		        case SchemaTypes.BOOL:
		            if (['true', 'yes', '1'].includes(value.toLowerCase())) {
		                return true;
		            }
		            if (['false', 'no', '0'].includes(value.toLowerCase())) {
		                return false;
		            }
		            return value;
		        case SchemaTypes.NUMBER:
		            return parseInt(value, 10);
		    }
		    return value;
		}
		function validate(value, allowedValues, validator) {
		    let valid = true;
		    if (validator) {
		        valid = validator(value);
		    }
		    if (valid) {
		        valid = (allowedValues === null || allowedValues === void 0 ? void 0 : allowedValues.includes(value)) || false;
		    }
		    return valid;
		}
		// eslint-disable-next-line @typescript-eslint/no-unused-vars
		function parseSqlConnectionString(connectionString, canonicalProps = false, allowUnknown = false, strict = false, schema = exports$1.SCHEMA) {
		    const flattenedSchema = Object.entries(schema).reduce((flattened, [key, item]) => {
		        var _a;
		        Object.assign(flattened, {
		            [key.toLowerCase()]: item,
		        });
		        return ((_a = item.aliases) === null || _a === void 0 ? void 0 : _a.reduce((accum, alias) => {
		            return Object.assign(accum, {
		                [alias.toLowerCase()]: {
		                    ...item,
		                    canonical: key.toLowerCase(),
		                },
		            });
		        }, flattened)) || flattened;
		    }, {});
		    return Object.entries((0, connection_string_1.default)(connectionString)).reduce((config, [prop, value]) => {
		        if (!Object.prototype.hasOwnProperty.call(flattenedSchema, prop)) {
		            return Object.assign(config, {
		                [prop]: coerce(value, guessType(value)),
		            });
		        }
		        let coercedValue = coerce(value, flattenedSchema[prop].type, flattenedSchema[prop].coerce);
		        if (strict && !validate(coercedValue, flattenedSchema[prop].allowedValues, flattenedSchema[prop].validator)) {
		            coercedValue = flattenedSchema[prop].default;
		        }
		        const propName = canonicalProps ? flattenedSchema[prop].canonical || prop : prop;
		        return Object.assign(config, {
		            [propName]: coercedValue,
		        });
		    }, {});
		}
		exports$1.default = parseSqlConnectionString;
		
	} (sqlConnectionString));
	return sqlConnectionString;
}

var builder = {};

var hasRequiredBuilder;

function requireBuilder () {
	if (hasRequiredBuilder) return builder;
	hasRequiredBuilder = 1;
	Object.defineProperty(builder, "__esModule", { value: true });
	builder.buildConnectionString = void 0;
	function isQuoted(val) {
	    if (val[0] !== '{') {
	        return false;
	    }
	    for (let i = 1; i < val.length; i++) {
	        if (val[i] === '}') {
	            if (i + 1 === val.length) {
	                // if last char, then it's quoted properly
	                return true;
	            }
	            else if (val[i + 1] !== '}') {
	                // the next char is no a `}` so there is no valid escaping here
	                return false;
	            }
	            else {
	                // we are seeing an escaped `}`, so skip ahead
	                i++;
	            }
	        }
	    }
	    return false;
	}
	function needsQuotes(val) {
	    var _a;
	    return !isQuoted(val) && !!((_a = val.match(/\[|]|{|}|\|\(|\)|,|;|\?|\*|=|!|@/)) === null || _a === void 0 ? void 0 : _a.length);
	}
	function encodeTuple(key, value) {
	    if (value === null || value === undefined) {
	        return [key, ''];
	    }
	    switch (typeof value) {
	        case 'boolean':
	            return [key, value ? 'Yes' : 'No'];
	        default: {
	            const strVal = value.toString();
	            if (needsQuotes(strVal)) {
	                return [key, `{${strVal.replace(/}/g, '}}')}}`];
	            }
	            return [key, strVal];
	        }
	    }
	}
	function buildConnectionString(data) {
	    return Object.entries(data).map(([key, value]) => {
	        return encodeTuple(key.trim(), value).join('=');
	    }).join(';');
	}
	builder.buildConnectionString = buildConnectionString;
	
	return builder;
}

var hasRequiredLib$2;

function requireLib$2 () {
	if (hasRequiredLib$2) return lib$2;
	hasRequiredLib$2 = 1;
	(function (exports$1) {
		var __createBinding = (lib$2 && lib$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __exportStar = (lib$2 && lib$2.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		var __importDefault = (lib$2 && lib$2.__importDefault) || function (mod) {
		    return (mod && mod.__esModule) ? mod : { "default": mod };
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.parseSqlConnectionString = exports$1.parseConnectionString = void 0;
		const connection_string_1 = __importDefault(requireConnectionString());
		exports$1.parseConnectionString = connection_string_1.default;
		const sql_connection_string_1 = __importDefault(requireSqlConnectionString());
		exports$1.parseSqlConnectionString = sql_connection_string_1.default;
		__exportStar(requireBuilder(), exports$1);
		
	} (lib$2));
	return lib$2;
}

var tarn = {exports: {}};

var Pool = {};

var PendingOperation = {};

var TimeoutError = {};

var hasRequiredTimeoutError$1;

function requireTimeoutError$1 () {
	if (hasRequiredTimeoutError$1) return TimeoutError;
	hasRequiredTimeoutError$1 = 1;
	Object.defineProperty(TimeoutError, "__esModule", { value: true });
	let TimeoutError$1 = class TimeoutError extends Error {
	};
	TimeoutError.TimeoutError = TimeoutError$1;
	return TimeoutError;
}

var utils$5 = {};

var PromiseInspection = {};

var hasRequiredPromiseInspection;

function requirePromiseInspection () {
	if (hasRequiredPromiseInspection) return PromiseInspection;
	hasRequiredPromiseInspection = 1;
	Object.defineProperty(PromiseInspection, "__esModule", { value: true });
	let PromiseInspection$1 = class PromiseInspection {
	    constructor(args) {
	        this._value = args.value;
	        this._error = args.error;
	    }
	    value() {
	        return this._value;
	    }
	    reason() {
	        return this._error;
	    }
	    isRejected() {
	        return !!this._error;
	    }
	    isFulfilled() {
	        return !!this._value;
	    }
	};
	PromiseInspection.PromiseInspection = PromiseInspection$1;
	return PromiseInspection;
}

var hasRequiredUtils$5;

function requireUtils$5 () {
	if (hasRequiredUtils$5) return utils$5;
	hasRequiredUtils$5 = 1;
	Object.defineProperty(utils$5, "__esModule", { value: true });
	const PromiseInspection_1 = requirePromiseInspection();
	function defer() {
	    let resolve = null;
	    let reject = null;
	    const promise = new Promise((resolver, rejecter) => {
	        resolve = resolver;
	        reject = rejecter;
	    });
	    return {
	        promise,
	        resolve,
	        reject
	    };
	}
	utils$5.defer = defer;
	function now() {
	    return Date.now();
	}
	utils$5.now = now;
	function duration(t1, t2) {
	    return Math.abs(t2 - t1);
	}
	utils$5.duration = duration;
	function checkOptionalTime(time) {
	    if (typeof time === 'undefined') {
	        return true;
	    }
	    return checkRequiredTime(time);
	}
	utils$5.checkOptionalTime = checkOptionalTime;
	function checkRequiredTime(time) {
	    return typeof time === 'number' && time === Math.round(time) && time > 0;
	}
	utils$5.checkRequiredTime = checkRequiredTime;
	function delay(millis) {
	    return new Promise(resolve => setTimeout(resolve, millis));
	}
	utils$5.delay = delay;
	function reflect(promise) {
	    return promise
	        .then(value => {
	        return new PromiseInspection_1.PromiseInspection({ value });
	    })
	        .catch(error => {
	        return new PromiseInspection_1.PromiseInspection({ error });
	    });
	}
	utils$5.reflect = reflect;
	function tryPromise(cb) {
	    try {
	        const result = cb();
	        return Promise.resolve(result);
	    }
	    catch (err) {
	        return Promise.reject(err);
	    }
	}
	utils$5.tryPromise = tryPromise;
	return utils$5;
}

var hasRequiredPendingOperation;

function requirePendingOperation () {
	if (hasRequiredPendingOperation) return PendingOperation;
	hasRequiredPendingOperation = 1;
	Object.defineProperty(PendingOperation, "__esModule", { value: true });
	const TimeoutError_1 = requireTimeoutError$1();
	const utils_1 = requireUtils$5();
	let PendingOperation$1 = class PendingOperation {
	    constructor(timeoutMillis) {
	        this.timeoutMillis = timeoutMillis;
	        this.deferred = utils_1.defer();
	        this.possibleTimeoutCause = null;
	        this.isRejected = false;
	        this.promise = timeout(this.deferred.promise, timeoutMillis).catch(err => {
	            if (err instanceof TimeoutError_1.TimeoutError) {
	                if (this.possibleTimeoutCause) {
	                    err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
	                }
	                else {
	                    err = new TimeoutError_1.TimeoutError('operation timed out for an unknown reason');
	                }
	            }
	            this.isRejected = true;
	            return Promise.reject(err);
	        });
	    }
	    abort() {
	        this.reject(new Error('aborted'));
	    }
	    reject(err) {
	        this.deferred.reject(err);
	    }
	    resolve(value) {
	        this.deferred.resolve(value);
	    }
	};
	PendingOperation.PendingOperation = PendingOperation$1;
	function timeout(promise, time) {
	    return new Promise((resolve, reject) => {
	        const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time);
	        promise
	            .then(result => {
	            clearTimeout(timeoutHandle);
	            resolve(result);
	        })
	            .catch(err => {
	            clearTimeout(timeoutHandle);
	            reject(err);
	        });
	    });
	}
	return PendingOperation;
}

var Resource = {};

var hasRequiredResource;

function requireResource () {
	if (hasRequiredResource) return Resource;
	hasRequiredResource = 1;
	Object.defineProperty(Resource, "__esModule", { value: true });
	const utils_1 = requireUtils$5();
	let Resource$1 = class Resource {
	    constructor(resource) {
	        this.resource = resource;
	        this.resource = resource;
	        this.timestamp = utils_1.now();
	        this.deferred = utils_1.defer();
	    }
	    get promise() {
	        return this.deferred.promise;
	    }
	    resolve() {
	        this.deferred.resolve(undefined);
	        return new Resource(this.resource);
	    }
	};
	Resource.Resource = Resource$1;
	return Resource;
}

var hasRequiredPool;

function requirePool () {
	if (hasRequiredPool) return Pool;
	hasRequiredPool = 1;
	Object.defineProperty(Pool, "__esModule", { value: true });
	const PendingOperation_1 = requirePendingOperation();
	const Resource_1 = requireResource();
	const utils_1 = requireUtils$5();
	const events_1 = require$$0$5;
	const timers_1 = require$$4$1;
	let Pool$1 = class Pool {
	    constructor(opt) {
	        this.destroyed = false;
	        this.emitter = new events_1.EventEmitter();
	        opt = opt || {};
	        if (!opt.create) {
	            throw new Error('Tarn: opt.create function most be provided');
	        }
	        if (!opt.destroy) {
	            throw new Error('Tarn: opt.destroy function most be provided');
	        }
	        if (typeof opt.min !== 'number' || opt.min < 0 || opt.min !== Math.round(opt.min)) {
	            throw new Error('Tarn: opt.min must be an integer >= 0');
	        }
	        if (typeof opt.max !== 'number' || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
	            throw new Error('Tarn: opt.max must be an integer > 0');
	        }
	        if (opt.min > opt.max) {
	            throw new Error('Tarn: opt.max is smaller than opt.min');
	        }
	        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
	            throw new Error('Tarn: invalid opt.acquireTimeoutMillis ' + JSON.stringify(opt.acquireTimeoutMillis));
	        }
	        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
	            throw new Error('Tarn: invalid opt.createTimeoutMillis ' + JSON.stringify(opt.createTimeoutMillis));
	        }
	        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
	            throw new Error('Tarn: invalid opt.destroyTimeoutMillis ' + JSON.stringify(opt.destroyTimeoutMillis));
	        }
	        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
	            throw new Error('Tarn: invalid opt.idleTimeoutMillis ' + JSON.stringify(opt.idleTimeoutMillis));
	        }
	        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
	            throw new Error('Tarn: invalid opt.reapIntervalMillis ' + JSON.stringify(opt.reapIntervalMillis));
	        }
	        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
	            throw new Error('Tarn: invalid opt.createRetryIntervalMillis ' +
	                JSON.stringify(opt.createRetryIntervalMillis));
	        }
	        const allowedKeys = {
	            create: true,
	            validate: true,
	            destroy: true,
	            log: true,
	            min: true,
	            max: true,
	            acquireTimeoutMillis: true,
	            createTimeoutMillis: true,
	            destroyTimeoutMillis: true,
	            idleTimeoutMillis: true,
	            reapIntervalMillis: true,
	            createRetryIntervalMillis: true,
	            propagateCreateError: true
	        };
	        for (const key of Object.keys(opt)) {
	            if (!allowedKeys[key]) {
	                throw new Error(`Tarn: unsupported option opt.${key}`);
	            }
	        }
	        this.creator = opt.create;
	        this.destroyer = opt.destroy;
	        this.validate = typeof opt.validate === 'function' ? opt.validate : () => true;
	        this.log = opt.log || (() => { });
	        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 30000;
	        this.createTimeoutMillis = opt.createTimeoutMillis || 30000;
	        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5000;
	        this.idleTimeoutMillis = opt.idleTimeoutMillis || 30000;
	        this.reapIntervalMillis = opt.reapIntervalMillis || 1000;
	        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
	        this.propagateCreateError = !!opt.propagateCreateError;
	        this.min = opt.min;
	        this.max = opt.max;
	        // All the resources, which are either already acquired or which are
	        // considered for being passed to acquire in async validation phase.
	        this.used = [];
	        // All the resources, which are either just created and free or returned
	        // back to pool after using.
	        this.free = [];
	        this.pendingCreates = [];
	        this.pendingAcquires = [];
	        this.pendingDestroys = [];
	        // When acquire is pending, but also still in validation phase
	        this.pendingValidations = [];
	        this.destroyed = false;
	        this.interval = null;
	        this.eventId = 1;
	    }
	    numUsed() {
	        return this.used.length;
	    }
	    numFree() {
	        return this.free.length;
	    }
	    numPendingAcquires() {
	        return this.pendingAcquires.length;
	    }
	    numPendingValidations() {
	        return this.pendingValidations.length;
	    }
	    numPendingCreates() {
	        return this.pendingCreates.length;
	    }
	    acquire() {
	        const eventId = this.eventId++;
	        this._executeEventHandlers('acquireRequest', eventId);
	        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
	        this.pendingAcquires.push(pendingAcquire);
	        // If the acquire fails for whatever reason
	        // remove it from the pending queue.
	        pendingAcquire.promise = pendingAcquire.promise
	            .then(resource => {
	            this._executeEventHandlers('acquireSuccess', eventId, resource);
	            return resource;
	        })
	            .catch(err => {
	            this._executeEventHandlers('acquireFail', eventId, err);
	            remove(this.pendingAcquires, pendingAcquire);
	            return Promise.reject(err);
	        });
	        this._tryAcquireOrCreate();
	        return pendingAcquire;
	    }
	    release(resource) {
	        this._executeEventHandlers('release', resource);
	        for (let i = 0, l = this.used.length; i < l; ++i) {
	            const used = this.used[i];
	            if (used.resource === resource) {
	                this.used.splice(i, 1);
	                this.free.push(used.resolve());
	                this._tryAcquireOrCreate();
	                return true;
	            }
	        }
	        return false;
	    }
	    isEmpty() {
	        return ([
	            this.numFree(),
	            this.numUsed(),
	            this.numPendingAcquires(),
	            this.numPendingValidations(),
	            this.numPendingCreates()
	        ].reduce((total, value) => total + value) === 0);
	    }
	    /**
	     * Reaping cycle.
	     */
	    check() {
	        const timestamp = utils_1.now();
	        const newFree = [];
	        const minKeep = this.min - this.used.length;
	        const maxDestroy = this.free.length - minKeep;
	        let numDestroyed = 0;
	        this.free.forEach(free => {
	            if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis &&
	                numDestroyed < maxDestroy) {
	                numDestroyed++;
	                this._destroy(free.resource);
	            }
	            else {
	                newFree.push(free);
	            }
	        });
	        this.free = newFree;
	        // Pool is completely empty, stop reaping.
	        // Next .acquire will start reaping interval again.
	        if (this.isEmpty()) {
	            this._stopReaping();
	        }
	    }
	    destroy() {
	        const eventId = this.eventId++;
	        this._executeEventHandlers('poolDestroyRequest', eventId);
	        this._stopReaping();
	        this.destroyed = true;
	        // First wait for all the pending creates get ready.
	        return utils_1.reflect(Promise.all(this.pendingCreates.map(create => utils_1.reflect(create.promise)))
	            .then(() => {
	            // eslint-disable-next-line
	            return new Promise((resolve, reject) => {
	                // poll every 100ms and wait that all validations are ready
	                if (this.numPendingValidations() === 0) {
	                    resolve();
	                    return;
	                }
	                const interval = setInterval(() => {
	                    if (this.numPendingValidations() === 0) {
	                        timers_1.clearInterval(interval);
	                        resolve();
	                    }
	                }, 100);
	            });
	        })
	            .then(() => {
	            // Wait for all the used resources to be freed.
	            return Promise.all(this.used.map(used => utils_1.reflect(used.promise)));
	        })
	            .then(() => {
	            // Abort all pending acquires.
	            return Promise.all(this.pendingAcquires.map(acquire => {
	                acquire.abort();
	                return utils_1.reflect(acquire.promise);
	            }));
	        })
	            .then(() => {
	            // Now we can destroy all the freed resources.
	            return Promise.all(this.free.map(free => utils_1.reflect(this._destroy(free.resource))));
	        })
	            .then(() => {
	            // Also wait rest of the pending destroys to finish
	            return Promise.all(this.pendingDestroys.map(pd => pd.promise));
	        })
	            .then(() => {
	            this.free = [];
	            this.pendingAcquires = [];
	        })).then(res => {
	            this._executeEventHandlers('poolDestroySuccess', eventId);
	            this.emitter.removeAllListeners();
	            return res;
	        });
	    }
	    on(event, listener) {
	        this.emitter.on(event, listener);
	    }
	    removeListener(event, listener) {
	        this.emitter.removeListener(event, listener);
	    }
	    removeAllListeners(event) {
	        this.emitter.removeAllListeners(event);
	    }
	    /**
	     * The most important method that is called always when resources
	     * are created / destroyed / acquired / released. In other words
	     * every time when resources are moved from used to free or vice
	     * versa.
	     *
	     * Either assigns free resources to pendingAcquires or creates new
	     * resources if there is room for it in the pool.
	     */
	    _tryAcquireOrCreate() {
	        if (this.destroyed) {
	            return;
	        }
	        if (this._hasFreeResources()) {
	            this._doAcquire();
	        }
	        else if (this._shouldCreateMoreResources()) {
	            this._doCreate();
	        }
	    }
	    _hasFreeResources() {
	        return this.free.length > 0;
	    }
	    _doAcquire() {
	        // Acquire as many pending acquires as possible concurrently
	        while (this._canAcquire()) {
	            // To allow async validation, we actually need to move free resource
	            // and pending acquire temporary from their respective arrays and depending
	            // on validation result to either leave the free resource to used resources array
	            // or destroy the free resource if validation did fail.
	            const pendingAcquire = this.pendingAcquires.shift();
	            const free = this.free.pop();
	            if (free === undefined || pendingAcquire === undefined) {
	                const errMessage = 'this.free was empty while trying to acquire resource';
	                this.log(`Tarn: ${errMessage}`, 'warn');
	                throw new Error(`Internal error, should never happen. ${errMessage}`);
	            }
	            // Make sure that pendingAcquire that is being validated is not lost and
	            // can be freed when pool is destroyed.
	            this.pendingValidations.push(pendingAcquire);
	            // Must be added here pre-emptively to prevent logic that decides
	            // if new resources are created will keep on working correctly.
	            this.used.push(free);
	            // if acquire fails also pending validation, must be aborted so that pre reserved
	            // resource will be returned to free resources immediately
	            const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
	            // eslint-disable-next-line
	            pendingAcquire.promise.catch(err => {
	                abortAbleValidation.abort();
	            });
	            abortAbleValidation.promise
	                .catch(err => {
	                // There's nothing we can do here but log the error. This would otherwise
	                // leak out as an unhandled exception.
	                this.log('Tarn: resource validator threw an exception ' + err.stack, 'warn');
	                return false;
	            })
	                .then(validationSuccess => {
	                try {
	                    if (validationSuccess && !pendingAcquire.isRejected) {
	                        // At least one active resource exist, start reaping.
	                        this._startReaping();
	                        pendingAcquire.resolve(free.resource);
	                    }
	                    else {
	                        remove(this.used, free);
	                        // Only destroy the resource if the validation has failed
	                        if (!validationSuccess) {
	                            this._destroy(free.resource);
	                            // Since we destroyed an invalid resource and were not able to fulfill
	                            // all the pending acquires, we may need to create new ones or at
	                            // least run this acquire loop again to verify it. But not immediately
	                            // to prevent starving event loop.
	                            setTimeout(() => {
	                                this._tryAcquireOrCreate();
	                            }, 0);
	                        }
	                        else {
	                            this.free.push(free);
	                        }
	                        // is acquire was canceled, failed or timed out already
	                        // no need to return it to pending queries
	                        if (!pendingAcquire.isRejected) {
	                            this.pendingAcquires.unshift(pendingAcquire);
	                        }
	                    }
	                }
	                finally {
	                    remove(this.pendingValidations, pendingAcquire);
	                }
	            });
	            // try to validate
	            this._validateResource(free.resource)
	                .then(validationSuccess => {
	                abortAbleValidation.resolve(validationSuccess);
	            })
	                .catch(err => {
	                abortAbleValidation.reject(err);
	            });
	        }
	    }
	    _canAcquire() {
	        return this.free.length > 0 && this.pendingAcquires.length > 0;
	    }
	    _validateResource(resource) {
	        try {
	            return Promise.resolve(this.validate(resource));
	        }
	        catch (err) {
	            // prevent leaking of sync exception
	            return Promise.reject(err);
	        }
	    }
	    _shouldCreateMoreResources() {
	        return (this.used.length + this.pendingCreates.length < this.max &&
	            this.pendingCreates.length < this.pendingAcquires.length);
	    }
	    _doCreate() {
	        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
	        const pendingCreate = this._create();
	        pendingCreate.promise
	            .then(() => {
	            // Not returned on purpose.
	            this._tryAcquireOrCreate();
	            return null;
	        })
	            .catch(err => {
	            if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
	                // If propagateCreateError is true, we don't retry the create
	                // but reject the first pending acquire immediately. Intentionally
	                // use `this.pendingAcquires` instead of `pendingAcquiresBeforeCreate`
	                // in case some acquires in pendingAcquiresBeforeCreate have already
	                // been resolved.
	                this.pendingAcquires[0].reject(err);
	            }
	            // Save the create error to all pending acquires so that we can use it
	            // as the error to reject the acquire if it times out.
	            pendingAcquiresBeforeCreate.forEach(pendingAcquire => {
	                pendingAcquire.possibleTimeoutCause = err;
	            });
	            // Not returned on purpose.
	            utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
	        });
	    }
	    _create() {
	        const eventId = this.eventId++;
	        this._executeEventHandlers('createRequest', eventId);
	        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
	        // If an error occurs (likely a create timeout) remove this creation from
	        // the list of pending creations so we try to create a new one.
	        pendingCreate.promise = pendingCreate.promise.catch(err => {
	            if (remove(this.pendingCreates, pendingCreate)) {
	                // TODO: figure out more consistent way for different error handlers in next rewrite
	                this._executeEventHandlers('createFail', eventId, err);
	            }
	            throw err;
	        });
	        this.pendingCreates.push(pendingCreate);
	        callbackOrPromise(this.creator)
	            .then(resource => {
	            if (pendingCreate.isRejected) {
	                this.destroyer(resource);
	                return null;
	            }
	            remove(this.pendingCreates, pendingCreate);
	            this.free.push(new Resource_1.Resource(resource));
	            // Not returned on purpose.
	            pendingCreate.resolve(resource);
	            this._executeEventHandlers('createSuccess', eventId, resource);
	            return null;
	        })
	            .catch(err => {
	            if (pendingCreate.isRejected) {
	                return null;
	            }
	            if (remove(this.pendingCreates, pendingCreate)) {
	                this._executeEventHandlers('createFail', eventId, err);
	            }
	            // Not returned on purpose.
	            pendingCreate.reject(err);
	            return null;
	        });
	        return pendingCreate;
	    }
	    _destroy(resource) {
	        const eventId = this.eventId++;
	        this._executeEventHandlers('destroyRequest', eventId, resource);
	        // this.destroyer can be both synchronous and asynchronous.
	        // so we wrap it to promise to get all exceptions through same pipeline
	        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
	        const retVal = Promise.resolve().then(() => this.destroyer(resource));
	        retVal
	            .then(() => {
	            pendingDestroy.resolve(resource);
	        })
	            .catch((err) => {
	            pendingDestroy.reject(err);
	        });
	        this.pendingDestroys.push(pendingDestroy);
	        // In case of an error there's nothing we can do here but log it.
	        return pendingDestroy.promise
	            .then(res => {
	            this._executeEventHandlers('destroySuccess', eventId, resource);
	            return res;
	        })
	            .catch(err => this._logDestroyerError(eventId, resource, err))
	            .then(res => {
	            const index = this.pendingDestroys.findIndex(pd => pd === pendingDestroy);
	            this.pendingDestroys.splice(index, 1);
	            return res;
	        });
	    }
	    _logDestroyerError(eventId, resource, err) {
	        this._executeEventHandlers('destroyFail', eventId, resource, err);
	        this.log('Tarn: resource destroyer threw an exception ' + err.stack, 'warn');
	    }
	    _startReaping() {
	        if (!this.interval) {
	            this._executeEventHandlers('startReaping');
	            this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
	        }
	    }
	    _stopReaping() {
	        if (this.interval !== null) {
	            this._executeEventHandlers('stopReaping');
	            timers_1.clearInterval(this.interval);
	        }
	        this.interval = null;
	    }
	    _executeEventHandlers(eventName, ...args) {
	        const listeners = this.emitter.listeners(eventName);
	        // just calling .emit() would stop running rest of the listeners if one them fails
	        listeners.forEach(listener => {
	            try {
	                listener(...args);
	            }
	            catch (err) {
	                // There's nothing we can do here but log the error. This would otherwise
	                // leak out as an unhandled exception.
	                this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, 'warn');
	            }
	        });
	    }
	};
	Pool.Pool = Pool$1;
	function remove(arr, item) {
	    const idx = arr.indexOf(item);
	    if (idx === -1) {
	        return false;
	    }
	    else {
	        arr.splice(idx, 1);
	        return true;
	    }
	}
	function callbackOrPromise(func) {
	    return new Promise((resolve, reject) => {
	        const callback = (err, resource) => {
	            if (err) {
	                reject(err);
	            }
	            else {
	                resolve(resource);
	            }
	        };
	        utils_1.tryPromise(() => func(callback))
	            .then(res => {
	            // If the result is falsy, we assume that the callback will
	            // be called instead of interpreting the falsy value as a
	            // result value.
	            if (res) {
	                resolve(res);
	            }
	        })
	            .catch(err => {
	            reject(err);
	        });
	    });
	}
	return Pool;
}

var hasRequiredTarn;

function requireTarn () {
	if (hasRequiredTarn) return tarn.exports;
	hasRequiredTarn = 1;
	(function (module, exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		const Pool_1 = requirePool();
		exports$1.Pool = Pool_1.Pool;
		const TimeoutError_1 = requireTimeoutError$1();
		exports$1.TimeoutError = TimeoutError_1.TimeoutError;
		module.exports = {
		    Pool: Pool_1.Pool,
		    TimeoutError: TimeoutError_1.TimeoutError
		}; 
	} (tarn, tarn.exports));
	return tarn.exports;
}

var utils$4;
var hasRequiredUtils$4;

function requireUtils$4 () {
	if (hasRequiredUtils$4) return utils$4;
	hasRequiredUtils$4 = 1;
	const IDS = new WeakMap();
	const INCREMENT = {
	  Connection: 1,
	  ConnectionPool: 1,
	  Request: 1,
	  Transaction: 1,
	  PreparedStatement: 1
	};

	utils$4 = {
	  objectHasProperty: (object, property) => Object.prototype.hasOwnProperty.call(object, property),
	  INCREMENT,
	  IDS: {
	    get: IDS.get.bind(IDS),
	    add: (object, type, id) => {
	      if (id) return IDS.set(object, id)
	      IDS.set(object, INCREMENT[type]++);
	    }
	  }
	};
	return utils$4;
}

var mssqlError;
var hasRequiredMssqlError;

function requireMssqlError () {
	if (hasRequiredMssqlError) return mssqlError;
	hasRequiredMssqlError = 1;

	class MSSQLError extends Error {
	  /**
	   * Creates a new ConnectionError.
	   *
	   * @param {String} message Error message.
	   * @param {String} [code] Error code.
	   */

	  constructor (message, code) {
	    if (message instanceof Error) {
	      super(message.message);
	      this.code = message.code || code;

	      Error.captureStackTrace(this, this.constructor);
	      Object.defineProperty(this, 'originalError', { enumerable: true, value: message });
	    } else {
	      super(message);
	      this.code = code;
	    }

	    this.name = 'MSSQLError';
	  }
	}

	mssqlError = MSSQLError;
	return mssqlError;
}

var connectionError;
var hasRequiredConnectionError;

function requireConnectionError () {
	if (hasRequiredConnectionError) return connectionError;
	hasRequiredConnectionError = 1;

	const MSSQLError = requireMssqlError();

	/**
	 * Class ConnectionError.
	 */

	class ConnectionError extends MSSQLError {
	  /**
	   * Creates a new ConnectionError.
	   *
	   * @param {String} message Error message.
	   * @param {String} [code] Error code.
	   */

	  constructor (message, code) {
	    super(message, code);

	    this.name = 'ConnectionError';
	  }
	}

	connectionError = ConnectionError;
	return connectionError;
}

var shared = {exports: {}};

var datatypes = {exports: {}};

var hasRequiredDatatypes;

function requireDatatypes () {
	if (hasRequiredDatatypes) return datatypes.exports;
	hasRequiredDatatypes = 1;
	(function (module) {
		const objectHasProperty = requireUtils$4().objectHasProperty;
		const inspect = Symbol.for('nodejs.util.inspect.custom');

		const TYPES = {
		  VarChar (length) {
		    return { type: TYPES.VarChar, length }
		  },
		  NVarChar (length) {
		    return { type: TYPES.NVarChar, length }
		  },
		  Text () {
		    return { type: TYPES.Text }
		  },
		  Int () {
		    return { type: TYPES.Int }
		  },
		  BigInt () {
		    return { type: TYPES.BigInt }
		  },
		  TinyInt () {
		    return { type: TYPES.TinyInt }
		  },
		  SmallInt () {
		    return { type: TYPES.SmallInt }
		  },
		  Bit () {
		    return { type: TYPES.Bit }
		  },
		  Float () {
		    return { type: TYPES.Float }
		  },
		  Numeric (precision, scale) {
		    return { type: TYPES.Numeric, precision, scale }
		  },
		  Decimal (precision, scale) {
		    return { type: TYPES.Decimal, precision, scale }
		  },
		  Real () {
		    return { type: TYPES.Real }
		  },
		  Date () {
		    return { type: TYPES.Date }
		  },
		  DateTime () {
		    return { type: TYPES.DateTime }
		  },
		  DateTime2 (scale) {
		    return { type: TYPES.DateTime2, scale }
		  },
		  DateTimeOffset (scale) {
		    return { type: TYPES.DateTimeOffset, scale }
		  },
		  SmallDateTime () {
		    return { type: TYPES.SmallDateTime }
		  },
		  Time (scale) {
		    return { type: TYPES.Time, scale }
		  },
		  UniqueIdentifier () {
		    return { type: TYPES.UniqueIdentifier }
		  },
		  SmallMoney () {
		    return { type: TYPES.SmallMoney }
		  },
		  Money () {
		    return { type: TYPES.Money }
		  },
		  Binary (length) {
		    return { type: TYPES.Binary, length }
		  },
		  VarBinary (length) {
		    return { type: TYPES.VarBinary, length }
		  },
		  Image () {
		    return { type: TYPES.Image }
		  },
		  Xml () {
		    return { type: TYPES.Xml }
		  },
		  Char (length) {
		    return { type: TYPES.Char, length }
		  },
		  NChar (length) {
		    return { type: TYPES.NChar, length }
		  },
		  NText () {
		    return { type: TYPES.NText }
		  },
		  TVP (tvpType) {
		    return { type: TYPES.TVP, tvpType }
		  },
		  UDT () {
		    return { type: TYPES.UDT }
		  },
		  Geography () {
		    return { type: TYPES.Geography }
		  },
		  Geometry () {
		    return { type: TYPES.Geometry }
		  },
		  Variant () {
		    return { type: TYPES.Variant }
		  }
		};

		module.exports.TYPES = TYPES;
		module.exports.DECLARATIONS = {};

		const zero = function (value, length) {
		  if (length == null) length = 2;

		  value = String(value);
		  if (value.length < length) {
		    for (let i = 1; i <= length - value.length; i++) {
		      value = `0${value}`;
		    }
		  }
		  return value
		};

		for (const key in TYPES) {
		  if (objectHasProperty(TYPES, key)) {
		    const value = TYPES[key];
		    value.declaration = key.toLowerCase();
		    module.exports.DECLARATIONS[value.declaration] = value;

		    ((key, value) => {
		      value[inspect] = () => `[sql.${key}]`;
		    })(key, value);
		  }
		}

		module.exports.declare = (type, options) => {
		  switch (type) {
		    case TYPES.VarChar: case TYPES.VarBinary:
		      return `${type.declaration} (${options.length > 8000 ? 'MAX' : (options.length == null ? 'MAX' : options.length)})`
		    case TYPES.NVarChar:
		      return `${type.declaration} (${options.length > 4000 ? 'MAX' : (options.length == null ? 'MAX' : options.length)})`
		    case TYPES.Char: case TYPES.NChar: case TYPES.Binary:
		      return `${type.declaration} (${options.length == null ? 1 : options.length})`
		    case TYPES.Decimal: case TYPES.Numeric:
		      return `${type.declaration} (${options.precision == null ? 18 : options.precision}, ${options.scale == null ? 0 : options.scale})`
		    case TYPES.Time: case TYPES.DateTime2: case TYPES.DateTimeOffset:
		      return `${type.declaration} (${options.scale == null ? 7 : options.scale})`
		    case TYPES.TVP:
		      return `${options.tvpType} readonly`
		    default:
		      return type.declaration
		  }
		};

		module.exports.cast = (value, type, options) => {
		  if (value == null) {
		    return null
		  }

		  switch (typeof value) {
		    case 'string':
		      return `N'${value.replace(/'/g, '\'\'')}'`

		    case 'number':
		    case 'bigint':
		      return value

		    case 'boolean':
		      return value ? 1 : 0

		    case 'object':
		      if (value instanceof Date) {
		        let ns = value.getUTCMilliseconds() / 1000;
		        if (value.nanosecondDelta != null) {
		          ns += value.nanosecondDelta;
		        }
		        const scale = options.scale == null ? 7 : options.scale;

		        if (scale > 0) {
		          ns = String(ns).substr(1, scale + 1);
		        } else {
		          ns = '';
		        }

		        return `N'${value.getUTCFullYear()}-${zero(value.getUTCMonth() + 1)}-${zero(value.getUTCDate())} ${zero(value.getUTCHours())}:${zero(value.getUTCMinutes())}:${zero(value.getUTCSeconds())}${ns}'`
		      } else if (Buffer.isBuffer(value)) {
		        return `0x${value.toString('hex')}`
		      }

		      return null

		    default:
		      return null
		  }
		}; 
	} (datatypes));
	return datatypes.exports;
}

var table;
var hasRequiredTable;

function requireTable () {
	if (hasRequiredTable) return table;
	hasRequiredTable = 1;

	const TYPES = requireDatatypes().TYPES;
	const declareType = requireDatatypes().declare;
	const objectHasProperty = requireUtils$4().objectHasProperty;

	const MAX = 65535; // (1 << 16) - 1
	const JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';

	function Table (name) {
	  if (name) {
	    const parsed = Table.parseName(name);
	    this.name = parsed.name;
	    this.schema = parsed.schema;
	    this.database = parsed.database;
	    this.path = (this.database ? `[${this.database}].` : '') + (this.schema ? `[${this.schema}].` : '') + `[${this.name}]`;
	    this.temporary = this.name.charAt(0) === '#';
	  }

	  this.columns = [];
	  this.rows = [];

	  Object.defineProperty(this.columns, 'add', {
	    value (name, column, options) {
	      if (column == null) {
	        throw new Error('Column data type is not defined.')
	      }
	      if (column instanceof Function) {
	        column = column();
	      }

	      options = options || {};
	      column.name = name;

	      ['nullable', 'primary', 'identity', 'readOnly', 'length'].forEach(prop => {
	        if (objectHasProperty(options, prop)) {
	          column[prop] = options[prop];
	        }
	      });

	      return this.push(column)
	    }
	  });

	  Object.defineProperty(this.rows, 'add', {
	    value () {
	      return this.push(Array.prototype.slice.call(arguments))
	    }
	  }
	  );

	  Object.defineProperty(this.rows, 'clear', {
	    value () {
	      return this.splice(0, this.length)
	    }
	  }
	  );
	}

	/*
	@private
	*/

	Table.prototype._makeBulk = function _makeBulk () {
	  for (let i = 0; i < this.columns.length; i++) {
	    const col = this.columns[i];
	    switch (col.type) {
	      case TYPES.Date:
	      case TYPES.DateTime:
	      case TYPES.DateTime2:
	        for (let j = 0; j < this.rows.length; j++) {
	          const dateValue = this.rows[j][i];
	          if (typeof dateValue === 'string' || typeof dateValue === 'number') {
	            const date = new Date(dateValue);
	            if (isNaN(date.getDate())) {
	              throw new TypeError('Invalid date value passed to bulk rows')
	            }
	            this.rows[j][i] = date;
	          }
	        }
	        break

	      case TYPES.Xml:
	        col.type = TYPES.NVarChar(MAX).type;
	        break

	      case TYPES.UDT:
	      case TYPES.Geography:
	      case TYPES.Geometry:
	        col.type = TYPES.VarBinary(MAX).type;
	        break
	    }
	  }

	  return this
	};

	Table.prototype.declare = function declare () {
	  const pkey = this.columns.filter(col => col.primary === true).map(col => `[${col.name}]`);
	  const cols = this.columns.map(col => {
	    const def = [`[${col.name}] ${declareType(col.type, col)}`];

	    if (col.nullable === true) {
	      def.push('null');
	    } else if (col.nullable === false) {
	      def.push('not null');
	    }

	    if (col.primary === true && pkey.length === 1) {
	      def.push('primary key');
	    }

	    return def.join(' ')
	  });

	  const constraint = pkey.length > 1 ? `, constraint [PK_${this.temporary ? this.name.substr(1) : this.name}] primary key (${pkey.join(', ')})` : '';
	  return `create table ${this.path} (${cols.join(', ')}${constraint})`
	};

	Table.fromRecordset = function fromRecordset (recordset, name) {
	  const t = new this(name);

	  for (const colName in recordset.columns) {
	    if (objectHasProperty(recordset.columns, colName)) {
	      const col = recordset.columns[colName];

	      t.columns.add(colName, {
	        type: col.type,
	        length: col.length,
	        scale: col.scale,
	        precision: col.precision
	      }, {
	        nullable: col.nullable,
	        identity: col.identity,
	        readOnly: col.readOnly
	      });
	    }
	  }

	  if (t.columns.length === 1 && t.columns[0].name === JSON_COLUMN_ID) {
	    for (let i = 0; i < recordset.length; i++) {
	      t.rows.add(JSON.stringify(recordset[i]));
	    }
	  } else {
	    for (let i = 0; i < recordset.length; i++) {
	      t.rows.add.apply(t.rows, t.columns.map(col => recordset[i][col.name]));
	    }
	  }

	  return t
	};

	Table.parseName = function parseName (name) {
	  const length = name.length;
	  let cursor = -1;
	  let buffer = '';
	  let escaped = false;
	  const path = [];

	  while (++cursor < length) {
	    const char = name.charAt(cursor);
	    if (char === '[') {
	      if (escaped) {
	        buffer += char;
	      } else {
	        escaped = true;
	      }
	    } else if (char === ']') {
	      if (escaped) {
	        escaped = false;
	      } else {
	        throw new Error('Invalid table name.')
	      }
	    } else if (char === '.') {
	      if (escaped) {
	        buffer += char;
	      } else {
	        path.push(buffer);
	        buffer = '';
	      }
	    } else {
	      buffer += char;
	    }
	  }

	  if (buffer) {
	    path.push(buffer);
	  }

	  switch (path.length) {
	    case 1:
	      return {
	        name: path[0],
	        schema: null,
	        database: null
	      }

	    case 2:
	      return {
	        name: path[1],
	        schema: path[0],
	        database: null
	      }

	    case 3:
	      return {
	        name: path[2],
	        schema: path[1],
	        database: path[0]
	      }

	    default:
	      throw new Error('Invalid table name.')
	  }
	};

	table = Table;
	return table;
}

var hasRequiredShared;

function requireShared () {
	if (hasRequiredShared) return shared.exports;
	hasRequiredShared = 1;
	(function (module) {

		const TYPES = requireDatatypes().TYPES;
		const Table = requireTable();

		let PromiseLibrary = Promise;
		const driver = {};
		const map = [];

		/**
		 * Register you own type map.
		 *
		 * @path module.exports.map
		 * @param {*} jstype JS data type.
		 * @param {*} sqltype SQL data type.
		 */

		map.register = function (jstype, sqltype) {
		  for (let index = 0; index < this.length; index++) {
		    const item = this[index];
		    if (item.js === jstype) {
		      this.splice(index, 1);
		      break
		    }
		  }

		  this.push({
		    js: jstype,
		    sql: sqltype
		  });

		  return null
		};

		map.register(String, TYPES.NVarChar);
		map.register(Number, TYPES.Int);
		map.register(Boolean, TYPES.Bit);
		map.register(Date, TYPES.DateTime);
		map.register(Buffer, TYPES.VarBinary);
		map.register(Table, TYPES.TVP);

		/**
		 * @ignore
		 */

		const getTypeByValue = function (value) {
		  if ((value === null) || (value === undefined)) { return TYPES.NVarChar }

		  switch (typeof value) {
		    case 'string':
		      for (const item of Array.from(map)) {
		        if (item.js === String) {
		          return item.sql
		        }
		      }

		      return TYPES.NVarChar

		    case 'number':
		      if (value % 1 === 0) {
		        if (value < -2147483648 || value > 2147483647) {
		          return TYPES.BigInt
		        } else {
		          return TYPES.Int
		        }
		      } else {
		        return TYPES.Float
		      }

		    case 'bigint':
		      if (value < -2147483648n || value > 2147483647n) {
		        return TYPES.BigInt
		      } else {
		        return TYPES.Int
		      }

		    case 'boolean':
		      for (const item of Array.from(map)) {
		        if (item.js === Boolean) {
		          return item.sql
		        }
		      }

		      return TYPES.Bit

		    case 'object':
		      for (const item of Array.from(map)) {
		        if (value instanceof item.js) {
		          return item.sql
		        }
		      }

		      return TYPES.NVarChar

		    default:
		      return TYPES.NVarChar
		  }
		};

		module.exports = {
		  driver,
		  getTypeByValue,
		  map
		};

		Object.defineProperty(module.exports, 'Promise', {
		  get: () => {
		    return PromiseLibrary
		  },
		  set: (value) => {
		    PromiseLibrary = value;
		  }
		});

		Object.defineProperty(module.exports, 'valueHandler', {
		  enumerable: true,
		  value: new Map(),
		  writable: false,
		  configurable: false
		}); 
	} (shared));
	return shared.exports;
}

var rfdc_1;
var hasRequiredRfdc;

function requireRfdc () {
	if (hasRequiredRfdc) return rfdc_1;
	hasRequiredRfdc = 1;
	rfdc_1 = rfdc;

	function copyBuffer (cur) {
	  if (cur instanceof Buffer) {
	    return Buffer.from(cur)
	  }

	  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)
	}

	function rfdc (opts) {
	  opts = opts || {};
	  if (opts.circles) return rfdcCircles(opts)

	  const constructorHandlers = new Map();
	  constructorHandlers.set(Date, (o) => new Date(o));
	  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
	  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
	  if (opts.constructorHandlers) {
	    for (const handler of opts.constructorHandlers) {
	      constructorHandlers.set(handler[0], handler[1]);
	    }
	  }

	  let handler = null;

	  return opts.proto ? cloneProto : clone

	  function cloneArray (a, fn) {
	    const keys = Object.keys(a);
	    const a2 = new Array(keys.length);
	    for (let i = 0; i < keys.length; i++) {
	      const k = keys[i];
	      const cur = a[k];
	      if (typeof cur !== 'object' || cur === null) {
	        a2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        a2[k] = handler(cur, fn);
	      } else if (ArrayBuffer.isView(cur)) {
	        a2[k] = copyBuffer(cur);
	      } else {
	        a2[k] = fn(cur);
	      }
	    }
	    return a2
	  }

	  function clone (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, clone)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, clone)
	    }
	    const o2 = {};
	    for (const k in o) {
	      if (Object.hasOwnProperty.call(o, k) === false) continue
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, clone);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        o2[k] = clone(cur);
	      }
	    }
	    return o2
	  }

	  function cloneProto (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, cloneProto)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, cloneProto)
	    }
	    const o2 = {};
	    for (const k in o) {
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, cloneProto);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        o2[k] = cloneProto(cur);
	      }
	    }
	    return o2
	  }
	}

	function rfdcCircles (opts) {
	  const refs = [];
	  const refsNew = [];

	  const constructorHandlers = new Map();
	  constructorHandlers.set(Date, (o) => new Date(o));
	  constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
	  constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
	  if (opts.constructorHandlers) {
	    for (const handler of opts.constructorHandlers) {
	      constructorHandlers.set(handler[0], handler[1]);
	    }
	  }

	  let handler = null;
	  return opts.proto ? cloneProto : clone

	  function cloneArray (a, fn) {
	    const keys = Object.keys(a);
	    const a2 = new Array(keys.length);
	    for (let i = 0; i < keys.length; i++) {
	      const k = keys[i];
	      const cur = a[k];
	      if (typeof cur !== 'object' || cur === null) {
	        a2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        a2[k] = handler(cur, fn);
	      } else if (ArrayBuffer.isView(cur)) {
	        a2[k] = copyBuffer(cur);
	      } else {
	        const index = refs.indexOf(cur);
	        if (index !== -1) {
	          a2[k] = refsNew[index];
	        } else {
	          a2[k] = fn(cur);
	        }
	      }
	    }
	    return a2
	  }

	  function clone (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, clone)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, clone)
	    }
	    const o2 = {};
	    refs.push(o);
	    refsNew.push(o2);
	    for (const k in o) {
	      if (Object.hasOwnProperty.call(o, k) === false) continue
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, clone);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        const i = refs.indexOf(cur);
	        if (i !== -1) {
	          o2[k] = refsNew[i];
	        } else {
	          o2[k] = clone(cur);
	        }
	      }
	    }
	    refs.pop();
	    refsNew.pop();
	    return o2
	  }

	  function cloneProto (o) {
	    if (typeof o !== 'object' || o === null) return o
	    if (Array.isArray(o)) return cloneArray(o, cloneProto)
	    if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
	      return handler(o, cloneProto)
	    }
	    const o2 = {};
	    refs.push(o);
	    refsNew.push(o2);
	    for (const k in o) {
	      const cur = o[k];
	      if (typeof cur !== 'object' || cur === null) {
	        o2[k] = cur;
	      } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
	        o2[k] = handler(cur, cloneProto);
	      } else if (ArrayBuffer.isView(cur)) {
	        o2[k] = copyBuffer(cur);
	      } else {
	        const i = refs.indexOf(cur);
	        if (i !== -1) {
	          o2[k] = refsNew[i];
	        } else {
	          o2[k] = cloneProto(cur);
	        }
	      }
	    }
	    refs.pop();
	    refsNew.pop();
	    return o2
	  }
	}
	return rfdc_1;
}

var _default;
var hasRequired_default;

function require_default () {
	if (hasRequired_default) return _default;
	hasRequired_default = 1;

	_default = requireRfdc()();
	return _default;
}

var preparedStatementError;
var hasRequiredPreparedStatementError;

function requirePreparedStatementError () {
	if (hasRequiredPreparedStatementError) return preparedStatementError;
	hasRequiredPreparedStatementError = 1;

	const MSSQLError = requireMssqlError();

	/**
	 * Class PreparedStatementError.
	 */

	class PreparedStatementError extends MSSQLError {
	  /**
	   * Creates a new PreparedStatementError.
	   *
	   * @param {String} message Error message.
	   * @param {String} [code] Error code.
	   */

	  constructor (message, code) {
	    super(message, code);

	    this.name = 'PreparedStatementError';
	  }
	}

	preparedStatementError = PreparedStatementError;
	return preparedStatementError;
}

var requestError;
var hasRequiredRequestError;

function requireRequestError () {
	if (hasRequiredRequestError) return requestError;
	hasRequiredRequestError = 1;

	const MSSQLError = requireMssqlError();

	/**
	 * Class RequestError.
	 *
	 * @property {String} number Error number.
	 * @property {Number} lineNumber Line number.
	 * @property {String} state Error state.
	 * @property {String} class Error class.
	 * @property {String} serverName Server name.
	 * @property {String} procName Procedure name.
	 */

	class RequestError extends MSSQLError {
	  /**
	   * Creates a new RequestError.
	   *
	   * @param {String} message Error message.
	   * @param {String} [code] Error code.
	   */

	  constructor (message, code) {
	    super(message, code);
	    if (message instanceof Error) {
	      if (message.info) {
	        this.number = message.info.number || message.code; // err.code is returned by msnodesql driver
	        this.lineNumber = message.info.lineNumber;
	        this.state = message.info.state || message.sqlstate; // err.sqlstate is returned by msnodesql driver
	        this.class = message.info.class;
	        this.serverName = message.info.serverName;
	        this.procName = message.info.procName;
	      } else {
	        // Use err attributes returned by msnodesql driver
	        this.number = message.code;
	        this.lineNumber = message.lineNumber;
	        this.state = message.sqlstate;
	        this.class = message.severity;
	        this.serverName = message.serverName;
	        this.procName = message.procName;
	      }
	    }

	    this.name = 'RequestError';
	    const parsedMessage = (/^\[Microsoft\]\[SQL Server Native Client 11\.0\](?:\[SQL Server\])?([\s\S]*)$/).exec(this.message);
	    if (parsedMessage) {
	      this.message = parsedMessage[1];
	    }
	  }
	}

	requestError = RequestError;
	return requestError;
}

var transactionError;
var hasRequiredTransactionError;

function requireTransactionError () {
	if (hasRequiredTransactionError) return transactionError;
	hasRequiredTransactionError = 1;

	const MSSQLError = requireMssqlError();

	/**
	 * Class TransactionError.
	 */

	class TransactionError extends MSSQLError {
	  /**
	   * Creates a new TransactionError.
	   *
	   * @param {String} message Error message.
	   * @param {String} [code] Error code.
	   */

	  constructor (message, code) {
	    super(message, code);

	    this.name = 'TransactionError';
	  }
	}

	transactionError = TransactionError;
	return transactionError;
}

var error$2;
var hasRequiredError$2;

function requireError$2 () {
	if (hasRequiredError$2) return error$2;
	hasRequiredError$2 = 1;

	const ConnectionError = requireConnectionError();
	const MSSQLError = requireMssqlError();
	const PreparedStatementError = requirePreparedStatementError();
	const RequestError = requireRequestError();
	const TransactionError = requireTransactionError();

	error$2 = {
	  ConnectionError,
	  MSSQLError,
	  PreparedStatementError,
	  RequestError,
	  TransactionError
	};
	return error$2;
}

var connectionPool$1;
var hasRequiredConnectionPool$1;

function requireConnectionPool$1 () {
	if (hasRequiredConnectionPool$1) return connectionPool$1;
	hasRequiredConnectionPool$1 = 1;

	const { EventEmitter } = __require$b();
	const debug = requireSrc()('mssql:base');
	const { parseSqlConnectionString } = requireLib$2();
	const tarn = requireTarn();
	const { IDS } = requireUtils$4();
	const ConnectionError = requireConnectionError();
	const shared = requireShared();
	const clone = require_default();
	const { MSSQLError } = requireError$2();

	/**
	 * Class ConnectionPool.
	 *
	 * Internally, each `Connection` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool.
	 *
	 * @property {Boolean} connected If true, connection is established.
	 * @property {Boolean} connecting If true, connection is being established.
	 *
	 * @fires ConnectionPool#connect
	 * @fires ConnectionPool#close
	 */

	class ConnectionPool extends EventEmitter {
	  /**
	   * Create new Connection.
	   *
	   * @param {Object|String} config Connection configuration object or connection string.
	   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.
	   */

	  constructor (config, callback) {
	    super();

	    IDS.add(this, 'ConnectionPool');
	    debug('pool(%d): created', IDS.get(this));

	    this._connectStack = [];
	    this._closeStack = [];

	    this._connected = false;
	    this._connecting = false;
	    this._healthy = false;

	    if (typeof config === 'string') {
	      try {
	        this.config = this.constructor.parseConnectionString(config);
	      } catch (ex) {
	        if (typeof callback === 'function') {
	          return setImmediate(callback, ex)
	        }
	        throw ex
	      }
	    } else {
	      this.config = clone(config);
	    }

	    // set defaults
	    this.config.port = this.config.port || 1433;
	    this.config.options = this.config.options || {};
	    this.config.stream = this.config.stream || false;
	    this.config.parseJSON = this.config.parseJSON || false;
	    this.config.arrayRowMode = this.config.arrayRowMode || false;
	    this.config.validateConnection = 'validateConnection' in this.config ? this.config.validateConnection : true;

	    const namedServer = /^(.*)\\(.*)$/.exec(this.config.server);
	    if (namedServer) {
	      this.config.server = namedServer[1];
	      this.config.options.instanceName = namedServer[2];
	    }

	    if (typeof this.config.options.useColumnNames !== 'undefined' && this.config.options.useColumnNames !== true) {
	      const ex = new MSSQLError('Invalid options `useColumnNames`, use `arrayRowMode` instead');
	      if (typeof callback === 'function') {
	        return setImmediate(callback, ex)
	      }
	      throw ex
	    }

	    if (typeof callback === 'function') {
	      this.connect(callback);
	    }
	  }

	  get connected () {
	    return this._connected
	  }

	  get connecting () {
	    return this._connecting
	  }

	  get healthy () {
	    return this._healthy
	  }

	  static parseConnectionString (connectionString) {
	    return this._parseConnectionString(connectionString)
	  }

	  static _parseAuthenticationType (type, entries) {
	    switch (type.toLowerCase()) {
	      case 'active directory integrated':
	        if (entries.includes('token')) {
	          return 'azure-active-directory-access-token'
	        } else if (['client id', 'client secret', 'tenant id'].every(entry => entries.includes(entry))) {
	          return 'azure-active-directory-service-principal-secret'
	        } else if (['client id', 'msi endpoint', 'msi secret'].every(entry => entries.includes(entry))) {
	          return 'azure-active-directory-msi-app-service'
	        } else if (['client id', 'msi endpoint'].every(entry => entries.includes(entry))) {
	          return 'azure-active-directory-msi-vm'
	        }
	        return 'azure-active-directory-default'
	      case 'active directory password':
	        return 'azure-active-directory-password'
	      case 'ntlm':
	        return 'ntlm'
	      default:
	        return 'default'
	    }
	  }

	  static _parseConnectionString (connectionString) {
	    const parsed = parseSqlConnectionString(connectionString, true, true);
	    return Object.entries(parsed).reduce((config, [key, value]) => {
	      switch (key) {
	        case 'application name':
	          break
	        case 'applicationintent':
	          Object.assign(config.options, {
	            readOnlyIntent: value === 'readonly'
	          });
	          break
	        case 'asynchronous processing':
	          break
	        case 'attachdbfilename':
	          break
	        case 'authentication':
	          Object.assign(config, {
	            authentication_type: this._parseAuthenticationType(value, Object.keys(parsed))
	          });
	          break
	        case 'column encryption setting':
	          break
	        case 'connection timeout':
	          Object.assign(config, {
	            connectionTimeout: value * 1000
	          });
	          break
	        case 'connection lifetime':
	          break
	        case 'connectretrycount':
	          break
	        case 'connectretryinterval':
	          Object.assign(config.options, {
	            connectionRetryInterval: value * 1000
	          });
	          break
	        case 'context connection':
	          break
	        case 'client id':
	          Object.assign(config, {
	            clientId: value
	          });
	          break
	        case 'client secret':
	          Object.assign(config, {
	            clientSecret: value
	          });
	          break
	        case 'current language':
	          Object.assign(config.options, {
	            language: value
	          });
	          break
	        case 'data source':
	        {
	          let server = value;
	          let instanceName;
	          let port = 1433;
	          if (/^np:/i.test(server)) {
	            throw new Error('Connection via Named Pipes is not supported.')
	          }
	          if (/^tcp:/i.test(server)) {
	            server = server.substr(4);
	          }
	          const namedServerParts = /^(.*)\\(.*)$/.exec(server);
	          if (namedServerParts) {
	            server = namedServerParts[1].trim();
	            instanceName = namedServerParts[2].trim();
	          }
	          const serverParts = /^(.*),(.*)$/.exec(server);
	          if (serverParts) {
	            server = serverParts[1].trim();
	            port = parseInt(serverParts[2].trim(), 10);
	          } else {
	            const instanceParts = /^(.*),(.*)$/.exec(instanceName);
	            if (instanceParts) {
	              instanceName = instanceParts[1].trim();
	              port = parseInt(instanceParts[2].trim(), 10);
	            }
	          }
	          if (server === '.' || server === '(.)' || server.toLowerCase() === '(localdb)' || server.toLowerCase() === '(local)') {
	            server = 'localhost';
	          }
	          Object.assign(config, {
	            port,
	            server
	          });
	          if (instanceName) {
	            Object.assign(config.options, {
	              instanceName
	            });
	          }
	          break
	        }
	        case 'encrypt':
	          Object.assign(config.options, {
	            encrypt: !!value
	          });
	          break
	        case 'enlist':
	          break
	        case 'failover partner':
	          break
	        case 'initial catalog':
	          Object.assign(config, {
	            database: value
	          });
	          break
	        case 'integrated security':
	          break
	        case 'max pool size':
	          Object.assign(config.pool, {
	            max: value
	          });
	          break
	        case 'min pool size':
	          Object.assign(config.pool, {
	            min: value
	          });
	          break
	        case 'msi endpoint':
	          Object.assign(config, {
	            msiEndpoint: value
	          });
	          break
	        case 'msi secret':
	          Object.assign(config, {
	            msiSecret: value
	          });
	          break
	        case 'multipleactiveresultsets':
	          break
	        case 'multisubnetfailover':
	          Object.assign(config.options, {
	            multiSubnetFailover: value
	          });
	          break
	        case 'network library':
	          break
	        case 'packet size':
	          Object.assign(config.options, {
	            packetSize: value
	          });
	          break
	        case 'password':
	          Object.assign(config, {
	            password: value
	          });
	          break
	        case 'persist security info':
	          break
	        case 'poolblockingperiod':
	          break
	        case 'pooling':
	          break
	        case 'replication':
	          break
	        case 'tenant id':
	          Object.assign(config, {
	            tenantId: value
	          });
	          break
	        case 'token':
	          Object.assign(config, {
	            token: value
	          });
	          break
	        case 'transaction binding':
	          Object.assign(config.options, {
	            enableImplicitTransactions: value.toLowerCase() === 'implicit unbind'
	          });
	          break
	        case 'transparentnetworkipresolution':
	          break
	        case 'trustservercertificate':
	          Object.assign(config.options, {
	            trustServerCertificate: value
	          });
	          break
	        case 'type system version':
	          break
	        case 'user id': {
	          let user = value;
	          let domain;
	          const domainUser = /^(.*)\\(.*)$/.exec(user);
	          if (domainUser) {
	            domain = domainUser[1];
	            user = domainUser[2];
	          }
	          if (domain) {
	            Object.assign(config, {
	              domain
	            });
	          }
	          if (user) {
	            Object.assign(config, {
	              user
	            });
	          }
	          break
	        }
	        case 'user instance':
	          break
	        case 'workstation id':
	          Object.assign(config.options, {
	            workstationId: value
	          });
	          break
	        case 'request timeout':
	          Object.assign(config, {
	            requestTimeout: parseInt(value, 10)
	          });
	          break
	        case 'stream':
	          Object.assign(config, {
	            stream: !!value
	          });
	          break
	        case 'useutc':
	          Object.assign(config.options, {
	            useUTC: !!value
	          });
	          break
	        case 'parsejson':
	          Object.assign(config, {
	            parseJSON: !!value
	          });
	          break
	      }
	      return config
	    }, { options: {}, pool: {} })
	  }

	  /**
	   * Acquire connection from this connection pool.
	   *
	   * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.
	   * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.
	   * @return {ConnectionPool|Promise}
	   */

	  acquire (requester, callback) {
	    const acquirePromise = shared.Promise.resolve(this._acquire()).catch(err => {
	      this.emit('error', err);
	      throw err
	    });
	    if (typeof callback === 'function') {
	      acquirePromise.then(connection => callback(null, connection, this.config)).catch(callback);
	      return this
	    }

	    return acquirePromise
	  }

	  _acquire () {
	    if (!this.pool) {
	      return shared.Promise.reject(new ConnectionError('Connection not yet open.', 'ENOTOPEN'))
	    } else if (this.pool.destroyed) {
	      return shared.Promise.reject(new ConnectionError('Connection is closing', 'ENOTOPEN'))
	    }

	    return this.pool.acquire().promise
	  }

	  /**
	   * Release connection back to the pool.
	   *
	   * @param {Connection} connection Previously acquired connection.
	   * @return {ConnectionPool}
	   */

	  release (connection) {
	    debug('connection(%d): released', IDS.get(connection));

	    if (this.pool) {
	      this.pool.release(connection);
	    }
	    return this
	  }

	  /**
	   * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.
	   *
	   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
	   * @return {ConnectionPool|Promise}
	   */

	  connect (callback) {
	    if (typeof callback === 'function') {
	      this._connect(callback);
	      return this
	    }

	    return new shared.Promise((resolve, reject) => {
	      return this._connect(err => {
	        if (err) return reject(err)
	        resolve(this);
	      })
	    })
	  }

	  /**
	   * @private
	   * @param {basicCallback} callback
	   */

	  _connect (callback) {
	    if (this._connected) {
	      debug('pool(%d): already connected, executing connect callback immediately', IDS.get(this));
	      return setImmediate(callback, null, this)
	    }

	    this._connectStack.push(callback);

	    if (this._connecting) {
	      return
	    }

	    this._connecting = true;
	    debug('pool(%d): connecting', IDS.get(this));

	    // create one test connection to check if everything is ok
	    this._poolCreate().then((connection) => {
	      debug('pool(%d): connected', IDS.get(this));
	      this._healthy = true;

	      return this._poolDestroy(connection).then(() => {
	        // prepare pool
	        this.pool = new tarn.Pool(
	          Object.assign({
	            create: () => this._poolCreate()
	              .then(connection => {
	                this._healthy = true;
	                return connection
	              })
	              .catch(err => {
	                if (this.pool.numUsed() + this.pool.numFree() <= 0) {
	                  this._healthy = false;
	                }
	                throw err
	              }),
	            validate: this._poolValidate.bind(this),
	            destroy: this._poolDestroy.bind(this),
	            max: 10,
	            min: 0,
	            idleTimeoutMillis: 30000,
	            propagateCreateError: true
	          }, this.config.pool)
	        );

	        this._connecting = false;
	        this._connected = true;
	      })
	    }).then(() => {
	      this._connectStack.forEach((cb) => {
	        setImmediate(cb, null, this);
	      });
	    }).catch(err => {
	      this._connecting = false;
	      this._connectStack.forEach((cb) => {
	        setImmediate(cb, err);
	      });
	    }).then(() => {
	      this._connectStack = [];
	    });
	  }

	  get size () {
	    return this.pool.numFree() + this.pool.numUsed() + this.pool.numPendingCreates()
	  }

	  get available () {
	    return this.pool.numFree()
	  }

	  get pending () {
	    return this.pool.numPendingAcquires()
	  }

	  get borrowed () {
	    return this.pool.numUsed()
	  }

	  /**
	   * Close all active connections in the pool.
	   *
	   * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.
	   * @return {ConnectionPool|Promise}
	   */

	  close (callback) {
	    if (typeof callback === 'function') {
	      this._close(callback);
	      return this
	    }

	    return new shared.Promise((resolve, reject) => {
	      this._close(err => {
	        if (err) return reject(err)
	        resolve(this);
	      });
	    })
	  }

	  /**
	   * @private
	   * @param {basicCallback} callback
	   */

	  _close (callback) {
	    // we don't allow pools in a connecting state to be closed because it means there are far too many
	    // edge cases to deal with
	    if (this._connecting) {
	      debug('pool(%d): close called while connecting', IDS.get(this));
	      setImmediate(callback, new ConnectionError('Cannot close a pool while it is connecting'));
	    }

	    if (!this.pool) {
	      debug('pool(%d): already closed, executing close callback immediately', IDS.get(this));
	      return setImmediate(callback, null)
	    }

	    this._closeStack.push(callback);

	    if (this.pool.destroyed) return

	    this._connecting = this._connected = this._healthy = false;

	    this.pool.destroy().then(() => {
	      debug('pool(%d): pool closed, removing pool reference and executing close callbacks', IDS.get(this));
	      this.pool = null;
	      this._closeStack.forEach(cb => {
	        setImmediate(cb, null);
	      });
	    }).catch(err => {
	      this.pool = null;
	      this._closeStack.forEach(cb => {
	        setImmediate(cb, err);
	      });
	    }).then(() => {
	      this._closeStack = [];
	    });
	  }

	  /**
	   * Returns new request using this connection.
	   *
	   * @return {Request}
	   */

	  request () {
	    return new shared.driver.Request(this)
	  }

	  /**
	   * Returns new transaction using this connection.
	   *
	   * @return {Transaction}
	   */

	  transaction () {
	    return new shared.driver.Transaction(this)
	  }

	  /**
	   * Creates a new query using this connection from a tagged template string.
	   *
	   * @variation 1
	   * @param {Array} strings Array of string literals.
	   * @param {...*} keys Values.
	   * @return {Request}
	   */

	  /**
	   * Execute the SQL command.
	   *
	   * @variation 2
	   * @param {String} command T-SQL command to be executed.
	   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
	   * @return {Request|Promise}
	   */

	  query () {
	    if (typeof arguments[0] === 'string') { return new shared.driver.Request(this).query(arguments[0], arguments[1]) }

	    const values = Array.prototype.slice.call(arguments);
	    const strings = values.shift();

	    return new shared.driver.Request(this)._template(strings, values, 'query')
	  }

	  /**
	   * Creates a new batch using this connection from a tagged template string.
	   *
	   * @variation 1
	   * @param {Array} strings Array of string literals.
	   * @param {...*} keys Values.
	   * @return {Request}
	   */

	  /**
	   * Execute the SQL command.
	   *
	   * @variation 2
	   * @param {String} command T-SQL command to be executed.
	   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
	   * @return {Request|Promise}
	   */

	  batch () {
	    if (typeof arguments[0] === 'string') { return new shared.driver.Request(this).batch(arguments[0], arguments[1]) }

	    const values = Array.prototype.slice.call(arguments);
	    const strings = values.shift();

	    return new shared.driver.Request(this)._template(strings, values, 'batch')
	  }
	}

	connectionPool$1 = ConnectionPool;
	return connectionPool$1;
}

var globalConnection = {exports: {}};

var hasRequiredGlobalConnection;

function requireGlobalConnection () {
	if (hasRequiredGlobalConnection) return globalConnection.exports;
	hasRequiredGlobalConnection = 1;
	(function (module) {

		const shared = requireShared();

		let globalConnection = null;
		const globalConnectionHandlers = {};

		/**
		 * Open global connection pool.
		 *
		 * @param {Object|String} config Connection configuration object or connection string.
		 * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
		 * @return {Promise.<ConnectionPool>}
		 */

		function connect (config, callback) {
		  if (!globalConnection) {
		    globalConnection = new shared.driver.ConnectionPool(config);

		    for (const event in globalConnectionHandlers) {
		      for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
		        globalConnection.on(event, globalConnectionHandlers[event][i]);
		      }
		    }

		    const ogClose = globalConnection.close;

		    const globalClose = function (callback) {
		      // remove event handlers from the global connection
		      for (const event in globalConnectionHandlers) {
		        for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {
		          this.removeListener(event, globalConnectionHandlers[event][i]);
		        }
		      }

		      // attach error handler to prevent process crash in case of error
		      this.on('error', err => {
		        if (globalConnectionHandlers.error) {
		          for (let i = 0, l = globalConnectionHandlers.error.length; i < l; i++) {
		            globalConnectionHandlers.error[i].call(this, err);
		          }
		        }
		      });

		      globalConnection = null;
		      return ogClose.call(this, callback)
		    };

		    globalConnection.close = globalClose.bind(globalConnection);
		  }
		  if (typeof callback === 'function') {
		    return globalConnection.connect((err, connection) => {
		      if (err) {
		        globalConnection = null;
		      }
		      callback(err, connection);
		    })
		  }
		  return globalConnection.connect().catch((err) => {
		    globalConnection = null;
		    return shared.Promise.reject(err)
		  })
		}

		/**
		 * Close all active connections in the global pool.
		 *
		 * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.
		 * @return {ConnectionPool|Promise}
		 */

		function close (callback) {
		  if (globalConnection) {
		    const gc = globalConnection;
		    globalConnection = null;
		    return gc.close(callback)
		  }

		  if (typeof callback === 'function') {
		    setImmediate(callback);
		    return null
		  }

		  return new shared.Promise((resolve) => {
		    resolve(globalConnection);
		  })
		}

		/**
		 * Attach event handler to global connection pool.
		 *
		 * @param {String} event Event name.
		 * @param {Function} handler Event handler.
		 * @return {ConnectionPool}
		 */

		function on (event, handler) {
		  if (!globalConnectionHandlers[event]) globalConnectionHandlers[event] = [];
		  globalConnectionHandlers[event].push(handler);

		  if (globalConnection) globalConnection.on(event, handler);
		  return globalConnection
		}

		/**
		 * Detach event handler from global connection.
		 *
		 * @param {String} event Event name.
		 * @param {Function} handler Event handler.
		 * @return {ConnectionPool}
		 */

		function removeListener (event, handler) {
		  if (!globalConnectionHandlers[event]) return globalConnection
		  const index = globalConnectionHandlers[event].indexOf(handler);
		  if (index === -1) return globalConnection
		  globalConnectionHandlers[event].splice(index, 1);
		  if (globalConnectionHandlers[event].length === 0) globalConnectionHandlers[event] = undefined;

		  if (globalConnection) globalConnection.removeListener(event, handler);
		  return globalConnection
		}

		/**
		 * Creates a new query using global connection from a tagged template string.
		 *
		 * @variation 1
		 * @param {Array|String} strings Array of string literals or sql command.
		 * @param {...*} keys Values.
		 * @return {Request}
		 */

		/**
		 * Execute the SQL command.
		 *
		 * @variation 2
		 * @param {String} command T-SQL command to be executed.
		 * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
		 * @return {Request|Promise}
		 */

		function query () {
		  if (typeof arguments[0] === 'string') { return new shared.driver.Request().query(arguments[0], arguments[1]) }

		  const values = Array.prototype.slice.call(arguments);
		  const strings = values.shift();

		  return new shared.driver.Request()._template(strings, values, 'query')
		}

		/**
		 * Creates a new batch using global connection from a tagged template string.
		 *
		 * @variation 1
		 * @param {Array} strings Array of string literals.
		 * @param {...*} keys Values.
		 * @return {Request}
		 */

		/**
		 * Execute the SQL command.
		 *
		 * @variation 2
		 * @param {String} command T-SQL command to be executed.
		 * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
		 * @return {Request|Promise}
		 */

		function batch () {
		  if (typeof arguments[0] === 'string') { return new shared.driver.Request().batch(arguments[0], arguments[1]) }

		  const values = Array.prototype.slice.call(arguments);
		  const strings = values.shift();

		  return new shared.driver.Request()._template(strings, values, 'batch')
		}

		module.exports = {
		  batch,
		  close,
		  connect,
		  off: removeListener,
		  on,
		  query,
		  removeListener
		};

		Object.defineProperty(module.exports, 'pool', {
		  get: () => {
		    return globalConnection
		  },
		  set: () => {}
		}); 
	} (globalConnection));
	return globalConnection.exports;
}

var preparedStatement;
var hasRequiredPreparedStatement;

function requirePreparedStatement () {
	if (hasRequiredPreparedStatement) return preparedStatement;
	hasRequiredPreparedStatement = 1;

	const debug = requireSrc()('mssql:base');
	const { EventEmitter } = __require$b();
	const { IDS, objectHasProperty } = requireUtils$4();
	const globalConnection = requireGlobalConnection();
	const { TransactionError, PreparedStatementError } = requireError$2();
	const shared = requireShared();
	const { TYPES, declare } = requireDatatypes();

	/**
	 * Class PreparedStatement.
	 *
	 * IMPORTANT: Rememeber that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!
	 *
	 * @property {String} statement Prepared SQL statement.
	 */

	class PreparedStatement extends EventEmitter {
	  /**
	   * Creates a new Prepared Statement.
	   *
	   * @param {ConnectionPool|Transaction} [holder]
	   */

	  constructor (parent) {
	    super();

	    IDS.add(this, 'PreparedStatement');
	    debug('ps(%d): created', IDS.get(this));

	    this.parent = parent || globalConnection.pool;
	    this._handle = 0;
	    this.prepared = false;
	    this.parameters = {};
	  }

	  get config () {
	    return this.parent.config
	  }

	  get connected () {
	    return this.parent.connected
	  }

	  /**
	   * Acquire connection from connection pool.
	   *
	   * @param {Request} request Request.
	   * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
	   * @return {PreparedStatement|Promise}
	   */

	  acquire (request, callback) {
	    if (!this._acquiredConnection) {
	      setImmediate(callback, new PreparedStatementError('Statement is not prepared. Call prepare() first.', 'ENOTPREPARED'));
	      return this
	    }

	    if (this._activeRequest) {
	      setImmediate(callback, new TransactionError("Can't acquire connection for the request. There is another request in progress.", 'EREQINPROG'));
	      return this
	    }

	    this._activeRequest = request;
	    setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
	    return this
	  }

	  /**
	   * Release connection back to the pool.
	   *
	   * @param {Connection} connection Previously acquired connection.
	   * @return {PreparedStatement}
	   */

	  release (connection) {
	    if (connection === this._acquiredConnection) {
	      this._activeRequest = null;
	    }

	    return this
	  }

	  /**
	   * Add an input parameter to the prepared statement.
	   *
	   * @param {String} name Name of the input parameter without @ char.
	   * @param {*} type SQL data type of input parameter.
	   * @return {PreparedStatement}
	   */

	  input (name, type) {
	    if (/--| |\/\*|\*\/|'/.test(name)) {
	      throw new PreparedStatementError(`SQL injection warning for param '${name}'`, 'EINJECT')
	    }

	    if (arguments.length < 2) {
	      throw new PreparedStatementError('Invalid number of arguments. 2 arguments expected.', 'EARGS')
	    }

	    if (type instanceof Function) {
	      type = type();
	    }

	    if (objectHasProperty(this.parameters, name)) {
	      throw new PreparedStatementError(`The parameter name ${name} has already been declared. Parameter names must be unique`, 'EDUPEPARAM')
	    }

	    this.parameters[name] = {
	      name,
	      type: type.type,
	      io: 1,
	      length: type.length,
	      scale: type.scale,
	      precision: type.precision,
	      tvpType: type.tvpType
	    };

	    return this
	  }

	  /**
	   * Replace an input parameter on the request.
	   *
	   * @param {String} name Name of the input parameter without @ char.
	   * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
	   * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
	   * @return {Request}
	   */

	  replaceInput (name, type, value) {
	    delete this.parameters[name];

	    return this.input(name, type, value)
	  }

	  /**
	   * Add an output parameter to the prepared statement.
	   *
	   * @param {String} name Name of the output parameter without @ char.
	   * @param {*} type SQL data type of output parameter.
	   * @return {PreparedStatement}
	   */

	  output (name, type) {
	    if (/--| |\/\*|\*\/|'/.test(name)) {
	      throw new PreparedStatementError(`SQL injection warning for param '${name}'`, 'EINJECT')
	    }

	    if (arguments.length < 2) {
	      throw new PreparedStatementError('Invalid number of arguments. 2 arguments expected.', 'EARGS')
	    }

	    if (type instanceof Function) type = type();

	    if (objectHasProperty(this.parameters, name)) {
	      throw new PreparedStatementError(`The parameter name ${name} has already been declared. Parameter names must be unique`, 'EDUPEPARAM')
	    }

	    this.parameters[name] = {
	      name,
	      type: type.type,
	      io: 2,
	      length: type.length,
	      scale: type.scale,
	      precision: type.precision
	    };

	    return this
	  }

	  /**
	   * Replace an output parameter on the request.
	   *
	   * @param {String} name Name of the output parameter without @ char.
	   * @param {*} type SQL data type of output parameter.
	   * @return {PreparedStatement}
	   */

	  replaceOutput (name, type) {
	    delete this.parameters[name];

	    return this.output(name, type)
	  }

	  /**
	   * Prepare a statement.
	   *
	   * @param {String} statement SQL statement to prepare.
	   * @param {basicCallback} [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.
	   * @return {PreparedStatement|Promise}
	   */

	  prepare (statement, callback) {
	    if (typeof callback === 'function') {
	      this._prepare(statement, callback);
	      return this
	    }

	    return new shared.Promise((resolve, reject) => {
	      this._prepare(statement, err => {
	        if (err) return reject(err)
	        resolve(this);
	      });
	    })
	  }

	  /**
	   * @private
	   * @param {String} statement
	   * @param {basicCallback} callback
	   */

	  _prepare (statement, callback) {
	    debug('ps(%d): prepare', IDS.get(this));

	    if (typeof statement === 'function') {
	      callback = statement;
	      statement = undefined;
	    }

	    if (this.prepared) {
	      return setImmediate(callback, new PreparedStatementError('Statement is already prepared.', 'EALREADYPREPARED'))
	    }

	    this.statement = statement || this.statement;

	    this.parent.acquire(this, (err, connection, config) => {
	      if (err) return callback(err)

	      this._acquiredConnection = connection;
	      this._acquiredConfig = config;

	      const req = new shared.driver.Request(this);
	      req.stream = false;
	      req.output('handle', TYPES.Int);
	      req.input('params', TYPES.NVarChar, ((() => {
	        const result = [];
	        for (const name in this.parameters) {
	          if (!objectHasProperty(this.parameters, name)) {
	            continue
	          }
	          const param = this.parameters[name];
	          result.push(`@${name} ${declare(param.type, param)}${param.io === 2 ? ' output' : ''}`);
	        }
	        return result
	      })()).join(','));
	      req.input('stmt', TYPES.NVarChar, this.statement);
	      req.execute('sp_prepare', (err, result) => {
	        if (err) {
	          this.parent.release(this._acquiredConnection);
	          this._acquiredConnection = null;
	          this._acquiredConfig = null;

	          return callback(err)
	        }

	        debug('ps(%d): prepared', IDS.get(this));

	        this._handle = result.output.handle;
	        this.prepared = true;

	        callback(null);
	      });
	    });
	  }

	  /**
	   * Execute a prepared statement.
	   *
	   * @param {Object} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.
	   * @param {basicCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
	   * @return {Request|Promise}
	   */

	  execute (values, callback) {
	    if (this.stream || (typeof callback === 'function')) {
	      return this._execute(values, callback)
	    }

	    return new shared.Promise((resolve, reject) => {
	      this._execute(values, (err, recordset) => {
	        if (err) return reject(err)
	        resolve(recordset);
	      });
	    })
	  }

	  /**
	   * @private
	   * @param {Object} values
	   * @param {basicCallback} callback
	   */

	  _execute (values, callback) {
	    const req = new shared.driver.Request(this);
	    req.stream = this.stream;
	    req.arrayRowMode = this.arrayRowMode;
	    req.input('handle', TYPES.Int, this._handle);

	    // copy parameters with new values
	    for (const name in this.parameters) {
	      if (!objectHasProperty(this.parameters, name)) {
	        continue
	      }
	      const param = this.parameters[name];
	      req.parameters[name] = {
	        name,
	        type: param.type,
	        io: param.io,
	        value: values[name],
	        length: param.length,
	        scale: param.scale,
	        precision: param.precision
	      };
	    }

	    req.execute('sp_execute', (err, result) => {
	      if (err) return callback(err)

	      callback(null, result);
	    });

	    return req
	  }

	  /**
	   * Unprepare a prepared statement.
	   *
	   * @param {basicCallback} [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.
	   * @return {PreparedStatement|Promise}
	   */

	  unprepare (callback) {
	    if (typeof callback === 'function') {
	      this._unprepare(callback);
	      return this
	    }

	    return new shared.Promise((resolve, reject) => {
	      this._unprepare(err => {
	        if (err) return reject(err)
	        resolve();
	      });
	    })
	  }

	  /**
	   * @private
	   * @param {basicCallback} callback
	   */

	  _unprepare (callback) {
	    debug('ps(%d): unprepare', IDS.get(this));

	    if (!this.prepared) {
	      return setImmediate(callback, new PreparedStatementError('Statement is not prepared. Call prepare() first.', 'ENOTPREPARED'))
	    }

	    if (this._activeRequest) {
	      return setImmediate(callback, new TransactionError("Can't unprepare the statement. There is a request in progress.", 'EREQINPROG'))
	    }

	    const req = new shared.driver.Request(this);
	    req.stream = false;
	    req.input('handle', TYPES.Int, this._handle);
	    req.execute('sp_unprepare', err => {
	      if (err) return callback(err)

	      this.parent.release(this._acquiredConnection);
	      this._acquiredConnection = null;
	      this._acquiredConfig = null;
	      this._handle = 0;
	      this.prepared = false;

	      debug('ps(%d): unprepared', IDS.get(this));

	      return callback(null)
	    });
	  }
	}

	preparedStatement = PreparedStatement;
	return preparedStatement;
}

const require$b = createRequire(import.meta.url);
function __require$a() { return require$b("node:stream"); }

var request$2;
var hasRequiredRequest$2;

function requireRequest$2 () {
	if (hasRequiredRequest$2) return request$2;
	hasRequiredRequest$2 = 1;

	const debug = requireSrc()('mssql:base');
	const { EventEmitter } = __require$b();
	const { Readable } = __require$a();
	const { IDS, objectHasProperty } = requireUtils$4();
	const globalConnection = requireGlobalConnection();
	const { RequestError, ConnectionError } = requireError$2();
	const { TYPES } = requireDatatypes();
	const shared = requireShared();

	/**
	 * Class Request.
	 *
	 * @property {Transaction} transaction Reference to transaction when request was created in transaction.
	 * @property {*} parameters Collection of input and output parameters.
	 * @property {Boolean} canceled `true` if request was canceled.
	 *
	 * @fires Request#recordset
	 * @fires Request#row
	 * @fires Request#done
	 * @fires Request#error
	 */

	class Request extends EventEmitter {
	  /**
	   * Create new Request.
	   *
	   * @param {Connection|ConnectionPool|Transaction|PreparedStatement} parent If omitted, global connection is used instead.
	   */

	  constructor (parent) {
	    super();

	    IDS.add(this, 'Request');
	    debug('request(%d): created', IDS.get(this));

	    this.canceled = false;
	    this._paused = false;
	    this.parent = parent || globalConnection.pool;
	    this.parameters = {};
	    this.stream = null;
	    this.arrayRowMode = null;
	  }

	  get paused () {
	    return this._paused
	  }

	  /**
	   * Generate sql string and set input parameters from tagged template string.
	   *
	   * @param {Template literal} template
	   * @return {String}
	   */
	  template () {
	    const values = Array.prototype.slice.call(arguments);
	    const strings = values.shift();
	    return this._template(strings, values)
	  }

	  /**
	   * Fetch request from tagged template string.
	   *
	   * @private
	   * @param {Array} strings
	   * @param {Array} values
	   * @param {String} [method] If provided, method is automatically called with serialized command on this object.
	   * @return {Request}
	   */

	  _template (strings, values, method) {
	    const command = [strings[0]];

	    for (let index = 0; index < values.length; index++) {
	      const value = values[index];
	      // if value is an array, prepare each items as it's own comma separated parameter
	      if (Array.isArray(value)) {
	        for (let parameterIndex = 0; parameterIndex < value.length; parameterIndex++) {
	          this.input(`param${index + 1}_${parameterIndex}`, value[parameterIndex]);
	          command.push(`@param${index + 1}_${parameterIndex}`);
	          if (parameterIndex < value.length - 1) {
	            command.push(', ');
	          }
	        }
	        command.push(strings[index + 1]);
	      } else {
	        this.input(`param${index + 1}`, value);
	        command.push(`@param${index + 1}`, strings[index + 1]);
	      }
	    }

	    if (method) {
	      return this[method](command.join(''))
	    } else {
	      return command.join('')
	    }
	  }

	  /**
	   * Add an input parameter to the request.
	   *
	   * @param {String} name Name of the input parameter without @ char.
	   * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
	   * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
	   * @return {Request}
	   */

	  input (name, type, value) {
	    if (/--| |\/\*|\*\/|'/.test(name)) {
	      throw new RequestError(`SQL injection warning for param '${name}'`, 'EINJECT')
	    }

	    if (arguments.length < 2) {
	      throw new RequestError('Invalid number of arguments. At least 2 arguments expected.', 'EARGS')
	    } else if (arguments.length === 2) {
	      value = type;
	      type = shared.getTypeByValue(value);
	    }

	    // support for custom data types
	    if (value && typeof value.valueOf === 'function' && !(value instanceof Date)) value = value.valueOf();

	    if (value === undefined) value = null; // undefined to null
	    if (typeof value === 'number' && isNaN(value)) value = null; // NaN to null
	    if (type instanceof Function) type = type();

	    if (objectHasProperty(this.parameters, name)) {
	      throw new RequestError(`The parameter name ${name} has already been declared. Parameter names must be unique`, 'EDUPEPARAM')
	    }

	    this.parameters[name] = {
	      name,
	      type: type.type,
	      io: 1,
	      value,
	      length: type.length,
	      scale: type.scale,
	      precision: type.precision,
	      tvpType: type.tvpType
	    };

	    return this
	  }

	  /**
	   * Replace an input parameter on the request.
	   *
	   * @param {String} name Name of the input parameter without @ char.
	   * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.
	   * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.
	   * @return {Request}
	   */

	  replaceInput (name, type, value) {
	    delete this.parameters[name];

	    return this.input(name, type, value)
	  }

	  /**
	   * Add an output parameter to the request.
	   *
	   * @param {String} name Name of the output parameter without @ char.
	   * @param {*} type SQL data type of output parameter.
	   * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
	   * @return {Request}
	   */

	  output (name, type, value) {
	    if (!type) { type = TYPES.NVarChar; }

	    if (/--| |\/\*|\*\/|'/.test(name)) {
	      throw new RequestError(`SQL injection warning for param '${name}'`, 'EINJECT')
	    }

	    if ((type === TYPES.Text) || (type === TYPES.NText) || (type === TYPES.Image)) {
	      throw new RequestError('Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.', 'EDEPRECATED')
	    }

	    // support for custom data types
	    if (value && typeof value.valueOf === 'function' && !(value instanceof Date)) value = value.valueOf();

	    if (value === undefined) value = null; // undefined to null
	    if (typeof value === 'number' && isNaN(value)) value = null; // NaN to null
	    if (type instanceof Function) type = type();

	    if (objectHasProperty(this.parameters, name)) {
	      throw new RequestError(`The parameter name ${name} has already been declared. Parameter names must be unique`, 'EDUPEPARAM')
	    }

	    this.parameters[name] = {
	      name,
	      type: type.type,
	      io: 2,
	      value,
	      length: type.length,
	      scale: type.scale,
	      precision: type.precision
	    };

	    return this
	  }

	  /**
	   * Replace an output parameter on the request.
	   *
	   * @param {String} name Name of the output parameter without @ char.
	   * @param {*} type SQL data type of output parameter.
	   * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.
	   * @return {Request}
	   */

	  replaceOutput (name, type, value) {
	    delete this.parameters[name];

	    return this.output(name, type, value)
	  }

	  /**
	   * Execute the SQL batch.
	   *
	   * @param {String} batch T-SQL batch to be executed.
	   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
	   * @return {Request|Promise}
	   */

	  batch (batch, callback) {
	    if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
	    if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
	    this.rowsAffected = 0;

	    if (typeof callback === 'function') {
	      this._batch(batch, (err, recordsets, output, rowsAffected) => {
	        if (this.stream) {
	          if (err) this.emit('error', err);
	          err = null;

	          this.emit('done', {
	            output,
	            rowsAffected
	          });
	        }

	        if (err) return callback(err)
	        callback(null, {
	          recordsets,
	          recordset: recordsets && recordsets[0],
	          output,
	          rowsAffected
	        });
	      });
	      return this
	    }

	    // Check is method was called as tagged template
	    if (typeof batch === 'object') {
	      const values = Array.prototype.slice.call(arguments);
	      const strings = values.shift();
	      batch = this._template(strings, values);
	    }

	    return new shared.Promise((resolve, reject) => {
	      this._batch(batch, (err, recordsets, output, rowsAffected) => {
	        if (this.stream) {
	          if (err) this.emit('error', err);
	          err = null;

	          this.emit('done', {
	            output,
	            rowsAffected
	          });
	        }

	        if (err) return reject(err)
	        resolve({
	          recordsets,
	          recordset: recordsets && recordsets[0],
	          output,
	          rowsAffected
	        });
	      });
	    })
	  }

	  /**
	   * @private
	   * @param {String} batch
	   * @param {Request~requestCallback} callback
	   */

	  _batch (batch, callback) {
	    if (!this.parent) {
	      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'))
	    }

	    if (!this.parent.connected) {
	      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'))
	    }

	    this.canceled = false;
	    setImmediate(callback);
	  }

	  /**
	   * Bulk load.
	   *
	   * @param {Table} table SQL table.
	   * @param {object} [options] Options to be passed to the underlying driver (tedious only).
	   * @param {Request~bulkCallback} [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.
	   * @return {Request|Promise}
	   */

	  bulk (table, options, callback) {
	    if (typeof options === 'function') {
	      callback = options;
	      options = {};
	    } else if (typeof options === 'undefined') {
	      options = {};
	    }

	    if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
	    if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;

	    if (this.stream || typeof callback === 'function') {
	      this._bulk(table, options, (err, rowsAffected) => {
	        if (this.stream) {
	          if (err) this.emit('error', err);
	          return this.emit('done', {
	            rowsAffected
	          })
	        }

	        if (err) return callback(err)
	        callback(null, {
	          rowsAffected
	        });
	      });
	      return this
	    }

	    return new shared.Promise((resolve, reject) => {
	      this._bulk(table, options, (err, rowsAffected) => {
	        if (err) return reject(err)
	        resolve({
	          rowsAffected
	        });
	      });
	    })
	  }

	  /**
	   * @private
	   * @param {Table} table
	   * @param {object} options
	   * @param {Request~bulkCallback} callback
	   */

	  _bulk (table, options, callback) {
	    if (!this.parent) {
	      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'))
	    }

	    if (!this.parent.connected) {
	      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'))
	    }

	    this.canceled = false;
	    setImmediate(callback);
	  }

	  /**
	   * Wrap original request in a Readable stream that supports back pressure and return.
	   * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
	   *
	   * @param {Object} streamOptions - optional options to configure the readable stream with like highWaterMark
	   * @return {Stream}
	   */
	  toReadableStream (streamOptions = {}) {
	    this.stream = true;
	    this.pause();
	    const readableStream = new Readable({
	      ...streamOptions,
	      objectMode: true,
	      read: (/* size */) => {
	        this.resume();
	      }
	    });
	    this.on('row', (row) => {
	      if (!readableStream.push(row)) {
	        this.pause();
	      }
	    });
	    this.on('error', (error) => {
	      readableStream.emit('error', error);
	    });
	    this.on('done', () => {
	      readableStream.push(null);
	    });
	    return readableStream
	  }

	  /**
	   * Wrap original request in a Readable stream that supports back pressure and pipe to the Writable stream.
	   * It also sets request to `stream` mode and pulls all rows from all recordsets to a given stream.
	   *
	   * @param {Stream} stream Stream to pipe data into.
	   * @return {Stream}
	   */
	  pipe (writableStream) {
	    const readableStream = this.toReadableStream();
	    return readableStream.pipe(writableStream)
	  }

	  /**
	   * Execute the SQL command.
	   *
	   * @param {String} command T-SQL command to be executed.
	   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
	   * @return {Request|Promise}
	   */

	  query (command, callback) {
	    if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
	    if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
	    this.rowsAffected = 0;

	    if (typeof callback === 'function') {
	      this._query(command, (err, recordsets, output, rowsAffected, columns) => {
	        if (this.stream) {
	          if (err) this.emit('error', err);
	          err = null;

	          this.emit('done', {
	            output,
	            rowsAffected
	          });
	        }

	        if (err) return callback(err)
	        const result = {
	          recordsets,
	          recordset: recordsets && recordsets[0],
	          output,
	          rowsAffected
	        };
	        if (this.arrayRowMode) result.columns = columns;
	        callback(null, result);
	      });
	      return this
	    }

	    // Check is method was called as tagged template
	    if (typeof command === 'object') {
	      const values = Array.prototype.slice.call(arguments);
	      const strings = values.shift();
	      command = this._template(strings, values);
	    }

	    return new shared.Promise((resolve, reject) => {
	      this._query(command, (err, recordsets, output, rowsAffected, columns) => {
	        if (this.stream) {
	          if (err) this.emit('error', err);
	          err = null;

	          this.emit('done', {
	            output,
	            rowsAffected
	          });
	        }

	        if (err) return reject(err)
	        const result = {
	          recordsets,
	          recordset: recordsets && recordsets[0],
	          output,
	          rowsAffected
	        };
	        if (this.arrayRowMode) result.columns = columns;
	        resolve(result);
	      });
	    })
	  }

	  /**
	   * @private
	   * @param {String} command
	   * @param {Request~bulkCallback} callback
	   */

	  _query (command, callback) {
	    if (!this.parent) {
	      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'))
	    }

	    if (!this.parent.connected) {
	      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'))
	    }

	    this.canceled = false;
	    setImmediate(callback);
	  }

	  /**
	   * Call a stored procedure.
	   *
	   * @param {String} procedure Name of the stored procedure to be executed.
	   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.
	   * @return {Request|Promise}
	   */

	  execute (command, callback) {
	    if (this.stream === null && this.parent) this.stream = this.parent.config.stream;
	    if (this.arrayRowMode === null && this.parent) this.arrayRowMode = this.parent.config.arrayRowMode;
	    this.rowsAffected = 0;

	    if (typeof callback === 'function') {
	      this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
	        if (this.stream) {
	          if (err) this.emit('error', err);
	          err = null;

	          this.emit('done', {
	            output,
	            rowsAffected,
	            returnValue
	          });
	        }

	        if (err) return callback(err)
	        const result = {
	          recordsets,
	          recordset: recordsets && recordsets[0],
	          output,
	          rowsAffected,
	          returnValue
	        };
	        if (this.arrayRowMode) result.columns = columns;
	        callback(null, result);
	      });
	      return this
	    }

	    return new shared.Promise((resolve, reject) => {
	      this._execute(command, (err, recordsets, output, returnValue, rowsAffected, columns) => {
	        if (this.stream) {
	          if (err) this.emit('error', err);
	          err = null;

	          this.emit('done', {
	            output,
	            rowsAffected,
	            returnValue
	          });
	        }

	        if (err) return reject(err)
	        const result = {
	          recordsets,
	          recordset: recordsets && recordsets[0],
	          output,
	          rowsAffected,
	          returnValue
	        };
	        if (this.arrayRowMode) result.columns = columns;
	        resolve(result);
	      });
	    })
	  }

	  /**
	   * @private
	   * @param {String} procedure
	   * @param {Request~bulkCallback} callback
	   */

	  _execute (procedure, callback) {
	    if (!this.parent) {
	      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'))
	    }

	    if (!this.parent.connected) {
	      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'))
	    }

	    this.canceled = false;
	    setImmediate(callback);
	  }

	  /**
	   * Cancel currently executed request.
	   *
	   * @return {Boolean}
	   */

	  cancel () {
	    this._cancel();
	    return true
	  }

	  /**
	   * @private
	   */

	  _cancel () {
	    this.canceled = true;
	  }

	  pause () {
	    if (this.stream) {
	      this._pause();
	      return true
	    }
	    return false
	  }

	  _pause () {
	    this._paused = true;
	  }

	  resume () {
	    if (this.stream) {
	      this._resume();
	      return true
	    }
	    return false
	  }

	  _resume () {
	    this._paused = false;
	  }

	  _setCurrentRequest (request) {
	    this._currentRequest = request;
	    if (this._paused) {
	      this.pause();
	    }
	    return this
	  }
	}

	request$2 = Request;
	return request$2;
}

var isolationlevel;
var hasRequiredIsolationlevel;

function requireIsolationlevel () {
	if (hasRequiredIsolationlevel) return isolationlevel;
	hasRequiredIsolationlevel = 1;

	isolationlevel = {
	  READ_UNCOMMITTED: 0x01,
	  READ_COMMITTED: 0x02,
	  REPEATABLE_READ: 0x03,
	  SERIALIZABLE: 0x04,
	  SNAPSHOT: 0x05
	};
	return isolationlevel;
}

var transaction$2;
var hasRequiredTransaction$2;

function requireTransaction$2 () {
	if (hasRequiredTransaction$2) return transaction$2;
	hasRequiredTransaction$2 = 1;

	const debug = requireSrc()('mssql:base');
	const { EventEmitter } = __require$b();
	const { IDS } = requireUtils$4();
	const globalConnection = requireGlobalConnection();
	const { TransactionError } = requireError$2();
	const shared = requireShared();
	const ISOLATION_LEVEL = requireIsolationlevel();

	/**
	 * Class Transaction.
	 *
	 * @property {Number} isolationLevel Controls the locking and row versioning behavior of TSQL statements issued by a connection. READ_COMMITTED by default.
	 * @property {String} name Transaction name. Empty string by default.
	 *
	 * @fires Transaction#begin
	 * @fires Transaction#commit
	 * @fires Transaction#rollback
	 */

	class Transaction extends EventEmitter {
	  /**
	   * Create new Transaction.
	   *
	   * @param {Connection} [parent] If ommited, global connection is used instead.
	   */

	  constructor (parent) {
	    super();

	    IDS.add(this, 'Transaction');
	    debug('transaction(%d): created', IDS.get(this));

	    this.parent = parent || globalConnection.pool;
	    this.isolationLevel = Transaction.defaultIsolationLevel;
	    this.name = '';
	  }

	  get config () {
	    return this.parent.config
	  }

	  get connected () {
	    return this.parent.connected
	  }

	  /**
	   * Acquire connection from connection pool.
	   *
	   * @param {Request} request Request.
	   * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.
	   * @return {Transaction|Promise}
	   */

	  acquire (request, callback) {
	    if (!this._acquiredConnection) {
	      setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'));
	      return this
	    }

	    if (this._activeRequest) {
	      setImmediate(callback, new TransactionError("Can't acquire connection for the request. There is another request in progress.", 'EREQINPROG'));
	      return this
	    }

	    this._activeRequest = request;
	    setImmediate(callback, null, this._acquiredConnection, this._acquiredConfig);
	    return this
	  }

	  /**
	   * Release connection back to the pool.
	   *
	   * @param {Connection} connection Previously acquired connection.
	   * @return {Transaction}
	   */

	  release (connection) {
	    if (connection === this._acquiredConnection) {
	      this._activeRequest = null;
	    }

	    return this
	  }

	  /**
	   * Begin a transaction.
	   *
	   * @param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.
	   * @param {basicCallback} [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.
	   * @return {Transaction|Promise}
	   */

	  begin (isolationLevel, callback) {
	    if (isolationLevel instanceof Function) {
	      callback = isolationLevel;
	      isolationLevel = undefined;
	    }

	    if (typeof callback === 'function') {
	      this._begin(isolationLevel, err => {
	        if (!err) {
	          this.emit('begin');
	        }
	        callback(err);
	      });
	      return this
	    }

	    return new shared.Promise((resolve, reject) => {
	      this._begin(isolationLevel, err => {
	        if (err) return reject(err)
	        this.emit('begin');
	        resolve(this);
	      });
	    })
	  }

	  /**
	   * @private
	   * @param {Number} [isolationLevel]
	   * @param {basicCallback} [callback]
	   * @return {Transaction}
	   */

	  _begin (isolationLevel, callback) {
	    if (this._acquiredConnection) {
	      return setImmediate(callback, new TransactionError('Transaction has already begun.', 'EALREADYBEGUN'))
	    }

	    this._aborted = false;
	    this._rollbackRequested = false;
	    if (isolationLevel) {
	      if (Object.keys(ISOLATION_LEVEL).some(key => {
	        return ISOLATION_LEVEL[key] === isolationLevel
	      })) {
	        this.isolationLevel = isolationLevel;
	      } else {
	        throw new TransactionError('Invalid isolation level.')
	      }
	    }

	    setImmediate(callback);
	  }

	  /**
	   * Commit a transaction.
	   *
	   * @param {basicCallback} [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.
	   * @return {Transaction|Promise}
	   */

	  commit (callback) {
	    if (typeof callback === 'function') {
	      this._commit(err => {
	        if (!err) {
	          this.emit('commit');
	        }
	        callback(err);
	      });
	      return this
	    }

	    return new shared.Promise((resolve, reject) => {
	      this._commit(err => {
	        if (err) return reject(err)
	        this.emit('commit');
	        resolve();
	      });
	    })
	  }

	  /**
	   * @private
	   * @param {basicCallback} [callback]
	   * @return {Transaction}
	   */

	  _commit (callback) {
	    if (this._aborted) {
	      return setImmediate(callback, new TransactionError('Transaction has been aborted.', 'EABORT'))
	    }

	    if (!this._acquiredConnection) {
	      return setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'))
	    }

	    if (this._activeRequest) {
	      return setImmediate(callback, new TransactionError("Can't commit transaction. There is a request in progress.", 'EREQINPROG'))
	    }

	    setImmediate(callback);
	  }

	  /**
	   * Returns new request using this transaction.
	   *
	   * @return {Request}
	   */

	  request () {
	    return new shared.driver.Request(this)
	  }

	  /**
	   * Rollback a transaction.
	   *
	   * @param {basicCallback} [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.
	   * @return {Transaction|Promise}
	   */

	  rollback (callback) {
	    if (typeof callback === 'function') {
	      this._rollback(err => {
	        if (!err) {
	          this.emit('rollback', this._aborted);
	        }
	        callback(err);
	      });
	      return this
	    }

	    return new shared.Promise((resolve, reject) => {
	      return this._rollback(err => {
	        if (err) return reject(err)
	        this.emit('rollback', this._aborted);
	        resolve();
	      })
	    })
	  }

	  /**
	   * @private
	   * @param {basicCallback} [callback]
	   * @return {Transaction}
	   */

	  _rollback (callback) {
	    if (this._aborted) {
	      return setImmediate(callback, new TransactionError('Transaction has been aborted.', 'EABORT'))
	    }

	    if (!this._acquiredConnection) {
	      return setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'))
	    }

	    if (this._activeRequest) {
	      return setImmediate(callback, new TransactionError("Can't rollback transaction. There is a request in progress.", 'EREQINPROG'))
	    }

	    this._rollbackRequested = true;

	    setImmediate(callback);
	  }
	}

	/**
	 * Default isolation level used for any transactions that don't explicitly specify an isolation level.
	 *
	 * @type {number}
	 */
	Transaction.defaultIsolationLevel = ISOLATION_LEVEL.READ_COMMITTED;

	transaction$2 = Transaction;
	return transaction$2;
}

var hasRequiredBase;

function requireBase () {
	if (hasRequiredBase) return base.exports;
	hasRequiredBase = 1;
	(function (module) {

		const ConnectionPool = requireConnectionPool$1();
		const PreparedStatement = requirePreparedStatement();
		const Request = requireRequest$2();
		const Transaction = requireTransaction$2();
		const { ConnectionError, TransactionError, RequestError, PreparedStatementError, MSSQLError } = requireError$2();
		const shared = requireShared();
		const Table = requireTable();
		const ISOLATION_LEVEL = requireIsolationlevel();
		const { TYPES } = requireDatatypes();
		const { connect, close, on, off, removeListener, query, batch } = requireGlobalConnection();

		module.exports = {
		  ConnectionPool,
		  Transaction,
		  Request,
		  PreparedStatement,
		  ConnectionError,
		  TransactionError,
		  RequestError,
		  PreparedStatementError,
		  MSSQLError,
		  driver: shared.driver,
		  exports: {
		    ConnectionError,
		    TransactionError,
		    RequestError,
		    PreparedStatementError,
		    MSSQLError,
		    Table,
		    ISOLATION_LEVEL,
		    TYPES,
		    MAX: 65535, // (1 << 16) - 1
		    map: shared.map,
		    getTypeByValue: shared.getTypeByValue,
		    connect,
		    close,
		    on,
		    removeListener,
		    off,
		    query,
		    batch
		  }
		};

		Object.defineProperty(module.exports, 'Promise', {
		  enumerable: true,
		  get: () => {
		    return shared.Promise
		  },
		  set: (value) => {
		    shared.Promise = value;
		  }
		});

		Object.defineProperty(module.exports, 'valueHandler', {
		  enumerable: true,
		  value: shared.valueHandler,
		  writable: false,
		  configurable: false
		});

		for (const key in TYPES) {
		  const value = TYPES[key];
		  module.exports.exports[key] = value;
		  module.exports.exports[key.toUpperCase()] = value;
		}

		/**
		 * @callback Request~requestCallback
		 * @param {Error} err Error on error, otherwise null.
		 * @param {Object} [result] Request result.
		 */

		/**
		 * @callback Request~bulkCallback
		 * @param {Error} err Error on error, otherwise null.
		 * @param {Number} [rowsAffected] Number of affected rows.
		 */

		/**
		 * @callback basicCallback
		 * @param {Error} err Error on error, otherwise null.
		 * @param {Connection} [connection] Acquired connection.
		 */

		/**
		 * @callback acquireCallback
		 * @param {Error} err Error on error, otherwise null.
		 * @param {Connection} [connection] Acquired connection.
		 * @param {Object} [config] Connection config
		 */

		/**
		 * Dispatched after connection has established.
		 * @event ConnectionPool#connect
		 */

		/**
		 * Dispatched after connection has closed a pool (by calling close).
		 * @event ConnectionPool#close
		 */

		/**
		 * Dispatched when transaction begin.
		 * @event Transaction#begin
		 */

		/**
		 * Dispatched on successful commit.
		 * @event Transaction#commit
		 */

		/**
		 * Dispatched on successful rollback.
		 * @event Transaction#rollback
		 */

		/**
		 * Dispatched when metadata for new recordset are parsed.
		 * @event Request#recordset
		 */

		/**
		 * Dispatched when new row is parsed.
		 * @event Request#row
		 */

		/**
		 * Dispatched when request is complete.
		 * @event Request#done
		 */

		/**
		 * Dispatched on error.
		 * @event Request#error
		 */ 
	} (base));
	return base.exports;
}

var tedious = {};

var bulkLoad = {exports: {}};

var writableTrackingBuffer = {exports: {}};

var hasRequiredWritableTrackingBuffer;

function requireWritableTrackingBuffer () {
	if (hasRequiredWritableTrackingBuffer) return writableTrackingBuffer.exports;
	hasRequiredWritableTrackingBuffer = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
		const SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
		const UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
		const ZERO_LENGTH_BUFFER = Buffer.alloc(0);
		/**
		  A Buffer-like class that tracks position.

		  As values are written, the position advances by the size of the written data.
		  When writing, automatically allocates new buffers if there's not enough space.
		 */
		class WritableTrackingBuffer {
		  constructor(initialSize, encoding, doubleSizeGrowth) {
		    this.initialSize = initialSize;
		    this.encoding = encoding || 'ucs2';
		    this.doubleSizeGrowth = doubleSizeGrowth || false;
		    this.buffer = Buffer.alloc(this.initialSize, 0);
		    this.compositeBuffer = ZERO_LENGTH_BUFFER;
		    this.position = 0;
		  }
		  get data() {
		    this.newBuffer(0);
		    return this.compositeBuffer;
		  }
		  copyFrom(buffer) {
		    const length = buffer.length;
		    this.makeRoomFor(length);
		    buffer.copy(this.buffer, this.position);
		    this.position += length;
		  }
		  makeRoomFor(requiredLength) {
		    if (this.buffer.length - this.position < requiredLength) {
		      if (this.doubleSizeGrowth) {
		        let size = Math.max(128, this.buffer.length * 2);
		        while (size < requiredLength) {
		          size *= 2;
		        }
		        this.newBuffer(size);
		      } else {
		        this.newBuffer(requiredLength);
		      }
		    }
		  }
		  newBuffer(size) {
		    const buffer = this.buffer.slice(0, this.position);
		    this.compositeBuffer = Buffer.concat([this.compositeBuffer, buffer]);
		    this.buffer = size === 0 ? ZERO_LENGTH_BUFFER : Buffer.alloc(size, 0);
		    this.position = 0;
		  }
		  writeUInt8(value) {
		    const length = 1;
		    this.makeRoomFor(length);
		    this.buffer.writeUInt8(value, this.position);
		    this.position += length;
		  }
		  writeUInt16LE(value) {
		    const length = 2;
		    this.makeRoomFor(length);
		    this.buffer.writeUInt16LE(value, this.position);
		    this.position += length;
		  }
		  writeUShort(value) {
		    this.writeUInt16LE(value);
		  }
		  writeUInt16BE(value) {
		    const length = 2;
		    this.makeRoomFor(length);
		    this.buffer.writeUInt16BE(value, this.position);
		    this.position += length;
		  }
		  writeUInt24LE(value) {
		    const length = 3;
		    this.makeRoomFor(length);
		    this.buffer[this.position + 2] = value >>> 16 & 0xff;
		    this.buffer[this.position + 1] = value >>> 8 & 0xff;
		    this.buffer[this.position] = value & 0xff;
		    this.position += length;
		  }
		  writeUInt32LE(value) {
		    const length = 4;
		    this.makeRoomFor(length);
		    this.buffer.writeUInt32LE(value, this.position);
		    this.position += length;
		  }
		  writeBigInt64LE(value) {
		    const length = 8;
		    this.makeRoomFor(length);
		    this.buffer.writeBigInt64LE(value, this.position);
		    this.position += length;
		  }
		  writeInt64LE(value) {
		    this.writeBigInt64LE(BigInt(value));
		  }
		  writeUInt64LE(value) {
		    this.writeBigUInt64LE(BigInt(value));
		  }
		  writeBigUInt64LE(value) {
		    const length = 8;
		    this.makeRoomFor(length);
		    this.buffer.writeBigUInt64LE(value, this.position);
		    this.position += length;
		  }
		  writeUInt32BE(value) {
		    const length = 4;
		    this.makeRoomFor(length);
		    this.buffer.writeUInt32BE(value, this.position);
		    this.position += length;
		  }
		  writeUInt40LE(value) {
		    // inspired by https://github.com/dpw/node-buffer-more-ints
		    this.writeInt32LE(value & -1);
		    this.writeUInt8(Math.floor(value * SHIFT_RIGHT_32));
		  }
		  writeInt8(value) {
		    const length = 1;
		    this.makeRoomFor(length);
		    this.buffer.writeInt8(value, this.position);
		    this.position += length;
		  }
		  writeInt16LE(value) {
		    const length = 2;
		    this.makeRoomFor(length);
		    this.buffer.writeInt16LE(value, this.position);
		    this.position += length;
		  }
		  writeInt16BE(value) {
		    const length = 2;
		    this.makeRoomFor(length);
		    this.buffer.writeInt16BE(value, this.position);
		    this.position += length;
		  }
		  writeInt32LE(value) {
		    const length = 4;
		    this.makeRoomFor(length);
		    this.buffer.writeInt32LE(value, this.position);
		    this.position += length;
		  }
		  writeInt32BE(value) {
		    const length = 4;
		    this.makeRoomFor(length);
		    this.buffer.writeInt32BE(value, this.position);
		    this.position += length;
		  }
		  writeFloatLE(value) {
		    const length = 4;
		    this.makeRoomFor(length);
		    this.buffer.writeFloatLE(value, this.position);
		    this.position += length;
		  }
		  writeDoubleLE(value) {
		    const length = 8;
		    this.makeRoomFor(length);
		    this.buffer.writeDoubleLE(value, this.position);
		    this.position += length;
		  }
		  writeString(value, encoding) {
		    if (encoding == null) {
		      encoding = this.encoding;
		    }
		    const length = Buffer.byteLength(value, encoding);
		    this.makeRoomFor(length);

		    // $FlowFixMe https://github.com/facebook/flow/pull/5398
		    this.buffer.write(value, this.position, encoding);
		    this.position += length;
		  }
		  writeBVarchar(value, encoding) {
		    this.writeUInt8(value.length);
		    this.writeString(value, encoding);
		  }
		  writeUsVarchar(value, encoding) {
		    this.writeUInt16LE(value.length);
		    this.writeString(value, encoding);
		  }

		  // TODO: Figure out what types are passed in other than `Buffer`
		  writeUsVarbyte(value, encoding) {
		    if (encoding == null) {
		      encoding = this.encoding;
		    }
		    let length;
		    if (value instanceof Buffer) {
		      length = value.length;
		    } else {
		      value = value.toString();
		      length = Buffer.byteLength(value, encoding);
		    }
		    this.writeUInt16LE(length);
		    if (value instanceof Buffer) {
		      this.writeBuffer(value);
		    } else {
		      this.makeRoomFor(length);
		      // $FlowFixMe https://github.com/facebook/flow/pull/5398
		      this.buffer.write(value, this.position, encoding);
		      this.position += length;
		    }
		  }
		  writePLPBody(value, encoding) {
		    if (encoding == null) {
		      encoding = this.encoding;
		    }
		    let length;
		    if (value instanceof Buffer) {
		      length = value.length;
		    } else {
		      value = value.toString();
		      length = Buffer.byteLength(value, encoding);
		    }

		    // Length of all chunks.
		    // this.writeUInt64LE(length);
		    // unknown seems to work better here - might revisit later.
		    this.writeBuffer(UNKNOWN_PLP_LEN);

		    // In the UNKNOWN_PLP_LEN case, the data is represented as a series of zero or more chunks.
		    if (length > 0) {
		      // One chunk.
		      this.writeUInt32LE(length);
		      if (value instanceof Buffer) {
		        this.writeBuffer(value);
		      } else {
		        this.makeRoomFor(length);
		        this.buffer.write(value, this.position, encoding);
		        this.position += length;
		      }
		    }

		    // PLP_TERMINATOR (no more chunks).
		    this.writeUInt32LE(0);
		  }
		  writeBuffer(value) {
		    const length = value.length;
		    this.makeRoomFor(length);
		    value.copy(this.buffer, this.position);
		    this.position += length;
		  }
		  writeMoney(value) {
		    this.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32));
		    this.writeInt32LE(value & -1);
		  }
		}
		exports$1.default = WritableTrackingBuffer;
		module.exports = WritableTrackingBuffer;
		
	} (writableTrackingBuffer, writableTrackingBuffer.exports));
	return writableTrackingBuffer.exports;
}

var token = {};

var hasRequiredToken;

function requireToken () {
	if (hasRequiredToken) return token;
	hasRequiredToken = 1;

	Object.defineProperty(token, "__esModule", {
	  value: true
	});
	token.Token = token.TYPE = token.SSPIToken = token.RowToken = token.RoutingEnvChangeToken = token.RollbackTransactionEnvChangeToken = token.ReturnValueToken = token.ReturnStatusToken = token.ResetConnectionEnvChangeToken = token.PacketSizeEnvChangeToken = token.OrderToken = token.NBCRowToken = token.LoginAckToken = token.LanguageEnvChangeToken = token.InfoMessageToken = token.FedAuthInfoToken = token.FeatureExtAckToken = token.ErrorMessageToken = token.DoneToken = token.DoneProcToken = token.DoneInProcToken = token.DatabaseMirroringPartnerEnvChangeToken = token.DatabaseEnvChangeToken = token.CommitTransactionEnvChangeToken = token.CollationChangeToken = token.ColMetadataToken = token.CharsetEnvChangeToken = token.BeginTransactionEnvChangeToken = void 0;
	token.TYPE = {
	  ALTMETADATA: 0x88,
	  ALTROW: 0xD3,
	  COLMETADATA: 0x81,
	  COLINFO: 0xA5,
	  DONE: 0xFD,
	  DONEPROC: 0xFE,
	  DONEINPROC: 0xFF,
	  ENVCHANGE: 0xE3,
	  ERROR: 0xAA,
	  FEATUREEXTACK: 0xAE,
	  FEDAUTHINFO: 0xEE,
	  INFO: 0xAB,
	  LOGINACK: 0xAD,
	  NBCROW: 0xD2,
	  OFFSET: 0x78,
	  ORDER: 0xA9,
	  RETURNSTATUS: 0x79,
	  RETURNVALUE: 0xAC,
	  ROW: 0xD1,
	  SSPI: 0xED,
	  TABNAME: 0xA4
	};
	class Token {
	  constructor(name, handlerName) {
	    this.name = name;
	    this.handlerName = handlerName;
	  }
	}
	token.Token = Token;
	class ColMetadataToken extends Token {
	  constructor(columns) {
	    super('COLMETADATA', 'onColMetadata');
	    this.columns = columns;
	  }
	}
	token.ColMetadataToken = ColMetadataToken;
	class DoneToken extends Token {
	  constructor({
	    more,
	    sqlError,
	    attention,
	    serverError,
	    rowCount,
	    curCmd
	  }) {
	    super('DONE', 'onDone');
	    this.more = more;
	    this.sqlError = sqlError;
	    this.attention = attention;
	    this.serverError = serverError;
	    this.rowCount = rowCount;
	    this.curCmd = curCmd;
	  }
	}
	token.DoneToken = DoneToken;
	class DoneInProcToken extends Token {
	  constructor({
	    more,
	    sqlError,
	    attention,
	    serverError,
	    rowCount,
	    curCmd
	  }) {
	    super('DONEINPROC', 'onDoneInProc');
	    this.more = more;
	    this.sqlError = sqlError;
	    this.attention = attention;
	    this.serverError = serverError;
	    this.rowCount = rowCount;
	    this.curCmd = curCmd;
	  }
	}
	token.DoneInProcToken = DoneInProcToken;
	class DoneProcToken extends Token {
	  constructor({
	    more,
	    sqlError,
	    attention,
	    serverError,
	    rowCount,
	    curCmd
	  }) {
	    super('DONEPROC', 'onDoneProc');
	    this.more = more;
	    this.sqlError = sqlError;
	    this.attention = attention;
	    this.serverError = serverError;
	    this.rowCount = rowCount;
	    this.curCmd = curCmd;
	  }
	}
	token.DoneProcToken = DoneProcToken;
	class DatabaseEnvChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onDatabaseChange');
	    this.type = 'DATABASE';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.DatabaseEnvChangeToken = DatabaseEnvChangeToken;
	class LanguageEnvChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onLanguageChange');
	    this.type = 'LANGUAGE';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.LanguageEnvChangeToken = LanguageEnvChangeToken;
	class CharsetEnvChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onCharsetChange');
	    this.type = 'CHARSET';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.CharsetEnvChangeToken = CharsetEnvChangeToken;
	class PacketSizeEnvChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onPacketSizeChange');
	    this.type = 'PACKET_SIZE';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.PacketSizeEnvChangeToken = PacketSizeEnvChangeToken;
	class BeginTransactionEnvChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onBeginTransaction');
	    this.type = 'BEGIN_TXN';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.BeginTransactionEnvChangeToken = BeginTransactionEnvChangeToken;
	class CommitTransactionEnvChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onCommitTransaction');
	    this.type = 'COMMIT_TXN';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.CommitTransactionEnvChangeToken = CommitTransactionEnvChangeToken;
	class RollbackTransactionEnvChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onRollbackTransaction');
	    this.type = 'ROLLBACK_TXN';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.RollbackTransactionEnvChangeToken = RollbackTransactionEnvChangeToken;
	class DatabaseMirroringPartnerEnvChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onDatabaseMirroringPartner');
	    this.type = 'DATABASE_MIRRORING_PARTNER';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.DatabaseMirroringPartnerEnvChangeToken = DatabaseMirroringPartnerEnvChangeToken;
	class ResetConnectionEnvChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onResetConnection');
	    this.type = 'RESET_CONNECTION';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.ResetConnectionEnvChangeToken = ResetConnectionEnvChangeToken;
	class CollationChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onSqlCollationChange');
	    this.type = 'SQL_COLLATION';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.CollationChangeToken = CollationChangeToken;
	class RoutingEnvChangeToken extends Token {
	  constructor(newValue, oldValue) {
	    super('ENVCHANGE', 'onRoutingChange');
	    this.type = 'ROUTING_CHANGE';
	    this.newValue = newValue;
	    this.oldValue = oldValue;
	  }
	}
	token.RoutingEnvChangeToken = RoutingEnvChangeToken;
	class FeatureExtAckToken extends Token {
	  /** Value of UTF8_SUPPORT acknowledgement.
	   *
	   * undefined when UTF8_SUPPORT not included in token. */

	  constructor(fedAuth, utf8Support) {
	    super('FEATUREEXTACK', 'onFeatureExtAck');
	    this.fedAuth = fedAuth;
	    this.utf8Support = utf8Support;
	  }
	}
	token.FeatureExtAckToken = FeatureExtAckToken;
	class FedAuthInfoToken extends Token {
	  constructor(spn, stsurl) {
	    super('FEDAUTHINFO', 'onFedAuthInfo');
	    this.spn = spn;
	    this.stsurl = stsurl;
	  }
	}
	token.FedAuthInfoToken = FedAuthInfoToken;
	class InfoMessageToken extends Token {
	  constructor({
	    number,
	    state,
	    class: clazz,
	    message,
	    serverName,
	    procName,
	    lineNumber
	  }) {
	    super('INFO', 'onInfoMessage');
	    this.number = number;
	    this.state = state;
	    this.class = clazz;
	    this.message = message;
	    this.serverName = serverName;
	    this.procName = procName;
	    this.lineNumber = lineNumber;
	  }
	}
	token.InfoMessageToken = InfoMessageToken;
	class ErrorMessageToken extends Token {
	  constructor({
	    number,
	    state,
	    class: clazz,
	    message,
	    serverName,
	    procName,
	    lineNumber
	  }) {
	    super('ERROR', 'onErrorMessage');
	    this.number = number;
	    this.state = state;
	    this.class = clazz;
	    this.message = message;
	    this.serverName = serverName;
	    this.procName = procName;
	    this.lineNumber = lineNumber;
	  }
	}
	token.ErrorMessageToken = ErrorMessageToken;
	class LoginAckToken extends Token {
	  constructor({
	    interface: interfaze,
	    tdsVersion,
	    progName,
	    progVersion
	  }) {
	    super('LOGINACK', 'onLoginAck');
	    this.interface = interfaze;
	    this.tdsVersion = tdsVersion;
	    this.progName = progName;
	    this.progVersion = progVersion;
	  }
	}
	token.LoginAckToken = LoginAckToken;
	class NBCRowToken extends Token {
	  constructor(columns) {
	    super('NBCROW', 'onRow');
	    this.columns = columns;
	  }
	}
	token.NBCRowToken = NBCRowToken;
	class OrderToken extends Token {
	  constructor(orderColumns) {
	    super('ORDER', 'onOrder');
	    this.orderColumns = orderColumns;
	  }
	}
	token.OrderToken = OrderToken;
	class ReturnStatusToken extends Token {
	  constructor(value) {
	    super('RETURNSTATUS', 'onReturnStatus');
	    this.value = value;
	  }
	}
	token.ReturnStatusToken = ReturnStatusToken;
	class ReturnValueToken extends Token {
	  constructor({
	    paramOrdinal,
	    paramName,
	    metadata,
	    value
	  }) {
	    super('RETURNVALUE', 'onReturnValue');
	    this.paramOrdinal = paramOrdinal;
	    this.paramName = paramName;
	    this.metadata = metadata;
	    this.value = value;
	  }
	}
	token.ReturnValueToken = ReturnValueToken;
	class RowToken extends Token {
	  constructor(columns) {
	    super('ROW', 'onRow');
	    this.columns = columns;
	  }
	}
	token.RowToken = RowToken;
	class SSPIToken extends Token {
	  constructor(ntlmpacket, ntlmpacketBuffer) {
	    super('SSPICHALLENGE', 'onSSPI');
	    this.ntlmpacket = ntlmpacket;
	    this.ntlmpacketBuffer = ntlmpacketBuffer;
	  }
	}
	token.SSPIToken = SSPIToken;
	
	return token;
}

var hasRequiredBulkLoad;

function requireBulkLoad () {
	if (hasRequiredBulkLoad) return bulkLoad.exports;
	hasRequiredBulkLoad = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _events = require$$0$5;
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		var _stream = require$$0$6;
		var _token = requireToken();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/**
		 * @private
		 */
		const FLAGS = {
		  nullable: 1 << 0,
		  updateableReadWrite: 1 << 2,
		  // introduced in TDS 7.2
		  nullableUnknown: 1 << 15 // introduced in TDS 7.2
		};

		/**
		 * @private
		 */
		const DONE_STATUS = {
		  FINAL: 0x00};

		/**
		 * @private
		 */

		const rowTokenBuffer = Buffer.from([_token.TYPE.ROW]);
		const textPointerAndTimestampBuffer = Buffer.from([
		// TextPointer length
		0x10,
		// TextPointer
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// Timestamp
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
		const textPointerNullBuffer = Buffer.from([0x00]);

		// A transform that converts rows to packets.
		class RowTransform extends _stream.Transform {
		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */
		  constructor(bulkLoad) {
		    super({
		      writableObjectMode: true
		    });
		    this.bulkLoad = bulkLoad;
		    this.mainOptions = bulkLoad.options;
		    this.columns = bulkLoad.columns;
		    this.columnMetadataWritten = false;
		  }

		  /**
		   * @private
		   */
		  _transform(row, _encoding, callback) {
		    if (!this.columnMetadataWritten) {
		      this.push(this.bulkLoad.getColMetaData());
		      this.columnMetadataWritten = true;
		    }
		    this.push(rowTokenBuffer);
		    for (let i = 0; i < this.columns.length; i++) {
		      const c = this.columns[i];
		      let value = Array.isArray(row) ? row[i] : row[c.objName];
		      if (!this.bulkLoad.firstRowWritten) {
		        try {
		          value = c.type.validate(value, c.collation);
		        } catch (error) {
		          return callback(error);
		        }
		      }
		      const parameter = {
		        length: c.length,
		        scale: c.scale,
		        precision: c.precision,
		        value: value
		      };
		      if (c.type.name === 'Text' || c.type.name === 'Image' || c.type.name === 'NText') {
		        if (value == null) {
		          this.push(textPointerNullBuffer);
		          continue;
		        }
		        this.push(textPointerAndTimestampBuffer);
		      }
		      try {
		        this.push(c.type.generateParameterLength(parameter, this.mainOptions));
		        for (const chunk of c.type.generateParameterData(parameter, this.mainOptions)) {
		          this.push(chunk);
		        }
		      } catch (error) {
		        return callback(error);
		      }
		    }
		    process.nextTick(callback);
		  }

		  /**
		   * @private
		   */
		  _flush(callback) {
		    this.push(this.bulkLoad.createDoneToken());
		    process.nextTick(callback);
		  }
		}

		/**
		 * A BulkLoad instance is used to perform a bulk insert.
		 *
		 * Use [[Connection.newBulkLoad]] to create a new instance, and [[Connection.execBulkLoad]] to execute it.
		 *
		 * Example of BulkLoad Usages:
		 *
		 * ```js
		 * // optional BulkLoad options
		 * const options = { keepNulls: true };
		 *
		 * // instantiate - provide the table where you'll be inserting to, options and a callback
		 * const bulkLoad = connection.newBulkLoad('MyTable', options, (error, rowCount) => {
		 *   console.log('inserted %d rows', rowCount);
		 * });
		 *
		 * // setup your columns - always indicate whether the column is nullable
		 * bulkLoad.addColumn('myInt', TYPES.Int, { nullable: false });
		 * bulkLoad.addColumn('myString', TYPES.NVarChar, { length: 50, nullable: true });
		 *
		 * // execute
		 * connection.execBulkLoad(bulkLoad, [
		 *   { myInt: 7, myString: 'hello' },
		 *   { myInt: 23, myString: 'world' }
		 * ]);
		 * ```
		 */
		class BulkLoad extends _events.EventEmitter {
		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */
		  constructor(table, collation, connectionOptions, {
		    checkConstraints = false,
		    fireTriggers = false,
		    keepNulls = false,
		    lockTable = false,
		    order = {}
		  }, callback) {
		    if (typeof checkConstraints !== 'boolean') {
		      throw new TypeError('The "options.checkConstraints" property must be of type boolean.');
		    }
		    if (typeof fireTriggers !== 'boolean') {
		      throw new TypeError('The "options.fireTriggers" property must be of type boolean.');
		    }
		    if (typeof keepNulls !== 'boolean') {
		      throw new TypeError('The "options.keepNulls" property must be of type boolean.');
		    }
		    if (typeof lockTable !== 'boolean') {
		      throw new TypeError('The "options.lockTable" property must be of type boolean.');
		    }
		    if (typeof order !== 'object' || order === null) {
		      throw new TypeError('The "options.order" property must be of type object.');
		    }
		    for (const [column, direction] of Object.entries(order)) {
		      if (direction !== 'ASC' && direction !== 'DESC') {
		        throw new TypeError('The value of the "' + column + '" key in the "options.order" object must be either "ASC" or "DESC".');
		      }
		    }
		    super();
		    this.error = undefined;
		    this.canceled = false;
		    this.executionStarted = false;
		    this.collation = collation;
		    this.table = table;
		    this.options = connectionOptions;
		    this.callback = callback;
		    this.columns = [];
		    this.columnsByName = {};
		    this.firstRowWritten = false;
		    this.streamingMode = false;
		    this.rowToPacketTransform = new RowTransform(this); // eslint-disable-line no-use-before-define

		    this.bulkOptions = {
		      checkConstraints,
		      fireTriggers,
		      keepNulls,
		      lockTable,
		      order
		    };
		  }

		  /**
		   * Adds a column to the bulk load.
		   *
		   * The column definitions should match the table you are trying to insert into.
		   * Attempting to call addColumn after the first row has been added will throw an exception.
		   *
		   * ```js
		   * bulkLoad.addColumn('MyIntColumn', TYPES.Int, { nullable: false });
		   * ```
		   *
		   * @param name The name of the column.
		   * @param type One of the supported `data types`.
		   * @param __namedParameters Additional column type information. At a minimum, `nullable` must be set to true or false.
		   * @param length For VarChar, NVarChar, VarBinary. Use length as `Infinity` for VarChar(max), NVarChar(max) and VarBinary(max).
		   * @param nullable Indicates whether the column accepts NULL values.
		   * @param objName If the name of the column is different from the name of the property found on `rowObj` arguments passed to [[addRow]] or [[Connection.execBulkLoad]], then you can use this option to specify the property name.
		   * @param precision For Numeric, Decimal.
		   * @param scale For Numeric, Decimal, Time, DateTime2, DateTimeOffset.
		  */
		  addColumn(name, type, {
		    output = false,
		    length,
		    precision,
		    scale,
		    objName = name,
		    nullable = true
		  }) {
		    if (this.firstRowWritten) {
		      throw new Error('Columns cannot be added to bulk insert after the first row has been written.');
		    }
		    if (this.executionStarted) {
		      throw new Error('Columns cannot be added to bulk insert after execution has started.');
		    }
		    const column = {
		      type: type,
		      name: name,
		      value: null,
		      output: output,
		      length: length,
		      precision: precision,
		      scale: scale,
		      objName: objName,
		      nullable: nullable,
		      collation: this.collation
		    };
		    if ((type.id & 0x30) === 0x20) {
		      if (column.length == null && type.resolveLength) {
		        column.length = type.resolveLength(column);
		      }
		    }
		    if (type.resolvePrecision && column.precision == null) {
		      column.precision = type.resolvePrecision(column);
		    }
		    if (type.resolveScale && column.scale == null) {
		      column.scale = type.resolveScale(column);
		    }
		    this.columns.push(column);
		    this.columnsByName[name] = column;
		  }

		  /**
		   * @private
		   */
		  getOptionsSql() {
		    const addOptions = [];
		    if (this.bulkOptions.checkConstraints) {
		      addOptions.push('CHECK_CONSTRAINTS');
		    }
		    if (this.bulkOptions.fireTriggers) {
		      addOptions.push('FIRE_TRIGGERS');
		    }
		    if (this.bulkOptions.keepNulls) {
		      addOptions.push('KEEP_NULLS');
		    }
		    if (this.bulkOptions.lockTable) {
		      addOptions.push('TABLOCK');
		    }
		    if (this.bulkOptions.order) {
		      const orderColumns = [];
		      for (const [column, direction] of Object.entries(this.bulkOptions.order)) {
		        orderColumns.push(`${column} ${direction}`);
		      }
		      if (orderColumns.length) {
		        addOptions.push(`ORDER (${orderColumns.join(', ')})`);
		      }
		    }
		    if (addOptions.length > 0) {
		      return ` WITH (${addOptions.join(',')})`;
		    } else {
		      return '';
		    }
		  }

		  /**
		   * @private
		   */
		  getBulkInsertSql() {
		    let sql = 'insert bulk ' + this.table + '(';
		    for (let i = 0, len = this.columns.length; i < len; i++) {
		      const c = this.columns[i];
		      if (i !== 0) {
		        sql += ', ';
		      }
		      sql += '[' + c.name + '] ' + c.type.declaration(c);
		    }
		    sql += ')';
		    sql += this.getOptionsSql();
		    return sql;
		  }

		  /**
		   * This is simply a helper utility function which returns a `CREATE TABLE SQL` statement based on the columns added to the bulkLoad object.
		   * This may be particularly handy when you want to insert into a temporary table (a table which starts with `#`).
		   *
		   * ```js
		   * var sql = bulkLoad.getTableCreationSql();
		   * ```
		   *
		   * A side note on bulk inserting into temporary tables: if you want to access a local temporary table after executing the bulk load,
		   * you'll need to use the same connection and execute your requests using [[Connection.execSqlBatch]] instead of [[Connection.execSql]]
		   */
		  getTableCreationSql() {
		    let sql = 'CREATE TABLE ' + this.table + '(\n';
		    for (let i = 0, len = this.columns.length; i < len; i++) {
		      const c = this.columns[i];
		      if (i !== 0) {
		        sql += ',\n';
		      }
		      sql += '[' + c.name + '] ' + c.type.declaration(c);
		      if (c.nullable !== undefined) {
		        sql += ' ' + (c.nullable ? 'NULL' : 'NOT NULL');
		      }
		    }
		    sql += '\n)';
		    return sql;
		  }

		  /**
		   * @private
		   */
		  getColMetaData() {
		    const tBuf = new _writableTrackingBuffer.default(100, null, true);
		    // TokenType
		    tBuf.writeUInt8(_token.TYPE.COLMETADATA);
		    // Count
		    tBuf.writeUInt16LE(this.columns.length);
		    for (let j = 0, len = this.columns.length; j < len; j++) {
		      const c = this.columns[j];
		      // UserType
		      if (this.options.tdsVersion < '7_2') {
		        tBuf.writeUInt16LE(0);
		      } else {
		        tBuf.writeUInt32LE(0);
		      }

		      // Flags
		      let flags = FLAGS.updateableReadWrite;
		      if (c.nullable) {
		        flags |= FLAGS.nullable;
		      } else if (c.nullable === undefined && this.options.tdsVersion >= '7_2') {
		        flags |= FLAGS.nullableUnknown;
		      }
		      tBuf.writeUInt16LE(flags);

		      // TYPE_INFO
		      tBuf.writeBuffer(c.type.generateTypeInfo(c, this.options));

		      // TableName
		      if (c.type.hasTableName) {
		        tBuf.writeUsVarchar(this.table, 'ucs2');
		      }

		      // ColName
		      tBuf.writeBVarchar(c.name, 'ucs2');
		    }
		    return tBuf.data;
		  }

		  /**
		   * Sets a timeout for this bulk load.
		   *
		   * ```js
		   * bulkLoad.setTimeout(timeout);
		   * ```
		   *
		   * @param timeout The number of milliseconds before the bulk load is considered failed, or 0 for no timeout.
		   *   When no timeout is set for the bulk load, the [[ConnectionOptions.requestTimeout]] of the Connection is used.
		   */
		  setTimeout(timeout) {
		    this.timeout = timeout;
		  }

		  /**
		   * @private
		   */
		  createDoneToken() {
		    // It might be nice to make DoneToken a class if anything needs to create them, but for now, just do it here
		    const tBuf = new _writableTrackingBuffer.default(this.options.tdsVersion < '7_2' ? 9 : 13);
		    tBuf.writeUInt8(_token.TYPE.DONE);
		    const status = DONE_STATUS.FINAL;
		    tBuf.writeUInt16LE(status);
		    tBuf.writeUInt16LE(0); // CurCmd (TDS ignores this)
		    tBuf.writeUInt32LE(0); // row count - doesn't really matter
		    if (this.options.tdsVersion >= '7_2') {
		      tBuf.writeUInt32LE(0); // row count is 64 bits in >= TDS 7.2
		    }
		    return tBuf.data;
		  }

		  /**
		   * @private
		   */
		  cancel() {
		    if (this.canceled) {
		      return;
		    }
		    this.canceled = true;
		    this.emit('cancel');
		  }
		}
		exports$1.default = BulkLoad;
		module.exports = BulkLoad;
		
	} (bulkLoad, bulkLoad.exports));
	return bulkLoad.exports;
}

var connection = {exports: {}};

var commonjs$8 = {};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  };
  return __assign.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
}
var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

var tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
};

var tslib_es6$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  __addDisposableResource: __addDisposableResource,
  get __assign () { return __assign; },
  __asyncDelegator: __asyncDelegator,
  __asyncGenerator: __asyncGenerator,
  __asyncValues: __asyncValues,
  __await: __await,
  __awaiter: __awaiter,
  __classPrivateFieldGet: __classPrivateFieldGet,
  __classPrivateFieldIn: __classPrivateFieldIn,
  __classPrivateFieldSet: __classPrivateFieldSet,
  __createBinding: __createBinding,
  __decorate: __decorate,
  __disposeResources: __disposeResources,
  __esDecorate: __esDecorate,
  __exportStar: __exportStar,
  __extends: __extends,
  __generator: __generator,
  __importDefault: __importDefault,
  __importStar: __importStar,
  __makeTemplateObject: __makeTemplateObject,
  __metadata: __metadata,
  __param: __param,
  __propKey: __propKey,
  __read: __read,
  __rest: __rest,
  __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,
  __runInitializers: __runInitializers,
  __setFunctionName: __setFunctionName,
  __spread: __spread,
  __spreadArray: __spreadArray,
  __spreadArrays: __spreadArrays,
  __values: __values,
  default: tslib_es6
});

var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(tslib_es6$1);

var consumer = {};

var msalPlugins = {};

var constants$3 = {};

var hasRequiredConstants$3;

function requireConstants$3 () {
	if (hasRequiredConstants$3) return constants$3;
	hasRequiredConstants$3 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(constants$3, "__esModule", { value: true });
	constants$3.DEFAULT_TOKEN_CACHE_NAME = constants$3.CACHE_NON_CAE_SUFFIX = constants$3.CACHE_CAE_SUFFIX = constants$3.ALL_TENANTS = constants$3.DefaultAuthority = constants$3.DefaultAuthorityHost = constants$3.AzureAuthorityHosts = constants$3.DefaultTenantId = constants$3.DeveloperSignOnClientId = constants$3.SDK_VERSION = void 0;
	/**
	 * Current version of the `@azure/identity` package.
	 */
	constants$3.SDK_VERSION = `4.13.0`;
	/**
	 * The default client ID for authentication
	 * @internal
	 */
	// TODO: temporary - this is the Azure CLI clientID - we'll replace it when
	// Developer Sign On application is available
	// https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/Constants.cs#L9
	constants$3.DeveloperSignOnClientId = "04b07795-8ddb-461a-bbee-02f9e1bf7b46";
	/**
	 * The default tenant for authentication
	 * @internal
	 */
	constants$3.DefaultTenantId = "common";
	/**
	 * A list of known Azure authority hosts
	 */
	var AzureAuthorityHosts;
	(function (AzureAuthorityHosts) {
	    /**
	     * China-based Azure Authority Host
	     */
	    AzureAuthorityHosts["AzureChina"] = "https://login.chinacloudapi.cn";
	    /**
	     * Germany-based Azure Authority Host
	     *
	     * @deprecated Microsoft Cloud Germany was closed on October 29th, 2021.
	     *
	     * */
	    AzureAuthorityHosts["AzureGermany"] = "https://login.microsoftonline.de";
	    /**
	     * US Government Azure Authority Host
	     */
	    AzureAuthorityHosts["AzureGovernment"] = "https://login.microsoftonline.us";
	    /**
	     * Public Cloud Azure Authority Host
	     */
	    AzureAuthorityHosts["AzurePublicCloud"] = "https://login.microsoftonline.com";
	})(AzureAuthorityHosts || (constants$3.AzureAuthorityHosts = AzureAuthorityHosts = {}));
	/**
	 * @internal
	 * The default authority host.
	 */
	constants$3.DefaultAuthorityHost = AzureAuthorityHosts.AzurePublicCloud;
	/**
	 * @internal
	 * The default environment host for Azure Public Cloud
	 */
	constants$3.DefaultAuthority = "login.microsoftonline.com";
	/**
	 * @internal
	 * Allow acquiring tokens for any tenant for multi-tentant auth.
	 */
	constants$3.ALL_TENANTS = ["*"];
	/**
	 * @internal
	 */
	constants$3.CACHE_CAE_SUFFIX = "cae";
	/**
	 * @internal
	 */
	constants$3.CACHE_NON_CAE_SUFFIX = "nocae";
	/**
	 * @internal
	 *
	 * The default name for the cache persistence plugin.
	 * Matches the constant defined in the cache persistence package.
	 */
	constants$3.DEFAULT_TOKEN_CACHE_NAME = "msal.cache";
	
	return constants$3;
}

var hasRequiredMsalPlugins;

function requireMsalPlugins () {
	if (hasRequiredMsalPlugins) return msalPlugins;
	hasRequiredMsalPlugins = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.msalPlugins = exports$1.msalNodeFlowVSCodeCredentialControl = exports$1.msalNodeFlowNativeBrokerControl = exports$1.vsCodeBrokerInfo = exports$1.vsCodeAuthRecordPath = exports$1.nativeBrokerInfo = exports$1.msalNodeFlowCacheControl = exports$1.persistenceProvider = void 0;
		exports$1.hasNativeBroker = hasNativeBroker;
		exports$1.hasVSCodePlugin = hasVSCodePlugin;
		const constants_js_1 = requireConstants$3();
		/**
		 * The current persistence provider, undefined by default.
		 * @internal
		 */
		exports$1.persistenceProvider = undefined;
		/**
		 * An object that allows setting the persistence provider.
		 * @internal
		 */
		exports$1.msalNodeFlowCacheControl = {
		    setPersistence(pluginProvider) {
		        exports$1.persistenceProvider = pluginProvider;
		    },
		};
		/**
		 * The current native broker provider, undefined by default.
		 * @internal
		 */
		exports$1.nativeBrokerInfo = undefined;
		/**
		 * The current VSCode auth record path, undefined by default.
		 * @internal
		 */
		exports$1.vsCodeAuthRecordPath = undefined;
		/**
		 * The current VSCode broker, undefined by default.
		 * @internal
		 */
		exports$1.vsCodeBrokerInfo = undefined;
		function hasNativeBroker() {
		    return exports$1.nativeBrokerInfo !== undefined;
		}
		function hasVSCodePlugin() {
		    return exports$1.vsCodeAuthRecordPath !== undefined && exports$1.vsCodeBrokerInfo !== undefined;
		}
		/**
		 * An object that allows setting the native broker provider.
		 * @internal
		 */
		exports$1.msalNodeFlowNativeBrokerControl = {
		    setNativeBroker(broker) {
		        exports$1.nativeBrokerInfo = {
		            broker,
		        };
		    },
		};
		/**
		 * An object that allows setting the VSCode credential auth record path and broker.
		 * @internal
		 */
		exports$1.msalNodeFlowVSCodeCredentialControl = {
		    setVSCodeAuthRecordPath(path) {
		        exports$1.vsCodeAuthRecordPath = path;
		    },
		    setVSCodeBroker(broker) {
		        exports$1.vsCodeBrokerInfo = {
		            broker,
		        };
		    },
		};
		/**
		 * Configures plugins, validating that required plugins are available and enabled.
		 *
		 * Does not create the plugins themselves, but rather returns the configuration that will be used to create them.
		 *
		 * @param options - options for creating the MSAL client
		 * @returns plugin configuration
		 */
		function generatePluginConfiguration(options) {
		    const config = {
		        cache: {},
		        broker: {
		            ...options.brokerOptions,
		            isEnabled: options.brokerOptions?.enabled ?? false,
		            enableMsaPassthrough: options.brokerOptions?.legacyEnableMsaPassthrough ?? false,
		        },
		    };
		    if (options.tokenCachePersistenceOptions?.enabled) {
		        if (exports$1.persistenceProvider === undefined) {
		            throw new Error([
		                "Persistent token caching was requested, but no persistence provider was configured.",
		                "You must install the identity-cache-persistence plugin package (`npm install --save @azure/identity-cache-persistence`)",
		                "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
		                "`useIdentityPlugin(cachePersistencePlugin)` before using `tokenCachePersistenceOptions`.",
		            ].join(" "));
		        }
		        const cacheBaseName = options.tokenCachePersistenceOptions.name || constants_js_1.DEFAULT_TOKEN_CACHE_NAME;
		        config.cache.cachePlugin = (0, exports$1.persistenceProvider)({
		            name: `${cacheBaseName}.${constants_js_1.CACHE_NON_CAE_SUFFIX}`,
		            ...options.tokenCachePersistenceOptions,
		        });
		        config.cache.cachePluginCae = (0, exports$1.persistenceProvider)({
		            name: `${cacheBaseName}.${constants_js_1.CACHE_CAE_SUFFIX}`,
		            ...options.tokenCachePersistenceOptions,
		        });
		    }
		    if (options.brokerOptions?.enabled) {
		        config.broker.nativeBrokerPlugin = getBrokerPlugin(options.isVSCodeCredential || false);
		    }
		    return config;
		}
		// Broker error message templates with variables for credential and package names
		const brokerErrorTemplates = {
		    missing: (credentialName, packageName, pluginVar) => [
		        `${credentialName} was requested, but no plugin was configured or no authentication record was found.`,
		        `You must install the ${packageName} plugin package (npm install --save ${packageName})`,
		        "and enable it by importing `useIdentityPlugin` from `@azure/identity` and calling",
		        `useIdentityPlugin(${pluginVar}) before using enableBroker.`,
		    ].join(" "),
		    unavailable: (credentialName, packageName) => [
		        `${credentialName} was requested, and the plugin is configured, but the broker is unavailable.`,
		        `Ensure the ${credentialName} plugin is properly installed and configured.`,
		        "Check for missing native dependencies and ensure the package is properly installed.",
		        `See the README for prerequisites on installing and using ${packageName}.`,
		    ].join(" "),
		};
		// Values for VSCode and native broker configurations for error message
		const brokerConfig = {
		    vsCode: {
		        credentialName: "Visual Studio Code Credential",
		        packageName: "@azure/identity-vscode",
		        pluginVar: "vsCodePlugin",
		        get brokerInfo() {
		            return exports$1.vsCodeBrokerInfo;
		        },
		    },
		    native: {
		        credentialName: "Broker for WAM",
		        packageName: "@azure/identity-broker",
		        pluginVar: "nativeBrokerPlugin",
		        get brokerInfo() {
		            return exports$1.nativeBrokerInfo;
		        },
		    },
		};
		/**
		 * Set appropriate broker plugin based on whether VSCode or native broker is requested.
		 * @param isVSCodePlugin - true for VSCode broker, false for native broker
		 * @returns the broker plugin if available
		 */
		function getBrokerPlugin(isVSCodePlugin) {
		    const { credentialName, packageName, pluginVar, brokerInfo } = brokerConfig[isVSCodePlugin ? "vsCode" : "native"];
		    if (brokerInfo === undefined) {
		        throw new Error(brokerErrorTemplates.missing(credentialName, packageName, pluginVar));
		    }
		    if (brokerInfo.broker.isBrokerAvailable === false) {
		        throw new Error(brokerErrorTemplates.unavailable(credentialName, packageName));
		    }
		    return brokerInfo.broker;
		}
		/**
		 * Wraps generatePluginConfiguration as a writeable property for test stubbing purposes.
		 */
		exports$1.msalPlugins = {
		    generatePluginConfiguration,
		};
		
	} (msalPlugins));
	return msalPlugins;
}

var hasRequiredConsumer;

function requireConsumer () {
	if (hasRequiredConsumer) return consumer;
	hasRequiredConsumer = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(consumer, "__esModule", { value: true });
	consumer.useIdentityPlugin = useIdentityPlugin;
	const msalPlugins_js_1 = requireMsalPlugins();
	/**
	 * The context passed to an Identity plugin. This contains objects that
	 * plugins can use to set backend implementations.
	 */
	const pluginContext = {
	    cachePluginControl: msalPlugins_js_1.msalNodeFlowCacheControl,
	    nativeBrokerPluginControl: msalPlugins_js_1.msalNodeFlowNativeBrokerControl,
	    vsCodeCredentialControl: msalPlugins_js_1.msalNodeFlowVSCodeCredentialControl,
	};
	/**
	 * Extend Azure Identity with additional functionality. Pass a plugin from
	 * a plugin package, such as:
	 *
	 * - `@azure/identity-cache-persistence`: provides persistent token caching
	 * - `@azure/identity-vscode`: provides the dependencies of
	 *   `VisualStudioCodeCredential` and enables it
	 *
	 * Example:
	 *
	 * ```ts snippet:consumer_example
	 * import { useIdentityPlugin, DeviceCodeCredential } from "@azure/identity";
	 *
	 * useIdentityPlugin(cachePersistencePlugin);
	 * // The plugin has the capability to extend `DeviceCodeCredential` and to
	 * // add middleware to the underlying credentials, such as persistence.
	 * const credential = new DeviceCodeCredential({
	 *   tokenCachePersistenceOptions: {
	 *     enabled: true,
	 *   },
	 * });
	 * ```
	 *
	 * @param plugin - the plugin to register
	 */
	function useIdentityPlugin(plugin) {
	    plugin(pluginContext);
	}
	
	return consumer;
}

var defaultAzureCredential = {};

var chainedTokenCredential = {};

var errors$2 = {};

var hasRequiredErrors$2;

function requireErrors$2 () {
	if (hasRequiredErrors$2) return errors$2;
	hasRequiredErrors$2 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.AuthenticationRequiredError = exports$1.AggregateAuthenticationError = exports$1.AggregateAuthenticationErrorName = exports$1.AuthenticationError = exports$1.AuthenticationErrorName = exports$1.CredentialUnavailableError = exports$1.CredentialUnavailableErrorName = void 0;
		function isErrorResponse(errorResponse) {
		    return (errorResponse &&
		        typeof errorResponse.error === "string" &&
		        typeof errorResponse.error_description === "string");
		}
		/**
		 * The Error.name value of an CredentialUnavailable
		 */
		exports$1.CredentialUnavailableErrorName = "CredentialUnavailableError";
		/**
		 * This signifies that the credential that was tried in a chained credential
		 * was not available to be used as the credential. Rather than treating this as
		 * an error that should halt the chain, it's caught and the chain continues
		 */
		class CredentialUnavailableError extends Error {
		    constructor(message, options) {
		        super(message, options);
		        this.name = exports$1.CredentialUnavailableErrorName;
		    }
		}
		exports$1.CredentialUnavailableError = CredentialUnavailableError;
		/**
		 * The Error.name value of an AuthenticationError
		 */
		exports$1.AuthenticationErrorName = "AuthenticationError";
		/**
		 * Provides details about a failure to authenticate with Azure Active
		 * Directory.  The `errorResponse` field contains more details about
		 * the specific failure.
		 */
		class AuthenticationError extends Error {
		    /**
		     * The HTTP status code returned from the authentication request.
		     */
		    statusCode;
		    /**
		     * The error response details.
		     */
		    errorResponse;
		    constructor(statusCode, errorBody, options) {
		        let errorResponse = {
		            error: "unknown",
		            errorDescription: "An unknown error occurred and no additional details are available.",
		        };
		        if (isErrorResponse(errorBody)) {
		            errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);
		        }
		        else if (typeof errorBody === "string") {
		            try {
		                // Most error responses will contain JSON-formatted error details
		                // in the response body
		                const oauthErrorResponse = JSON.parse(errorBody);
		                errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);
		            }
		            catch (e) {
		                if (statusCode === 400) {
		                    errorResponse = {
		                        error: "invalid_request",
		                        errorDescription: `The service indicated that the request was invalid.\n\n${errorBody}`,
		                    };
		                }
		                else {
		                    errorResponse = {
		                        error: "unknown_error",
		                        errorDescription: `An unknown error has occurred. Response body:\n\n${errorBody}`,
		                    };
		                }
		            }
		        }
		        else {
		            errorResponse = {
		                error: "unknown_error",
		                errorDescription: "An unknown error occurred and no additional details are available.",
		            };
		        }
		        super(`${errorResponse.error} Status code: ${statusCode}\nMore details:\n${errorResponse.errorDescription},`, options);
		        this.statusCode = statusCode;
		        this.errorResponse = errorResponse;
		        // Ensure that this type reports the correct name
		        this.name = exports$1.AuthenticationErrorName;
		    }
		}
		exports$1.AuthenticationError = AuthenticationError;
		/**
		 * The Error.name value of an AggregateAuthenticationError
		 */
		exports$1.AggregateAuthenticationErrorName = "AggregateAuthenticationError";
		/**
		 * Provides an `errors` array containing {@link AuthenticationError} instance
		 * for authentication failures from credentials in a {@link ChainedTokenCredential}.
		 */
		class AggregateAuthenticationError extends Error {
		    /**
		     * The array of error objects that were thrown while trying to authenticate
		     * with the credentials in a {@link ChainedTokenCredential}.
		     */
		    errors;
		    constructor(errors, errorMessage) {
		        const errorDetail = errors.join("\n");
		        super(`${errorMessage}\n${errorDetail}`);
		        this.errors = errors;
		        // Ensure that this type reports the correct name
		        this.name = exports$1.AggregateAuthenticationErrorName;
		    }
		}
		exports$1.AggregateAuthenticationError = AggregateAuthenticationError;
		function convertOAuthErrorResponseToErrorResponse(errorBody) {
		    return {
		        error: errorBody.error,
		        errorDescription: errorBody.error_description,
		        correlationId: errorBody.correlation_id,
		        errorCodes: errorBody.error_codes,
		        timestamp: errorBody.timestamp,
		        traceId: errorBody.trace_id,
		    };
		}
		/**
		 * Error used to enforce authentication after trying to retrieve a token silently.
		 */
		class AuthenticationRequiredError extends Error {
		    /**
		     * The list of scopes for which the token will have access.
		     */
		    scopes;
		    /**
		     * The options passed to the getToken request.
		     */
		    getTokenOptions;
		    constructor(
		    /**
		     * Optional parameters. A message can be specified. The {@link GetTokenOptions} of the request can also be specified to more easily associate the error with the received parameters.
		     */
		    options) {
		        super(options.message, options.cause ? { cause: options.cause } : undefined);
		        this.scopes = options.scopes;
		        this.getTokenOptions = options.getTokenOptions;
		        this.name = "AuthenticationRequiredError";
		    }
		}
		exports$1.AuthenticationRequiredError = AuthenticationRequiredError;
		
	} (errors$2));
	return errors$2;
}

var logging = {};

var commonjs$7 = {};

var internal$3 = {};

var logger = {};

var debug$2 = {};

var log$3 = {};

const require$a = createRequire(import.meta.url);
function __require$9() { return require$a("node:os"); }

const require$9 = createRequire(import.meta.url);
function __require$8() { return require$9("node:util"); }

const require$8 = createRequire(import.meta.url);
function __require$7() { return require$8("node:process"); }

var hasRequiredLog$3;

function requireLog$3 () {
	if (hasRequiredLog$3) return log$3;
	hasRequiredLog$3 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(log$3, "__esModule", { value: true });
	log$3.log = log;
	const tslib_1 = require$$0$3;
	const node_os_1 = __require$9();
	const node_util_1 = tslib_1.__importDefault(__require$8());
	const node_process_1 = tslib_1.__importDefault(__require$7());
	function log(message, ...args) {
	    node_process_1.default.stderr.write(`${node_util_1.default.format(message, ...args)}${node_os_1.EOL}`);
	}
	
	return log$3;
}

var hasRequiredDebug$2;

function requireDebug$2 () {
	if (hasRequiredDebug$2) return debug$2;
	hasRequiredDebug$2 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(debug$2, "__esModule", { value: true });
	const log_js_1 = requireLog$3();
	const debugEnvVariable = (typeof process !== "undefined" && process.env && process.env.DEBUG) || undefined;
	let enabledString;
	let enabledNamespaces = [];
	let skippedNamespaces = [];
	const debuggers = [];
	if (debugEnvVariable) {
	    enable(debugEnvVariable);
	}
	const debugObj = Object.assign((namespace) => {
	    return createDebugger(namespace);
	}, {
	    enable,
	    enabled,
	    disable,
	    log: log_js_1.log,
	});
	function enable(namespaces) {
	    enabledString = namespaces;
	    enabledNamespaces = [];
	    skippedNamespaces = [];
	    const namespaceList = namespaces.split(",").map((ns) => ns.trim());
	    for (const ns of namespaceList) {
	        if (ns.startsWith("-")) {
	            skippedNamespaces.push(ns.substring(1));
	        }
	        else {
	            enabledNamespaces.push(ns);
	        }
	    }
	    for (const instance of debuggers) {
	        instance.enabled = enabled(instance.namespace);
	    }
	}
	function enabled(namespace) {
	    if (namespace.endsWith("*")) {
	        return true;
	    }
	    for (const skipped of skippedNamespaces) {
	        if (namespaceMatches(namespace, skipped)) {
	            return false;
	        }
	    }
	    for (const enabledNamespace of enabledNamespaces) {
	        if (namespaceMatches(namespace, enabledNamespace)) {
	            return true;
	        }
	    }
	    return false;
	}
	/**
	 * Given a namespace, check if it matches a pattern.
	 * Patterns only have a single wildcard character which is *.
	 * The behavior of * is that it matches zero or more other characters.
	 */
	function namespaceMatches(namespace, patternToMatch) {
	    // simple case, no pattern matching required
	    if (patternToMatch.indexOf("*") === -1) {
	        return namespace === patternToMatch;
	    }
	    let pattern = patternToMatch;
	    // normalize successive * if needed
	    if (patternToMatch.indexOf("**") !== -1) {
	        const patternParts = [];
	        let lastCharacter = "";
	        for (const character of patternToMatch) {
	            if (character === "*" && lastCharacter === "*") {
	                continue;
	            }
	            else {
	                lastCharacter = character;
	                patternParts.push(character);
	            }
	        }
	        pattern = patternParts.join("");
	    }
	    let namespaceIndex = 0;
	    let patternIndex = 0;
	    const patternLength = pattern.length;
	    const namespaceLength = namespace.length;
	    let lastWildcard = -1;
	    let lastWildcardNamespace = -1;
	    while (namespaceIndex < namespaceLength && patternIndex < patternLength) {
	        if (pattern[patternIndex] === "*") {
	            lastWildcard = patternIndex;
	            patternIndex++;
	            if (patternIndex === patternLength) {
	                // if wildcard is the last character, it will match the remaining namespace string
	                return true;
	            }
	            // now we let the wildcard eat characters until we match the next literal in the pattern
	            while (namespace[namespaceIndex] !== pattern[patternIndex]) {
	                namespaceIndex++;
	                // reached the end of the namespace without a match
	                if (namespaceIndex === namespaceLength) {
	                    return false;
	                }
	            }
	            // now that we have a match, let's try to continue on
	            // however, it's possible we could find a later match
	            // so keep a reference in case we have to backtrack
	            lastWildcardNamespace = namespaceIndex;
	            namespaceIndex++;
	            patternIndex++;
	            continue;
	        }
	        else if (pattern[patternIndex] === namespace[namespaceIndex]) {
	            // simple case: literal pattern matches so keep going
	            patternIndex++;
	            namespaceIndex++;
	        }
	        else if (lastWildcard >= 0) {
	            // special case: we don't have a literal match, but there is a previous wildcard
	            // which we can backtrack to and try having the wildcard eat the match instead
	            patternIndex = lastWildcard + 1;
	            namespaceIndex = lastWildcardNamespace + 1;
	            // we've reached the end of the namespace without a match
	            if (namespaceIndex === namespaceLength) {
	                return false;
	            }
	            // similar to the previous logic, let's keep going until we find the next literal match
	            while (namespace[namespaceIndex] !== pattern[patternIndex]) {
	                namespaceIndex++;
	                if (namespaceIndex === namespaceLength) {
	                    return false;
	                }
	            }
	            lastWildcardNamespace = namespaceIndex;
	            namespaceIndex++;
	            patternIndex++;
	            continue;
	        }
	        else {
	            return false;
	        }
	    }
	    const namespaceDone = namespaceIndex === namespace.length;
	    const patternDone = patternIndex === pattern.length;
	    // this is to detect the case of an unneeded final wildcard
	    // e.g. the pattern `ab*` should match the string `ab`
	    const trailingWildCard = patternIndex === pattern.length - 1 && pattern[patternIndex] === "*";
	    return namespaceDone && (patternDone || trailingWildCard);
	}
	function disable() {
	    const result = enabledString || "";
	    enable("");
	    return result;
	}
	function createDebugger(namespace) {
	    const newDebugger = Object.assign(debug, {
	        enabled: enabled(namespace),
	        destroy,
	        log: debugObj.log,
	        namespace,
	        extend,
	    });
	    function debug(...args) {
	        if (!newDebugger.enabled) {
	            return;
	        }
	        if (args.length > 0) {
	            args[0] = `${namespace} ${args[0]}`;
	        }
	        newDebugger.log(...args);
	    }
	    debuggers.push(newDebugger);
	    return newDebugger;
	}
	function destroy() {
	    const index = debuggers.indexOf(this);
	    if (index >= 0) {
	        debuggers.splice(index, 1);
	        return true;
	    }
	    return false;
	}
	function extend(namespace) {
	    const newDebugger = createDebugger(`${this.namespace}:${namespace}`);
	    newDebugger.log = this.log;
	    return newDebugger;
	}
	debug$2.default = debugObj;
	
	return debug$2;
}

var hasRequiredLogger;

function requireLogger () {
	if (hasRequiredLogger) return logger;
	hasRequiredLogger = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(logger, "__esModule", { value: true });
	logger.TypeSpecRuntimeLogger = void 0;
	logger.createLoggerContext = createLoggerContext;
	logger.setLogLevel = setLogLevel;
	logger.getLogLevel = getLogLevel;
	logger.createClientLogger = createClientLogger;
	const tslib_1 = require$$0$3;
	const debug_js_1 = tslib_1.__importDefault(requireDebug$2());
	const TYPESPEC_RUNTIME_LOG_LEVELS = ["verbose", "info", "warning", "error"];
	const levelMap = {
	    verbose: 400,
	    info: 300,
	    warning: 200,
	    error: 100,
	};
	function patchLogMethod(parent, child) {
	    child.log = (...args) => {
	        parent.log(...args);
	    };
	}
	function isTypeSpecRuntimeLogLevel(level) {
	    return TYPESPEC_RUNTIME_LOG_LEVELS.includes(level);
	}
	/**
	 * Creates a logger context base on the provided options.
	 * @param options - The options for creating a logger context.
	 * @returns The logger context.
	 */
	function createLoggerContext(options) {
	    const registeredLoggers = new Set();
	    const logLevelFromEnv = (typeof process !== "undefined" && process.env && process.env[options.logLevelEnvVarName]) ||
	        undefined;
	    let logLevel;
	    const clientLogger = (0, debug_js_1.default)(options.namespace);
	    clientLogger.log = (...args) => {
	        debug_js_1.default.log(...args);
	    };
	    function contextSetLogLevel(level) {
	        if (level && !isTypeSpecRuntimeLogLevel(level)) {
	            throw new Error(`Unknown log level '${level}'. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(",")}`);
	        }
	        logLevel = level;
	        const enabledNamespaces = [];
	        for (const logger of registeredLoggers) {
	            if (shouldEnable(logger)) {
	                enabledNamespaces.push(logger.namespace);
	            }
	        }
	        debug_js_1.default.enable(enabledNamespaces.join(","));
	    }
	    if (logLevelFromEnv) {
	        // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
	        if (isTypeSpecRuntimeLogLevel(logLevelFromEnv)) {
	            contextSetLogLevel(logLevelFromEnv);
	        }
	        else {
	            console.error(`${options.logLevelEnvVarName} set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${TYPESPEC_RUNTIME_LOG_LEVELS.join(", ")}.`);
	        }
	    }
	    function shouldEnable(logger) {
	        return Boolean(logLevel && levelMap[logger.level] <= levelMap[logLevel]);
	    }
	    function createLogger(parent, level) {
	        const logger = Object.assign(parent.extend(level), {
	            level,
	        });
	        patchLogMethod(parent, logger);
	        if (shouldEnable(logger)) {
	            const enabledNamespaces = debug_js_1.default.disable();
	            debug_js_1.default.enable(enabledNamespaces + "," + logger.namespace);
	        }
	        registeredLoggers.add(logger);
	        return logger;
	    }
	    function contextGetLogLevel() {
	        return logLevel;
	    }
	    function contextCreateClientLogger(namespace) {
	        const clientRootLogger = clientLogger.extend(namespace);
	        patchLogMethod(clientLogger, clientRootLogger);
	        return {
	            error: createLogger(clientRootLogger, "error"),
	            warning: createLogger(clientRootLogger, "warning"),
	            info: createLogger(clientRootLogger, "info"),
	            verbose: createLogger(clientRootLogger, "verbose"),
	        };
	    }
	    return {
	        setLogLevel: contextSetLogLevel,
	        getLogLevel: contextGetLogLevel,
	        createClientLogger: contextCreateClientLogger,
	        logger: clientLogger,
	    };
	}
	const context = createLoggerContext({
	    logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
	    namespace: "typeSpecRuntime",
	});
	/**
	 * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.
	 * @param level - The log level to enable for logging.
	 * Options from most verbose to least verbose are:
	 * - verbose
	 * - info
	 * - warning
	 * - error
	 */
	// eslint-disable-next-line @typescript-eslint/no-redeclare
	logger.TypeSpecRuntimeLogger = context.logger;
	/**
	 * Retrieves the currently specified log level.
	 */
	function setLogLevel(logLevel) {
	    context.setLogLevel(logLevel);
	}
	/**
	 * Retrieves the currently specified log level.
	 */
	function getLogLevel() {
	    return context.getLogLevel();
	}
	/**
	 * Creates a logger for use by the SDKs that inherits from `TypeSpecRuntimeLogger`.
	 * @param namespace - The name of the SDK package.
	 * @hidden
	 */
	function createClientLogger(namespace) {
	    return context.createClientLogger(namespace);
	}
	
	return logger;
}

var hasRequiredInternal$3;

function requireInternal$3 () {
	if (hasRequiredInternal$3) return internal$3;
	hasRequiredInternal$3 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.createLoggerContext = void 0;
		var logger_js_1 = requireLogger();
		Object.defineProperty(exports$1, "createLoggerContext", { enumerable: true, get: function () { return logger_js_1.createLoggerContext; } });
		
	} (internal$3));
	return internal$3;
}

var hasRequiredCommonjs$8;

function requireCommonjs$8 () {
	if (hasRequiredCommonjs$8) return commonjs$7;
	hasRequiredCommonjs$8 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(commonjs$7, "__esModule", { value: true });
	commonjs$7.AzureLogger = void 0;
	commonjs$7.setLogLevel = setLogLevel;
	commonjs$7.getLogLevel = getLogLevel;
	commonjs$7.createClientLogger = createClientLogger;
	const logger_1 = /*@__PURE__*/ requireInternal$3();
	const context = (0, logger_1.createLoggerContext)({
	    logLevelEnvVarName: "AZURE_LOG_LEVEL",
	    namespace: "azure",
	});
	/**
	 * The AzureLogger provides a mechanism for overriding where logs are output to.
	 * By default, logs are sent to stderr.
	 * Override the `log` method to redirect logs to another location.
	 */
	commonjs$7.AzureLogger = context.logger;
	/**
	 * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.
	 * @param level - The log level to enable for logging.
	 * Options from most verbose to least verbose are:
	 * - verbose
	 * - info
	 * - warning
	 * - error
	 */
	function setLogLevel(level) {
	    context.setLogLevel(level);
	}
	/**
	 * Retrieves the currently specified log level.
	 */
	function getLogLevel() {
	    return context.getLogLevel();
	}
	/**
	 * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.
	 * @param namespace - The name of the SDK package.
	 * @hidden
	 */
	function createClientLogger(namespace) {
	    return context.createClientLogger(namespace);
	}
	
	return commonjs$7;
}

var hasRequiredLogging;

function requireLogging () {
	if (hasRequiredLogging) return logging;
	hasRequiredLogging = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.logger = void 0;
		exports$1.processEnvVars = processEnvVars;
		exports$1.logEnvVars = logEnvVars;
		exports$1.formatSuccess = formatSuccess;
		exports$1.formatError = formatError;
		exports$1.credentialLoggerInstance = credentialLoggerInstance;
		exports$1.credentialLogger = credentialLogger;
		const logger_1 = /*@__PURE__*/ requireCommonjs$8();
		/**
		 * The AzureLogger used for all clients within the identity package
		 */
		exports$1.logger = (0, logger_1.createClientLogger)("identity");
		/**
		 * Separates a list of environment variable names into a plain object with two arrays: an array of missing environment variables and another array with assigned environment variables.
		 * @param supportedEnvVars - List of environment variable names
		 */
		function processEnvVars(supportedEnvVars) {
		    return supportedEnvVars.reduce((acc, envVariable) => {
		        if (process.env[envVariable]) {
		            acc.assigned.push(envVariable);
		        }
		        else {
		            acc.missing.push(envVariable);
		        }
		        return acc;
		    }, { missing: [], assigned: [] });
		}
		/**
		 * Based on a given list of environment variable names,
		 * logs the environment variables currently assigned during the usage of a credential that goes by the given name.
		 * @param credentialName - Name of the credential in use
		 * @param supportedEnvVars - List of environment variables supported by that credential
		 */
		function logEnvVars(credentialName, supportedEnvVars) {
		    const { assigned } = processEnvVars(supportedEnvVars);
		    exports$1.logger.info(`${credentialName} => Found the following environment variables: ${assigned.join(", ")}`);
		}
		/**
		 * Formatting the success event on the credentials
		 */
		function formatSuccess(scope) {
		    return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
		}
		/**
		 * Formatting the success event on the credentials
		 */
		function formatError(scope, error) {
		    let message = "ERROR.";
		    if (scope?.length) {
		        message += ` Scopes: ${Array.isArray(scope) ? scope.join(", ") : scope}.`;
		    }
		    return `${message} Error message: ${typeof error === "string" ? error : error.message}.`;
		}
		/**
		 * Generates a CredentialLoggerInstance.
		 *
		 * It logs with the format:
		 *
		 *   `[title] => [message]`
		 *
		 */
		function credentialLoggerInstance(title, parent, log = exports$1.logger) {
		    const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;
		    function info(message) {
		        log.info(`${fullTitle} =>`, message);
		    }
		    function warning(message) {
		        log.warning(`${fullTitle} =>`, message);
		    }
		    function verbose(message) {
		        log.verbose(`${fullTitle} =>`, message);
		    }
		    function error(message) {
		        log.error(`${fullTitle} =>`, message);
		    }
		    return {
		        title,
		        fullTitle,
		        info,
		        warning,
		        verbose,
		        error,
		    };
		}
		/**
		 * Generates a CredentialLogger, which is a logger declared at the credential's constructor, and used at any point in the credential.
		 * It has all the properties of a CredentialLoggerInstance, plus other logger instances, one per method.
		 *
		 * It logs with the format:
		 *
		 *   `[title] => [message]`
		 *   `[title] => getToken() => [message]`
		 *
		 */
		function credentialLogger(title, log = exports$1.logger) {
		    const credLogger = credentialLoggerInstance(title, undefined, log);
		    return {
		        ...credLogger,
		        parent: log,
		        getToken: credentialLoggerInstance("=> getToken()", credLogger, log),
		    };
		}
		
	} (logging));
	return logging;
}

var tracing = {};

var commonjs$6 = {};

var instrumenter = {};

var tracingContext = {};

var hasRequiredTracingContext;

function requireTracingContext () {
	if (hasRequiredTracingContext) return tracingContext;
	hasRequiredTracingContext = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.TracingContextImpl = exports$1.knownContextKeys = void 0;
		exports$1.createTracingContext = createTracingContext;
		/** @internal */
		exports$1.knownContextKeys = {
		    span: Symbol.for("@azure/core-tracing span"),
		    namespace: Symbol.for("@azure/core-tracing namespace"),
		};
		/**
		 * Creates a new {@link TracingContext} with the given options.
		 * @param options - A set of known keys that may be set on the context.
		 * @returns A new {@link TracingContext} with the given options.
		 *
		 * @internal
		 */
		function createTracingContext(options = {}) {
		    let context = new TracingContextImpl(options.parentContext);
		    if (options.span) {
		        context = context.setValue(exports$1.knownContextKeys.span, options.span);
		    }
		    if (options.namespace) {
		        context = context.setValue(exports$1.knownContextKeys.namespace, options.namespace);
		    }
		    return context;
		}
		/** @internal */
		class TracingContextImpl {
		    _contextMap;
		    constructor(initialContext) {
		        this._contextMap =
		            initialContext instanceof TracingContextImpl
		                ? new Map(initialContext._contextMap)
		                : new Map();
		    }
		    setValue(key, value) {
		        const newContext = new TracingContextImpl(this);
		        newContext._contextMap.set(key, value);
		        return newContext;
		    }
		    getValue(key) {
		        return this._contextMap.get(key);
		    }
		    deleteValue(key) {
		        const newContext = new TracingContextImpl(this);
		        newContext._contextMap.delete(key);
		        return newContext;
		    }
		}
		exports$1.TracingContextImpl = TracingContextImpl;
		
	} (tracingContext));
	return tracingContext;
}

var state$2 = {};

var hasRequiredState$2;

function requireState$2 () {
	if (hasRequiredState$2) return state$2;
	hasRequiredState$2 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(state$2, "__esModule", { value: true });
	state$2.state = void 0;
	/**
	 * @internal
	 *
	 * Holds the singleton instrumenter, to be shared across CJS and ESM imports.
	 */
	state$2.state = {
	    instrumenterImplementation: undefined,
	};
	
	return state$2;
}

var hasRequiredInstrumenter;

function requireInstrumenter () {
	if (hasRequiredInstrumenter) return instrumenter;
	hasRequiredInstrumenter = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(instrumenter, "__esModule", { value: true });
	instrumenter.createDefaultTracingSpan = createDefaultTracingSpan;
	instrumenter.createDefaultInstrumenter = createDefaultInstrumenter;
	instrumenter.useInstrumenter = useInstrumenter;
	instrumenter.getInstrumenter = getInstrumenter;
	const tracingContext_js_1 = requireTracingContext();
	const state_js_1 = requireState$2();
	function createDefaultTracingSpan() {
	    return {
	        end: () => {
	            // noop
	        },
	        isRecording: () => false,
	        recordException: () => {
	            // noop
	        },
	        setAttribute: () => {
	            // noop
	        },
	        setStatus: () => {
	            // noop
	        },
	        addEvent: () => {
	            // noop
	        },
	    };
	}
	function createDefaultInstrumenter() {
	    return {
	        createRequestHeaders: () => {
	            return {};
	        },
	        parseTraceparentHeader: () => {
	            return undefined;
	        },
	        startSpan: (_name, spanOptions) => {
	            return {
	                span: createDefaultTracingSpan(),
	                tracingContext: (0, tracingContext_js_1.createTracingContext)({ parentContext: spanOptions.tracingContext }),
	            };
	        },
	        withContext(_context, callback, ...callbackArgs) {
	            return callback(...callbackArgs);
	        },
	    };
	}
	/**
	 * Extends the Azure SDK with support for a given instrumenter implementation.
	 *
	 * @param instrumenter - The instrumenter implementation to use.
	 */
	function useInstrumenter(instrumenter) {
	    state_js_1.state.instrumenterImplementation = instrumenter;
	}
	/**
	 * Gets the currently set instrumenter, a No-Op instrumenter by default.
	 *
	 * @returns The currently set instrumenter
	 */
	function getInstrumenter() {
	    if (!state_js_1.state.instrumenterImplementation) {
	        state_js_1.state.instrumenterImplementation = createDefaultInstrumenter();
	    }
	    return state_js_1.state.instrumenterImplementation;
	}
	
	return instrumenter;
}

var tracingClient = {};

var hasRequiredTracingClient;

function requireTracingClient () {
	if (hasRequiredTracingClient) return tracingClient;
	hasRequiredTracingClient = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(tracingClient, "__esModule", { value: true });
	tracingClient.createTracingClient = createTracingClient;
	const instrumenter_js_1 = requireInstrumenter();
	const tracingContext_js_1 = requireTracingContext();
	/**
	 * Creates a new tracing client.
	 *
	 * @param options - Options used to configure the tracing client.
	 * @returns - An instance of {@link TracingClient}.
	 */
	function createTracingClient(options) {
	    const { namespace, packageName, packageVersion } = options;
	    function startSpan(name, operationOptions, spanOptions) {
	        const startSpanResult = (0, instrumenter_js_1.getInstrumenter)().startSpan(name, {
	            ...spanOptions,
	            packageName: packageName,
	            packageVersion: packageVersion,
	            tracingContext: operationOptions?.tracingOptions?.tracingContext,
	        });
	        let tracingContext = startSpanResult.tracingContext;
	        const span = startSpanResult.span;
	        if (!tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace)) {
	            tracingContext = tracingContext.setValue(tracingContext_js_1.knownContextKeys.namespace, namespace);
	        }
	        span.setAttribute("az.namespace", tracingContext.getValue(tracingContext_js_1.knownContextKeys.namespace));
	        const updatedOptions = Object.assign({}, operationOptions, {
	            tracingOptions: { ...operationOptions?.tracingOptions, tracingContext },
	        });
	        return {
	            span,
	            updatedOptions,
	        };
	    }
	    async function withSpan(name, operationOptions, callback, spanOptions) {
	        const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);
	        try {
	            const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));
	            span.setStatus({ status: "success" });
	            return result;
	        }
	        catch (err) {
	            span.setStatus({ status: "error", error: err });
	            throw err;
	        }
	        finally {
	            span.end();
	        }
	    }
	    function withContext(context, callback, ...callbackArgs) {
	        return (0, instrumenter_js_1.getInstrumenter)().withContext(context, callback, ...callbackArgs);
	    }
	    /**
	     * Parses a traceparent header value into a span identifier.
	     *
	     * @param traceparentHeader - The traceparent header to parse.
	     * @returns An implementation-specific identifier for the span.
	     */
	    function parseTraceparentHeader(traceparentHeader) {
	        return (0, instrumenter_js_1.getInstrumenter)().parseTraceparentHeader(traceparentHeader);
	    }
	    /**
	     * Creates a set of request headers to propagate tracing information to a backend.
	     *
	     * @param tracingContext - The context containing the span to serialize.
	     * @returns The set of headers to add to a request.
	     */
	    function createRequestHeaders(tracingContext) {
	        return (0, instrumenter_js_1.getInstrumenter)().createRequestHeaders(tracingContext);
	    }
	    return {
	        startSpan,
	        withSpan,
	        withContext,
	        parseTraceparentHeader,
	        createRequestHeaders,
	    };
	}
	
	return tracingClient;
}

var hasRequiredCommonjs$7;

function requireCommonjs$7 () {
	if (hasRequiredCommonjs$7) return commonjs$6;
	hasRequiredCommonjs$7 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.createTracingClient = exports$1.useInstrumenter = void 0;
		var instrumenter_js_1 = requireInstrumenter();
		Object.defineProperty(exports$1, "useInstrumenter", { enumerable: true, get: function () { return instrumenter_js_1.useInstrumenter; } });
		var tracingClient_js_1 = requireTracingClient();
		Object.defineProperty(exports$1, "createTracingClient", { enumerable: true, get: function () { return tracingClient_js_1.createTracingClient; } });
		
	} (commonjs$6));
	return commonjs$6;
}

var hasRequiredTracing;

function requireTracing () {
	if (hasRequiredTracing) return tracing;
	hasRequiredTracing = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(tracing, "__esModule", { value: true });
	tracing.tracingClient = void 0;
	const constants_js_1 = requireConstants$3();
	const core_tracing_1 = /*@__PURE__*/ requireCommonjs$7();
	/**
	 * Creates a span using the global tracer.
	 * @internal
	 */
	tracing.tracingClient = (0, core_tracing_1.createTracingClient)({
	    namespace: "Microsoft.AAD",
	    packageName: "@azure/identity",
	    packageVersion: constants_js_1.SDK_VERSION,
	});
	
	return tracing;
}

var hasRequiredChainedTokenCredential;

function requireChainedTokenCredential () {
	if (hasRequiredChainedTokenCredential) return chainedTokenCredential;
	hasRequiredChainedTokenCredential = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.ChainedTokenCredential = exports$1.logger = void 0;
		const errors_js_1 = requireErrors$2();
		const logging_js_1 = requireLogging();
		const tracing_js_1 = requireTracing();
		/**
		 * @internal
		 */
		exports$1.logger = (0, logging_js_1.credentialLogger)("ChainedTokenCredential");
		/**
		 * Enables multiple `TokenCredential` implementations to be tried in order until
		 * one of the getToken methods returns an access token. For more information, see
		 * [ChainedTokenCredential overview](https://aka.ms/azsdk/js/identity/credential-chains#use-chainedtokencredential-for-granularity).
		 */
		class ChainedTokenCredential {
		    _sources = [];
		    /**
		     * Creates an instance of ChainedTokenCredential using the given credentials.
		     *
		     * @param sources - `TokenCredential` implementations to be tried in order.
		     *
		     * Example usage:
		     * ```ts snippet:chained_token_credential_example
		     * import { ClientSecretCredential, ChainedTokenCredential } from "@azure/identity";
		     *
		     * const tenantId = "<tenant-id>";
		     * const clientId = "<client-id>";
		     * const clientSecret = "<client-secret>";
		     * const anotherClientId = "<another-client-id>";
		     * const anotherSecret = "<another-client-secret>";
		     *
		     * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
		     * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);
		     *
		     * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);
		     * ```
		     */
		    constructor(...sources) {
		        this._sources = sources;
		    }
		    /**
		     * Returns the first access token returned by one of the chained
		     * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}
		     * when one or more credentials throws an {@link AuthenticationError} and
		     * no credentials have returned an access token.
		     *
		     * This method is called automatically by Azure SDK client libraries. You may call this method
		     * directly, but you must also handle token caching and token refreshing.
		     *
		     * @param scopes - The list of scopes for which the token will have access.
		     * @param options - The options used to configure any requests this
		     *                `TokenCredential` implementation might make.
		     */
		    async getToken(scopes, options = {}) {
		        const { token } = await this.getTokenInternal(scopes, options);
		        return token;
		    }
		    async getTokenInternal(scopes, options = {}) {
		        let token = null;
		        let successfulCredential;
		        const errors = [];
		        return tracing_js_1.tracingClient.withSpan("ChainedTokenCredential.getToken", options, async (updatedOptions) => {
		            for (let i = 0; i < this._sources.length && token === null; i++) {
		                try {
		                    token = await this._sources[i].getToken(scopes, updatedOptions);
		                    successfulCredential = this._sources[i];
		                }
		                catch (err) {
		                    if (err.name === "CredentialUnavailableError" ||
		                        err.name === "AuthenticationRequiredError") {
		                        errors.push(err);
		                    }
		                    else {
		                        exports$1.logger.getToken.info((0, logging_js_1.formatError)(scopes, err));
		                        throw err;
		                    }
		                }
		            }
		            if (!token && errors.length > 0) {
		                const err = new errors_js_1.AggregateAuthenticationError(errors, "ChainedTokenCredential authentication failed.");
		                exports$1.logger.getToken.info((0, logging_js_1.formatError)(scopes, err));
		                throw err;
		            }
		            exports$1.logger.getToken.info(`Result for ${successfulCredential.constructor.name}: ${(0, logging_js_1.formatSuccess)(scopes)}`);
		            if (token === null) {
		                throw new errors_js_1.CredentialUnavailableError("Failed to retrieve a valid token");
		            }
		            return { token, successfulCredential };
		        });
		    }
		}
		exports$1.ChainedTokenCredential = ChainedTokenCredential;
		
	} (chainedTokenCredential));
	return chainedTokenCredential;
}

var defaultAzureCredentialFunctions = {};

var environmentCredential = {};

var clientCertificateCredential = {};

var msalClient = {};

var msalNode = {};

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto$1.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

function validate(uuid) {
  return typeof uuid === 'string' && REGEX.test(uuid);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!validate(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || stringify(b);
}

function parse(uuid) {
  if (!validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL$1 = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35 (name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = parse(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return stringify(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL$1;
  return generateUUID;
}

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return crypto$1.createHash('md5').update(bytes).digest();
}

const v3 = v35('v3', 0x30, md5);

function v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return stringify(rnds);
}

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return crypto$1.createHash('sha1').update(bytes).digest();
}

const v5 = v35('v5', 0x50, sha1);

var nil = '00000000-0000-0000-0000-000000000000';

function version$1(uuid) {
  if (!validate(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var esmNode = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NIL: nil,
  parse: parse,
  stringify: stringify,
  v1: v1,
  v3: v3,
  v4: v4,
  v5: v5,
  validate: validate,
  version: version$1
});

var require$$2$1 = /*@__PURE__*/getAugmentedNamespace(esmNode);

var lib$1 = {};

var indexNode4Jss3kYh = {};

/*! @azure/msal-common v15.13.3 2025-12-04 */

var hasRequiredIndexNode4Jss3kYh;

function requireIndexNode4Jss3kYh () {
	if (hasRequiredIndexNode4Jss3kYh) return indexNode4Jss3kYh;
	hasRequiredIndexNode4Jss3kYh = 1;
	(function (exports$1) {

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const Constants = {
		    LIBRARY_NAME: "MSAL.JS",
		    SKU: "msal.js.common",
		    // default authority
		    DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
		    DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
		    DEFAULT_COMMON_TENANT: "common",
		    // ADFS String
		    ADFS: "adfs",
		    DSTS: "dstsv2",
		    // Default AAD Instance Discovery Endpoint
		    AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
		    // CIAM URL
		    CIAM_AUTH_URL: ".ciamlogin.com",
		    AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
		    // Resource delimiter - used for certain cache entries
		    RESOURCE_DELIM: "|",
		    // Placeholder for non-existent account ids/objects
		    NO_ACCOUNT: "NO_ACCOUNT",
		    // Claims
		    CLAIMS: "claims",
		    // Consumer UTID
		    CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
		    // Default scopes
		    OPENID_SCOPE: "openid",
		    PROFILE_SCOPE: "profile",
		    OFFLINE_ACCESS_SCOPE: "offline_access",
		    EMAIL_SCOPE: "email",
		    CODE_GRANT_TYPE: "authorization_code",
		    RT_GRANT_TYPE: "refresh_token",
		    S256_CODE_CHALLENGE_METHOD: "S256",
		    URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
		    AUTHORIZATION_PENDING: "authorization_pending",
		    NOT_DEFINED: "not_defined",
		    EMPTY_STRING: "",
		    NOT_APPLICABLE: "N/A",
		    NOT_AVAILABLE: "Not Available",
		    FORWARD_SLASH: "/",
		    IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
		    IMDS_VERSION: "2020-06-01",
		    IMDS_TIMEOUT: 2000,
		    AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
		    REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
		    KNOWN_PUBLIC_CLOUDS: [
		        "login.microsoftonline.com",
		        "login.windows.net",
		        "login.microsoft.com",
		        "sts.windows.net",
		    ],
		    SHR_NONCE_VALIDITY: 240,
		    INVALID_INSTANCE: "invalid_instance",
		};
		const HttpStatus = {
		    SUCCESS: 200,
		    SUCCESS_RANGE_START: 200,
		    SUCCESS_RANGE_END: 299,
		    REDIRECT: 302,
		    CLIENT_ERROR: 400,
		    CLIENT_ERROR_RANGE_START: 400,
		    BAD_REQUEST: 400,
		    UNAUTHORIZED: 401,
		    NOT_FOUND: 404,
		    REQUEST_TIMEOUT: 408,
		    GONE: 410,
		    TOO_MANY_REQUESTS: 429,
		    CLIENT_ERROR_RANGE_END: 499,
		    SERVER_ERROR: 500,
		    SERVER_ERROR_RANGE_START: 500,
		    SERVICE_UNAVAILABLE: 503,
		    GATEWAY_TIMEOUT: 504,
		    SERVER_ERROR_RANGE_END: 599,
		    MULTI_SIDED_ERROR: 600,
		};
		const HttpMethod = {
		    GET: "GET",
		    POST: "POST",
		};
		const OIDC_DEFAULT_SCOPES = [
		    Constants.OPENID_SCOPE,
		    Constants.PROFILE_SCOPE,
		    Constants.OFFLINE_ACCESS_SCOPE,
		];
		const OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants.EMAIL_SCOPE];
		/**
		 * Request header names
		 */
		const HeaderNames = {
		    CONTENT_TYPE: "Content-Type",
		    CONTENT_LENGTH: "Content-Length",
		    RETRY_AFTER: "Retry-After",
		    CCS_HEADER: "X-AnchorMailbox",
		    WWWAuthenticate: "WWW-Authenticate",
		    AuthenticationInfo: "Authentication-Info",
		    X_MS_REQUEST_ID: "x-ms-request-id",
		    X_MS_HTTP_VERSION: "x-ms-httpver",
		};
		/**
		 * Persistent cache keys MSAL which stay while user is logged in.
		 */
		const PersistentCacheKeys = {
		    ACTIVE_ACCOUNT_FILTERS: "active-account-filters", // new cache entry for active_account for a more robust version for browser
		};
		/**
		 * String constants related to AAD Authority
		 */
		const AADAuthorityConstants = {
		    COMMON: "common",
		    ORGANIZATIONS: "organizations",
		    CONSUMERS: "consumers",
		};
		/**
		 * Claims request keys
		 */
		const ClaimsRequestKeys = {
		    ACCESS_TOKEN: "access_token",
		    XMS_CC: "xms_cc",
		};
		/**
		 * we considered making this "enum" in the request instead of string, however it looks like the allowed list of
		 * prompt values kept changing over past couple of years. There are some undocumented prompt values for some
		 * internal partners too, hence the choice of generic "string" type instead of the "enum"
		 */
		const PromptValue = {
		    LOGIN: "login",
		    SELECT_ACCOUNT: "select_account",
		    CONSENT: "consent",
		    NONE: "none",
		    CREATE: "create",
		    NO_SESSION: "no_session",
		};
		/**
		 * allowed values for codeVerifier
		 */
		const CodeChallengeMethodValues = {
		    PLAIN: "plain",
		    S256: "S256",
		};
		/**
		 * Allowed values for response_type
		 */
		const OAuthResponseType = {
		    CODE: "code",
		    IDTOKEN_TOKEN: "id_token token",
		    IDTOKEN_TOKEN_REFRESHTOKEN: "id_token token refresh_token",
		};
		/**
		 * allowed values for server response type
		 * @deprecated Use ResponseMode instead
		 */
		const ServerResponseType = {
		    QUERY: "query",
		    FRAGMENT: "fragment",
		};
		/**
		 * allowed values for response_mode
		 */
		const ResponseMode = {
		    QUERY: "query",
		    FRAGMENT: "fragment",
		    FORM_POST: "form_post",
		};
		/**
		 * allowed grant_type
		 */
		const GrantType = {
		    IMPLICIT_GRANT: "implicit",
		    AUTHORIZATION_CODE_GRANT: "authorization_code",
		    CLIENT_CREDENTIALS_GRANT: "client_credentials",
		    RESOURCE_OWNER_PASSWORD_GRANT: "password",
		    REFRESH_TOKEN_GRANT: "refresh_token",
		    DEVICE_CODE_GRANT: "device_code",
		    JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer",
		};
		/**
		 * Account types in Cache
		 */
		const CacheAccountType = {
		    MSSTS_ACCOUNT_TYPE: "MSSTS",
		    ADFS_ACCOUNT_TYPE: "ADFS",
		    MSAV1_ACCOUNT_TYPE: "MSA",
		    GENERIC_ACCOUNT_TYPE: "Generic", // NTLM, Kerberos, FBA, Basic etc
		};
		/**
		 * Separators used in cache
		 */
		const Separators = {
		    CACHE_KEY_SEPARATOR: "-",
		    CLIENT_INFO_SEPARATOR: ".",
		};
		/**
		 * Credential Type stored in the cache
		 */
		const CredentialType = {
		    ID_TOKEN: "IdToken",
		    ACCESS_TOKEN: "AccessToken",
		    ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme",
		    REFRESH_TOKEN: "RefreshToken",
		};
		/**
		 * Combine all cache types
		 */
		const CacheType = {
		    ADFS: 1001,
		    MSA: 1002,
		    MSSTS: 1003,
		    GENERIC: 1004,
		    ACCESS_TOKEN: 2001,
		    REFRESH_TOKEN: 2002,
		    ID_TOKEN: 2003,
		    APP_METADATA: 3001,
		    UNDEFINED: 9999,
		};
		/**
		 * More Cache related constants
		 */
		const APP_METADATA = "appmetadata";
		const CLIENT_INFO$1 = "client_info";
		const THE_FAMILY_ID = "1";
		const AUTHORITY_METADATA_CONSTANTS = {
		    CACHE_KEY: "authority-metadata",
		    REFRESH_TIME_SECONDS: 3600 * 24, // 24 Hours
		};
		const AuthorityMetadataSource = {
		    CONFIG: "config",
		    CACHE: "cache",
		    NETWORK: "network",
		    HARDCODED_VALUES: "hardcoded_values",
		};
		const SERVER_TELEM_CONSTANTS = {
		    SCHEMA_VERSION: 5,
		    MAX_LAST_HEADER_BYTES: 330,
		    MAX_CACHED_ERRORS: 50,
		    CACHE_KEY: "server-telemetry",
		    CATEGORY_SEPARATOR: "|",
		    VALUE_SEPARATOR: ",",
		    OVERFLOW_TRUE: "1",
		    OVERFLOW_FALSE: "0",
		    UNKNOWN_ERROR: "unknown_error",
		};
		/**
		 * Type of the authentication request
		 */
		const AuthenticationScheme = {
		    BEARER: "Bearer",
		    POP: "pop",
		    SSH: "ssh-cert",
		};
		/**
		 * Constants related to throttling
		 */
		const ThrottlingConstants = {
		    // Default time to throttle RequestThumbprint in seconds
		    DEFAULT_THROTTLE_TIME_SECONDS: 60,
		    // Default maximum time to throttle in seconds, overrides what the server sends back
		    DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
		    // Prefix for storing throttling entries
		    THROTTLING_PREFIX: "throttling",
		    // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
		    X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429",
		};
		const Errors = {
		    INVALID_GRANT_ERROR: "invalid_grant",
		    CLIENT_MISMATCH_ERROR: "client_mismatch",
		};
		/**
		 * Password grant parameters
		 */
		const PasswordGrantConstants = {
		    username: "username",
		    password: "password",
		};
		/**
		 * Region Discovery Sources
		 */
		const RegionDiscoverySources = {
		    FAILED_AUTO_DETECTION: "1",
		    INTERNAL_CACHE: "2",
		    ENVIRONMENT_VARIABLE: "3",
		    IMDS: "4",
		};
		/**
		 * Region Discovery Outcomes
		 */
		const RegionDiscoveryOutcomes = {
		    CONFIGURED_NO_AUTO_DETECTION: "2",
		    AUTO_DETECTION_REQUESTED_SUCCESSFUL: "4",
		    AUTO_DETECTION_REQUESTED_FAILED: "5",
		};
		/**
		 * Specifies the reason for fetching the access token from the identity provider
		 */
		const CacheOutcome = {
		    // When a token is found in the cache or the cache is not supposed to be hit when making the request
		    NOT_APPLICABLE: "0",
		    // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested
		    FORCE_REFRESH_OR_CLAIMS: "1",
		    // When the token request goes to the identity provider because no cached access token exists
		    NO_CACHED_ACCESS_TOKEN: "2",
		    // When the token request goes to the identity provider because cached access token expired
		    CACHED_ACCESS_TOKEN_EXPIRED: "3",
		    // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed
		    PROACTIVELY_REFRESHED: "4",
		};
		const JsonWebTokenTypes = {
		    Jwt: "JWT",
		    Jwk: "JWK",
		    Pop: "pop",
		};
		const ONE_DAY_IN_MS = 86400000;
		// Token renewal offset default in seconds
		const DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
		const EncodingTypes = {
		    BASE64: "base64",
		    HEX: "hex",
		    UTF8: "utf-8",
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * AuthErrorMessage class containing string constants used by error codes and messages.
		 */
		const unexpectedError = "unexpected_error";
		const postRequestFailed = "post_request_failed";

		var AuthErrorCodes = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    postRequestFailed: postRequestFailed,
		    unexpectedError: unexpectedError
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const AuthErrorMessages = {
		    [unexpectedError]: "Unexpected error in authentication.",
		    [postRequestFailed]: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details.",
		};
		/**
		 * AuthErrorMessage class containing string constants used by error codes and messages.
		 * @deprecated Use AuthErrorCodes instead
		 */
		const AuthErrorMessage = {
		    unexpectedError: {
		        code: unexpectedError,
		        desc: AuthErrorMessages[unexpectedError],
		    },
		    postRequestFailed: {
		        code: postRequestFailed,
		        desc: AuthErrorMessages[postRequestFailed],
		    },
		};
		/**
		 * General error class thrown by the MSAL.js library.
		 */
		class AuthError extends Error {
		    constructor(errorCode, errorMessage, suberror) {
		        const errorString = errorMessage
		            ? `${errorCode}: ${errorMessage}`
		            : errorCode;
		        super(errorString);
		        Object.setPrototypeOf(this, AuthError.prototype);
		        this.errorCode = errorCode || Constants.EMPTY_STRING;
		        this.errorMessage = errorMessage || Constants.EMPTY_STRING;
		        this.subError = suberror || Constants.EMPTY_STRING;
		        this.name = "AuthError";
		    }
		    setCorrelationId(correlationId) {
		        this.correlationId = correlationId;
		    }
		}
		function createAuthError(code, additionalMessage) {
		    return new AuthError(code, additionalMessage
		        ? `${AuthErrorMessages[code]} ${additionalMessage}`
		        : AuthErrorMessages[code]);
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const clientInfoDecodingError = "client_info_decoding_error";
		const clientInfoEmptyError = "client_info_empty_error";
		const tokenParsingError = "token_parsing_error";
		const nullOrEmptyToken = "null_or_empty_token";
		const endpointResolutionError = "endpoints_resolution_error";
		const networkError = "network_error";
		const openIdConfigError = "openid_config_error";
		const hashNotDeserialized = "hash_not_deserialized";
		const invalidState = "invalid_state";
		const stateMismatch = "state_mismatch";
		const stateNotFound = "state_not_found";
		const nonceMismatch = "nonce_mismatch";
		const authTimeNotFound = "auth_time_not_found";
		const maxAgeTranspired = "max_age_transpired";
		const multipleMatchingTokens = "multiple_matching_tokens";
		const multipleMatchingAccounts = "multiple_matching_accounts";
		const multipleMatchingAppMetadata = "multiple_matching_appMetadata";
		const requestCannotBeMade = "request_cannot_be_made";
		const cannotRemoveEmptyScope = "cannot_remove_empty_scope";
		const cannotAppendScopeSet = "cannot_append_scopeset";
		const emptyInputScopeSet = "empty_input_scopeset";
		const deviceCodePollingCancelled = "device_code_polling_cancelled";
		const deviceCodeExpired = "device_code_expired";
		const deviceCodeUnknownError = "device_code_unknown_error";
		const noAccountInSilentRequest = "no_account_in_silent_request";
		const invalidCacheRecord = "invalid_cache_record";
		const invalidCacheEnvironment = "invalid_cache_environment";
		const noAccountFound = "no_account_found";
		const noCryptoObject = "no_crypto_object";
		const unexpectedCredentialType = "unexpected_credential_type";
		const invalidAssertion = "invalid_assertion";
		const invalidClientCredential = "invalid_client_credential";
		const tokenRefreshRequired = "token_refresh_required";
		const userTimeoutReached = "user_timeout_reached";
		const tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";
		const authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";
		const bindingKeyNotRemoved = "binding_key_not_removed";
		const endSessionEndpointNotSupported = "end_session_endpoint_not_supported";
		const keyIdMissing = "key_id_missing";
		const noNetworkConnectivity = "no_network_connectivity";
		const userCanceled = "user_canceled";
		const missingTenantIdError = "missing_tenant_id_error";
		const methodNotImplemented = "method_not_implemented";
		const nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";
		const platformBrokerError = "platform_broker_error";

		var ClientAuthErrorCodes = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    authTimeNotFound: authTimeNotFound,
		    authorizationCodeMissingFromServerResponse: authorizationCodeMissingFromServerResponse,
		    bindingKeyNotRemoved: bindingKeyNotRemoved,
		    cannotAppendScopeSet: cannotAppendScopeSet,
		    cannotRemoveEmptyScope: cannotRemoveEmptyScope,
		    clientInfoDecodingError: clientInfoDecodingError,
		    clientInfoEmptyError: clientInfoEmptyError,
		    deviceCodeExpired: deviceCodeExpired,
		    deviceCodePollingCancelled: deviceCodePollingCancelled,
		    deviceCodeUnknownError: deviceCodeUnknownError,
		    emptyInputScopeSet: emptyInputScopeSet,
		    endSessionEndpointNotSupported: endSessionEndpointNotSupported,
		    endpointResolutionError: endpointResolutionError,
		    hashNotDeserialized: hashNotDeserialized,
		    invalidAssertion: invalidAssertion,
		    invalidCacheEnvironment: invalidCacheEnvironment,
		    invalidCacheRecord: invalidCacheRecord,
		    invalidClientCredential: invalidClientCredential,
		    invalidState: invalidState,
		    keyIdMissing: keyIdMissing,
		    maxAgeTranspired: maxAgeTranspired,
		    methodNotImplemented: methodNotImplemented,
		    missingTenantIdError: missingTenantIdError,
		    multipleMatchingAccounts: multipleMatchingAccounts,
		    multipleMatchingAppMetadata: multipleMatchingAppMetadata,
		    multipleMatchingTokens: multipleMatchingTokens,
		    nestedAppAuthBridgeDisabled: nestedAppAuthBridgeDisabled,
		    networkError: networkError,
		    noAccountFound: noAccountFound,
		    noAccountInSilentRequest: noAccountInSilentRequest,
		    noCryptoObject: noCryptoObject,
		    noNetworkConnectivity: noNetworkConnectivity,
		    nonceMismatch: nonceMismatch,
		    nullOrEmptyToken: nullOrEmptyToken,
		    openIdConfigError: openIdConfigError,
		    platformBrokerError: platformBrokerError,
		    requestCannotBeMade: requestCannotBeMade,
		    stateMismatch: stateMismatch,
		    stateNotFound: stateNotFound,
		    tokenClaimsCnfRequiredForSignedJwt: tokenClaimsCnfRequiredForSignedJwt,
		    tokenParsingError: tokenParsingError,
		    tokenRefreshRequired: tokenRefreshRequired,
		    unexpectedCredentialType: unexpectedCredentialType,
		    userCanceled: userCanceled,
		    userTimeoutReached: userTimeoutReached
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * ClientAuthErrorMessage class containing string constants used by error codes and messages.
		 */
		const ClientAuthErrorMessages = {
		    [clientInfoDecodingError]: "The client info could not be parsed/decoded correctly",
		    [clientInfoEmptyError]: "The client info was empty",
		    [tokenParsingError]: "Token cannot be parsed",
		    [nullOrEmptyToken]: "The token is null or empty",
		    [endpointResolutionError]: "Endpoints cannot be resolved",
		    [networkError]: "Network request failed",
		    [openIdConfigError]: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.",
		    [hashNotDeserialized]: "The hash parameters could not be deserialized",
		    [invalidState]: "State was not the expected format",
		    [stateMismatch]: "State mismatch error",
		    [stateNotFound]: "State not found",
		    [nonceMismatch]: "Nonce mismatch error",
		    [authTimeNotFound]: "Max Age was requested and the ID token is missing the auth_time variable." +
		        " auth_time is an optional claim and is not enabled by default - it must be enabled." +
		        " See https://aka.ms/msaljs/optional-claims for more information.",
		    [maxAgeTranspired]: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication.",
		    [multipleMatchingTokens]: "The cache contains multiple tokens satisfying the requirements. " +
		        "Call AcquireToken again providing more requirements such as authority or account.",
		    [multipleMatchingAccounts]: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account",
		    [multipleMatchingAppMetadata]: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata",
		    [requestCannotBeMade]: "Token request cannot be made without authorization code or refresh token.",
		    [cannotRemoveEmptyScope]: "Cannot remove null or empty scope from ScopeSet",
		    [cannotAppendScopeSet]: "Cannot append ScopeSet",
		    [emptyInputScopeSet]: "Empty input ScopeSet cannot be processed",
		    [deviceCodePollingCancelled]: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.",
		    [deviceCodeExpired]: "Device code is expired.",
		    [deviceCodeUnknownError]: "Device code stopped polling for unknown reasons.",
		    [noAccountInSilentRequest]: "Please pass an account object, silent flow is not supported without account information",
		    [invalidCacheRecord]: "Cache record object was null or undefined.",
		    [invalidCacheEnvironment]: "Invalid environment when attempting to create cache entry",
		    [noAccountFound]: "No account found in cache for given key.",
		    [noCryptoObject]: "No crypto object detected.",
		    [unexpectedCredentialType]: "Unexpected credential type.",
		    [invalidAssertion]: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515",
		    [invalidClientCredential]: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential",
		    [tokenRefreshRequired]: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.",
		    [userTimeoutReached]: "User defined timeout for device code polling reached",
		    [tokenClaimsCnfRequiredForSignedJwt]: "Cannot generate a POP jwt if the token_claims are not populated",
		    [authorizationCodeMissingFromServerResponse]: "Server response does not contain an authorization code to proceed",
		    [bindingKeyNotRemoved]: "Could not remove the credential's binding key from storage.",
		    [endSessionEndpointNotSupported]: "The provided authority does not support logout",
		    [keyIdMissing]: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.",
		    [noNetworkConnectivity]: "No network connectivity. Check your internet connection.",
		    [userCanceled]: "User cancelled the flow.",
		    [missingTenantIdError]: "A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.",
		    [methodNotImplemented]: "This method has not been implemented",
		    [nestedAppAuthBridgeDisabled]: "The nested app auth bridge is disabled",
		    [platformBrokerError]: "An error occurred in the native broker. See the platformBrokerError property for details.",
		};
		/**
		 * String constants used by error codes and messages.
		 * @deprecated Use ClientAuthErrorCodes instead
		 */
		const ClientAuthErrorMessage = {
		    clientInfoDecodingError: {
		        code: clientInfoDecodingError,
		        desc: ClientAuthErrorMessages[clientInfoDecodingError],
		    },
		    clientInfoEmptyError: {
		        code: clientInfoEmptyError,
		        desc: ClientAuthErrorMessages[clientInfoEmptyError],
		    },
		    tokenParsingError: {
		        code: tokenParsingError,
		        desc: ClientAuthErrorMessages[tokenParsingError],
		    },
		    nullOrEmptyToken: {
		        code: nullOrEmptyToken,
		        desc: ClientAuthErrorMessages[nullOrEmptyToken],
		    },
		    endpointResolutionError: {
		        code: endpointResolutionError,
		        desc: ClientAuthErrorMessages[endpointResolutionError],
		    },
		    networkError: {
		        code: networkError,
		        desc: ClientAuthErrorMessages[networkError],
		    },
		    unableToGetOpenidConfigError: {
		        code: openIdConfigError,
		        desc: ClientAuthErrorMessages[openIdConfigError],
		    },
		    hashNotDeserialized: {
		        code: hashNotDeserialized,
		        desc: ClientAuthErrorMessages[hashNotDeserialized],
		    },
		    invalidStateError: {
		        code: invalidState,
		        desc: ClientAuthErrorMessages[invalidState],
		    },
		    stateMismatchError: {
		        code: stateMismatch,
		        desc: ClientAuthErrorMessages[stateMismatch],
		    },
		    stateNotFoundError: {
		        code: stateNotFound,
		        desc: ClientAuthErrorMessages[stateNotFound],
		    },
		    nonceMismatchError: {
		        code: nonceMismatch,
		        desc: ClientAuthErrorMessages[nonceMismatch],
		    },
		    authTimeNotFoundError: {
		        code: authTimeNotFound,
		        desc: ClientAuthErrorMessages[authTimeNotFound],
		    },
		    maxAgeTranspired: {
		        code: maxAgeTranspired,
		        desc: ClientAuthErrorMessages[maxAgeTranspired],
		    },
		    multipleMatchingTokens: {
		        code: multipleMatchingTokens,
		        desc: ClientAuthErrorMessages[multipleMatchingTokens],
		    },
		    multipleMatchingAccounts: {
		        code: multipleMatchingAccounts,
		        desc: ClientAuthErrorMessages[multipleMatchingAccounts],
		    },
		    multipleMatchingAppMetadata: {
		        code: multipleMatchingAppMetadata,
		        desc: ClientAuthErrorMessages[multipleMatchingAppMetadata],
		    },
		    tokenRequestCannotBeMade: {
		        code: requestCannotBeMade,
		        desc: ClientAuthErrorMessages[requestCannotBeMade],
		    },
		    removeEmptyScopeError: {
		        code: cannotRemoveEmptyScope,
		        desc: ClientAuthErrorMessages[cannotRemoveEmptyScope],
		    },
		    appendScopeSetError: {
		        code: cannotAppendScopeSet,
		        desc: ClientAuthErrorMessages[cannotAppendScopeSet],
		    },
		    emptyInputScopeSetError: {
		        code: emptyInputScopeSet,
		        desc: ClientAuthErrorMessages[emptyInputScopeSet],
		    },
		    DeviceCodePollingCancelled: {
		        code: deviceCodePollingCancelled,
		        desc: ClientAuthErrorMessages[deviceCodePollingCancelled],
		    },
		    DeviceCodeExpired: {
		        code: deviceCodeExpired,
		        desc: ClientAuthErrorMessages[deviceCodeExpired],
		    },
		    DeviceCodeUnknownError: {
		        code: deviceCodeUnknownError,
		        desc: ClientAuthErrorMessages[deviceCodeUnknownError],
		    },
		    NoAccountInSilentRequest: {
		        code: noAccountInSilentRequest,
		        desc: ClientAuthErrorMessages[noAccountInSilentRequest],
		    },
		    invalidCacheRecord: {
		        code: invalidCacheRecord,
		        desc: ClientAuthErrorMessages[invalidCacheRecord],
		    },
		    invalidCacheEnvironment: {
		        code: invalidCacheEnvironment,
		        desc: ClientAuthErrorMessages[invalidCacheEnvironment],
		    },
		    noAccountFound: {
		        code: noAccountFound,
		        desc: ClientAuthErrorMessages[noAccountFound],
		    },
		    noCryptoObj: {
		        code: noCryptoObject,
		        desc: ClientAuthErrorMessages[noCryptoObject],
		    },
		    unexpectedCredentialType: {
		        code: unexpectedCredentialType,
		        desc: ClientAuthErrorMessages[unexpectedCredentialType],
		    },
		    invalidAssertion: {
		        code: invalidAssertion,
		        desc: ClientAuthErrorMessages[invalidAssertion],
		    },
		    invalidClientCredential: {
		        code: invalidClientCredential,
		        desc: ClientAuthErrorMessages[invalidClientCredential],
		    },
		    tokenRefreshRequired: {
		        code: tokenRefreshRequired,
		        desc: ClientAuthErrorMessages[tokenRefreshRequired],
		    },
		    userTimeoutReached: {
		        code: userTimeoutReached,
		        desc: ClientAuthErrorMessages[userTimeoutReached],
		    },
		    tokenClaimsRequired: {
		        code: tokenClaimsCnfRequiredForSignedJwt,
		        desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt],
		    },
		    noAuthorizationCodeFromServer: {
		        code: authorizationCodeMissingFromServerResponse,
		        desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse],
		    },
		    bindingKeyNotRemovedError: {
		        code: bindingKeyNotRemoved,
		        desc: ClientAuthErrorMessages[bindingKeyNotRemoved],
		    },
		    logoutNotSupported: {
		        code: endSessionEndpointNotSupported,
		        desc: ClientAuthErrorMessages[endSessionEndpointNotSupported],
		    },
		    keyIdMissing: {
		        code: keyIdMissing,
		        desc: ClientAuthErrorMessages[keyIdMissing],
		    },
		    noNetworkConnectivity: {
		        code: noNetworkConnectivity,
		        desc: ClientAuthErrorMessages[noNetworkConnectivity],
		    },
		    userCanceledError: {
		        code: userCanceled,
		        desc: ClientAuthErrorMessages[userCanceled],
		    },
		    missingTenantIdError: {
		        code: missingTenantIdError,
		        desc: ClientAuthErrorMessages[missingTenantIdError],
		    },
		    nestedAppAuthBridgeDisabled: {
		        code: nestedAppAuthBridgeDisabled,
		        desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled],
		    },
		    platformBrokerError: {
		        code: platformBrokerError,
		        desc: ClientAuthErrorMessages[platformBrokerError],
		    },
		};
		/**
		 * Error thrown when there is an error in the client code running on the browser.
		 */
		class ClientAuthError extends AuthError {
		    constructor(errorCode, additionalMessage) {
		        super(errorCode, additionalMessage
		            ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}`
		            : ClientAuthErrorMessages[errorCode]);
		        this.name = "ClientAuthError";
		        Object.setPrototypeOf(this, ClientAuthError.prototype);
		    }
		}
		function createClientAuthError(errorCode, additionalMessage) {
		    return new ClientAuthError(errorCode, additionalMessage);
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Extract token by decoding the rawToken
		 *
		 * @param encodedToken
		 */
		function extractTokenClaims(encodedToken, base64Decode) {
		    const jswPayload = getJWSPayload(encodedToken);
		    // token will be decoded to get the username
		    try {
		        // base64Decode() should throw an error if there is an issue
		        const base64Decoded = base64Decode(jswPayload);
		        return JSON.parse(base64Decoded);
		    }
		    catch (err) {
		        throw createClientAuthError(tokenParsingError);
		    }
		}
		/**
		 * Check if the signin_state claim contains "kmsi"
		 * @param idTokenClaims
		 * @returns
		 */
		function isKmsi(idTokenClaims) {
		    if (!idTokenClaims.signin_state) {
		        return false;
		    }
		    /**
		     * Signin_state claim known values:
		     * dvc_mngd - device is managed
		     * dvc_dmjd - device is domain joined
		     * kmsi - user opted to "keep me signed in"
		     * inknownntwk - Request made inside a known network. Don't use this, use CAE instead.
		     */
		    const kmsiClaims = ["kmsi", "dvc_dmjd"]; // There are some cases where kmsi may not be returned but persistent storage is still OK - allow dvc_dmjd as well
		    const kmsi = idTokenClaims.signin_state.some((value) => kmsiClaims.includes(value.trim().toLowerCase()));
		    return kmsi;
		}
		/**
		 * decode a JWT
		 *
		 * @param authToken
		 */
		function getJWSPayload(authToken) {
		    if (!authToken) {
		        throw createClientAuthError(nullOrEmptyToken);
		    }
		    const tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
		    const matches = tokenPartsRegex.exec(authToken);
		    if (!matches || matches.length < 4) {
		        throw createClientAuthError(tokenParsingError);
		    }
		    /**
		     * const crackedToken = {
		     *  header: matches[1],
		     *  JWSPayload: matches[2],
		     *  JWSSig: matches[3],
		     * };
		     */
		    return matches[2];
		}
		/**
		 * Determine if the token's max_age has transpired
		 */
		function checkMaxAge(authTime, maxAge) {
		    /*
		     * per https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
		     * To force an immediate re-authentication: If an app requires that a user re-authenticate prior to access,
		     * provide a value of 0 for the max_age parameter and the AS will force a fresh login.
		     */
		    const fiveMinuteSkew = 300000; // five minutes in milliseconds
		    if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
		        throw createClientAuthError(maxAgeTranspired);
		    }
		}

		var AuthToken = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    checkMaxAge: checkMaxAge,
		    extractTokenClaims: extractTokenClaims,
		    getJWSPayload: getJWSPayload,
		    isKmsi: isKmsi
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Authority types supported by MSAL.
		 */
		const AuthorityType = {
		    Default: 0,
		    Adfs: 1,
		    Dsts: 2,
		    Ciam: 3,
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function isOpenIdConfigResponse(response) {
		    return (response.hasOwnProperty("authorization_endpoint") &&
		        response.hasOwnProperty("token_endpoint") &&
		        response.hasOwnProperty("issuer") &&
		        response.hasOwnProperty("jwks_uri"));
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const redirectUriEmpty = "redirect_uri_empty";
		const claimsRequestParsingError = "claims_request_parsing_error";
		const authorityUriInsecure = "authority_uri_insecure";
		const urlParseError = "url_parse_error";
		const urlEmptyError = "empty_url_error";
		const emptyInputScopesError = "empty_input_scopes_error";
		const invalidClaims = "invalid_claims";
		const tokenRequestEmpty = "token_request_empty";
		const logoutRequestEmpty = "logout_request_empty";
		const invalidCodeChallengeMethod = "invalid_code_challenge_method";
		const pkceParamsMissing = "pkce_params_missing";
		const invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";
		const invalidAuthorityMetadata = "invalid_authority_metadata";
		const untrustedAuthority = "untrusted_authority";
		const missingSshJwk = "missing_ssh_jwk";
		const missingSshKid = "missing_ssh_kid";
		const missingNonceAuthenticationHeader = "missing_nonce_authentication_header";
		const invalidAuthenticationHeader = "invalid_authentication_header";
		const cannotSetOIDCOptions = "cannot_set_OIDCOptions";
		const cannotAllowPlatformBroker = "cannot_allow_platform_broker";
		const authorityMismatch = "authority_mismatch";
		const invalidRequestMethodForEAR = "invalid_request_method_for_EAR";
		const invalidAuthorizePostBodyParameters = "invalid_authorize_post_body_parameters";
		const invalidPlatformBrokerConfiguration = "invalid_platform_broker_configuration";

		var ClientConfigurationErrorCodes = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    authorityMismatch: authorityMismatch,
		    authorityUriInsecure: authorityUriInsecure,
		    cannotAllowPlatformBroker: cannotAllowPlatformBroker,
		    cannotSetOIDCOptions: cannotSetOIDCOptions,
		    claimsRequestParsingError: claimsRequestParsingError,
		    emptyInputScopesError: emptyInputScopesError,
		    invalidAuthenticationHeader: invalidAuthenticationHeader,
		    invalidAuthorityMetadata: invalidAuthorityMetadata,
		    invalidAuthorizePostBodyParameters: invalidAuthorizePostBodyParameters,
		    invalidClaims: invalidClaims,
		    invalidCloudDiscoveryMetadata: invalidCloudDiscoveryMetadata,
		    invalidCodeChallengeMethod: invalidCodeChallengeMethod,
		    invalidPlatformBrokerConfiguration: invalidPlatformBrokerConfiguration,
		    invalidRequestMethodForEAR: invalidRequestMethodForEAR,
		    logoutRequestEmpty: logoutRequestEmpty,
		    missingNonceAuthenticationHeader: missingNonceAuthenticationHeader,
		    missingSshJwk: missingSshJwk,
		    missingSshKid: missingSshKid,
		    pkceParamsMissing: pkceParamsMissing,
		    redirectUriEmpty: redirectUriEmpty,
		    tokenRequestEmpty: tokenRequestEmpty,
		    untrustedAuthority: untrustedAuthority,
		    urlEmptyError: urlEmptyError,
		    urlParseError: urlParseError
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const ClientConfigurationErrorMessages = {
		    [redirectUriEmpty]: "A redirect URI is required for all calls, and none has been set.",
		    [claimsRequestParsingError]: "Could not parse the given claims request object.",
		    [authorityUriInsecure]: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
		    [urlParseError]: "URL could not be parsed into appropriate segments.",
		    [urlEmptyError]: "URL was empty or null.",
		    [emptyInputScopesError]: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",
		    [invalidClaims]: "Given claims parameter must be a stringified JSON object.",
		    [tokenRequestEmpty]: "Token request was empty and not found in cache.",
		    [logoutRequestEmpty]: "The logout request was null or undefined.",
		    [invalidCodeChallengeMethod]: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
		    [pkceParamsMissing]: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",
		    [invalidCloudDiscoveryMetadata]: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",
		    [invalidAuthorityMetadata]: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",
		    [untrustedAuthority]: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",
		    [missingSshJwk]: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",
		    [missingSshKid]: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",
		    [missingNonceAuthenticationHeader]: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",
		    [invalidAuthenticationHeader]: "Invalid authentication header provided",
		    [cannotSetOIDCOptions]: "Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.",
		    [cannotAllowPlatformBroker]: "Cannot set allowPlatformBroker parameter to true when not in AAD protocol mode.",
		    [authorityMismatch]: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority.",
		    [invalidAuthorizePostBodyParameters]: "Invalid authorize post body parameters provided. If you are using authorizePostBodyParameters, the request method must be POST. Please check the request method and parameters.",
		    [invalidRequestMethodForEAR]: "Invalid request method for EAR protocol mode. The request method cannot be GET when using EAR protocol mode. Please change the request method to POST.",
		    [invalidPlatformBrokerConfiguration]: "Invalid platform broker configuration. `allowPlatformBrokerWithDOM` can only be enabled when `allowPlatformBroker` is enabled.",
		};
		/**
		 * ClientConfigurationErrorMessage class containing string constants used by error codes and messages.
		 * @deprecated Use ClientConfigurationErrorCodes instead
		 */
		const ClientConfigurationErrorMessage = {
		    redirectUriNotSet: {
		        code: redirectUriEmpty,
		        desc: ClientConfigurationErrorMessages[redirectUriEmpty],
		    },
		    claimsRequestParsingError: {
		        code: claimsRequestParsingError,
		        desc: ClientConfigurationErrorMessages[claimsRequestParsingError],
		    },
		    authorityUriInsecure: {
		        code: authorityUriInsecure,
		        desc: ClientConfigurationErrorMessages[authorityUriInsecure],
		    },
		    urlParseError: {
		        code: urlParseError,
		        desc: ClientConfigurationErrorMessages[urlParseError],
		    },
		    urlEmptyError: {
		        code: urlEmptyError,
		        desc: ClientConfigurationErrorMessages[urlEmptyError],
		    },
		    emptyScopesError: {
		        code: emptyInputScopesError,
		        desc: ClientConfigurationErrorMessages[emptyInputScopesError],
		    },
		    invalidClaimsRequest: {
		        code: invalidClaims,
		        desc: ClientConfigurationErrorMessages[invalidClaims],
		    },
		    tokenRequestEmptyError: {
		        code: tokenRequestEmpty,
		        desc: ClientConfigurationErrorMessages[tokenRequestEmpty],
		    },
		    logoutRequestEmptyError: {
		        code: logoutRequestEmpty,
		        desc: ClientConfigurationErrorMessages[logoutRequestEmpty],
		    },
		    invalidCodeChallengeMethod: {
		        code: invalidCodeChallengeMethod,
		        desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod],
		    },
		    invalidCodeChallengeParams: {
		        code: pkceParamsMissing,
		        desc: ClientConfigurationErrorMessages[pkceParamsMissing],
		    },
		    invalidCloudDiscoveryMetadata: {
		        code: invalidCloudDiscoveryMetadata,
		        desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata],
		    },
		    invalidAuthorityMetadata: {
		        code: invalidAuthorityMetadata,
		        desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata],
		    },
		    untrustedAuthority: {
		        code: untrustedAuthority,
		        desc: ClientConfigurationErrorMessages[untrustedAuthority],
		    },
		    missingSshJwk: {
		        code: missingSshJwk,
		        desc: ClientConfigurationErrorMessages[missingSshJwk],
		    },
		    missingSshKid: {
		        code: missingSshKid,
		        desc: ClientConfigurationErrorMessages[missingSshKid],
		    },
		    missingNonceAuthenticationHeader: {
		        code: missingNonceAuthenticationHeader,
		        desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader],
		    },
		    invalidAuthenticationHeader: {
		        code: invalidAuthenticationHeader,
		        desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader],
		    },
		    cannotSetOIDCOptions: {
		        code: cannotSetOIDCOptions,
		        desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions],
		    },
		    cannotAllowPlatformBroker: {
		        code: cannotAllowPlatformBroker,
		        desc: ClientConfigurationErrorMessages[cannotAllowPlatformBroker],
		    },
		    authorityMismatch: {
		        code: authorityMismatch,
		        desc: ClientConfigurationErrorMessages[authorityMismatch],
		    },
		    invalidAuthorizePostBodyParameters: {
		        code: invalidAuthorizePostBodyParameters,
		        desc: ClientConfigurationErrorMessages[invalidAuthorizePostBodyParameters],
		    },
		    invalidRequestMethodForEAR: {
		        code: invalidRequestMethodForEAR,
		        desc: ClientConfigurationErrorMessages[invalidRequestMethodForEAR],
		    },
		    invalidPlatformBrokerConfiguration: {
		        code: invalidPlatformBrokerConfiguration,
		        desc: ClientConfigurationErrorMessages[invalidPlatformBrokerConfiguration],
		    },
		};
		/**
		 * Error thrown when there is an error in configuration of the MSAL.js library.
		 */
		class ClientConfigurationError extends AuthError {
		    constructor(errorCode) {
		        super(errorCode, ClientConfigurationErrorMessages[errorCode]);
		        this.name = "ClientConfigurationError";
		        Object.setPrototypeOf(this, ClientConfigurationError.prototype);
		    }
		}
		function createClientConfigurationError(errorCode) {
		    return new ClientConfigurationError(errorCode);
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * @hidden
		 */
		class StringUtils {
		    /**
		     * Check if stringified object is empty
		     * @param strObj
		     */
		    static isEmptyObj(strObj) {
		        if (strObj) {
		            try {
		                const obj = JSON.parse(strObj);
		                return Object.keys(obj).length === 0;
		            }
		            catch (e) { }
		        }
		        return true;
		    }
		    static startsWith(str, search) {
		        return str.indexOf(search) === 0;
		    }
		    static endsWith(str, search) {
		        return (str.length >= search.length &&
		            str.lastIndexOf(search) === str.length - search.length);
		    }
		    /**
		     * Parses string into an object.
		     *
		     * @param query
		     */
		    static queryStringToObject(query) {
		        const obj = {};
		        const params = query.split("&");
		        const decode = (s) => decodeURIComponent(s.replace(/\+/g, " "));
		        params.forEach((pair) => {
		            if (pair.trim()) {
		                const [key, value] = pair.split(/=(.+)/g, 2); // Split on the first occurence of the '=' character
		                if (key && value) {
		                    obj[decode(key)] = decode(value);
		                }
		            }
		        });
		        return obj;
		    }
		    /**
		     * Trims entries in an array.
		     *
		     * @param arr
		     */
		    static trimArrayEntries(arr) {
		        return arr.map((entry) => entry.trim());
		    }
		    /**
		     * Removes empty strings from array
		     * @param arr
		     */
		    static removeEmptyStringsFromArray(arr) {
		        return arr.filter((entry) => {
		            return !!entry;
		        });
		    }
		    /**
		     * Attempts to parse a string into JSON
		     * @param str
		     */
		    static jsonParseHelper(str) {
		        try {
		            return JSON.parse(str);
		        }
		        catch (e) {
		            return null;
		        }
		    }
		    /**
		     * Tests if a given string matches a given pattern, with support for wildcards and queries.
		     * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
		     * @param input String to match against
		     */
		    static matchPattern(pattern, input) {
		        /**
		         * Wildcard support: https://stackoverflow.com/a/3117248/4888559
		         * Queries: replaces "?" in string with escaped "\?" for regex test
		         */
		        // eslint-disable-next-line security/detect-non-literal-regexp
		        const regex = new RegExp(pattern
		            .replace(/\\/g, "\\\\")
		            .replace(/\*/g, "[^ ]*")
		            .replace(/\?/g, "\\?"));
		        return regex.test(input);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Canonicalizes a URL by making it lowercase and ensuring it ends with /
		 * Inlined version of UrlString.canonicalizeUri to avoid circular dependency
		 * @param url - URL to canonicalize
		 * @returns Canonicalized URL
		 */
		function canonicalizeUrl(url) {
		    if (!url) {
		        return url;
		    }
		    let lowerCaseUrl = url.toLowerCase();
		    if (StringUtils.endsWith(lowerCaseUrl, "?")) {
		        lowerCaseUrl = lowerCaseUrl.slice(0, -1);
		    }
		    else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
		        lowerCaseUrl = lowerCaseUrl.slice(0, -2);
		    }
		    if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
		        lowerCaseUrl += "/";
		    }
		    return lowerCaseUrl;
		}
		/**
		 * Parses hash string from given string. Returns empty string if no hash symbol is found.
		 * @param hashString
		 */
		function stripLeadingHashOrQuery(responseString) {
		    if (responseString.startsWith("#/")) {
		        return responseString.substring(2);
		    }
		    else if (responseString.startsWith("#") ||
		        responseString.startsWith("?")) {
		        return responseString.substring(1);
		    }
		    return responseString;
		}
		/**
		 * Returns URL hash as server auth code response object.
		 */
		function getDeserializedResponse(responseString) {
		    // Check if given hash is empty
		    if (!responseString || responseString.indexOf("=") < 0) {
		        return null;
		    }
		    try {
		        // Strip the # or ? symbol if present
		        const normalizedResponse = stripLeadingHashOrQuery(responseString);
		        // If # symbol was not present, above will return empty string, so give original hash value
		        const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));
		        // Check for known response properties
		        if (deserializedHash.code ||
		            deserializedHash.ear_jwe ||
		            deserializedHash.error ||
		            deserializedHash.error_description ||
		            deserializedHash.state) {
		            return deserializedHash;
		        }
		    }
		    catch (e) {
		        throw createClientAuthError(hashNotDeserialized);
		    }
		    return null;
		}
		/**
		 * Utility to create a URL from the params map
		 */
		function mapToQueryString(parameters, encodeExtraParams = true, extraQueryParameters) {
		    const queryParameterArray = new Array();
		    parameters.forEach((value, key) => {
		        if (!encodeExtraParams &&
		            extraQueryParameters &&
		            key in extraQueryParameters) {
		            queryParameterArray.push(`${key}=${value}`);
		        }
		        else {
		            queryParameterArray.push(`${key}=${encodeURIComponent(value)}`);
		        }
		    });
		    return queryParameterArray.join("&");
		}
		/**
		 * Normalizes URLs for comparison by removing hash, canonicalizing,
		 * and ensuring consistent URL encoding in query parameters.
		 * This fixes redirect loops when URLs contain encoded characters like apostrophes (%27).
		 * @param url - URL to normalize
		 * @returns Normalized URL string for comparison
		 */
		function normalizeUrlForComparison(url) {
		    if (!url) {
		        return url;
		    }
		    // Remove hash first
		    const urlWithoutHash = url.split("#")[0];
		    try {
		        // Parse the URL to handle encoding consistently
		        const urlObj = new URL(urlWithoutHash);
		        /*
		         * Reconstruct the URL with properly decoded query parameters
		         * This ensures that %27 and ' are treated as equivalent
		         */
		        const normalizedUrl = urlObj.origin + urlObj.pathname + urlObj.search;
		        // Apply canonicalization logic inline to avoid circular dependency
		        return canonicalizeUrl(normalizedUrl);
		    }
		    catch (e) {
		        // Fallback to original logic if URL parsing fails
		        return canonicalizeUrl(urlWithoutHash);
		    }
		}

		var UrlUtils = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    getDeserializedResponse: getDeserializedResponse,
		    mapToQueryString: mapToQueryString,
		    normalizeUrlForComparison: normalizeUrlForComparison,
		    stripLeadingHashOrQuery: stripLeadingHashOrQuery
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Url object class which can perform various transformations on url strings.
		 */
		class UrlString {
		    get urlString() {
		        return this._urlString;
		    }
		    constructor(url) {
		        this._urlString = url;
		        if (!this._urlString) {
		            // Throws error if url is empty
		            throw createClientConfigurationError(urlEmptyError);
		        }
		        if (!url.includes("#")) {
		            this._urlString = UrlString.canonicalizeUri(url);
		        }
		    }
		    /**
		     * Ensure urls are lower case and end with a / character.
		     * @param url
		     */
		    static canonicalizeUri(url) {
		        if (url) {
		            let lowerCaseUrl = url.toLowerCase();
		            if (StringUtils.endsWith(lowerCaseUrl, "?")) {
		                lowerCaseUrl = lowerCaseUrl.slice(0, -1);
		            }
		            else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
		                lowerCaseUrl = lowerCaseUrl.slice(0, -2);
		            }
		            if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
		                lowerCaseUrl += "/";
		            }
		            return lowerCaseUrl;
		        }
		        return url;
		    }
		    /**
		     * Throws if urlString passed is not a valid authority URI string.
		     */
		    validateAsUri() {
		        // Attempts to parse url for uri components
		        let components;
		        try {
		            components = this.getUrlComponents();
		        }
		        catch (e) {
		            throw createClientConfigurationError(urlParseError);
		        }
		        // Throw error if URI or path segments are not parseable.
		        if (!components.HostNameAndPort || !components.PathSegments) {
		            throw createClientConfigurationError(urlParseError);
		        }
		        // Throw error if uri is insecure.
		        if (!components.Protocol ||
		            components.Protocol.toLowerCase() !== "https:") {
		            throw createClientConfigurationError(authorityUriInsecure);
		        }
		    }
		    /**
		     * Given a url and a query string return the url with provided query string appended
		     * @param url
		     * @param queryString
		     */
		    static appendQueryString(url, queryString) {
		        if (!queryString) {
		            return url;
		        }
		        return url.indexOf("?") < 0
		            ? `${url}?${queryString}`
		            : `${url}&${queryString}`;
		    }
		    /**
		     * Returns a url with the hash removed
		     * @param url
		     */
		    static removeHashFromUrl(url) {
		        return UrlString.canonicalizeUri(url.split("#")[0]);
		    }
		    /**
		     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
		     * @param href The url
		     * @param tenantId The tenant id to replace
		     */
		    replaceTenantPath(tenantId) {
		        const urlObject = this.getUrlComponents();
		        const pathArray = urlObject.PathSegments;
		        if (tenantId &&
		            pathArray.length !== 0 &&
		            (pathArray[0] === AADAuthorityConstants.COMMON ||
		                pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {
		            pathArray[0] = tenantId;
		        }
		        return UrlString.constructAuthorityUriFromObject(urlObject);
		    }
		    /**
		     * Parses out the components from a url string.
		     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
		     */
		    getUrlComponents() {
		        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0
		        const regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
		        // If url string does not match regEx, we throw an error
		        const match = this.urlString.match(regEx);
		        if (!match) {
		            throw createClientConfigurationError(urlParseError);
		        }
		        // Url component object
		        const urlComponents = {
		            Protocol: match[1],
		            HostNameAndPort: match[4],
		            AbsolutePath: match[5],
		            QueryString: match[7],
		        };
		        let pathSegments = urlComponents.AbsolutePath.split("/");
		        pathSegments = pathSegments.filter((val) => val && val.length > 0); // remove empty elements
		        urlComponents.PathSegments = pathSegments;
		        if (urlComponents.QueryString &&
		            urlComponents.QueryString.endsWith("/")) {
		            urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
		        }
		        return urlComponents;
		    }
		    static getDomainFromUrl(url) {
		        const regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
		        const match = url.match(regEx);
		        if (!match) {
		            throw createClientConfigurationError(urlParseError);
		        }
		        return match[2];
		    }
		    static getAbsoluteUrl(relativeUrl, baseUrl) {
		        if (relativeUrl[0] === Constants.FORWARD_SLASH) {
		            const url = new UrlString(baseUrl);
		            const baseComponents = url.getUrlComponents();
		            return (baseComponents.Protocol +
		                "//" +
		                baseComponents.HostNameAndPort +
		                relativeUrl);
		        }
		        return relativeUrl;
		    }
		    static constructAuthorityUriFromObject(urlObject) {
		        return new UrlString(urlObject.Protocol +
		            "//" +
		            urlObject.HostNameAndPort +
		            "/" +
		            urlObject.PathSegments.join("/"));
		    }
		    /**
		     * Check if the hash of the URL string contains known properties
		     * @deprecated This API will be removed in a future version
		     */
		    static hashContainsKnownProperties(response) {
		        return !!getDeserializedResponse(response);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const rawMetdataJSON = {
		    endpointMetadata: {
		        "login.microsoftonline.com": {
		            token_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token",
		            jwks_uri: "https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys",
		            issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
		            authorization_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize",
		            end_session_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout",
		        },
		        "login.chinacloudapi.cn": {
		            token_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token",
		            jwks_uri: "https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys",
		            issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
		            authorization_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize",
		            end_session_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout",
		        },
		        "login.microsoftonline.us": {
		            token_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token",
		            jwks_uri: "https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys",
		            issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
		            authorization_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize",
		            end_session_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout",
		        },
		    },
		    instanceDiscoveryMetadata: {
		        metadata: [
		            {
		                preferred_network: "login.microsoftonline.com",
		                preferred_cache: "login.windows.net",
		                aliases: [
		                    "login.microsoftonline.com",
		                    "login.windows.net",
		                    "login.microsoft.com",
		                    "sts.windows.net",
		                ],
		            },
		            {
		                preferred_network: "login.partner.microsoftonline.cn",
		                preferred_cache: "login.partner.microsoftonline.cn",
		                aliases: [
		                    "login.partner.microsoftonline.cn",
		                    "login.chinacloudapi.cn",
		                ],
		            },
		            {
		                preferred_network: "login.microsoftonline.de",
		                preferred_cache: "login.microsoftonline.de",
		                aliases: ["login.microsoftonline.de"],
		            },
		            {
		                preferred_network: "login.microsoftonline.us",
		                preferred_cache: "login.microsoftonline.us",
		                aliases: [
		                    "login.microsoftonline.us",
		                    "login.usgovcloudapi.net",
		                ],
		            },
		            {
		                preferred_network: "login-us.microsoftonline.com",
		                preferred_cache: "login-us.microsoftonline.com",
		                aliases: ["login-us.microsoftonline.com"],
		            },
		        ],
		    },
		};
		const EndpointMetadata = rawMetdataJSON.endpointMetadata;
		const InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
		const InstanceDiscoveryMetadataAliases = new Set();
		InstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {
		    metadataEntry.aliases.forEach((alias) => {
		        InstanceDiscoveryMetadataAliases.add(alias);
		    });
		});
		/**
		 * Attempts to get an aliases array from the static authority metadata sources based on the canonical authority host
		 * @param staticAuthorityOptions
		 * @param logger
		 * @returns
		 */
		function getAliasesFromStaticSources(staticAuthorityOptions, logger) {
		    let staticAliases;
		    const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;
		    if (canonicalAuthority) {
		        const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;
		        staticAliases =
		            getAliasesFromMetadata(authorityHost, staticAuthorityOptions.cloudDiscoveryMetadata?.metadata, AuthorityMetadataSource.CONFIG, logger) ||
		                getAliasesFromMetadata(authorityHost, InstanceDiscoveryMetadata.metadata, AuthorityMetadataSource.HARDCODED_VALUES, logger) ||
		                staticAuthorityOptions.knownAuthorities;
		    }
		    return staticAliases || [];
		}
		/**
		 * Returns aliases for from the raw cloud discovery metadata passed in
		 * @param authorityHost
		 * @param rawCloudDiscoveryMetadata
		 * @returns
		 */
		function getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source, logger) {
		    logger?.trace(`getAliasesFromMetadata called with source: ${source}`);
		    if (authorityHost && cloudDiscoveryMetadata) {
		        const metadata = getCloudDiscoveryMetadataFromNetworkResponse(cloudDiscoveryMetadata, authorityHost);
		        if (metadata) {
		            logger?.trace(`getAliasesFromMetadata: found cloud discovery metadata in ${source}, returning aliases`);
		            return metadata.aliases;
		        }
		        else {
		            logger?.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source}`);
		        }
		    }
		    return null;
		}
		/**
		 * Get cloud discovery metadata for common authorities
		 */
		function getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {
		    const metadata = getCloudDiscoveryMetadataFromNetworkResponse(InstanceDiscoveryMetadata.metadata, authorityHost);
		    return metadata;
		}
		/**
		 * Searches instance discovery network response for the entry that contains the host in the aliases list
		 * @param response
		 * @param authority
		 */
		function getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {
		    for (let i = 0; i < response.length; i++) {
		        const metadata = response[i];
		        if (metadata.aliases.includes(authorityHost)) {
		            return metadata;
		        }
		    }
		    return null;
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Protocol modes supported by MSAL.
		 */
		const ProtocolMode = {
		    /**
		     * Auth Code + PKCE with Entra ID (formerly AAD) specific optimizations and features
		     */
		    AAD: "AAD",
		    /**
		     * Auth Code + PKCE without Entra ID specific optimizations and features. For use only with non-Microsoft owned authorities.
		     * Support is limited for this mode.
		     */
		    OIDC: "OIDC",
		    /**
		     * Encrypted Authorize Response (EAR) with Entra ID specific optimizations and features
		     */
		    EAR: "EAR",
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const AzureCloudInstance = {
		    // AzureCloudInstance is not specified.
		    None: "none",
		    // Microsoft Azure public cloud
		    AzurePublic: "https://login.microsoftonline.com",
		    // Microsoft PPE
		    AzurePpe: "https://login.windows-ppe.net",
		    // Microsoft Chinese national/regional cloud
		    AzureChina: "https://login.chinacloudapi.cn",
		    // Microsoft German national/regional cloud ("Black Forest")
		    AzureGermany: "https://login.microsoftonline.de",
		    // US Government cloud
		    AzureUsGovernment: "https://login.microsoftonline.us",
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function isCloudInstanceDiscoveryResponse(response) {
		    return (response.hasOwnProperty("tenant_discovery_endpoint") &&
		        response.hasOwnProperty("metadata"));
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function isCloudInstanceDiscoveryErrorResponse(response) {
		    return (response.hasOwnProperty("error") &&
		        response.hasOwnProperty("error_description"));
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Enumeration of operations that are instrumented by have their performance measured by the PerformanceClient.
		 *
		 * @export
		 * @enum {number}
		 */
		const PerformanceEvents = {
		    /**
		     * acquireTokenByCode API (msal-browser and msal-node).
		     * Used to acquire tokens by trading an authorization code against the token endpoint.
		     */
		    AcquireTokenByCode: "acquireTokenByCode",
		    /**
		     * acquireTokenByRefreshToken API (msal-browser and msal-node).
		     * Used to renew an access token using a refresh token against the token endpoint.
		     */
		    AcquireTokenByRefreshToken: "acquireTokenByRefreshToken",
		    /**
		     * acquireTokenSilent API (msal-browser and msal-node).
		     * Used to silently acquire a new access token (from the cache or the network).
		     */
		    AcquireTokenSilent: "acquireTokenSilent",
		    /**
		     * acquireTokenSilentAsync (msal-browser).
		     * Internal API for acquireTokenSilent.
		     */
		    AcquireTokenSilentAsync: "acquireTokenSilentAsync",
		    /**
		     * acquireTokenPopup (msal-browser).
		     * Used to acquire a new access token interactively through pop ups
		     */
		    AcquireTokenPopup: "acquireTokenPopup",
		    /**
		     * acquireTokenPreRedirect (msal-browser).
		     * First part of the redirect flow.
		     * Used to acquire a new access token interactively through redirects.
		     */
		    AcquireTokenPreRedirect: "acquireTokenPreRedirect",
		    /**
		     * acquireTokenRedirect (msal-browser).
		     * Second part of the redirect flow.
		     * Used to acquire a new access token interactively through redirects.
		     */
		    AcquireTokenRedirect: "acquireTokenRedirect",
		    /**
		     * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
		     * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
		     */
		    CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint",
		    /**
		     * signJwt API in CryptoOpts class (msal-browser).
		     * Used to signed a pop token.
		     */
		    CryptoOptsSignJwt: "cryptoOptsSignJwt",
		    /**
		     * acquireToken API in the SilentCacheClient class (msal-browser).
		     * Used to read access tokens from the cache.
		     */
		    SilentCacheClientAcquireToken: "silentCacheClientAcquireToken",
		    /**
		     * acquireToken API in the SilentIframeClient class (msal-browser).
		     * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
		     */
		    SilentIframeClientAcquireToken: "silentIframeClientAcquireToken",
		    AwaitConcurrentIframe: "awaitConcurrentIframe",
		    /**
		     * acquireToken API in SilentRereshClient (msal-browser).
		     * Used to acquire a new set of tokens from the token endpoint using a refresh token.
		     */
		    SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken",
		    /**
		     * ssoSilent API (msal-browser).
		     * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
		     */
		    SsoSilent: "ssoSilent",
		    /**
		     * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
		     * Used to load authority metadata for a request.
		     */
		    StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority",
		    /**
		     * acquireToken APIs in msal-browser.
		     * Used to make an /authorize endpoint call with native brokering enabled.
		     */
		    FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker",
		    /**
		     * acquireToken API in NativeInteractionClient class (msal-browser).
		     * Used to acquire a token from Native component when native brokering is enabled.
		     */
		    NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken",
		    /**
		     * Time spent creating default headers for requests to token endpoint
		     */
		    BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders",
		    /**
		     * Time spent sending/waiting for the response of a request to the token endpoint
		     */
		    NetworkClientSendPostRequestAsync: "networkClientSendPostRequestAsync",
		    RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint",
		    AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint",
		    /**
		     * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
		     */
		    BrokerHandhshake: "brokerHandshake",
		    /**
		     * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
		     */
		    AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker",
		    /**
		     * Time taken for token acquisition by broker
		     */
		    AcquireTokenByBroker: "acquireTokenByBroker",
		    /**
		     * Time spent on the network for refresh token acquisition
		     */
		    RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest",
		    /**
		     * Time taken for acquiring refresh token , records RT size
		     */
		    RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken",
		    /**
		     * Time taken for acquiring cached refresh token
		     */
		    RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken",
		    /**
		     * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
		     */
		    RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken",
		    /**
		     * Helper function to create token request body in RefreshTokenClient (msal-common).
		     */
		    RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody",
		    /**
		     * acquireTokenFromCache (msal-browser).
		     * Internal API for acquiring token from cache
		     */
		    AcquireTokenFromCache: "acquireTokenFromCache",
		    SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken",
		    SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord",
		    /**
		     * acquireTokenBySilentIframe (msal-browser).
		     * Internal API for acquiring token by silent Iframe
		     */
		    AcquireTokenBySilentIframe: "acquireTokenBySilentIframe",
		    /**
		     * Internal API for initializing base request in BaseInteractionClient (msal-browser)
		     */
		    InitializeBaseRequest: "initializeBaseRequest",
		    /**
		     * Internal API for initializing silent request in SilentCacheClient (msal-browser)
		     */
		    InitializeSilentRequest: "initializeSilentRequest",
		    InitializeClientApplication: "initializeClientApplication",
		    InitializeCache: "initializeCache",
		    /**
		     * Helper function in SilentIframeClient class (msal-browser).
		     */
		    SilentIframeClientTokenHelper: "silentIframeClientTokenHelper",
		    /**
		     * SilentHandler
		     */
		    SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest",
		    SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash",
		    SilentHandlerLoadFrame: "silentHandlerLoadFrame",
		    SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync",
		    /**
		     * Helper functions in StandardInteractionClient class (msal-browser)
		     */
		    StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient",
		    StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration",
		    StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest",
		    /**
		     * getAuthCodeUrl API (msal-browser and msal-node).
		     */
		    GetAuthCodeUrl: "getAuthCodeUrl",
		    GetStandardParams: "getStandardParams",
		    /**
		     * Functions from InteractionHandler (msal-browser)
		     */
		    HandleCodeResponseFromServer: "handleCodeResponseFromServer",
		    HandleCodeResponse: "handleCodeResponse",
		    HandleResponseEar: "handleResponseEar",
		    HandleResponsePlatformBroker: "handleResponsePlatformBroker",
		    HandleResponseCode: "handleResponseCode",
		    UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority",
		    /**
		     * APIs in Authorization Code Client (msal-common)
		     */
		    AuthClientAcquireToken: "authClientAcquireToken",
		    AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest",
		    AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody",
		    /**
		     * Generate functions in PopTokenGenerator (msal-common)
		     */
		    PopTokenGenerateCnf: "popTokenGenerateCnf",
		    PopTokenGenerateKid: "popTokenGenerateKid",
		    /**
		     * handleServerTokenResponse API in ResponseHandler (msal-common)
		     */
		    HandleServerTokenResponse: "handleServerTokenResponse",
		    DeserializeResponse: "deserializeResponse",
		    /**
		     * Authority functions
		     */
		    AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance",
		    AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync",
		    AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources",
		    AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork",
		    AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata",
		    AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork",
		    AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata",
		    AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation",
		    /**
		     * Region Discovery functions
		     */
		    RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion",
		    RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS",
		    RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion",
		    AcquireTokenByCodeAsync: "acquireTokenByCodeAsync",
		    GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork",
		    GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement",
		    HandleRedirectPromiseMeasurement: "handleRedirectPromise",
		    HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise",
		    UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement",
		    UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken",
		    NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake",
		    NativeGenerateAuthResult: "nativeGenerateAuthResult",
		    RemoveHiddenIframe: "removeHiddenIframe",
		    /**
		     * Cache operations
		     */
		    ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims",
		    CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken",
		    ImportExistingCache: "importExistingCache",
		    SetUserData: "setUserData",
		    LocalStorageUpdated: "localStorageUpdated",
		    /**
		     * Crypto Operations
		     */
		    GeneratePkceCodes: "generatePkceCodes",
		    GenerateCodeVerifier: "generateCodeVerifier",
		    GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier",
		    Sha256Digest: "sha256Digest",
		    GetRandomValues: "getRandomValues",
		    GenerateHKDF: "generateHKDF",
		    GenerateBaseKey: "generateBaseKey",
		    Base64Decode: "base64Decode",
		    UrlEncodeArr: "urlEncodeArr",
		    Encrypt: "encrypt",
		    Decrypt: "decrypt",
		    GenerateEarKey: "generateEarKey",
		    DecryptEarResponse: "decryptEarResponse",
		};
		const PerformanceEventAbbreviations = new Map([
		    [PerformanceEvents.AcquireTokenByCode, "ATByCode"],
		    [PerformanceEvents.AcquireTokenByRefreshToken, "ATByRT"],
		    [PerformanceEvents.AcquireTokenSilent, "ATS"],
		    [PerformanceEvents.AcquireTokenSilentAsync, "ATSAsync"],
		    [PerformanceEvents.AcquireTokenPopup, "ATPopup"],
		    [PerformanceEvents.AcquireTokenRedirect, "ATRedirect"],
		    [
		        PerformanceEvents.CryptoOptsGetPublicKeyThumbprint,
		        "CryptoGetPKThumb",
		    ],
		    [PerformanceEvents.CryptoOptsSignJwt, "CryptoSignJwt"],
		    [PerformanceEvents.SilentCacheClientAcquireToken, "SltCacheClientAT"],
		    [PerformanceEvents.SilentIframeClientAcquireToken, "SltIframeClientAT"],
		    [PerformanceEvents.SilentRefreshClientAcquireToken, "SltRClientAT"],
		    [PerformanceEvents.SsoSilent, "SsoSlt"],
		    [
		        PerformanceEvents.StandardInteractionClientGetDiscoveredAuthority,
		        "StdIntClientGetDiscAuth",
		    ],
		    [
		        PerformanceEvents.FetchAccountIdWithNativeBroker,
		        "FetchAccIdWithNtvBroker",
		    ],
		    [
		        PerformanceEvents.NativeInteractionClientAcquireToken,
		        "NtvIntClientAT",
		    ],
		    [
		        PerformanceEvents.BaseClientCreateTokenRequestHeaders,
		        "BaseClientCreateTReqHead",
		    ],
		    [
		        PerformanceEvents.NetworkClientSendPostRequestAsync,
		        "NetClientSendPost",
		    ],
		    [
		        PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint,
		        "RTClientExecPost",
		    ],
		    [
		        PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint,
		        "AuthCodeClientExecPost",
		    ],
		    [PerformanceEvents.BrokerHandhshake, "BrokerHandshake"],
		    [
		        PerformanceEvents.AcquireTokenByRefreshTokenInBroker,
		        "ATByRTInBroker",
		    ],
		    [PerformanceEvents.AcquireTokenByBroker, "ATByBroker"],
		    [
		        PerformanceEvents.RefreshTokenClientExecuteTokenRequest,
		        "RTClientExecTReq",
		    ],
		    [PerformanceEvents.RefreshTokenClientAcquireToken, "RTClientAT"],
		    [
		        PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken,
		        "RTClientATWithCachedRT",
		    ],
		    [
		        PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken,
		        "RTClientATByRT",
		    ],
		    [
		        PerformanceEvents.RefreshTokenClientCreateTokenRequestBody,
		        "RTClientCreateTReqBody",
		    ],
		    [PerformanceEvents.AcquireTokenFromCache, "ATFromCache"],
		    [
		        PerformanceEvents.SilentFlowClientAcquireCachedToken,
		        "SltFlowClientATCached",
		    ],
		    [
		        PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord,
		        "SltFlowClientGenResFromCache",
		    ],
		    [PerformanceEvents.AcquireTokenBySilentIframe, "ATBySltIframe"],
		    [PerformanceEvents.InitializeBaseRequest, "InitBaseReq"],
		    [PerformanceEvents.InitializeSilentRequest, "InitSltReq"],
		    [
		        PerformanceEvents.InitializeClientApplication,
		        "InitClientApplication",
		    ],
		    [PerformanceEvents.InitializeCache, "InitCache"],
		    [PerformanceEvents.ImportExistingCache, "importCache"],
		    [PerformanceEvents.SetUserData, "setUserData"],
		    [PerformanceEvents.LocalStorageUpdated, "localStorageUpdated"],
		    [PerformanceEvents.SilentIframeClientTokenHelper, "SIClientTHelper"],
		    [
		        PerformanceEvents.SilentHandlerInitiateAuthRequest,
		        "SHandlerInitAuthReq",
		    ],
		    [
		        PerformanceEvents.SilentHandlerMonitorIframeForHash,
		        "SltHandlerMonitorIframeForHash",
		    ],
		    [PerformanceEvents.SilentHandlerLoadFrame, "SHandlerLoadFrame"],
		    [PerformanceEvents.SilentHandlerLoadFrameSync, "SHandlerLoadFrameSync"],
		    [
		        PerformanceEvents.StandardInteractionClientCreateAuthCodeClient,
		        "StdIntClientCreateAuthCodeClient",
		    ],
		    [
		        PerformanceEvents.StandardInteractionClientGetClientConfiguration,
		        "StdIntClientGetClientConf",
		    ],
		    [
		        PerformanceEvents.StandardInteractionClientInitializeAuthorizationRequest,
		        "StdIntClientInitAuthReq",
		    ],
		    [PerformanceEvents.GetAuthCodeUrl, "GetAuthCodeUrl"],
		    [
		        PerformanceEvents.HandleCodeResponseFromServer,
		        "HandleCodeResFromServer",
		    ],
		    [PerformanceEvents.HandleCodeResponse, "HandleCodeResp"],
		    [PerformanceEvents.HandleResponseEar, "HandleRespEar"],
		    [PerformanceEvents.HandleResponseCode, "HandleRespCode"],
		    [
		        PerformanceEvents.HandleResponsePlatformBroker,
		        "HandleRespPlatBroker",
		    ],
		    [PerformanceEvents.UpdateTokenEndpointAuthority, "UpdTEndpointAuth"],
		    [PerformanceEvents.AuthClientAcquireToken, "AuthClientAT"],
		    [PerformanceEvents.AuthClientExecuteTokenRequest, "AuthClientExecTReq"],
		    [
		        PerformanceEvents.AuthClientCreateTokenRequestBody,
		        "AuthClientCreateTReqBody",
		    ],
		    [PerformanceEvents.PopTokenGenerateCnf, "PopTGenCnf"],
		    [PerformanceEvents.PopTokenGenerateKid, "PopTGenKid"],
		    [PerformanceEvents.HandleServerTokenResponse, "HandleServerTRes"],
		    [PerformanceEvents.DeserializeResponse, "DeserializeRes"],
		    [
		        PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance,
		        "AuthFactCreateDiscInst",
		    ],
		    [
		        PerformanceEvents.AuthorityResolveEndpointsAsync,
		        "AuthResolveEndpointsAsync",
		    ],
		    [
		        PerformanceEvents.AuthorityResolveEndpointsFromLocalSources,
		        "AuthResolveEndpointsFromLocal",
		    ],
		    [
		        PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork,
		        "AuthGetCDMetaFromNet",
		    ],
		    [
		        PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata,
		        "AuthUpdCDMeta",
		    ],
		    [
		        PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork,
		        "AuthUpdCDMetaFromNet",
		    ],
		    [
		        PerformanceEvents.AuthorityUpdateEndpointMetadata,
		        "AuthUpdEndpointMeta",
		    ],
		    [
		        PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation,
		        "AuthUpdMetaWithRegInfo",
		    ],
		    [PerformanceEvents.RegionDiscoveryDetectRegion, "RegDiscDetectReg"],
		    [
		        PerformanceEvents.RegionDiscoveryGetRegionFromIMDS,
		        "RegDiscGetRegFromIMDS",
		    ],
		    [
		        PerformanceEvents.RegionDiscoveryGetCurrentVersion,
		        "RegDiscGetCurrentVer",
		    ],
		    [PerformanceEvents.AcquireTokenByCodeAsync, "ATByCodeAsync"],
		    [
		        PerformanceEvents.GetEndpointMetadataFromNetwork,
		        "GetEndpointMetaFromNet",
		    ],
		    [
		        PerformanceEvents.GetCloudDiscoveryMetadataFromNetworkMeasurement,
		        "GetCDMetaFromNet",
		    ],
		    [
		        PerformanceEvents.HandleRedirectPromiseMeasurement,
		        "HandleRedirectPromise",
		    ],
		    [
		        PerformanceEvents.HandleNativeRedirectPromiseMeasurement,
		        "HandleNtvRedirectPromise",
		    ],
		    [
		        PerformanceEvents.UpdateCloudDiscoveryMetadataMeasurement,
		        "UpdateCDMeta",
		    ],
		    [
		        PerformanceEvents.UsernamePasswordClientAcquireToken,
		        "UserPassClientAT",
		    ],
		    [
		        PerformanceEvents.NativeMessageHandlerHandshake,
		        "NtvMsgHandlerHandshake",
		    ],
		    [PerformanceEvents.NativeGenerateAuthResult, "NtvGenAuthRes"],
		    [PerformanceEvents.RemoveHiddenIframe, "RemoveHiddenIframe"],
		    [
		        PerformanceEvents.ClearTokensAndKeysWithClaims,
		        "ClearTAndKeysWithClaims",
		    ],
		    [PerformanceEvents.CacheManagerGetRefreshToken, "CacheManagerGetRT"],
		    [PerformanceEvents.GeneratePkceCodes, "GenPkceCodes"],
		    [PerformanceEvents.GenerateCodeVerifier, "GenCodeVerifier"],
		    [
		        PerformanceEvents.GenerateCodeChallengeFromVerifier,
		        "GenCodeChallengeFromVerifier",
		    ],
		    [PerformanceEvents.Sha256Digest, "Sha256Digest"],
		    [PerformanceEvents.GetRandomValues, "GetRandomValues"],
		    [PerformanceEvents.GenerateHKDF, "genHKDF"],
		    [PerformanceEvents.GenerateBaseKey, "genBaseKey"],
		    [PerformanceEvents.Base64Decode, "b64Decode"],
		    [PerformanceEvents.UrlEncodeArr, "urlEncArr"],
		    [PerformanceEvents.Encrypt, "encrypt"],
		    [PerformanceEvents.Decrypt, "decrypt"],
		    [PerformanceEvents.GenerateEarKey, "genEarKey"],
		    [PerformanceEvents.DecryptEarResponse, "decryptEarResp"],
		]);
		/**
		 * State of the performance event.
		 *
		 * @export
		 * @enum {number}
		 */
		const PerformanceEventStatus = {
		    NotStarted: 0,
		    InProgress: 1,
		    Completed: 2,
		};
		const IntFields = new Set([
		    "accessTokenSize",
		    "durationMs",
		    "idTokenSize",
		    "matsSilentStatus",
		    "matsHttpStatus",
		    "refreshTokenSize",
		    "queuedTimeMs",
		    "startTimeMs",
		    "status",
		    "multiMatchedAT",
		    "multiMatchedID",
		    "multiMatchedRT",
		    "unencryptedCacheCount",
		    "encryptedCacheExpiredCount",
		    "oldAccountCount",
		    "oldAccessCount",
		    "oldIdCount",
		    "oldRefreshCount",
		    "currAccountCount",
		    "currAccessCount",
		    "currIdCount",
		    "currRefreshCount",
		    "expiredCacheRemovedCount",
		    "upgradedCacheCount",
		]);

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Wraps a function with a performance measurement.
		 * Usage: invoke(functionToCall, performanceClient, "EventName", "correlationId")(...argsToPassToFunction)
		 * @param callback
		 * @param eventName
		 * @param logger
		 * @param telemetryClient
		 * @param correlationId
		 * @returns
		 * @internal
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const invoke = (callback, eventName, logger, telemetryClient, correlationId) => {
		    return (...args) => {
		        logger.trace(`Executing function ${eventName}`);
		        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
		        if (correlationId) {
		            // Track number of times this API is called in a single request
		            const eventCount = eventName + "CallCount";
		            telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
		        }
		        try {
		            const result = callback(...args);
		            inProgressEvent?.end({
		                success: true,
		            });
		            logger.trace(`Returning result from ${eventName}`);
		            return result;
		        }
		        catch (e) {
		            logger.trace(`Error occurred in ${eventName}`);
		            try {
		                logger.trace(JSON.stringify(e));
		            }
		            catch (e) {
		                logger.trace("Unable to print error message.");
		            }
		            inProgressEvent?.end({
		                success: false,
		            }, e);
		            throw e;
		        }
		    };
		};
		/**
		 * Wraps an async function with a performance measurement.
		 * Usage: invokeAsync(functionToCall, performanceClient, "EventName", "correlationId")(...argsToPassToFunction)
		 * @param callback
		 * @param eventName
		 * @param logger
		 * @param telemetryClient
		 * @param correlationId
		 * @returns
		 * @internal
		 *
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const invokeAsync = (callback, eventName, logger, telemetryClient, correlationId) => {
		    return (...args) => {
		        logger.trace(`Executing function ${eventName}`);
		        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
		        if (correlationId) {
		            // Track number of times this API is called in a single request
		            const eventCount = eventName + "CallCount";
		            telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
		        }
		        telemetryClient?.setPreQueueTime(eventName, correlationId);
		        return callback(...args)
		            .then((response) => {
		            logger.trace(`Returning result from ${eventName}`);
		            inProgressEvent?.end({
		                success: true,
		            });
		            return response;
		        })
		            .catch((e) => {
		            logger.trace(`Error occurred in ${eventName}`);
		            try {
		                logger.trace(JSON.stringify(e));
		            }
		            catch (e) {
		                logger.trace("Unable to print error message.");
		            }
		            inProgressEvent?.end({
		                success: false,
		            }, e);
		            throw e;
		        });
		    };
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class RegionDiscovery {
		    constructor(networkInterface, logger, performanceClient, correlationId) {
		        this.networkInterface = networkInterface;
		        this.logger = logger;
		        this.performanceClient = performanceClient;
		        this.correlationId = correlationId;
		    }
		    /**
		     * Detect the region from the application's environment.
		     *
		     * @returns Promise<string | null>
		     */
		    async detectRegion(environmentRegion, regionDiscoveryMetadata) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
		        // Initialize auto detected region with the region from the envrionment
		        let autodetectedRegionName = environmentRegion;
		        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS
		        if (!autodetectedRegionName) {
		            const options = RegionDiscovery.IMDS_OPTIONS;
		            try {
		                const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants.IMDS_VERSION, options);
		                if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {
		                    autodetectedRegionName = localIMDSVersionResponse.body;
		                    regionDiscoveryMetadata.region_source =
		                        RegionDiscoverySources.IMDS;
		                }
		                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.
		                if (localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST) {
		                    const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);
		                    if (!currentIMDSVersion) {
		                        regionDiscoveryMetadata.region_source =
		                            RegionDiscoverySources.FAILED_AUTO_DETECTION;
		                        return null;
		                    }
		                    const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);
		                    if (currentIMDSVersionResponse.status === HttpStatus.SUCCESS) {
		                        autodetectedRegionName =
		                            currentIMDSVersionResponse.body;
		                        regionDiscoveryMetadata.region_source =
		                            RegionDiscoverySources.IMDS;
		                    }
		                }
		            }
		            catch (e) {
		                regionDiscoveryMetadata.region_source =
		                    RegionDiscoverySources.FAILED_AUTO_DETECTION;
		                return null;
		            }
		        }
		        else {
		            regionDiscoveryMetadata.region_source =
		                RegionDiscoverySources.ENVIRONMENT_VARIABLE;
		        }
		        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION
		        if (!autodetectedRegionName) {
		            regionDiscoveryMetadata.region_source =
		                RegionDiscoverySources.FAILED_AUTO_DETECTION;
		        }
		        return autodetectedRegionName || null;
		    }
		    /**
		     * Make the call to the IMDS endpoint
		     *
		     * @param imdsEndpointUrl
		     * @returns Promise<NetworkResponse<string>>
		     */
		    async getRegionFromIMDS(version, options) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
		        return this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants.IMDS_TIMEOUT);
		    }
		    /**
		     * Get the most recent version of the IMDS endpoint available
		     *
		     * @returns Promise<string | null>
		     */
		    async getCurrentVersion(options) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
		        try {
		            const response = await this.networkInterface.sendGetRequestAsync(`${Constants.IMDS_ENDPOINT}?format=json`, options);
		            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.
		            if (response.status === HttpStatus.BAD_REQUEST &&
		                response.body &&
		                response.body["newest-versions"] &&
		                response.body["newest-versions"].length > 0) {
		                return response.body["newest-versions"][0];
		            }
		            return null;
		        }
		        catch (e) {
		            return null;
		        }
		    }
		}
		// Options for the IMDS endpoint request
		RegionDiscovery.IMDS_OPTIONS = {
		    headers: {
		        Metadata: "true",
		    },
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Utility functions for managing date and time operations.
		 */
		/**
		 * return the current time in Unix time (seconds).
		 */
		function nowSeconds() {
		    // Date.getTime() returns in milliseconds.
		    return Math.round(new Date().getTime() / 1000.0);
		}
		/**
		 * Converts JS Date object to seconds
		 * @param date Date
		 */
		function toSecondsFromDate(date) {
		    // Convert date to seconds
		    return date.getTime() / 1000;
		}
		/**
		 * Convert seconds to JS Date object. Seconds can be in a number or string format or undefined (will still return a date).
		 * @param seconds
		 */
		function toDateFromSeconds(seconds) {
		    if (seconds) {
		        return new Date(Number(seconds) * 1000);
		    }
		    return new Date();
		}
		/**
		 * check if a token is expired based on given UTC time in seconds.
		 * @param expiresOn
		 */
		function isTokenExpired(expiresOn, offset) {
		    // check for access token expiry
		    const expirationSec = Number(expiresOn) || 0;
		    const offsetCurrentTimeSec = nowSeconds() + offset;
		    // If current time + offset is greater than token expiration time, then token is expired.
		    return offsetCurrentTimeSec > expirationSec;
		}
		/**
		 * Checks if a cache entry is expired based on the last updated time and cache retention days.
		 * @param lastUpdatedAt
		 * @param cacheRetentionDays
		 * @returns
		 */
		function isCacheExpired(lastUpdatedAt, cacheRetentionDays) {
		    const cacheExpirationTimestamp = Number(lastUpdatedAt) + cacheRetentionDays * 24 * 60 * 60 * 1000;
		    return Date.now() > cacheExpirationTimestamp;
		}
		/**
		 * If the current time is earlier than the time that a token was cached at, we must discard the token
		 * i.e. The system clock was turned back after acquiring the cached token
		 * @param cachedAt
		 * @param offset
		 */
		function wasClockTurnedBack(cachedAt) {
		    const cachedAtSec = Number(cachedAt);
		    return cachedAtSec > nowSeconds();
		}
		/**
		 * Waits for t number of milliseconds
		 * @param t number
		 * @param value T
		 */
		function delay(t, value) {
		    return new Promise((resolve) => setTimeout(() => resolve(value), t));
		}

		var TimeUtils = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    delay: delay,
		    isCacheExpired: isCacheExpired,
		    isTokenExpired: isTokenExpired,
		    nowSeconds: nowSeconds,
		    toDateFromSeconds: toDateFromSeconds,
		    toSecondsFromDate: toSecondsFromDate,
		    wasClockTurnedBack: wasClockTurnedBack
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Create IdTokenEntity
		 * @param homeAccountId
		 * @param authenticationResult
		 * @param clientId
		 * @param authority
		 */
		function createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {
		    const idTokenEntity = {
		        credentialType: CredentialType.ID_TOKEN,
		        homeAccountId: homeAccountId,
		        environment: environment,
		        clientId: clientId,
		        secret: idToken,
		        realm: tenantId,
		        lastUpdatedAt: Date.now().toString(), // Set the last updated time to now
		    };
		    return idTokenEntity;
		}
		/**
		 * Create AccessTokenEntity
		 * @param homeAccountId
		 * @param environment
		 * @param accessToken
		 * @param clientId
		 * @param tenantId
		 * @param scopes
		 * @param expiresOn
		 * @param extExpiresOn
		 */
		function createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
		    const atEntity = {
		        homeAccountId: homeAccountId,
		        credentialType: CredentialType.ACCESS_TOKEN,
		        secret: accessToken,
		        cachedAt: nowSeconds().toString(),
		        expiresOn: expiresOn.toString(),
		        extendedExpiresOn: extExpiresOn.toString(),
		        environment: environment,
		        clientId: clientId,
		        realm: tenantId,
		        target: scopes,
		        tokenType: tokenType || AuthenticationScheme.BEARER,
		        lastUpdatedAt: Date.now().toString(), // Set the last updated time to now
		    };
		    if (userAssertionHash) {
		        atEntity.userAssertionHash = userAssertionHash;
		    }
		    if (refreshOn) {
		        atEntity.refreshOn = refreshOn.toString();
		    }
		    if (requestedClaims) {
		        atEntity.requestedClaims = requestedClaims;
		        atEntity.requestedClaimsHash = requestedClaimsHash;
		    }
		    /*
		     * Create Access Token With Auth Scheme instead of regular access token
		     * Cast to lower to handle "bearer" from ADFS
		     */
		    if (atEntity.tokenType?.toLowerCase() !==
		        AuthenticationScheme.BEARER.toLowerCase()) {
		        atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
		        switch (atEntity.tokenType) {
		            case AuthenticationScheme.POP:
		                // Make sure keyId is present and add it to credential
		                const tokenClaims = extractTokenClaims(accessToken, base64Decode);
		                if (!tokenClaims?.cnf?.kid) {
		                    throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);
		                }
		                atEntity.keyId = tokenClaims.cnf.kid;
		                break;
		            case AuthenticationScheme.SSH:
		                atEntity.keyId = keyId;
		        }
		    }
		    return atEntity;
		}
		/**
		 * Create RefreshTokenEntity
		 * @param homeAccountId
		 * @param authenticationResult
		 * @param clientId
		 * @param authority
		 */
		function createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {
		    const rtEntity = {
		        credentialType: CredentialType.REFRESH_TOKEN,
		        homeAccountId: homeAccountId,
		        environment: environment,
		        clientId: clientId,
		        secret: refreshToken,
		        lastUpdatedAt: Date.now().toString(),
		    };
		    if (userAssertionHash) {
		        rtEntity.userAssertionHash = userAssertionHash;
		    }
		    if (familyId) {
		        rtEntity.familyId = familyId;
		    }
		    if (expiresOn) {
		        rtEntity.expiresOn = expiresOn.toString();
		    }
		    return rtEntity;
		}
		function isCredentialEntity(entity) {
		    return (entity.hasOwnProperty("homeAccountId") &&
		        entity.hasOwnProperty("environment") &&
		        entity.hasOwnProperty("credentialType") &&
		        entity.hasOwnProperty("clientId") &&
		        entity.hasOwnProperty("secret"));
		}
		/**
		 * Validates an entity: checks for all expected params
		 * @param entity
		 */
		function isAccessTokenEntity(entity) {
		    if (!entity) {
		        return false;
		    }
		    return (isCredentialEntity(entity) &&
		        entity.hasOwnProperty("realm") &&
		        entity.hasOwnProperty("target") &&
		        (entity["credentialType"] === CredentialType.ACCESS_TOKEN ||
		            entity["credentialType"] ===
		                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME));
		}
		/**
		 * Validates an entity: checks for all expected params
		 * @param entity
		 */
		function isIdTokenEntity(entity) {
		    if (!entity) {
		        return false;
		    }
		    return (isCredentialEntity(entity) &&
		        entity.hasOwnProperty("realm") &&
		        entity["credentialType"] === CredentialType.ID_TOKEN);
		}
		/**
		 * Validates an entity: checks for all expected params
		 * @param entity
		 */
		function isRefreshTokenEntity(entity) {
		    if (!entity) {
		        return false;
		    }
		    return (isCredentialEntity(entity) &&
		        entity["credentialType"] === CredentialType.REFRESH_TOKEN);
		}
		/**
		 * validates if a given cache entry is "Telemetry", parses <key,value>
		 * @param key
		 * @param entity
		 */
		function isServerTelemetryEntity(key, entity) {
		    const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
		    let validateEntity = true;
		    if (entity) {
		        validateEntity =
		            entity.hasOwnProperty("failedRequests") &&
		                entity.hasOwnProperty("errors") &&
		                entity.hasOwnProperty("cacheHits");
		    }
		    return validateKey && validateEntity;
		}
		/**
		 * validates if a given cache entry is "Throttling", parses <key,value>
		 * @param key
		 * @param entity
		 */
		function isThrottlingEntity(key, entity) {
		    let validateKey = false;
		    if (key) {
		        validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
		    }
		    let validateEntity = true;
		    if (entity) {
		        validateEntity = entity.hasOwnProperty("throttleTime");
		    }
		    return validateKey && validateEntity;
		}
		/**
		 * Generate AppMetadata Cache Key as per the schema: appmetadata-<environment>-<client_id>
		 */
		function generateAppMetadataKey({ environment, clientId, }) {
		    const appMetaDataKeyArray = [
		        APP_METADATA,
		        environment,
		        clientId,
		    ];
		    return appMetaDataKeyArray
		        .join(Separators.CACHE_KEY_SEPARATOR)
		        .toLowerCase();
		}
		/*
		 * Validates an entity: checks for all expected params
		 * @param entity
		 */
		function isAppMetadataEntity(key, entity) {
		    if (!entity) {
		        return false;
		    }
		    return (key.indexOf(APP_METADATA) === 0 &&
		        entity.hasOwnProperty("clientId") &&
		        entity.hasOwnProperty("environment"));
		}
		/**
		 * Validates an entity: checks for all expected params
		 * @param entity
		 */
		function isAuthorityMetadataEntity(key, entity) {
		    if (!entity) {
		        return false;
		    }
		    return (key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 &&
		        entity.hasOwnProperty("aliases") &&
		        entity.hasOwnProperty("preferred_cache") &&
		        entity.hasOwnProperty("preferred_network") &&
		        entity.hasOwnProperty("canonical_authority") &&
		        entity.hasOwnProperty("authorization_endpoint") &&
		        entity.hasOwnProperty("token_endpoint") &&
		        entity.hasOwnProperty("issuer") &&
		        entity.hasOwnProperty("aliasesFromNetwork") &&
		        entity.hasOwnProperty("endpointsFromNetwork") &&
		        entity.hasOwnProperty("expiresAt") &&
		        entity.hasOwnProperty("jwks_uri"));
		}
		/**
		 * Reset the exiresAt value
		 */
		function generateAuthorityMetadataExpiresAt() {
		    return (nowSeconds() +
		        AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS);
		}
		function updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {
		    authorityMetadata.authorization_endpoint =
		        updatedValues.authorization_endpoint;
		    authorityMetadata.token_endpoint = updatedValues.token_endpoint;
		    authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;
		    authorityMetadata.issuer = updatedValues.issuer;
		    authorityMetadata.endpointsFromNetwork = fromNetwork;
		    authorityMetadata.jwks_uri = updatedValues.jwks_uri;
		}
		function updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {
		    authorityMetadata.aliases = updatedValues.aliases;
		    authorityMetadata.preferred_cache = updatedValues.preferred_cache;
		    authorityMetadata.preferred_network = updatedValues.preferred_network;
		    authorityMetadata.aliasesFromNetwork = fromNetwork;
		}
		/**
		 * Returns whether or not the data needs to be refreshed
		 */
		function isAuthorityMetadataExpired(metadata) {
		    return metadata.expiresAt <= nowSeconds();
		}

		var CacheHelpers = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    createAccessTokenEntity: createAccessTokenEntity,
		    createIdTokenEntity: createIdTokenEntity,
		    createRefreshTokenEntity: createRefreshTokenEntity,
		    generateAppMetadataKey: generateAppMetadataKey,
		    generateAuthorityMetadataExpiresAt: generateAuthorityMetadataExpiresAt,
		    isAccessTokenEntity: isAccessTokenEntity,
		    isAppMetadataEntity: isAppMetadataEntity,
		    isAuthorityMetadataEntity: isAuthorityMetadataEntity,
		    isAuthorityMetadataExpired: isAuthorityMetadataExpired,
		    isCredentialEntity: isCredentialEntity,
		    isIdTokenEntity: isIdTokenEntity,
		    isRefreshTokenEntity: isRefreshTokenEntity,
		    isServerTelemetryEntity: isServerTelemetryEntity,
		    isThrottlingEntity: isThrottlingEntity,
		    updateAuthorityEndpointMetadata: updateAuthorityEndpointMetadata,
		    updateCloudDiscoveryMetadata: updateCloudDiscoveryMetadata
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the
		 * endpoint. It will store the pertinent config data in this object for use during token calls.
		 * @internal
		 */
		class Authority {
		    constructor(authority, networkInterface, cacheManager, authorityOptions, logger, correlationId, performanceClient, managedIdentity) {
		        this.canonicalAuthority = authority;
		        this._canonicalAuthority.validateAsUri();
		        this.networkInterface = networkInterface;
		        this.cacheManager = cacheManager;
		        this.authorityOptions = authorityOptions;
		        this.regionDiscoveryMetadata = {
		            region_used: undefined,
		            region_source: undefined,
		            region_outcome: undefined,
		        };
		        this.logger = logger;
		        this.performanceClient = performanceClient;
		        this.correlationId = correlationId;
		        this.managedIdentity = managedIdentity || false;
		        this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);
		    }
		    /**
		     * Get {@link AuthorityType}
		     * @param authorityUri {@link IUri}
		     * @private
		     */
		    getAuthorityType(authorityUri) {
		        // CIAM auth url pattern is being standardized as: <tenant>.ciamlogin.com
		        if (authorityUri.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
		            return AuthorityType.Ciam;
		        }
		        const pathSegments = authorityUri.PathSegments;
		        if (pathSegments.length) {
		            switch (pathSegments[0].toLowerCase()) {
		                case Constants.ADFS:
		                    return AuthorityType.Adfs;
		                case Constants.DSTS:
		                    return AuthorityType.Dsts;
		            }
		        }
		        return AuthorityType.Default;
		    }
		    // See above for AuthorityType
		    get authorityType() {
		        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
		    }
		    /**
		     * ProtocolMode enum representing the way endpoints are constructed.
		     */
		    get protocolMode() {
		        return this.authorityOptions.protocolMode;
		    }
		    /**
		     * Returns authorityOptions which can be used to reinstantiate a new authority instance
		     */
		    get options() {
		        return this.authorityOptions;
		    }
		    /**
		     * A URL that is the authority set by the developer
		     */
		    get canonicalAuthority() {
		        return this._canonicalAuthority.urlString;
		    }
		    /**
		     * Sets canonical authority.
		     */
		    set canonicalAuthority(url) {
		        this._canonicalAuthority = new UrlString(url);
		        this._canonicalAuthority.validateAsUri();
		        this._canonicalAuthorityUrlComponents = null;
		    }
		    /**
		     * Get authority components.
		     */
		    get canonicalAuthorityUrlComponents() {
		        if (!this._canonicalAuthorityUrlComponents) {
		            this._canonicalAuthorityUrlComponents =
		                this._canonicalAuthority.getUrlComponents();
		        }
		        return this._canonicalAuthorityUrlComponents;
		    }
		    /**
		     * Get hostname and port i.e. login.microsoftonline.com
		     */
		    get hostnameAndPort() {
		        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
		    }
		    /**
		     * Get tenant for authority.
		     */
		    get tenant() {
		        return this.canonicalAuthorityUrlComponents.PathSegments[0];
		    }
		    /**
		     * OAuth /authorize endpoint for requests
		     */
		    get authorizationEndpoint() {
		        if (this.discoveryComplete()) {
		            return this.replacePath(this.metadata.authorization_endpoint);
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * OAuth /token endpoint for requests
		     */
		    get tokenEndpoint() {
		        if (this.discoveryComplete()) {
		            return this.replacePath(this.metadata.token_endpoint);
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    get deviceCodeEndpoint() {
		        if (this.discoveryComplete()) {
		            return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * OAuth logout endpoint for requests
		     */
		    get endSessionEndpoint() {
		        if (this.discoveryComplete()) {
		            // ROPC policies may not have end_session_endpoint set
		            if (!this.metadata.end_session_endpoint) {
		                throw createClientAuthError(endSessionEndpointNotSupported);
		            }
		            return this.replacePath(this.metadata.end_session_endpoint);
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * OAuth issuer for requests
		     */
		    get selfSignedJwtAudience() {
		        if (this.discoveryComplete()) {
		            return this.replacePath(this.metadata.issuer);
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * Jwks_uri for token signing keys
		     */
		    get jwksUri() {
		        if (this.discoveryComplete()) {
		            return this.replacePath(this.metadata.jwks_uri);
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
		     * @param authorityUri {@link IUri}
		     * @private
		     */
		    canReplaceTenant(authorityUri) {
		        return (authorityUri.PathSegments.length === 1 &&
		            !Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) &&
		            this.getAuthorityType(authorityUri) === AuthorityType.Default &&
		            this.protocolMode !== ProtocolMode.OIDC);
		    }
		    /**
		     * Replaces tenant in url path with current tenant. Defaults to common.
		     * @param urlString
		     */
		    replaceTenant(urlString) {
		        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
		    }
		    /**
		     * Replaces path such as tenant or policy with the current tenant or policy.
		     * @param urlString
		     */
		    replacePath(urlString) {
		        let endpoint = urlString;
		        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
		        const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
		        const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
		        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
		        currentAuthorityParts.forEach((currentPart, index) => {
		            let cachedPart = cachedAuthorityParts[index];
		            if (index === 0 &&
		                this.canReplaceTenant(cachedAuthorityUrlComponents)) {
		                const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];
		                /**
		                 * Check if AAD canonical authority contains tenant domain name, for example "testdomain.onmicrosoft.com",
		                 * by comparing its first path segment to the corresponding authorization endpoint path segment, which is
		                 * always resolved with tenant id by OIDC.
		                 */
		                if (cachedPart !== tenantId) {
		                    this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);
		                    cachedPart = tenantId;
		                }
		            }
		            if (currentPart !== cachedPart) {
		                endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);
		            }
		        });
		        return this.replaceTenant(endpoint);
		    }
		    /**
		     * The default open id configuration endpoint for any canonical authority.
		     */
		    get defaultOpenIdConfigurationEndpoint() {
		        const canonicalAuthorityHost = this.hostnameAndPort;
		        if (this.canonicalAuthority.endsWith("v2.0/") ||
		            this.authorityType === AuthorityType.Adfs ||
		            (this.protocolMode === ProtocolMode.OIDC &&
		                !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost))) {
		            return `${this.canonicalAuthority}.well-known/openid-configuration`;
		        }
		        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;
		    }
		    /**
		     * Boolean that returns whether or not tenant discovery has been completed.
		     */
		    discoveryComplete() {
		        return !!this.metadata;
		    }
		    /**
		     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
		     * and the /authorize, /token and logout endpoints.
		     */
		    async resolveEndpointsAsync() {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
		        const metadataEntity = this.getCurrentMetadataEntity();
		        const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
		        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
		        const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
		        this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {
		            source: endpointSource,
		        });
		        this.performanceClient?.addFields({
		            cloudDiscoverySource: cloudDiscoverySource,
		            authorityEndpointSource: endpointSource,
		        }, this.correlationId);
		    }
		    /**
		     * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built
		     * from the configured canonical authority
		     * @returns
		     */
		    getCurrentMetadataEntity() {
		        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
		        if (!metadataEntity) {
		            metadataEntity = {
		                aliases: [],
		                preferred_cache: this.hostnameAndPort,
		                preferred_network: this.hostnameAndPort,
		                canonical_authority: this.canonicalAuthority,
		                authorization_endpoint: "",
		                token_endpoint: "",
		                end_session_endpoint: "",
		                issuer: "",
		                aliasesFromNetwork: false,
		                endpointsFromNetwork: false,
		                expiresAt: generateAuthorityMetadataExpiresAt(),
		                jwks_uri: "",
		            };
		        }
		        return metadataEntity;
		    }
		    /**
		     * Updates cached metadata based on metadata source and sets the instance's metadata
		     * property to the same value
		     * @param metadataEntity
		     * @param cloudDiscoverySource
		     * @param endpointMetadataResult
		     */
		    updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {
		        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE &&
		            endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE) {
		            // Reset the expiration time unless both values came from a successful cache lookup
		            metadataEntity.expiresAt =
		                generateAuthorityMetadataExpiresAt();
		            metadataEntity.canonical_authority = this.canonicalAuthority;
		        }
		        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
		        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
		        this.metadata = metadataEntity;
		    }
		    /**
		     * Update AuthorityMetadataEntity with new endpoints and return where the information came from
		     * @param metadataEntity
		     */
		    async updateEndpointMetadata(metadataEntity) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
		        const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);
		        // Further update may be required for hardcoded metadata if regional metadata is preferred
		        if (localMetadata) {
		            if (localMetadata.source ===
		                AuthorityMetadataSource.HARDCODED_VALUES) {
		                // If the user prefers to use an azure region replace the global endpoints with regional information.
		                if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
		                    if (localMetadata.metadata) {
		                        const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);
		                        updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
		                        metadataEntity.canonical_authority =
		                            this.canonicalAuthority;
		                    }
		                }
		            }
		            return localMetadata.source;
		        }
		        // Get metadata from network if local sources aren't available
		        let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
		        if (metadata) {
		            // If the user prefers to use an azure region replace the global endpoints with regional information.
		            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
		                metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);
		            }
		            updateAuthorityEndpointMetadata(metadataEntity, metadata, true);
		            return AuthorityMetadataSource.NETWORK;
		        }
		        else {
		            // Metadata could not be obtained from the config, cache, network or hardcoded values
		            throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);
		        }
		    }
		    /**
		     * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config
		     * response if the source is hardcoded metadata
		     * @param metadataEntity
		     * @returns
		     */
		    updateEndpointMetadataFromLocalSources(metadataEntity) {
		        this.logger.verbose("Attempting to get endpoint metadata from authority configuration");
		        const configMetadata = this.getEndpointMetadataFromConfig();
		        if (configMetadata) {
		            this.logger.verbose("Found endpoint metadata in authority configuration");
		            updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);
		            return {
		                source: AuthorityMetadataSource.CONFIG,
		            };
		        }
		        this.logger.verbose("Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.");
		        // skipAuthorityMetadataCache is used to bypass hardcoded authority metadata and force a network metadata cache lookup and network metadata request if no cached response is available.
		        if (this.authorityOptions.skipAuthorityMetadataCache) {
		            this.logger.verbose("Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.");
		        }
		        else {
		            const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
		            if (hardcodedMetadata) {
		                updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
		                return {
		                    source: AuthorityMetadataSource.HARDCODED_VALUES,
		                    metadata: hardcodedMetadata,
		                };
		            }
		            else {
		                this.logger.verbose("Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.");
		            }
		        }
		        // Check cached metadata entity expiration status
		        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
		        if (this.isAuthoritySameType(metadataEntity) &&
		            metadataEntity.endpointsFromNetwork &&
		            !metadataEntityExpired) {
		            // No need to update
		            this.logger.verbose("Found endpoint metadata in the cache.");
		            return { source: AuthorityMetadataSource.CACHE };
		        }
		        else if (metadataEntityExpired) {
		            this.logger.verbose("The metadata entity is expired.");
		        }
		        return null;
		    }
		    /**
		     * Compares the number of url components after the domain to determine if the cached
		     * authority metadata can be used for the requested authority. Protects against same domain different
		     * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
		     * @param metadataEntity
		     */
		    isAuthoritySameType(metadataEntity) {
		        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
		        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
		        return (cachedParts.length ===
		            this.canonicalAuthorityUrlComponents.PathSegments.length);
		    }
		    /**
		     * Parse authorityMetadata config option
		     */
		    getEndpointMetadataFromConfig() {
		        if (this.authorityOptions.authorityMetadata) {
		            try {
		                return JSON.parse(this.authorityOptions.authorityMetadata);
		            }
		            catch (e) {
		                throw createClientConfigurationError(invalidAuthorityMetadata);
		            }
		        }
		        return null;
		    }
		    /**
		     * Gets OAuth endpoints from the given OpenID configuration endpoint.
		     *
		     * @param hasHardcodedMetadata boolean
		     */
		    async getEndpointMetadataFromNetwork() {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
		        const options = {};
		        /*
		         * TODO: Add a timeout if the authority exists in our library's
		         * hardcoded list of metadata
		         */
		        const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;
		        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);
		        try {
		            const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);
		            const isValidResponse = isOpenIdConfigResponse(response.body);
		            if (isValidResponse) {
		                return response.body;
		            }
		            else {
		                this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);
		                return null;
		            }
		        }
		        catch (e) {
		            this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);
		            return null;
		        }
		    }
		    /**
		     * Get OAuth endpoints for common authorities.
		     */
		    getEndpointMetadataFromHardcodedValues() {
		        if (this.hostnameAndPort in EndpointMetadata) {
		            return EndpointMetadata[this.hostnameAndPort];
		        }
		        return null;
		    }
		    /**
		     * Update the retrieved metadata with regional information.
		     * User selected Azure region will be used if configured.
		     */
		    async updateMetadataWithRegionalInformation(metadata) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
		        const userConfiguredAzureRegion = this.authorityOptions.azureRegionConfiguration?.azureRegion;
		        if (userConfiguredAzureRegion) {
		            if (userConfiguredAzureRegion !==
		                Constants.AZURE_REGION_AUTO_DISCOVER_FLAG) {
		                this.regionDiscoveryMetadata.region_outcome =
		                    RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
		                this.regionDiscoveryMetadata.region_used =
		                    userConfiguredAzureRegion;
		                return Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);
		            }
		            const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)(this.authorityOptions.azureRegionConfiguration
		                ?.environmentRegion, this.regionDiscoveryMetadata);
		            if (autodetectedRegionName) {
		                this.regionDiscoveryMetadata.region_outcome =
		                    RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
		                this.regionDiscoveryMetadata.region_used =
		                    autodetectedRegionName;
		                return Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);
		            }
		            this.regionDiscoveryMetadata.region_outcome =
		                RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
		        }
		        return metadata;
		    }
		    /**
		     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
		     * and returns where the information was retrieved from
		     * @param metadataEntity
		     * @returns AuthorityMetadataSource
		     */
		    async updateCloudDiscoveryMetadata(metadataEntity) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
		        const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);
		        if (localMetadataSource) {
		            return localMetadataSource;
		        }
		        // Fallback to network as metadata source
		        const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
		        if (metadata) {
		            updateCloudDiscoveryMetadata(metadataEntity, metadata, true);
		            return AuthorityMetadataSource.NETWORK;
		        }
		        // Metadata could not be obtained from the config, cache, network or hardcoded values
		        throw createClientConfigurationError(untrustedAuthority);
		    }
		    updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {
		        this.logger.verbose("Attempting to get cloud discovery metadata  from authority configuration");
		        this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities ||
		            Constants.NOT_APPLICABLE}`);
		        this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata ||
		            Constants.NOT_APPLICABLE}`);
		        this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants.NOT_APPLICABLE}`);
		        const metadata = this.getCloudDiscoveryMetadataFromConfig();
		        if (metadata) {
		            this.logger.verbose("Found cloud discovery metadata in authority configuration");
		            updateCloudDiscoveryMetadata(metadataEntity, metadata, false);
		            return AuthorityMetadataSource.CONFIG;
		        }
		        // If the cached metadata came from config but that config was not passed to this instance, we must go to hardcoded values
		        this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.");
		        if (this.options.skipAuthorityMetadataCache) {
		            this.logger.verbose("Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.");
		        }
		        else {
		            const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);
		            if (hardcodedMetadata) {
		                this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
		                updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);
		                return AuthorityMetadataSource.HARDCODED_VALUES;
		            }
		            this.logger.verbose("Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.");
		        }
		        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
		        if (this.isAuthoritySameType(metadataEntity) &&
		            metadataEntity.aliasesFromNetwork &&
		            !metadataEntityExpired) {
		            this.logger.verbose("Found cloud discovery metadata in the cache.");
		            // No need to update
		            return AuthorityMetadataSource.CACHE;
		        }
		        else if (metadataEntityExpired) {
		            this.logger.verbose("The metadata entity is expired.");
		        }
		        return null;
		    }
		    /**
		     * Parse cloudDiscoveryMetadata config or check knownAuthorities
		     */
		    getCloudDiscoveryMetadataFromConfig() {
		        // CIAM does not support cloud discovery metadata
		        if (this.authorityType === AuthorityType.Ciam) {
		            this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
		            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
		        }
		        // Check if network response was provided in config
		        if (this.authorityOptions.cloudDiscoveryMetadata) {
		            this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
		            try {
		                this.logger.verbose("Attempting to parse the cloud discovery metadata.");
		                const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
		                const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
		                this.logger.verbose("Parsed the cloud discovery metadata.");
		                if (metadata) {
		                    this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
		                    return metadata;
		                }
		                else {
		                    this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
		                }
		            }
		            catch (e) {
		                this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
		                throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
		            }
		        }
		        // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities
		        if (this.isInKnownAuthorities()) {
		            this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
		            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
		        }
		        return null;
		    }
		    /**
		     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
		     *
		     * @param hasHardcodedMetadata boolean
		     */
		    async getCloudDiscoveryMetadataFromNetwork() {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
		        const instanceDiscoveryEndpoint = `${Constants.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;
		        const options = {};
		        /*
		         * TODO: Add a timeout if the authority exists in our library's
		         * hardcoded list of metadata
		         */
		        let match = null;
		        try {
		            const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);
		            let typedResponseBody;
		            let metadata;
		            if (isCloudInstanceDiscoveryResponse(response.body)) {
		                typedResponseBody =
		                    response.body;
		                metadata = typedResponseBody.metadata;
		                this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);
		            }
		            else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
		                this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);
		                typedResponseBody =
		                    response.body;
		                if (typedResponseBody.error === Constants.INVALID_INSTANCE) {
		                    this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
		                    return null;
		                }
		                this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);
		                this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);
		                this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
		                metadata = [];
		            }
		            else {
		                this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
		                return null;
		            }
		            this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
		            match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
		        }
		        catch (error) {
		            if (error instanceof AuthError) {
		                this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.\nError: ${error.errorCode}\nError Description: ${error.errorMessage}`);
		            }
		            else {
		                const typedError = error;
		                this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\nError: ${typedError.name}\nError Description: ${typedError.message}`);
		            }
		            return null;
		        }
		        // Custom Domain scenario, host is trusted because Instance Discovery call succeeded
		        if (!match) {
		            this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
		            this.logger.verbose("Creating custom Authority for custom domain scenario.");
		            match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
		        }
		        return match;
		    }
		    /**
		     * Helper function to determine if this host is included in the knownAuthorities config option
		     */
		    isInKnownAuthorities() {
		        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {
		            return (authority &&
		                UrlString.getDomainFromUrl(authority).toLowerCase() ===
		                    this.hostnameAndPort);
		        });
		        return matches.length > 0;
		    }
		    /**
		     * helper function to populate the authority based on azureCloudOptions
		     * @param authorityString
		     * @param azureCloudOptions
		     */
		    static generateAuthority(authorityString, azureCloudOptions) {
		        let authorityAzureCloudInstance;
		        if (azureCloudOptions &&
		            azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
		            const tenant = azureCloudOptions.tenant
		                ? azureCloudOptions.tenant
		                : Constants.DEFAULT_COMMON_TENANT;
		            authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;
		        }
		        return authorityAzureCloudInstance
		            ? authorityAzureCloudInstance
		            : authorityString;
		    }
		    /**
		     * Creates cloud discovery metadata object from a given host
		     * @param host
		     */
		    static createCloudDiscoveryMetadataFromHost(host) {
		        return {
		            preferred_network: host,
		            preferred_cache: host,
		            aliases: [host],
		        };
		    }
		    /**
		     * helper function to generate environment from authority object
		     */
		    getPreferredCache() {
		        if (this.managedIdentity) {
		            return Constants.DEFAULT_AUTHORITY_HOST;
		        }
		        else if (this.discoveryComplete()) {
		            return this.metadata.preferred_cache;
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * Returns whether or not the provided host is an alias of this authority instance
		     * @param host
		     */
		    isAlias(host) {
		        return this.metadata.aliases.indexOf(host) > -1;
		    }
		    /**
		     * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery
		     * @param host
		     */
		    isAliasOfKnownMicrosoftAuthority(host) {
		        return InstanceDiscoveryMetadataAliases.has(host);
		    }
		    /**
		     * Checks whether the provided host is that of a public cloud authority
		     *
		     * @param authority string
		     * @returns bool
		     */
		    static isPublicCloudAuthority(host) {
		        return Constants.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
		    }
		    /**
		     * Rebuild the authority string with the region
		     *
		     * @param host string
		     * @param region string
		     */
		    static buildRegionalAuthorityString(host, region, queryString) {
		        // Create and validate a Url string object with the initial authority string
		        const authorityUrlInstance = new UrlString(host);
		        authorityUrlInstance.validateAsUri();
		        const authorityUrlParts = authorityUrlInstance.getUrlComponents();
		        let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;
		        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
		            hostNameAndPort = `${region}.${Constants.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;
		        }
		        // Include the query string portion of the url
		        const url = UrlString.constructAuthorityUriFromObject({
		            ...authorityUrlInstance.getUrlComponents(),
		            HostNameAndPort: hostNameAndPort,
		        }).urlString;
		        // Add the query string if a query string was provided
		        if (queryString)
		            return `${url}?${queryString}`;
		        return url;
		    }
		    /**
		     * Replace the endpoints in the metadata object with their regional equivalents.
		     *
		     * @param metadata OpenIdConfigResponse
		     * @param azureRegion string
		     */
		    static replaceWithRegionalInformation(metadata, azureRegion) {
		        const regionalMetadata = { ...metadata };
		        regionalMetadata.authorization_endpoint =
		            Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);
		        regionalMetadata.token_endpoint =
		            Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);
		        if (regionalMetadata.end_session_endpoint) {
		            regionalMetadata.end_session_endpoint =
		                Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);
		        }
		        return regionalMetadata;
		    }
		    /**
		     * Transform CIAM_AUTHORIY as per the below rules:
		     * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
		     *
		     * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
		     * `ciamlogin.com` can also change in the future and we should accommodate the same
		     *
		     * @param authority
		     */
		    static transformCIAMAuthority(authority) {
		        let ciamAuthority = authority;
		        const authorityUrl = new UrlString(authority);
		        const authorityUrlComponents = authorityUrl.getUrlComponents();
		        // check if transformation is needed
		        if (authorityUrlComponents.PathSegments.length === 0 &&
		            authorityUrlComponents.HostNameAndPort.endsWith(Constants.CIAM_AUTH_URL)) {
		            const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
		            ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants.AAD_TENANT_DOMAIN_SUFFIX}`;
		        }
		        return ciamAuthority;
		    }
		}
		// Reserved tenant domain names that will not be replaced with tenant id
		Authority.reservedTenantDomains = new Set([
		    "{tenant}",
		    "{tenantid}",
		    AADAuthorityConstants.COMMON,
		    AADAuthorityConstants.CONSUMERS,
		    AADAuthorityConstants.ORGANIZATIONS,
		]);
		/**
		 * Extract tenantId from authority
		 */
		function getTenantFromAuthorityString(authority) {
		    const authorityUrl = new UrlString(authority);
		    const authorityUrlComponents = authorityUrl.getUrlComponents();
		    /**
		     * For credential matching purposes, tenantId is the last path segment of the authority URL:
		     *  AAD Authority - domain/tenantId -> Credentials are cached with realm = tenantId
		     *  B2C Authority - domain/{tenantId}?/.../policy -> Credentials are cached with realm = policy
		     *  tenantId is downcased because B2C policies can have mixed case but tfp claim is downcased
		     *
		     * Note that we may not have any path segments in certain OIDC scenarios.
		     */
		    const tenantId = authorityUrlComponents.PathSegments.slice(-1)[0]?.toLowerCase();
		    switch (tenantId) {
		        case AADAuthorityConstants.COMMON:
		        case AADAuthorityConstants.ORGANIZATIONS:
		        case AADAuthorityConstants.CONSUMERS:
		            return undefined;
		        default:
		            return tenantId;
		    }
		}
		function formatAuthorityUri(authorityUri) {
		    return authorityUri.endsWith(Constants.FORWARD_SLASH)
		        ? authorityUri
		        : `${authorityUri}${Constants.FORWARD_SLASH}`;
		}
		function buildStaticAuthorityOptions(authOptions) {
		    const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;
		    let cloudDiscoveryMetadata = undefined;
		    if (rawCloudDiscoveryMetadata) {
		        try {
		            cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);
		        }
		        catch (e) {
		            throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
		        }
		    }
		    return {
		        canonicalAuthority: authOptions.authority
		            ? formatAuthorityUri(authOptions.authority)
		            : undefined,
		        knownAuthorities: authOptions.knownAuthorities,
		        cloudDiscoveryMetadata: cloudDiscoveryMetadata,
		    };
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Create an authority object of the correct type based on the url
		 * Performs basic authority validation - checks to see if the authority is of a valid type (i.e. aad, b2c, adfs)
		 *
		 * Also performs endpoint discovery.
		 *
		 * @param authorityUri
		 * @param networkClient
		 * @param protocolMode
		 * @internal
		 */
		async function createDiscoveredInstance(authorityUri, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient) {
		    performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
		    const authorityUriFinal = Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));
		    // Initialize authority and perform discovery endpoint check.
		    const acquireTokenAuthority = new Authority(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient);
		    try {
		        await invokeAsync(acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority), PerformanceEvents.AuthorityResolveEndpointsAsync, logger, performanceClient, correlationId)();
		        return acquireTokenAuthority;
		    }
		    catch (e) {
		        throw createClientAuthError(endpointResolutionError);
		    }
		}

		var AuthorityFactory = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    createDiscoveredInstance: createDiscoveredInstance
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const CLIENT_ID = "client_id";
		const REDIRECT_URI = "redirect_uri";
		const RESPONSE_TYPE = "response_type";
		const RESPONSE_MODE = "response_mode";
		const GRANT_TYPE = "grant_type";
		const CLAIMS = "claims";
		const SCOPE = "scope";
		const ERROR = "error";
		const ERROR_DESCRIPTION = "error_description";
		const ACCESS_TOKEN = "access_token";
		const ID_TOKEN = "id_token";
		const REFRESH_TOKEN = "refresh_token";
		const EXPIRES_IN = "expires_in";
		const REFRESH_TOKEN_EXPIRES_IN = "refresh_token_expires_in";
		const STATE = "state";
		const NONCE = "nonce";
		const PROMPT = "prompt";
		const SESSION_STATE = "session_state";
		const CLIENT_INFO = "client_info";
		const CODE = "code";
		const CODE_CHALLENGE = "code_challenge";
		const CODE_CHALLENGE_METHOD = "code_challenge_method";
		const CODE_VERIFIER = "code_verifier";
		const CLIENT_REQUEST_ID = "client-request-id";
		const X_CLIENT_SKU = "x-client-SKU";
		const X_CLIENT_VER = "x-client-VER";
		const X_CLIENT_OS = "x-client-OS";
		const X_CLIENT_CPU = "x-client-CPU";
		const X_CLIENT_CURR_TELEM = "x-client-current-telemetry";
		const X_CLIENT_LAST_TELEM = "x-client-last-telemetry";
		const X_MS_LIB_CAPABILITY = "x-ms-lib-capability";
		const X_APP_NAME = "x-app-name";
		const X_APP_VER = "x-app-ver";
		const POST_LOGOUT_URI = "post_logout_redirect_uri";
		const ID_TOKEN_HINT = "id_token_hint";
		const DEVICE_CODE = "device_code";
		const CLIENT_SECRET = "client_secret";
		const CLIENT_ASSERTION = "client_assertion";
		const CLIENT_ASSERTION_TYPE = "client_assertion_type";
		const TOKEN_TYPE = "token_type";
		const REQ_CNF = "req_cnf";
		const OBO_ASSERTION = "assertion";
		const REQUESTED_TOKEN_USE = "requested_token_use";
		const ON_BEHALF_OF = "on_behalf_of";
		const FOCI = "foci";
		const CCS_HEADER = "X-AnchorMailbox";
		const RETURN_SPA_CODE = "return_spa_code";
		const NATIVE_BROKER = "nativebroker";
		const LOGOUT_HINT = "logout_hint";
		const SID = "sid";
		const LOGIN_HINT = "login_hint";
		const DOMAIN_HINT = "domain_hint";
		const X_CLIENT_EXTRA_SKU = "x-client-xtra-sku";
		const BROKER_CLIENT_ID = "brk_client_id";
		const BROKER_REDIRECT_URI = "brk_redirect_uri";
		const INSTANCE_AWARE = "instance_aware";
		const EAR_JWK = "ear_jwk";
		const EAR_JWE_CRYPTO = "ear_jwe_crypto";

		var AADServerParamKeys = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    ACCESS_TOKEN: ACCESS_TOKEN,
		    BROKER_CLIENT_ID: BROKER_CLIENT_ID,
		    BROKER_REDIRECT_URI: BROKER_REDIRECT_URI,
		    CCS_HEADER: CCS_HEADER,
		    CLAIMS: CLAIMS,
		    CLIENT_ASSERTION: CLIENT_ASSERTION,
		    CLIENT_ASSERTION_TYPE: CLIENT_ASSERTION_TYPE,
		    CLIENT_ID: CLIENT_ID,
		    CLIENT_INFO: CLIENT_INFO,
		    CLIENT_REQUEST_ID: CLIENT_REQUEST_ID,
		    CLIENT_SECRET: CLIENT_SECRET,
		    CODE: CODE,
		    CODE_CHALLENGE: CODE_CHALLENGE,
		    CODE_CHALLENGE_METHOD: CODE_CHALLENGE_METHOD,
		    CODE_VERIFIER: CODE_VERIFIER,
		    DEVICE_CODE: DEVICE_CODE,
		    DOMAIN_HINT: DOMAIN_HINT,
		    EAR_JWE_CRYPTO: EAR_JWE_CRYPTO,
		    EAR_JWK: EAR_JWK,
		    ERROR: ERROR,
		    ERROR_DESCRIPTION: ERROR_DESCRIPTION,
		    EXPIRES_IN: EXPIRES_IN,
		    FOCI: FOCI,
		    GRANT_TYPE: GRANT_TYPE,
		    ID_TOKEN: ID_TOKEN,
		    ID_TOKEN_HINT: ID_TOKEN_HINT,
		    INSTANCE_AWARE: INSTANCE_AWARE,
		    LOGIN_HINT: LOGIN_HINT,
		    LOGOUT_HINT: LOGOUT_HINT,
		    NATIVE_BROKER: NATIVE_BROKER,
		    NONCE: NONCE,
		    OBO_ASSERTION: OBO_ASSERTION,
		    ON_BEHALF_OF: ON_BEHALF_OF,
		    POST_LOGOUT_URI: POST_LOGOUT_URI,
		    PROMPT: PROMPT,
		    REDIRECT_URI: REDIRECT_URI,
		    REFRESH_TOKEN: REFRESH_TOKEN,
		    REFRESH_TOKEN_EXPIRES_IN: REFRESH_TOKEN_EXPIRES_IN,
		    REQUESTED_TOKEN_USE: REQUESTED_TOKEN_USE,
		    REQ_CNF: REQ_CNF,
		    RESPONSE_MODE: RESPONSE_MODE,
		    RESPONSE_TYPE: RESPONSE_TYPE,
		    RETURN_SPA_CODE: RETURN_SPA_CODE,
		    SCOPE: SCOPE,
		    SESSION_STATE: SESSION_STATE,
		    SID: SID,
		    STATE: STATE,
		    TOKEN_TYPE: TOKEN_TYPE,
		    X_APP_NAME: X_APP_NAME,
		    X_APP_VER: X_APP_VER,
		    X_CLIENT_CPU: X_CLIENT_CPU,
		    X_CLIENT_CURR_TELEM: X_CLIENT_CURR_TELEM,
		    X_CLIENT_EXTRA_SKU: X_CLIENT_EXTRA_SKU,
		    X_CLIENT_LAST_TELEM: X_CLIENT_LAST_TELEM,
		    X_CLIENT_OS: X_CLIENT_OS,
		    X_CLIENT_SKU: X_CLIENT_SKU,
		    X_CLIENT_VER: X_CLIENT_VER,
		    X_MS_LIB_CAPABILITY: X_MS_LIB_CAPABILITY
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const DEFAULT_CRYPTO_IMPLEMENTATION = {
		    createNewGuid: () => {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    base64Decode: () => {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    base64Encode: () => {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    base64UrlEncode: () => {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    encodeKid: () => {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async getPublicKeyThumbprint() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async removeTokenBindingKey() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async clearKeystore() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async signJwt() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async hashString() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Log message level.
		 */
		exports$1.LogLevel = void 0;
		(function (LogLevel) {
		    LogLevel[LogLevel["Error"] = 0] = "Error";
		    LogLevel[LogLevel["Warning"] = 1] = "Warning";
		    LogLevel[LogLevel["Info"] = 2] = "Info";
		    LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
		    LogLevel[LogLevel["Trace"] = 4] = "Trace";
		})(exports$1.LogLevel || (exports$1.LogLevel = {}));
		/**
		 * Class which facilitates logging of messages to a specific place.
		 */
		class Logger {
		    constructor(loggerOptions, packageName, packageVersion) {
		        // Current log level, defaults to info.
		        this.level = exports$1.LogLevel.Info;
		        const defaultLoggerCallback = () => {
		            return;
		        };
		        const setLoggerOptions = loggerOptions || Logger.createDefaultLoggerOptions();
		        this.localCallback =
		            setLoggerOptions.loggerCallback || defaultLoggerCallback;
		        this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
		        this.level =
		            typeof setLoggerOptions.logLevel === "number"
		                ? setLoggerOptions.logLevel
		                : exports$1.LogLevel.Info;
		        this.correlationId =
		            setLoggerOptions.correlationId || Constants.EMPTY_STRING;
		        this.packageName = packageName || Constants.EMPTY_STRING;
		        this.packageVersion = packageVersion || Constants.EMPTY_STRING;
		    }
		    static createDefaultLoggerOptions() {
		        return {
		            loggerCallback: () => {
		                // allow users to not set loggerCallback
		            },
		            piiLoggingEnabled: false,
		            logLevel: exports$1.LogLevel.Info,
		        };
		    }
		    /**
		     * Create new Logger with existing configurations.
		     */
		    clone(packageName, packageVersion, correlationId) {
		        return new Logger({
		            loggerCallback: this.localCallback,
		            piiLoggingEnabled: this.piiLoggingEnabled,
		            logLevel: this.level,
		            correlationId: correlationId || this.correlationId,
		        }, packageName, packageVersion);
		    }
		    /**
		     * Log message with required options.
		     */
		    logMessage(logMessage, options) {
		        if (options.logLevel > this.level ||
		            (!this.piiLoggingEnabled && options.containsPii)) {
		            return;
		        }
		        const timestamp = new Date().toUTCString();
		        // Add correlationId to logs if set, correlationId provided on log messages take precedence
		        const logHeader = `[${timestamp}] : [${options.correlationId || this.correlationId || ""}]`;
		        const log = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${exports$1.LogLevel[options.logLevel]} - ${logMessage}`;
		        // debug(`msal:${LogLevel[options.logLevel]}${options.containsPii ? "-Pii": Constants.EMPTY_STRING}${options.context ? `:${options.context}` : Constants.EMPTY_STRING}`)(logMessage);
		        this.executeCallback(options.logLevel, log, options.containsPii || false);
		    }
		    /**
		     * Execute callback with message.
		     */
		    executeCallback(level, message, containsPii) {
		        if (this.localCallback) {
		            this.localCallback(level, message, containsPii);
		        }
		    }
		    /**
		     * Logs error messages.
		     */
		    error(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Error,
		            containsPii: false,
		            correlationId: correlationId || Constants.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs error messages with PII.
		     */
		    errorPii(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Error,
		            containsPii: true,
		            correlationId: correlationId || Constants.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs warning messages.
		     */
		    warning(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Warning,
		            containsPii: false,
		            correlationId: correlationId || Constants.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs warning messages with PII.
		     */
		    warningPii(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Warning,
		            containsPii: true,
		            correlationId: correlationId || Constants.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs info messages.
		     */
		    info(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Info,
		            containsPii: false,
		            correlationId: correlationId || Constants.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs info messages with PII.
		     */
		    infoPii(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Info,
		            containsPii: true,
		            correlationId: correlationId || Constants.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs verbose messages.
		     */
		    verbose(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Verbose,
		            containsPii: false,
		            correlationId: correlationId || Constants.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs verbose messages with PII.
		     */
		    verbosePii(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Verbose,
		            containsPii: true,
		            correlationId: correlationId || Constants.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs trace messages.
		     */
		    trace(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Trace,
		            containsPii: false,
		            correlationId: correlationId || Constants.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs trace messages with PII.
		     */
		    tracePii(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Trace,
		            containsPii: true,
		            correlationId: correlationId || Constants.EMPTY_STRING,
		        });
		    }
		    /**
		     * Returns whether PII Logging is enabled or not.
		     */
		    isPiiLoggingEnabled() {
		        return this.piiLoggingEnabled || false;
		    }
		}

		/* eslint-disable header/header */
		const name = "@azure/msal-common";
		const version = "15.13.3";

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * The ScopeSet class creates a set of scopes. Scopes are case-insensitive, unique values, so the Set object in JS makes
		 * the most sense to implement for this class. All scopes are trimmed and converted to lower case strings in intersection and union functions
		 * to ensure uniqueness of strings.
		 */
		class ScopeSet {
		    constructor(inputScopes) {
		        // Filter empty string and null/undefined array items
		        const scopeArr = inputScopes
		            ? StringUtils.trimArrayEntries([...inputScopes])
		            : [];
		        const filteredInput = scopeArr
		            ? StringUtils.removeEmptyStringsFromArray(scopeArr)
		            : [];
		        // Check if scopes array has at least one member
		        if (!filteredInput || !filteredInput.length) {
		            throw createClientConfigurationError(emptyInputScopesError);
		        }
		        this.scopes = new Set(); // Iterator in constructor not supported by IE11
		        filteredInput.forEach((scope) => this.scopes.add(scope));
		    }
		    /**
		     * Factory method to create ScopeSet from space-delimited string
		     * @param inputScopeString
		     * @param appClientId
		     * @param scopesRequired
		     */
		    static fromString(inputScopeString) {
		        const scopeString = inputScopeString || Constants.EMPTY_STRING;
		        const inputScopes = scopeString.split(" ");
		        return new ScopeSet(inputScopes);
		    }
		    /**
		     * Creates the set of scopes to search for in cache lookups
		     * @param inputScopeString
		     * @returns
		     */
		    static createSearchScopes(inputScopeString) {
		        // Handle empty scopes by using default OIDC scopes for cache lookup
		        const scopesToUse = inputScopeString && inputScopeString.length > 0
		            ? inputScopeString
		            : [...OIDC_DEFAULT_SCOPES];
		        const scopeSet = new ScopeSet(scopesToUse);
		        if (!scopeSet.containsOnlyOIDCScopes()) {
		            scopeSet.removeOIDCScopes();
		        }
		        else {
		            scopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);
		        }
		        return scopeSet;
		    }
		    /**
		     * Check if a given scope is present in this set of scopes.
		     * @param scope
		     */
		    containsScope(scope) {
		        const lowerCaseScopes = this.printScopesLowerCase().split(" ");
		        const lowerCaseScopesSet = new ScopeSet(lowerCaseScopes);
		        // compare lowercase scopes
		        return scope
		            ? lowerCaseScopesSet.scopes.has(scope.toLowerCase())
		            : false;
		    }
		    /**
		     * Check if a set of scopes is present in this set of scopes.
		     * @param scopeSet
		     */
		    containsScopeSet(scopeSet) {
		        if (!scopeSet || scopeSet.scopes.size <= 0) {
		            return false;
		        }
		        return (this.scopes.size >= scopeSet.scopes.size &&
		            scopeSet.asArray().every((scope) => this.containsScope(scope)));
		    }
		    /**
		     * Check if set of scopes contains only the defaults
		     */
		    containsOnlyOIDCScopes() {
		        let defaultScopeCount = 0;
		        OIDC_SCOPES.forEach((defaultScope) => {
		            if (this.containsScope(defaultScope)) {
		                defaultScopeCount += 1;
		            }
		        });
		        return this.scopes.size === defaultScopeCount;
		    }
		    /**
		     * Appends single scope if passed
		     * @param newScope
		     */
		    appendScope(newScope) {
		        if (newScope) {
		            this.scopes.add(newScope.trim());
		        }
		    }
		    /**
		     * Appends multiple scopes if passed
		     * @param newScopes
		     */
		    appendScopes(newScopes) {
		        try {
		            newScopes.forEach((newScope) => this.appendScope(newScope));
		        }
		        catch (e) {
		            throw createClientAuthError(cannotAppendScopeSet);
		        }
		    }
		    /**
		     * Removes element from set of scopes.
		     * @param scope
		     */
		    removeScope(scope) {
		        if (!scope) {
		            throw createClientAuthError(cannotRemoveEmptyScope);
		        }
		        this.scopes.delete(scope.trim());
		    }
		    /**
		     * Removes default scopes from set of scopes
		     * Primarily used to prevent cache misses if the default scopes are not returned from the server
		     */
		    removeOIDCScopes() {
		        OIDC_SCOPES.forEach((defaultScope) => {
		            this.scopes.delete(defaultScope);
		        });
		    }
		    /**
		     * Combines an array of scopes with the current set of scopes.
		     * @param otherScopes
		     */
		    unionScopeSets(otherScopes) {
		        if (!otherScopes) {
		            throw createClientAuthError(emptyInputScopeSet);
		        }
		        const unionScopes = new Set(); // Iterator in constructor not supported in IE11
		        otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
		        this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
		        return unionScopes;
		    }
		    /**
		     * Check if scopes intersect between this set and another.
		     * @param otherScopes
		     */
		    intersectingScopeSets(otherScopes) {
		        if (!otherScopes) {
		            throw createClientAuthError(emptyInputScopeSet);
		        }
		        // Do not allow OIDC scopes to be the only intersecting scopes
		        if (!otherScopes.containsOnlyOIDCScopes()) {
		            otherScopes.removeOIDCScopes();
		        }
		        const unionScopes = this.unionScopeSets(otherScopes);
		        const sizeOtherScopes = otherScopes.getScopeCount();
		        const sizeThisScopes = this.getScopeCount();
		        const sizeUnionScopes = unionScopes.size;
		        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
		    }
		    /**
		     * Returns size of set of scopes.
		     */
		    getScopeCount() {
		        return this.scopes.size;
		    }
		    /**
		     * Returns the scopes as an array of string values
		     */
		    asArray() {
		        const array = [];
		        this.scopes.forEach((val) => array.push(val));
		        return array;
		    }
		    /**
		     * Prints scopes into a space-delimited string
		     */
		    printScopes() {
		        if (this.scopes) {
		            const scopeArr = this.asArray();
		            return scopeArr.join(" ");
		        }
		        return Constants.EMPTY_STRING;
		    }
		    /**
		     * Prints scopes into a space-delimited lower-case string (used for caching)
		     */
		    printScopesLowerCase() {
		        return this.printScopes().toLowerCase();
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Function to build a client info object from server clientInfo string
		 * @param rawClientInfo
		 * @param crypto
		 */
		function buildClientInfo(rawClientInfo, base64Decode) {
		    if (!rawClientInfo) {
		        throw createClientAuthError(clientInfoEmptyError);
		    }
		    try {
		        const decodedClientInfo = base64Decode(rawClientInfo);
		        return JSON.parse(decodedClientInfo);
		    }
		    catch (e) {
		        throw createClientAuthError(clientInfoDecodingError);
		    }
		}
		/**
		 * Function to build a client info object from cached homeAccountId string
		 * @param homeAccountId
		 */
		function buildClientInfoFromHomeAccountId(homeAccountId) {
		    if (!homeAccountId) {
		        throw createClientAuthError(clientInfoDecodingError);
		    }
		    const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
		    return {
		        uid: clientInfoParts[0],
		        utid: clientInfoParts.length < 2
		            ? Constants.EMPTY_STRING
		            : clientInfoParts[1],
		    };
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Returns true if tenantId matches the utid portion of homeAccountId
		 * @param tenantId
		 * @param homeAccountId
		 * @returns
		 */
		function tenantIdMatchesHomeTenant(tenantId, homeAccountId) {
		    return (!!tenantId &&
		        !!homeAccountId &&
		        tenantId === homeAccountId.split(".")[1]);
		}
		/**
		 * Build tenant profile
		 * @param homeAccountId - Home account identifier for this account object
		 * @param localAccountId - Local account identifer for this account object
		 * @param tenantId - Full tenant or organizational id that this account belongs to
		 * @param idTokenClaims - Claims from the ID token
		 * @returns
		 */
		function buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {
		    if (idTokenClaims) {
		        const { oid, sub, tid, name, tfp, acr, preferred_username, upn, login_hint, } = idTokenClaims;
		        /**
		         * Since there is no way to determine if the authority is AAD or B2C, we exhaust all the possible claims that can serve as tenant ID with the following precedence:
		         * tid - TenantID claim that identifies the tenant that issued the token in AAD. Expected in all AAD ID tokens, not present in B2C ID Tokens.
		         * tfp - Trust Framework Policy claim that identifies the policy that was used to authenticate the user. Functions as tenant for B2C scenarios.
		         * acr - Authentication Context Class Reference claim used only with older B2C policies. Fallback in case tfp is not present, but likely won't be present anyway.
		         */
		        const tenantId = tid || tfp || acr || "";
		        return {
		            tenantId: tenantId,
		            localAccountId: oid || sub || "",
		            name: name,
		            username: preferred_username || upn || "",
		            loginHint: login_hint,
		            isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId),
		        };
		    }
		    else {
		        return {
		            tenantId,
		            localAccountId,
		            username: "",
		            isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId),
		        };
		    }
		}
		/**
		 * Replaces account info that varies by tenant profile sourced from the ID token claims passed in with the tenant-specific account info
		 * @param baseAccountInfo
		 * @param idTokenClaims
		 * @returns
		 */
		function updateAccountTenantProfileData(baseAccountInfo, tenantProfile, idTokenClaims, idTokenSecret) {
		    let updatedAccountInfo = baseAccountInfo;
		    // Tenant Profile overrides passed in account info
		    if (tenantProfile) {
		        // eslint-disable-next-line @typescript-eslint/no-unused-vars
		        const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;
		        updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };
		    }
		    // ID token claims override passed in account info and tenant profile
		    if (idTokenClaims) {
		        // Ignore isHomeTenant, loginHint, and sid which are part of tenant profile but not base account info
		        // eslint-disable-next-line @typescript-eslint/no-unused-vars
		        const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(baseAccountInfo.homeAccountId, baseAccountInfo.localAccountId, baseAccountInfo.tenantId, idTokenClaims);
		        updatedAccountInfo = {
		            ...updatedAccountInfo,
		            ...claimsSourcedTenantProfile,
		            idTokenClaims: idTokenClaims,
		            idToken: idTokenSecret,
		        };
		        return updatedAccountInfo;
		    }
		    return updatedAccountInfo;
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Gets tenantId from available ID token claims to set as credential realm with the following precedence:
		 * 1. tid - if the token is acquired from an Azure AD tenant tid will be present
		 * 2. tfp - if the token is acquired from a modern B2C tenant tfp should be present
		 * 3. acr - if the token is acquired from a legacy B2C tenant acr should be present
		 * Downcased to match the realm case-insensitive comparison requirements
		 * @param idTokenClaims
		 * @returns
		 */
		function getTenantIdFromIdTokenClaims(idTokenClaims) {
		    if (idTokenClaims) {
		        const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;
		        return tenantId || null;
		    }
		    return null;
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).
		 *
		 * Key : Value Schema
		 *
		 * Key: <home_account_id>-<environment>-<realm*>
		 *
		 * Value Schema:
		 * {
		 *      homeAccountId: home account identifier for the auth scheme,
		 *      environment: entity that issued the token, represented as a full host
		 *      realm: Full tenant or organizational identifier that the account belongs to
		 *      localAccountId: Original tenant-specific accountID, usually used for legacy cases
		 *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt
		 *      authorityType: Accounts authority type as a string
		 *      name: Full name for the account, including given name and family name,
		 *      lastModificationTime: last time this entity was modified in the cache
		 *      lastModificationApp:
		 *      nativeAccountId: Account identifier on the native device
		 *      tenantProfiles: Array of tenant profile objects for each tenant that the account has authenticated with in the browser
		 * }
		 * @internal
		 */
		class AccountEntity {
		    /**
		     * Returns the AccountInfo interface for this account.
		     */
		    static getAccountInfo(accountEntity) {
		        return {
		            homeAccountId: accountEntity.homeAccountId,
		            environment: accountEntity.environment,
		            tenantId: accountEntity.realm,
		            username: accountEntity.username,
		            localAccountId: accountEntity.localAccountId,
		            loginHint: accountEntity.loginHint,
		            name: accountEntity.name,
		            nativeAccountId: accountEntity.nativeAccountId,
		            authorityType: accountEntity.authorityType,
		            // Deserialize tenant profiles array into a Map
		            tenantProfiles: new Map((accountEntity.tenantProfiles || []).map((tenantProfile) => {
		                return [tenantProfile.tenantId, tenantProfile];
		            })),
		            dataBoundary: accountEntity.dataBoundary,
		        };
		    }
		    /**
		     * Returns true if the account entity is in single tenant format (outdated), false otherwise
		     */
		    isSingleTenant() {
		        return !this.tenantProfiles;
		    }
		    /**
		     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
		     * @param accountDetails
		     */
		    static createAccount(accountDetails, authority, base64Decode) {
		        const account = new AccountEntity();
		        if (authority.authorityType === AuthorityType.Adfs) {
		            account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;
		        }
		        else if (authority.protocolMode === ProtocolMode.OIDC) {
		            account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;
		        }
		        else {
		            account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
		        }
		        let clientInfo;
		        if (accountDetails.clientInfo && base64Decode) {
		            clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);
		            if (clientInfo.xms_tdbr) {
		                account.dataBoundary =
		                    clientInfo.xms_tdbr === "EU" ? "EU" : "None";
		            }
		        }
		        account.clientInfo = accountDetails.clientInfo;
		        account.homeAccountId = accountDetails.homeAccountId;
		        account.nativeAccountId = accountDetails.nativeAccountId;
		        const env = accountDetails.environment ||
		            (authority && authority.getPreferredCache());
		        if (!env) {
		            throw createClientAuthError(invalidCacheEnvironment);
		        }
		        account.environment = env;
		        // non AAD scenarios can have empty realm
		        account.realm =
		            clientInfo?.utid ||
		                getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) ||
		                "";
		        // How do you account for MSA CID here?
		        account.localAccountId =
		            clientInfo?.uid ||
		                accountDetails.idTokenClaims?.oid ||
		                accountDetails.idTokenClaims?.sub ||
		                "";
		        /*
		         * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.
		         * In most cases it will contain a single email. This field should not be relied upon if a custom
		         * policy is configured to return more than 1 email.
		         */
		        const preferredUsername = accountDetails.idTokenClaims?.preferred_username ||
		            accountDetails.idTokenClaims?.upn;
		        const email = accountDetails.idTokenClaims?.emails
		            ? accountDetails.idTokenClaims.emails[0]
		            : null;
		        account.username = preferredUsername || email || "";
		        account.loginHint = accountDetails.idTokenClaims?.login_hint;
		        account.name = accountDetails.idTokenClaims?.name || "";
		        account.cloudGraphHostName = accountDetails.cloudGraphHostName;
		        account.msGraphHost = accountDetails.msGraphHost;
		        if (accountDetails.tenantProfiles) {
		            account.tenantProfiles = accountDetails.tenantProfiles;
		        }
		        else {
		            const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);
		            account.tenantProfiles = [tenantProfile];
		        }
		        return account;
		    }
		    /**
		     * Creates an AccountEntity object from AccountInfo
		     * @param accountInfo
		     * @param cloudGraphHostName
		     * @param msGraphHost
		     * @returns
		     */
		    static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {
		        const account = new AccountEntity();
		        account.authorityType =
		            accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;
		        account.homeAccountId = accountInfo.homeAccountId;
		        account.localAccountId = accountInfo.localAccountId;
		        account.nativeAccountId = accountInfo.nativeAccountId;
		        account.realm = accountInfo.tenantId;
		        account.environment = accountInfo.environment;
		        account.username = accountInfo.username;
		        account.name = accountInfo.name;
		        account.loginHint = accountInfo.loginHint;
		        account.cloudGraphHostName = cloudGraphHostName;
		        account.msGraphHost = msGraphHost;
		        // Serialize tenant profiles map into an array
		        account.tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);
		        account.dataBoundary = accountInfo.dataBoundary;
		        return account;
		    }
		    /**
		     * Generate HomeAccountId from server response
		     * @param serverClientInfo
		     * @param authType
		     */
		    static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {
		        // since ADFS/DSTS do not have tid and does not set client_info
		        if (!(authType === AuthorityType.Adfs ||
		            authType === AuthorityType.Dsts)) {
		            // for cases where there is clientInfo
		            if (serverClientInfo) {
		                try {
		                    const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);
		                    if (clientInfo.uid && clientInfo.utid) {
		                        return `${clientInfo.uid}.${clientInfo.utid}`;
		                    }
		                }
		                catch (e) { }
		            }
		            logger.warning("No client info in response");
		        }
		        // default to "sub" claim
		        return idTokenClaims?.sub || "";
		    }
		    /**
		     * Validates an entity: checks for all expected params
		     * @param entity
		     */
		    static isAccountEntity(entity) {
		        if (!entity) {
		            return false;
		        }
		        return (entity.hasOwnProperty("homeAccountId") &&
		            entity.hasOwnProperty("environment") &&
		            entity.hasOwnProperty("realm") &&
		            entity.hasOwnProperty("localAccountId") &&
		            entity.hasOwnProperty("username") &&
		            entity.hasOwnProperty("authorityType"));
		    }
		    /**
		     * Helper function to determine whether 2 accountInfo objects represent the same account
		     * @param accountA
		     * @param accountB
		     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
		     */
		    static accountInfoIsEqual(accountA, accountB, compareClaims) {
		        if (!accountA || !accountB) {
		            return false;
		        }
		        let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false
		        if (compareClaims) {
		            const accountAClaims = (accountA.idTokenClaims ||
		                {});
		            const accountBClaims = (accountB.idTokenClaims ||
		                {});
		            // issued at timestamp and nonce are expected to change each time a new id token is acquired
		            claimsMatch =
		                accountAClaims.iat === accountBClaims.iat &&
		                    accountAClaims.nonce === accountBClaims.nonce;
		        }
		        return (accountA.homeAccountId === accountB.homeAccountId &&
		            accountA.localAccountId === accountB.localAccountId &&
		            accountA.username === accountB.username &&
		            accountA.tenantId === accountB.tenantId &&
		            accountA.loginHint === accountB.loginHint &&
		            accountA.environment === accountB.environment &&
		            accountA.nativeAccountId === accountB.nativeAccountId &&
		            claimsMatch);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const cacheQuotaExceeded = "cache_quota_exceeded";
		const cacheErrorUnknown = "cache_error_unknown";

		var CacheErrorCodes = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    cacheErrorUnknown: cacheErrorUnknown,
		    cacheQuotaExceeded: cacheQuotaExceeded
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const CacheErrorMessages = {
		    [cacheQuotaExceeded]: "Exceeded cache storage capacity.",
		    [cacheErrorUnknown]: "Unexpected error occurred when using cache storage.",
		};
		/**
		 * Error thrown when there is an error with the cache
		 */
		class CacheError extends AuthError {
		    constructor(errorCode, errorMessage) {
		        const message = errorMessage ||
		            (CacheErrorMessages[errorCode]
		                ? CacheErrorMessages[errorCode]
		                : CacheErrorMessages[cacheErrorUnknown]);
		        super(`${errorCode}: ${message}`);
		        Object.setPrototypeOf(this, CacheError.prototype);
		        this.name = "CacheError";
		        this.errorCode = errorCode;
		        this.errorMessage = message;
		    }
		}
		/**
		 * Helper function to wrap browser errors in a CacheError object
		 * @param e
		 * @returns
		 */
		function createCacheError(e) {
		    if (!(e instanceof Error)) {
		        return new CacheError(cacheErrorUnknown);
		    }
		    if (e.name === "QuotaExceededError" ||
		        e.name === "NS_ERROR_DOM_QUOTA_REACHED" ||
		        e.message.includes("exceeded the quota")) {
		        return new CacheError(cacheQuotaExceeded);
		    }
		    else {
		        return new CacheError(e.name, e.message);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.
		 * @internal
		 */
		class CacheManager {
		    constructor(clientId, cryptoImpl, logger, performanceClient, staticAuthorityOptions) {
		        this.clientId = clientId;
		        this.cryptoImpl = cryptoImpl;
		        this.commonLogger = logger.clone(name, version);
		        this.staticAuthorityOptions = staticAuthorityOptions;
		        this.performanceClient = performanceClient;
		    }
		    /**
		     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
		     * @param accountFilter - (Optional) filter to narrow down the accounts returned
		     * @returns Array of AccountInfo objects in cache
		     */
		    getAllAccounts(accountFilter, correlationId) {
		        return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter, correlationId), correlationId, accountFilter);
		    }
		    /**
		     * Gets first tenanted AccountInfo object found based on provided filters
		     */
		    getAccountInfoFilteredBy(accountFilter, correlationId) {
		        if (Object.keys(accountFilter).length === 0 ||
		            Object.values(accountFilter).every((value) => !value)) {
		            this.commonLogger.warning("getAccountInfoFilteredBy: Account filter is empty or invalid, returning null");
		            return null;
		        }
		        const allAccounts = this.getAllAccounts(accountFilter, correlationId);
		        if (allAccounts.length > 1) {
		            // If one or more accounts are found, prioritize accounts that have an ID token
		            const sortedAccounts = allAccounts.sort((account) => {
		                return account.idTokenClaims ? -1 : 1;
		            });
		            return sortedAccounts[0];
		        }
		        else if (allAccounts.length === 1) {
		            // If only one account is found, return it regardless of whether a matching ID token was found
		            return allAccounts[0];
		        }
		        else {
		            return null;
		        }
		    }
		    /**
		     * Returns a single matching
		     * @param accountFilter
		     * @returns
		     */
		    getBaseAccountInfo(accountFilter, correlationId) {
		        const accountEntities = this.getAccountsFilteredBy(accountFilter, correlationId);
		        if (accountEntities.length > 0) {
		            return AccountEntity.getAccountInfo(accountEntities[0]);
		        }
		        else {
		            return null;
		        }
		    }
		    /**
		     * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters
		     * and builds the account info objects from the matching ID token's claims
		     * @param cachedAccounts
		     * @param accountFilter
		     * @returns Array of AccountInfo objects that match account and tenant profile filters
		     */
		    buildTenantProfiles(cachedAccounts, correlationId, accountFilter) {
		        return cachedAccounts.flatMap((accountEntity) => {
		            return this.getTenantProfilesFromAccountEntity(accountEntity, correlationId, accountFilter?.tenantId, accountFilter);
		        });
		    }
		    getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter) {
		        let tenantedAccountInfo = null;
		        let idTokenClaims;
		        if (tenantProfileFilter) {
		            if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {
		                return null;
		            }
		        }
		        const idToken = this.getIdToken(accountInfo, correlationId, tokenKeys, tenantProfile.tenantId);
		        if (idToken) {
		            idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);
		            if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {
		                // ID token sourced claims don't match so this tenant profile is not a match
		                return null;
		            }
		        }
		        // Expand tenant profile into account info based on matching tenant profile and if available matching ID token claims
		        tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken?.secret);
		        return tenantedAccountInfo;
		    }
		    getTenantProfilesFromAccountEntity(accountEntity, correlationId, targetTenantId, tenantProfileFilter) {
		        const accountInfo = AccountEntity.getAccountInfo(accountEntity);
		        let searchTenantProfiles = accountInfo.tenantProfiles || new Map();
		        const tokenKeys = this.getTokenKeys();
		        // If a tenant ID was provided, only return the tenant profile for that tenant ID if it exists
		        if (targetTenantId) {
		            const tenantProfile = searchTenantProfiles.get(targetTenantId);
		            if (tenantProfile) {
		                // Reduce search field to just this tenant profile
		                searchTenantProfiles = new Map([
		                    [targetTenantId, tenantProfile],
		                ]);
		            }
		            else {
		                // No tenant profile for search tenant ID, return empty array
		                return [];
		            }
		        }
		        const matchingTenantProfiles = [];
		        searchTenantProfiles.forEach((tenantProfile) => {
		            const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter);
		            if (tenantedAccountInfo) {
		                matchingTenantProfiles.push(tenantedAccountInfo);
		            }
		        });
		        return matchingTenantProfiles;
		    }
		    tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {
		        if (!!tenantProfileFilter.localAccountId &&
		            !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {
		            return false;
		        }
		        if (!!tenantProfileFilter.name &&
		            !(tenantProfile.name === tenantProfileFilter.name)) {
		            return false;
		        }
		        if (tenantProfileFilter.isHomeTenant !== undefined &&
		            !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {
		            return false;
		        }
		        return true;
		    }
		    idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {
		        // Tenant Profile filtering
		        if (tenantProfileFilter) {
		            if (!!tenantProfileFilter.localAccountId &&
		                !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {
		                return false;
		            }
		            if (!!tenantProfileFilter.loginHint &&
		                !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {
		                return false;
		            }
		            if (!!tenantProfileFilter.username &&
		                !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {
		                return false;
		            }
		            if (!!tenantProfileFilter.name &&
		                !this.matchName(idTokenClaims, tenantProfileFilter.name)) {
		                return false;
		            }
		            if (!!tenantProfileFilter.sid &&
		                !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {
		                return false;
		            }
		        }
		        return true;
		    }
		    /**
		     * saves a cache record
		     * @param cacheRecord {CacheRecord}
		     * @param correlationId {?string} correlation id
		     * @param kmsi - Keep Me Signed In
		     * @param storeInCache {?StoreInCache}
		     */
		    async saveCacheRecord(cacheRecord, correlationId, kmsi, storeInCache) {
		        if (!cacheRecord) {
		            throw createClientAuthError(invalidCacheRecord);
		        }
		        try {
		            if (!!cacheRecord.account) {
		                await this.setAccount(cacheRecord.account, correlationId, kmsi);
		            }
		            if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {
		                await this.setIdTokenCredential(cacheRecord.idToken, correlationId, kmsi);
		            }
		            if (!!cacheRecord.accessToken &&
		                storeInCache?.accessToken !== false) {
		                await this.saveAccessToken(cacheRecord.accessToken, correlationId, kmsi);
		            }
		            if (!!cacheRecord.refreshToken &&
		                storeInCache?.refreshToken !== false) {
		                await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId, kmsi);
		            }
		            if (!!cacheRecord.appMetadata) {
		                this.setAppMetadata(cacheRecord.appMetadata, correlationId);
		            }
		        }
		        catch (e) {
		            this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);
		            if (e instanceof AuthError) {
		                throw e;
		            }
		            else {
		                throw createCacheError(e);
		            }
		        }
		    }
		    /**
		     * saves access token credential
		     * @param credential
		     */
		    async saveAccessToken(credential, correlationId, kmsi) {
		        const accessTokenFilter = {
		            clientId: credential.clientId,
		            credentialType: credential.credentialType,
		            environment: credential.environment,
		            homeAccountId: credential.homeAccountId,
		            realm: credential.realm,
		            tokenType: credential.tokenType,
		            requestedClaimsHash: credential.requestedClaimsHash,
		        };
		        const tokenKeys = this.getTokenKeys();
		        const currentScopes = ScopeSet.fromString(credential.target);
		        tokenKeys.accessToken.forEach((key) => {
		            if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {
		                return;
		            }
		            const tokenEntity = this.getAccessTokenCredential(key, correlationId);
		            if (tokenEntity &&
		                this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
		                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
		                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
		                    this.removeAccessToken(key, correlationId);
		                }
		            }
		        });
		        await this.setAccessTokenCredential(credential, correlationId, kmsi);
		    }
		    /**
		     * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache
		     * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
		     * @param accountFilter - An object containing Account properties to filter by
		     */
		    getAccountsFilteredBy(accountFilter, correlationId) {
		        const allAccountKeys = this.getAccountKeys();
		        const matchingAccounts = [];
		        allAccountKeys.forEach((cacheKey) => {
		            const entity = this.getAccount(cacheKey, correlationId);
		            // Match base account fields
		            if (!entity) {
		                return;
		            }
		            if (!!accountFilter.homeAccountId &&
		                !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
		                return;
		            }
		            if (!!accountFilter.username &&
		                !this.matchUsername(entity.username, accountFilter.username)) {
		                return;
		            }
		            if (!!accountFilter.environment &&
		                !this.matchEnvironment(entity, accountFilter.environment)) {
		                return;
		            }
		            if (!!accountFilter.realm &&
		                !this.matchRealm(entity, accountFilter.realm)) {
		                return;
		            }
		            if (!!accountFilter.nativeAccountId &&
		                !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
		                return;
		            }
		            if (!!accountFilter.authorityType &&
		                !this.matchAuthorityType(entity, accountFilter.authorityType)) {
		                return;
		            }
		            // If at least one tenant profile matches the tenant profile filter, add the account to the list of matching accounts
		            const tenantProfileFilter = {
		                localAccountId: accountFilter?.localAccountId,
		                name: accountFilter?.name,
		            };
		            const matchingTenantProfiles = entity.tenantProfiles?.filter((tenantProfile) => {
		                return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);
		            });
		            if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {
		                // No tenant profile for this account matches filter, don't add to list of matching accounts
		                return;
		            }
		            matchingAccounts.push(entity);
		        });
		        return matchingAccounts;
		    }
		    /**
		     * Returns whether or not the given credential entity matches the filter
		     * @param entity
		     * @param filter
		     * @returns
		     */
		    credentialMatchesFilter(entity, filter) {
		        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
		            return false;
		        }
		        if (!!filter.userAssertionHash &&
		            !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {
		            return false;
		        }
		        /*
		         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of ""
		         * because we don't want a client_credential request to return a cached token that has a homeAccountId
		         */
		        if (typeof filter.homeAccountId === "string" &&
		            !this.matchHomeAccountId(entity, filter.homeAccountId)) {
		            return false;
		        }
		        if (!!filter.environment &&
		            !this.matchEnvironment(entity, filter.environment)) {
		            return false;
		        }
		        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {
		            return false;
		        }
		        if (!!filter.credentialType &&
		            !this.matchCredentialType(entity, filter.credentialType)) {
		            return false;
		        }
		        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {
		            return false;
		        }
		        /*
		         * idTokens do not have "target", target specific refreshTokens do exist for some types of authentication
		         * Resource specific refresh tokens case will be added when the support is deemed necessary
		         */
		        if (!!filter.target && !this.matchTarget(entity, filter.target)) {
		            return false;
		        }
		        // If request OR cached entity has requested Claims Hash, check if they match
		        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {
		            // Don't match if either is undefined or they are different
		            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {
		                return false;
		            }
		        }
		        // Access Token with Auth Scheme specific matching
		        if (entity.credentialType ===
		            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
		            if (!!filter.tokenType &&
		                !this.matchTokenType(entity, filter.tokenType)) {
		                return false;
		            }
		            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key
		            if (filter.tokenType === AuthenticationScheme.SSH) {
		                if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {
		                    return false;
		                }
		            }
		        }
		        return true;
		    }
		    /**
		     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
		     * @param filter
		     */
		    getAppMetadataFilteredBy(filter) {
		        const allCacheKeys = this.getKeys();
		        const matchingAppMetadata = {};
		        allCacheKeys.forEach((cacheKey) => {
		            // don't parse any non-appMetadata type cache entities
		            if (!this.isAppMetadata(cacheKey)) {
		                return;
		            }
		            // Attempt retrieval
		            const entity = this.getAppMetadata(cacheKey);
		            if (!entity) {
		                return;
		            }
		            if (!!filter.environment &&
		                !this.matchEnvironment(entity, filter.environment)) {
		                return;
		            }
		            if (!!filter.clientId &&
		                !this.matchClientId(entity, filter.clientId)) {
		                return;
		            }
		            matchingAppMetadata[cacheKey] = entity;
		        });
		        return matchingAppMetadata;
		    }
		    /**
		     * retrieve authorityMetadata that contains a matching alias
		     * @param filter
		     */
		    getAuthorityMetadataByAlias(host) {
		        const allCacheKeys = this.getAuthorityMetadataKeys();
		        let matchedEntity = null;
		        allCacheKeys.forEach((cacheKey) => {
		            // don't parse any non-authorityMetadata type cache entities
		            if (!this.isAuthorityMetadata(cacheKey) ||
		                cacheKey.indexOf(this.clientId) === -1) {
		                return;
		            }
		            // Attempt retrieval
		            const entity = this.getAuthorityMetadata(cacheKey);
		            if (!entity) {
		                return;
		            }
		            if (entity.aliases.indexOf(host) === -1) {
		                return;
		            }
		            matchedEntity = entity;
		        });
		        return matchedEntity;
		    }
		    /**
		     * Removes all accounts and related tokens from cache.
		     */
		    removeAllAccounts(correlationId) {
		        const accounts = this.getAllAccounts({}, correlationId);
		        accounts.forEach((account) => {
		            this.removeAccount(account, correlationId);
		        });
		    }
		    /**
		     * Removes the account and related tokens for a given account key
		     * @param account
		     */
		    removeAccount(account, correlationId) {
		        this.removeAccountContext(account, correlationId);
		        const accountKeys = this.getAccountKeys();
		        const keyFilter = (key) => {
		            return (key.includes(account.homeAccountId) &&
		                key.includes(account.environment));
		        };
		        accountKeys.filter(keyFilter).forEach((key) => {
		            this.removeItem(key, correlationId);
		            this.performanceClient.incrementFields({ accountsRemoved: 1 }, correlationId);
		        });
		    }
		    /**
		     * Removes credentials associated with the provided account
		     * @param account
		     */
		    removeAccountContext(account, correlationId) {
		        const allTokenKeys = this.getTokenKeys();
		        const keyFilter = (key) => {
		            return (key.includes(account.homeAccountId) &&
		                key.includes(account.environment));
		        };
		        allTokenKeys.idToken.filter(keyFilter).forEach((key) => {
		            this.removeIdToken(key, correlationId);
		        });
		        allTokenKeys.accessToken.filter(keyFilter).forEach((key) => {
		            this.removeAccessToken(key, correlationId);
		        });
		        allTokenKeys.refreshToken.filter(keyFilter).forEach((key) => {
		            this.removeRefreshToken(key, correlationId);
		        });
		    }
		    /**
		     * Removes accessToken from the cache
		     * @param key
		     * @param correlationId
		     */
		    removeAccessToken(key, correlationId) {
		        const credential = this.getAccessTokenCredential(key, correlationId);
		        this.removeItem(key, correlationId);
		        this.performanceClient.incrementFields({ accessTokensRemoved: 1 }, correlationId);
		        if (!credential ||
		            credential.credentialType.toLowerCase() !==
		                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase() ||
		            credential.tokenType !== AuthenticationScheme.POP) {
		            // If the credential is not a PoP token, we can return
		            return;
		        }
		        // Remove Token Binding Key from key store for PoP Tokens Credentials
		        const kid = credential.keyId;
		        if (kid) {
		            void this.cryptoImpl.removeTokenBindingKey(kid).catch(() => {
		                this.commonLogger.error(`Failed to remove token binding key ${kid}`, correlationId);
		                this.performanceClient?.incrementFields({ removeTokenBindingKeyFailure: 1 }, correlationId);
		            });
		        }
		    }
		    /**
		     * Removes all app metadata objects from cache.
		     */
		    removeAppMetadata(correlationId) {
		        const allCacheKeys = this.getKeys();
		        allCacheKeys.forEach((cacheKey) => {
		            if (this.isAppMetadata(cacheKey)) {
		                this.removeItem(cacheKey, correlationId);
		            }
		        });
		        return true;
		    }
		    /**
		     * Retrieve IdTokenEntity from cache
		     * @param account {AccountInfo}
		     * @param tokenKeys {?TokenKeys}
		     * @param targetRealm {?string}
		     * @param performanceClient {?IPerformanceClient}
		     * @param correlationId {?string}
		     */
		    getIdToken(account, correlationId, tokenKeys, targetRealm, performanceClient) {
		        this.commonLogger.trace("CacheManager - getIdToken called");
		        const idTokenFilter = {
		            homeAccountId: account.homeAccountId,
		            environment: account.environment,
		            credentialType: CredentialType.ID_TOKEN,
		            clientId: this.clientId,
		            realm: targetRealm,
		        };
		        const idTokenMap = this.getIdTokensByFilter(idTokenFilter, correlationId, tokenKeys);
		        const numIdTokens = idTokenMap.size;
		        if (numIdTokens < 1) {
		            this.commonLogger.info("CacheManager:getIdToken - No token found");
		            return null;
		        }
		        else if (numIdTokens > 1) {
		            let tokensToBeRemoved = idTokenMap;
		            // Multiple tenant profiles and no tenant specified, pick home account
		            if (!targetRealm) {
		                const homeIdTokenMap = new Map();
		                idTokenMap.forEach((idToken, key) => {
		                    if (idToken.realm === account.tenantId) {
		                        homeIdTokenMap.set(key, idToken);
		                    }
		                });
		                const numHomeIdTokens = homeIdTokenMap.size;
		                if (numHomeIdTokens < 1) {
		                    this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result");
		                    return idTokenMap.values().next().value;
		                }
		                else if (numHomeIdTokens === 1) {
		                    this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile");
		                    return homeIdTokenMap.values().next().value;
		                }
		                else {
		                    // Multiple ID tokens for home tenant profile, remove all and return null
		                    tokensToBeRemoved = homeIdTokenMap;
		                }
		            }
		            // Multiple tokens for a single tenant profile, remove all and return null
		            this.commonLogger.info("CacheManager:getIdToken - Multiple matching ID tokens found, clearing them");
		            tokensToBeRemoved.forEach((idToken, key) => {
		                this.removeIdToken(key, correlationId);
		            });
		            if (performanceClient && correlationId) {
		                performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);
		            }
		            return null;
		        }
		        this.commonLogger.info("CacheManager:getIdToken - Returning ID token");
		        return idTokenMap.values().next().value;
		    }
		    /**
		     * Gets all idTokens matching the given filter
		     * @param filter
		     * @returns
		     */
		    getIdTokensByFilter(filter, correlationId, tokenKeys) {
		        const idTokenKeys = (tokenKeys && tokenKeys.idToken) || this.getTokenKeys().idToken;
		        const idTokens = new Map();
		        idTokenKeys.forEach((key) => {
		            if (!this.idTokenKeyMatchesFilter(key, {
		                clientId: this.clientId,
		                ...filter,
		            })) {
		                return;
		            }
		            const idToken = this.getIdTokenCredential(key, correlationId);
		            if (idToken && this.credentialMatchesFilter(idToken, filter)) {
		                idTokens.set(key, idToken);
		            }
		        });
		        return idTokens;
		    }
		    /**
		     * Validate the cache key against filter before retrieving and parsing cache value
		     * @param key
		     * @param filter
		     * @returns
		     */
		    idTokenKeyMatchesFilter(inputKey, filter) {
		        const key = inputKey.toLowerCase();
		        if (filter.clientId &&
		            key.indexOf(filter.clientId.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.homeAccountId &&
		            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
		            return false;
		        }
		        return true;
		    }
		    /**
		     * Removes idToken from the cache
		     * @param key
		     */
		    removeIdToken(key, correlationId) {
		        this.removeItem(key, correlationId);
		    }
		    /**
		     * Removes refresh token from the cache
		     * @param key
		     */
		    removeRefreshToken(key, correlationId) {
		        this.removeItem(key, correlationId);
		    }
		    /**
		     * Retrieve AccessTokenEntity from cache
		     * @param account {AccountInfo}
		     * @param request {BaseAuthRequest}
		     * @param correlationId {?string}
		     * @param tokenKeys {?TokenKeys}
		     * @param performanceClient {?IPerformanceClient}
		     */
		    getAccessToken(account, request, tokenKeys, targetRealm) {
		        const correlationId = request.correlationId;
		        this.commonLogger.trace("CacheManager - getAccessToken called", correlationId);
		        const scopes = ScopeSet.createSearchScopes(request.scopes);
		        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
		        /*
		         * Distinguish between Bearer and PoP/SSH token cache types
		         * Cast to lowercase to handle "bearer" from ADFS
		         */
		        const credentialType = authScheme &&
		            authScheme.toLowerCase() !==
		                AuthenticationScheme.BEARER.toLowerCase()
		            ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME
		            : CredentialType.ACCESS_TOKEN;
		        const accessTokenFilter = {
		            homeAccountId: account.homeAccountId,
		            environment: account.environment,
		            credentialType: credentialType,
		            clientId: this.clientId,
		            realm: targetRealm || account.tenantId,
		            target: scopes,
		            tokenType: authScheme,
		            keyId: request.sshKid,
		            requestedClaimsHash: request.requestedClaimsHash,
		        };
		        const accessTokenKeys = (tokenKeys && tokenKeys.accessToken) ||
		            this.getTokenKeys().accessToken;
		        const accessTokens = [];
		        accessTokenKeys.forEach((key) => {
		            // Validate key
		            if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {
		                const accessToken = this.getAccessTokenCredential(key, correlationId);
		                // Validate value
		                if (accessToken &&
		                    this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
		                    accessTokens.push(accessToken);
		                }
		            }
		        });
		        const numAccessTokens = accessTokens.length;
		        if (numAccessTokens < 1) {
		            this.commonLogger.info("CacheManager:getAccessToken - No token found", correlationId);
		            return null;
		        }
		        else if (numAccessTokens > 1) {
		            this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them", correlationId);
		            accessTokens.forEach((accessToken) => {
		                this.removeAccessToken(this.generateCredentialKey(accessToken), correlationId);
		            });
		            this.performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);
		            return null;
		        }
		        this.commonLogger.info("CacheManager:getAccessToken - Returning access token", correlationId);
		        return accessTokens[0];
		    }
		    /**
		     * Validate the cache key against filter before retrieving and parsing cache value
		     * @param key
		     * @param filter
		     * @param keyMustContainAllScopes
		     * @returns
		     */
		    accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {
		        const key = inputKey.toLowerCase();
		        if (filter.clientId &&
		            key.indexOf(filter.clientId.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.homeAccountId &&
		            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.requestedClaimsHash &&
		            key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.target) {
		            const scopes = filter.target.asArray();
		            for (let i = 0; i < scopes.length; i++) {
		                if (keyMustContainAllScopes &&
		                    !key.includes(scopes[i].toLowerCase())) {
		                    // When performing a cache lookup a missing scope would be a cache miss
		                    return false;
		                }
		                else if (!keyMustContainAllScopes &&
		                    key.includes(scopes[i].toLowerCase())) {
		                    // When performing a cache write, any token with a subset of requested scopes should be replaced
		                    return true;
		                }
		            }
		        }
		        return true;
		    }
		    /**
		     * Gets all access tokens matching the filter
		     * @param filter
		     * @returns
		     */
		    getAccessTokensByFilter(filter, correlationId) {
		        const tokenKeys = this.getTokenKeys();
		        const accessTokens = [];
		        tokenKeys.accessToken.forEach((key) => {
		            if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {
		                return;
		            }
		            const accessToken = this.getAccessTokenCredential(key, correlationId);
		            if (accessToken &&
		                this.credentialMatchesFilter(accessToken, filter)) {
		                accessTokens.push(accessToken);
		            }
		        });
		        return accessTokens;
		    }
		    /**
		     * Helper to retrieve the appropriate refresh token from cache
		     * @param account {AccountInfo}
		     * @param familyRT {boolean}
		     * @param correlationId {?string}
		     * @param tokenKeys {?TokenKeys}
		     * @param performanceClient {?IPerformanceClient}
		     */
		    getRefreshToken(account, familyRT, correlationId, tokenKeys, performanceClient) {
		        this.commonLogger.trace("CacheManager - getRefreshToken called");
		        const id = familyRT ? THE_FAMILY_ID : undefined;
		        const refreshTokenFilter = {
		            homeAccountId: account.homeAccountId,
		            environment: account.environment,
		            credentialType: CredentialType.REFRESH_TOKEN,
		            clientId: this.clientId,
		            familyId: id,
		        };
		        const refreshTokenKeys = (tokenKeys && tokenKeys.refreshToken) ||
		            this.getTokenKeys().refreshToken;
		        const refreshTokens = [];
		        refreshTokenKeys.forEach((key) => {
		            // Validate key
		            if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {
		                const refreshToken = this.getRefreshTokenCredential(key, correlationId);
		                // Validate value
		                if (refreshToken &&
		                    this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
		                    refreshTokens.push(refreshToken);
		                }
		            }
		        });
		        const numRefreshTokens = refreshTokens.length;
		        if (numRefreshTokens < 1) {
		            this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
		            return null;
		        }
		        // address the else case after remove functions address environment aliases
		        if (numRefreshTokens > 1 && performanceClient && correlationId) {
		            performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);
		        }
		        this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
		        return refreshTokens[0];
		    }
		    /**
		     * Validate the cache key against filter before retrieving and parsing cache value
		     * @param key
		     * @param filter
		     */
		    refreshTokenKeyMatchesFilter(inputKey, filter) {
		        const key = inputKey.toLowerCase();
		        if (filter.familyId &&
		            key.indexOf(filter.familyId.toLowerCase()) === -1) {
		            return false;
		        }
		        // If familyId is used, clientId is not in the key
		        if (!filter.familyId &&
		            filter.clientId &&
		            key.indexOf(filter.clientId.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.homeAccountId &&
		            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
		            return false;
		        }
		        return true;
		    }
		    /**
		     * Retrieve AppMetadataEntity from cache
		     */
		    readAppMetadataFromCache(environment) {
		        const appMetadataFilter = {
		            environment,
		            clientId: this.clientId,
		        };
		        const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
		        const appMetadataEntries = Object.keys(appMetadata).map((key) => appMetadata[key]);
		        const numAppMetadata = appMetadataEntries.length;
		        if (numAppMetadata < 1) {
		            return null;
		        }
		        else if (numAppMetadata > 1) {
		            throw createClientAuthError(multipleMatchingAppMetadata);
		        }
		        return appMetadataEntries[0];
		    }
		    /**
		     * Return the family_id value associated  with FOCI
		     * @param environment
		     * @param clientId
		     */
		    isAppMetadataFOCI(environment) {
		        const appMetadata = this.readAppMetadataFromCache(environment);
		        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
		    }
		    /**
		     * helper to match account ids
		     * @param value
		     * @param homeAccountId
		     */
		    matchHomeAccountId(entity, homeAccountId) {
		        return !!(typeof entity.homeAccountId === "string" &&
		            homeAccountId === entity.homeAccountId);
		    }
		    /**
		     * helper to match account ids
		     * @param entity
		     * @param localAccountId
		     * @returns
		     */
		    matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {
		        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;
		        return localAccountId === idTokenLocalAccountId;
		    }
		    matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {
		        return tenantProfile.localAccountId === localAccountId;
		    }
		    /**
		     * helper to match names
		     * @param entity
		     * @param name
		     * @returns true if the downcased name properties are present and match in the filter and the entity
		     */
		    matchName(claims, name) {
		        return !!(name.toLowerCase() === claims.name?.toLowerCase());
		    }
		    /**
		     * helper to match usernames
		     * @param entity
		     * @param username
		     * @returns
		     */
		    matchUsername(cachedUsername, filterUsername) {
		        return !!(cachedUsername &&
		            typeof cachedUsername === "string" &&
		            filterUsername?.toLowerCase() === cachedUsername.toLowerCase());
		    }
		    /**
		     * helper to match assertion
		     * @param value
		     * @param oboAssertion
		     */
		    matchUserAssertionHash(entity, userAssertionHash) {
		        return !!(entity.userAssertionHash &&
		            userAssertionHash === entity.userAssertionHash);
		    }
		    /**
		     * helper to match environment
		     * @param value
		     * @param environment
		     */
		    matchEnvironment(entity, environment) {
		        // Check static authority options first for cases where authority metadata has not been resolved and cached yet
		        if (this.staticAuthorityOptions) {
		            const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);
		            if (staticAliases.includes(environment) &&
		                staticAliases.includes(entity.environment)) {
		                return true;
		            }
		        }
		        // Query metadata cache if no static authority configuration has aliases that match enviroment
		        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);
		        if (cloudMetadata &&
		            cloudMetadata.aliases.indexOf(entity.environment) > -1) {
		            return true;
		        }
		        return false;
		    }
		    /**
		     * helper to match credential type
		     * @param entity
		     * @param credentialType
		     */
		    matchCredentialType(entity, credentialType) {
		        return (entity.credentialType &&
		            credentialType.toLowerCase() === entity.credentialType.toLowerCase());
		    }
		    /**
		     * helper to match client ids
		     * @param entity
		     * @param clientId
		     */
		    matchClientId(entity, clientId) {
		        return !!(entity.clientId && clientId === entity.clientId);
		    }
		    /**
		     * helper to match family ids
		     * @param entity
		     * @param familyId
		     */
		    matchFamilyId(entity, familyId) {
		        return !!(entity.familyId && familyId === entity.familyId);
		    }
		    /**
		     * helper to match realm
		     * @param entity
		     * @param realm
		     */
		    matchRealm(entity, realm) {
		        return !!(entity.realm?.toLowerCase() === realm.toLowerCase());
		    }
		    /**
		     * helper to match nativeAccountId
		     * @param entity
		     * @param nativeAccountId
		     * @returns boolean indicating the match result
		     */
		    matchNativeAccountId(entity, nativeAccountId) {
		        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
		    }
		    /**
		     * helper to match loginHint which can be either:
		     * 1. login_hint ID token claim
		     * 2. username in cached account object
		     * 3. upn in ID token claims
		     * @param entity
		     * @param loginHint
		     * @returns
		     */
		    matchLoginHintFromTokenClaims(tokenClaims, loginHint) {
		        if (tokenClaims.login_hint === loginHint) {
		            return true;
		        }
		        if (tokenClaims.preferred_username === loginHint) {
		            return true;
		        }
		        if (tokenClaims.upn === loginHint) {
		            return true;
		        }
		        return false;
		    }
		    /**
		     * Helper to match sid
		     * @param entity
		     * @param sid
		     * @returns true if the sid claim is present and matches the filter
		     */
		    matchSid(idTokenClaims, sid) {
		        return idTokenClaims.sid === sid;
		    }
		    matchAuthorityType(entity, authorityType) {
		        return !!(entity.authorityType &&
		            authorityType.toLowerCase() === entity.authorityType.toLowerCase());
		    }
		    /**
		     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
		     * @param entity
		     * @param target
		     */
		    matchTarget(entity, target) {
		        const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN &&
		            entity.credentialType !==
		                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
		        if (isNotAccessTokenCredential || !entity.target) {
		            return false;
		        }
		        const entityScopeSet = ScopeSet.fromString(entity.target);
		        return entityScopeSet.containsScopeSet(target);
		    }
		    /**
		     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
		     * @param entity
		     * @param tokenType
		     */
		    matchTokenType(entity, tokenType) {
		        return !!(entity.tokenType && entity.tokenType === tokenType);
		    }
		    /**
		     * Returns true if the credential's keyId matches the one in the request, false otherwise
		     * @param entity
		     * @param keyId
		     */
		    matchKeyId(entity, keyId) {
		        return !!(entity.keyId && entity.keyId === keyId);
		    }
		    /**
		     * returns if a given cache entity is of the type appmetadata
		     * @param key
		     */
		    isAppMetadata(key) {
		        return key.indexOf(APP_METADATA) !== -1;
		    }
		    /**
		     * returns if a given cache entity is of the type authoritymetadata
		     * @param key
		     */
		    isAuthorityMetadata(key) {
		        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
		    }
		    /**
		     * returns cache key used for cloud instance metadata
		     */
		    generateAuthorityMetadataCacheKey(authority) {
		        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;
		    }
		    /**
		     * Helper to convert serialized data to object
		     * @param obj
		     * @param json
		     */
		    static toObject(obj, json) {
		        for (const propertyName in json) {
		            obj[propertyName] = json[propertyName];
		        }
		        return obj;
		    }
		}
		/** @internal */
		class DefaultStorageClass extends CacheManager {
		    async setAccount() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAccount() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    async setIdTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getIdTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    async setAccessTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAccessTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    async setRefreshTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getRefreshTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    setAppMetadata() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAppMetadata() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    setServerTelemetry() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getServerTelemetry() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    setAuthorityMetadata() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAuthorityMetadata() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAuthorityMetadataKeys() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    setThrottlingCache() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getThrottlingCache() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    removeItem() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getKeys() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAccountKeys() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getTokenKeys() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    generateCredentialKey() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    generateAccountKey() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class StubPerformanceMeasurement {
		    startMeasurement() {
		        return;
		    }
		    endMeasurement() {
		        return;
		    }
		    flushMeasurement() {
		        return null;
		    }
		}
		class StubPerformanceClient {
		    generateId() {
		        return "callback-id";
		    }
		    startMeasurement(measureName, correlationId) {
		        return {
		            end: () => null,
		            discard: () => { },
		            add: () => { },
		            increment: () => { },
		            event: {
		                eventId: this.generateId(),
		                status: PerformanceEventStatus.InProgress,
		                authority: "",
		                libraryName: "",
		                libraryVersion: "",
		                clientId: "",
		                name: measureName,
		                startTimeMs: Date.now(),
		                correlationId: correlationId || "",
		            },
		            measurement: new StubPerformanceMeasurement(),
		        };
		    }
		    startPerformanceMeasurement() {
		        return new StubPerformanceMeasurement();
		    }
		    calculateQueuedTime() {
		        return 0;
		    }
		    addQueueMeasurement() {
		        return;
		    }
		    setPreQueueTime() {
		        return;
		    }
		    endMeasurement() {
		        return null;
		    }
		    discardMeasurements() {
		        return;
		    }
		    removePerformanceCallback() {
		        return true;
		    }
		    addPerformanceCallback() {
		        return "";
		    }
		    emitEvents() {
		        return;
		    }
		    addFields() {
		        return;
		    }
		    incrementFields() {
		        return;
		    }
		    cacheEventByCorrelationId() {
		        return;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const DEFAULT_SYSTEM_OPTIONS = {
		    tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
		    preventCorsPreflight: false,
		};
		const DEFAULT_LOGGER_IMPLEMENTATION = {
		    loggerCallback: () => {
		        // allow users to not set loggerCallback
		    },
		    piiLoggingEnabled: false,
		    logLevel: exports$1.LogLevel.Info,
		    correlationId: Constants.EMPTY_STRING,
		};
		const DEFAULT_CACHE_OPTIONS = {
		    claimsBasedCachingEnabled: false,
		};
		const DEFAULT_NETWORK_IMPLEMENTATION = {
		    async sendGetRequestAsync() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async sendPostRequestAsync() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		};
		const DEFAULT_LIBRARY_INFO = {
		    sku: Constants.SKU,
		    version: version,
		    cpu: Constants.EMPTY_STRING,
		    os: Constants.EMPTY_STRING,
		};
		const DEFAULT_CLIENT_CREDENTIALS = {
		    clientSecret: Constants.EMPTY_STRING,
		    clientAssertion: undefined,
		};
		const DEFAULT_AZURE_CLOUD_OPTIONS = {
		    azureCloudInstance: AzureCloudInstance.None,
		    tenant: `${Constants.DEFAULT_COMMON_TENANT}`,
		};
		const DEFAULT_TELEMETRY_OPTIONS = {
		    application: {
		        appName: "",
		        appVersion: "",
		    },
		};
		/**
		 * Function that sets the default options when not explicitly configured from app developer
		 *
		 * @param Configuration
		 *
		 * @returns Configuration
		 */
		function buildClientConfiguration({ authOptions: userAuthOptions, systemOptions: userSystemOptions, loggerOptions: userLoggerOption, cacheOptions: userCacheOptions, storageInterface: storageImplementation, networkInterface: networkImplementation, cryptoInterface: cryptoImplementation, clientCredentials: clientCredentials, libraryInfo: libraryInfo, telemetry: telemetry, serverTelemetryManager: serverTelemetryManager, persistencePlugin: persistencePlugin, serializableCache: serializableCache, }) {
		    const loggerOptions = {
		        ...DEFAULT_LOGGER_IMPLEMENTATION,
		        ...userLoggerOption,
		    };
		    return {
		        authOptions: buildAuthOptions(userAuthOptions),
		        systemOptions: { ...DEFAULT_SYSTEM_OPTIONS, ...userSystemOptions },
		        loggerOptions: loggerOptions,
		        cacheOptions: { ...DEFAULT_CACHE_OPTIONS, ...userCacheOptions },
		        storageInterface: storageImplementation ||
		            new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions), new StubPerformanceClient()),
		        networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
		        cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
		        clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
		        libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },
		        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },
		        serverTelemetryManager: serverTelemetryManager || null,
		        persistencePlugin: persistencePlugin || null,
		        serializableCache: serializableCache || null,
		    };
		}
		/**
		 * Construct authoptions from the client and platform passed values
		 * @param authOptions
		 */
		function buildAuthOptions(authOptions) {
		    return {
		        clientCapabilities: [],
		        azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
		        skipAuthorityMetadataCache: false,
		        instanceAware: false,
		        encodeExtraQueryParams: false,
		        ...authOptions,
		    };
		}
		/**
		 * Returns true if config has protocolMode set to ProtocolMode.OIDC, false otherwise
		 * @param ClientConfiguration
		 */
		function isOidcProtocolMode(config) {
		    return (config.authOptions.authority.options.protocolMode === ProtocolMode.OIDC);
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const CcsCredentialType = {
		    HOME_ACCOUNT_ID: "home_account_id",
		    UPN: "UPN",
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function instrumentBrokerParams(parameters, correlationId, performanceClient) {
		    if (!correlationId) {
		        return;
		    }
		    const clientId = parameters.get(CLIENT_ID);
		    if (clientId && parameters.has(BROKER_CLIENT_ID)) {
		        performanceClient?.addFields({
		            embeddedClientId: clientId,
		            embeddedRedirectUri: parameters.get(REDIRECT_URI),
		        }, correlationId);
		    }
		}
		/**
		 * Add the given response_type
		 * @param parameters
		 * @param responseType
		 */
		function addResponseType(parameters, responseType) {
		    parameters.set(RESPONSE_TYPE, responseType);
		}
		/**
		 * add response_mode. defaults to query.
		 * @param responseMode
		 */
		function addResponseMode(parameters, responseMode) {
		    parameters.set(RESPONSE_MODE, responseMode ? responseMode : ResponseMode.QUERY);
		}
		/**
		 * Add flag to indicate STS should attempt to use WAM if available
		 */
		function addNativeBroker(parameters) {
		    parameters.set(NATIVE_BROKER, "1");
		}
		/**
		 * add scopes. set addOidcScopes to false to prevent default scopes in non-user scenarios
		 * @param scopeSet
		 * @param addOidcScopes
		 */
		function addScopes(parameters, scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {
		    // Always add openid to the scopes when adding OIDC scopes
		    if (addOidcScopes &&
		        !defaultScopes.includes("openid") &&
		        !scopes.includes("openid")) {
		        defaultScopes.push("openid");
		    }
		    const requestScopes = addOidcScopes
		        ? [...(scopes || []), ...defaultScopes]
		        : scopes || [];
		    const scopeSet = new ScopeSet(requestScopes);
		    parameters.set(SCOPE, scopeSet.printScopes());
		}
		/**
		 * add clientId
		 * @param clientId
		 */
		function addClientId(parameters, clientId) {
		    parameters.set(CLIENT_ID, clientId);
		}
		/**
		 * add redirect_uri
		 * @param redirectUri
		 */
		function addRedirectUri(parameters, redirectUri) {
		    parameters.set(REDIRECT_URI, redirectUri);
		}
		/**
		 * add post logout redirectUri
		 * @param redirectUri
		 */
		function addPostLogoutRedirectUri(parameters, redirectUri) {
		    parameters.set(POST_LOGOUT_URI, redirectUri);
		}
		/**
		 * add id_token_hint to logout request
		 * @param idTokenHint
		 */
		function addIdTokenHint(parameters, idTokenHint) {
		    parameters.set(ID_TOKEN_HINT, idTokenHint);
		}
		/**
		 * add domain_hint
		 * @param domainHint
		 */
		function addDomainHint(parameters, domainHint) {
		    parameters.set(DOMAIN_HINT, domainHint);
		}
		/**
		 * add login_hint
		 * @param loginHint
		 */
		function addLoginHint(parameters, loginHint) {
		    parameters.set(LOGIN_HINT, loginHint);
		}
		/**
		 * Adds the CCS (Cache Credential Service) query parameter for login_hint
		 * @param loginHint
		 */
		function addCcsUpn(parameters, loginHint) {
		    parameters.set(HeaderNames.CCS_HEADER, `UPN:${loginHint}`);
		}
		/**
		 * Adds the CCS (Cache Credential Service) query parameter for account object
		 * @param loginHint
		 */
		function addCcsOid(parameters, clientInfo) {
		    parameters.set(HeaderNames.CCS_HEADER, `Oid:${clientInfo.uid}@${clientInfo.utid}`);
		}
		/**
		 * add sid
		 * @param sid
		 */
		function addSid(parameters, sid) {
		    parameters.set(SID, sid);
		}
		/**
		 * add claims
		 * @param claims
		 */
		function addClaims(parameters, claims, clientCapabilities) {
		    const mergedClaims = addClientCapabilitiesToClaims(claims, clientCapabilities);
		    try {
		        JSON.parse(mergedClaims);
		    }
		    catch (e) {
		        throw createClientConfigurationError(invalidClaims);
		    }
		    parameters.set(CLAIMS, mergedClaims);
		}
		/**
		 * add correlationId
		 * @param correlationId
		 */
		function addCorrelationId(parameters, correlationId) {
		    parameters.set(CLIENT_REQUEST_ID, correlationId);
		}
		/**
		 * add library info query params
		 * @param libraryInfo
		 */
		function addLibraryInfo(parameters, libraryInfo) {
		    // Telemetry Info
		    parameters.set(X_CLIENT_SKU, libraryInfo.sku);
		    parameters.set(X_CLIENT_VER, libraryInfo.version);
		    if (libraryInfo.os) {
		        parameters.set(X_CLIENT_OS, libraryInfo.os);
		    }
		    if (libraryInfo.cpu) {
		        parameters.set(X_CLIENT_CPU, libraryInfo.cpu);
		    }
		}
		/**
		 * Add client telemetry parameters
		 * @param appTelemetry
		 */
		function addApplicationTelemetry(parameters, appTelemetry) {
		    if (appTelemetry?.appName) {
		        parameters.set(X_APP_NAME, appTelemetry.appName);
		    }
		    if (appTelemetry?.appVersion) {
		        parameters.set(X_APP_VER, appTelemetry.appVersion);
		    }
		}
		/**
		 * add prompt
		 * @param prompt
		 */
		function addPrompt(parameters, prompt) {
		    parameters.set(PROMPT, prompt);
		}
		/**
		 * add state
		 * @param state
		 */
		function addState(parameters, state) {
		    if (state) {
		        parameters.set(STATE, state);
		    }
		}
		/**
		 * add nonce
		 * @param nonce
		 */
		function addNonce(parameters, nonce) {
		    parameters.set(NONCE, nonce);
		}
		/**
		 * add code_challenge and code_challenge_method
		 * - throw if either of them are not passed
		 * @param codeChallenge
		 * @param codeChallengeMethod
		 */
		function addCodeChallengeParams(parameters, codeChallenge, codeChallengeMethod) {
		    if (codeChallenge && codeChallengeMethod) {
		        parameters.set(CODE_CHALLENGE, codeChallenge);
		        parameters.set(CODE_CHALLENGE_METHOD, codeChallengeMethod);
		    }
		    else {
		        throw createClientConfigurationError(pkceParamsMissing);
		    }
		}
		/**
		 * add the `authorization_code` passed by the user to exchange for a token
		 * @param code
		 */
		function addAuthorizationCode(parameters, code) {
		    parameters.set(CODE, code);
		}
		/**
		 * add the `authorization_code` passed by the user to exchange for a token
		 * @param code
		 */
		function addDeviceCode(parameters, code) {
		    parameters.set(DEVICE_CODE, code);
		}
		/**
		 * add the `refreshToken` passed by the user
		 * @param refreshToken
		 */
		function addRefreshToken(parameters, refreshToken) {
		    parameters.set(REFRESH_TOKEN, refreshToken);
		}
		/**
		 * add the `code_verifier` passed by the user to exchange for a token
		 * @param codeVerifier
		 */
		function addCodeVerifier(parameters, codeVerifier) {
		    parameters.set(CODE_VERIFIER, codeVerifier);
		}
		/**
		 * add client_secret
		 * @param clientSecret
		 */
		function addClientSecret(parameters, clientSecret) {
		    parameters.set(CLIENT_SECRET, clientSecret);
		}
		/**
		 * add clientAssertion for confidential client flows
		 * @param clientAssertion
		 */
		function addClientAssertion(parameters, clientAssertion) {
		    if (clientAssertion) {
		        parameters.set(CLIENT_ASSERTION, clientAssertion);
		    }
		}
		/**
		 * add clientAssertionType for confidential client flows
		 * @param clientAssertionType
		 */
		function addClientAssertionType(parameters, clientAssertionType) {
		    if (clientAssertionType) {
		        parameters.set(CLIENT_ASSERTION_TYPE, clientAssertionType);
		    }
		}
		/**
		 * add OBO assertion for confidential client flows
		 * @param clientAssertion
		 */
		function addOboAssertion(parameters, oboAssertion) {
		    parameters.set(OBO_ASSERTION, oboAssertion);
		}
		/**
		 * add grant type
		 * @param grantType
		 */
		function addRequestTokenUse(parameters, tokenUse) {
		    parameters.set(REQUESTED_TOKEN_USE, tokenUse);
		}
		/**
		 * add grant type
		 * @param grantType
		 */
		function addGrantType(parameters, grantType) {
		    parameters.set(GRANT_TYPE, grantType);
		}
		/**
		 * add client info
		 *
		 */
		function addClientInfo(parameters) {
		    parameters.set(CLIENT_INFO$1, "1");
		}
		function addInstanceAware(parameters) {
		    if (!parameters.has(INSTANCE_AWARE)) {
		        parameters.set(INSTANCE_AWARE, "true");
		    }
		}
		/**
		 * add extraQueryParams
		 * @param eQParams
		 */
		function addExtraQueryParameters(parameters, eQParams) {
		    Object.entries(eQParams).forEach(([key, value]) => {
		        if (!parameters.has(key) && value) {
		            parameters.set(key, value);
		        }
		    });
		}
		function addClientCapabilitiesToClaims(claims, clientCapabilities) {
		    let mergedClaims;
		    // Parse provided claims into JSON object or initialize empty object
		    if (!claims) {
		        mergedClaims = {};
		    }
		    else {
		        try {
		            mergedClaims = JSON.parse(claims);
		        }
		        catch (e) {
		            throw createClientConfigurationError(invalidClaims);
		        }
		    }
		    if (clientCapabilities && clientCapabilities.length > 0) {
		        if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
		            // Add access_token key to claims object
		            mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
		        }
		        // Add xms_cc claim with provided clientCapabilities to access_token key
		        mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] =
		            {
		                values: clientCapabilities,
		            };
		    }
		    return JSON.stringify(mergedClaims);
		}
		/**
		 * adds `username` for Password Grant flow
		 * @param username
		 */
		function addUsername(parameters, username) {
		    parameters.set(PasswordGrantConstants.username, username);
		}
		/**
		 * adds `password` for Password Grant flow
		 * @param password
		 */
		function addPassword(parameters, password) {
		    parameters.set(PasswordGrantConstants.password, password);
		}
		/**
		 * add pop_jwk to query params
		 * @param cnfString
		 */
		function addPopToken(parameters, cnfString) {
		    if (cnfString) {
		        parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);
		        parameters.set(REQ_CNF, cnfString);
		    }
		}
		/**
		 * add SSH JWK and key ID to query params
		 */
		function addSshJwk(parameters, sshJwkString) {
		    if (sshJwkString) {
		        parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);
		        parameters.set(REQ_CNF, sshJwkString);
		    }
		}
		/**
		 * add server telemetry fields
		 * @param serverTelemetryManager
		 */
		function addServerTelemetry(parameters, serverTelemetryManager) {
		    parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
		    parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
		}
		/**
		 * Adds parameter that indicates to the server that throttling is supported
		 */
		function addThrottling(parameters) {
		    parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
		}
		/**
		 * Adds logout_hint parameter for "silent" logout which prevent server account picker
		 */
		function addLogoutHint(parameters, logoutHint) {
		    parameters.set(LOGOUT_HINT, logoutHint);
		}
		function addBrokerParameters(parameters, brokerClientId, brokerRedirectUri) {
		    if (!parameters.has(BROKER_CLIENT_ID)) {
		        parameters.set(BROKER_CLIENT_ID, brokerClientId);
		    }
		    if (!parameters.has(BROKER_REDIRECT_URI)) {
		        parameters.set(BROKER_REDIRECT_URI, brokerRedirectUri);
		    }
		}
		/**
		 * Add EAR (Encrypted Authorize Response) request parameters
		 * @param parameters
		 * @param jwk
		 */
		function addEARParameters(parameters, jwk) {
		    parameters.set(EAR_JWK, encodeURIComponent(jwk));
		    // ear_jwe_crypto will always have value: {"alg":"dir","enc":"A256GCM"} so we can hardcode this
		    const jweCryptoB64Encoded = "eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0";
		    parameters.set(EAR_JWE_CRYPTO, jweCryptoB64Encoded);
		}
		/**
		 * Adds authorize body parameters to the request parameters
		 * @param parameters
		 * @param bodyParameters
		 */
		function addPostBodyParameters(parameters, bodyParameters) {
		    Object.entries(bodyParameters).forEach(([key, value]) => {
		        if (value) {
		            parameters.set(key, value);
		        }
		    });
		}

		var RequestParameterBuilder = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    addApplicationTelemetry: addApplicationTelemetry,
		    addAuthorizationCode: addAuthorizationCode,
		    addBrokerParameters: addBrokerParameters,
		    addCcsOid: addCcsOid,
		    addCcsUpn: addCcsUpn,
		    addClaims: addClaims,
		    addClientAssertion: addClientAssertion,
		    addClientAssertionType: addClientAssertionType,
		    addClientCapabilitiesToClaims: addClientCapabilitiesToClaims,
		    addClientId: addClientId,
		    addClientInfo: addClientInfo,
		    addClientSecret: addClientSecret,
		    addCodeChallengeParams: addCodeChallengeParams,
		    addCodeVerifier: addCodeVerifier,
		    addCorrelationId: addCorrelationId,
		    addDeviceCode: addDeviceCode,
		    addDomainHint: addDomainHint,
		    addEARParameters: addEARParameters,
		    addExtraQueryParameters: addExtraQueryParameters,
		    addGrantType: addGrantType,
		    addIdTokenHint: addIdTokenHint,
		    addInstanceAware: addInstanceAware,
		    addLibraryInfo: addLibraryInfo,
		    addLoginHint: addLoginHint,
		    addLogoutHint: addLogoutHint,
		    addNativeBroker: addNativeBroker,
		    addNonce: addNonce,
		    addOboAssertion: addOboAssertion,
		    addPassword: addPassword,
		    addPopToken: addPopToken,
		    addPostBodyParameters: addPostBodyParameters,
		    addPostLogoutRedirectUri: addPostLogoutRedirectUri,
		    addPrompt: addPrompt,
		    addRedirectUri: addRedirectUri,
		    addRefreshToken: addRefreshToken,
		    addRequestTokenUse: addRequestTokenUse,
		    addResponseMode: addResponseMode,
		    addResponseType: addResponseType,
		    addScopes: addScopes,
		    addServerTelemetry: addServerTelemetry,
		    addSid: addSid,
		    addSshJwk: addSshJwk,
		    addState: addState,
		    addThrottling: addThrottling,
		    addUsername: addUsername,
		    instrumentBrokerParams: instrumentBrokerParams
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Error thrown when there is an error with the server code, for example, unavailability.
		 */
		class ServerError extends AuthError {
		    constructor(errorCode, errorMessage, subError, errorNo, status) {
		        super(errorCode, errorMessage, subError);
		        this.name = "ServerError";
		        this.errorNo = errorNo;
		        this.status = status;
		        Object.setPrototypeOf(this, ServerError.prototype);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function getRequestThumbprint(clientId, request, homeAccountId) {
		    return {
		        clientId: clientId,
		        authority: request.authority,
		        scopes: request.scopes,
		        homeAccountIdentifier: homeAccountId,
		        claims: request.claims,
		        authenticationScheme: request.authenticationScheme,
		        resourceRequestMethod: request.resourceRequestMethod,
		        resourceRequestUri: request.resourceRequestUri,
		        shrClaims: request.shrClaims,
		        sshKid: request.sshKid,
		        embeddedClientId: request.embeddedClientId || request.tokenBodyParameters?.clientId,
		    };
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/** @internal */
		class ThrottlingUtils {
		    /**
		     * Prepares a RequestThumbprint to be stored as a key.
		     * @param thumbprint
		     */
		    static generateThrottlingStorageKey(thumbprint) {
		        return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;
		    }
		    /**
		     * Performs necessary throttling checks before a network request.
		     * @param cacheManager
		     * @param thumbprint
		     */
		    static preProcess(cacheManager, thumbprint, correlationId) {
		        const key = ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
		        const value = cacheManager.getThrottlingCache(key);
		        if (value) {
		            if (value.throttleTime < Date.now()) {
		                cacheManager.removeItem(key, correlationId);
		                return;
		            }
		            throw new ServerError(value.errorCodes?.join(" ") || Constants.EMPTY_STRING, value.errorMessage, value.subError);
		        }
		    }
		    /**
		     * Performs necessary throttling checks after a network request.
		     * @param cacheManager
		     * @param thumbprint
		     * @param response
		     */
		    static postProcess(cacheManager, thumbprint, response, correlationId) {
		        if (ThrottlingUtils.checkResponseStatus(response) ||
		            ThrottlingUtils.checkResponseForRetryAfter(response)) {
		            const thumbprintValue = {
		                throttleTime: ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
		                error: response.body.error,
		                errorCodes: response.body.error_codes,
		                errorMessage: response.body.error_description,
		                subError: response.body.suberror,
		            };
		            cacheManager.setThrottlingCache(ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue, correlationId);
		        }
		    }
		    /**
		     * Checks a NetworkResponse object's status codes against 429 or 5xx
		     * @param response
		     */
		    static checkResponseStatus(response) {
		        return (response.status === 429 ||
		            (response.status >= 500 && response.status < 600));
		    }
		    /**
		     * Checks a NetworkResponse object's RetryAfter header
		     * @param response
		     */
		    static checkResponseForRetryAfter(response) {
		        if (response.headers) {
		            return (response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) &&
		                (response.status < 200 || response.status >= 300));
		        }
		        return false;
		    }
		    /**
		     * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
		     * @param throttleTime
		     */
		    static calculateThrottleTime(throttleTime) {
		        const time = throttleTime <= 0 ? 0 : throttleTime;
		        const currentSeconds = Date.now() / 1000;
		        return Math.floor(Math.min(currentSeconds +
		            (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds +
		            ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1000);
		    }
		    static removeThrottle(cacheManager, clientId, request, homeAccountIdentifier) {
		        const thumbprint = getRequestThumbprint(clientId, request, homeAccountIdentifier);
		        const key = this.generateThrottlingStorageKey(thumbprint);
		        cacheManager.removeItem(key, request.correlationId);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Represents network related errors
		 */
		class NetworkError extends AuthError {
		    constructor(error, httpStatus, responseHeaders) {
		        super(error.errorCode, error.errorMessage, error.subError);
		        Object.setPrototypeOf(this, NetworkError.prototype);
		        this.name = "NetworkError";
		        this.error = error;
		        this.httpStatus = httpStatus;
		        this.responseHeaders = responseHeaders;
		    }
		}
		/**
		 * Creates NetworkError object for a failed network request
		 * @param error - Error to be thrown back to the caller
		 * @param httpStatus - Status code of the network request
		 * @param responseHeaders - Response headers of the network request, when available
		 * @returns NetworkError object
		 */
		function createNetworkError(error, httpStatus, responseHeaders, additionalError) {
		    error.errorMessage = `${error.errorMessage}, additionalErrorInfo: error.name:${additionalError?.name}, error.message:${additionalError?.message}`;
		    return new NetworkError(error, httpStatus, responseHeaders);
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Base application class which will construct requests to send to and handle responses from the Microsoft STS using the authorization code flow.
		 * @internal
		 */
		class BaseClient {
		    constructor(configuration, performanceClient) {
		        // Set the configuration
		        this.config = buildClientConfiguration(configuration);
		        // Initialize the logger
		        this.logger = new Logger(this.config.loggerOptions, name, version);
		        // Initialize crypto
		        this.cryptoUtils = this.config.cryptoInterface;
		        // Initialize storage interface
		        this.cacheManager = this.config.storageInterface;
		        // Set the network interface
		        this.networkClient = this.config.networkInterface;
		        // Set TelemetryManager
		        this.serverTelemetryManager = this.config.serverTelemetryManager;
		        // set Authority
		        this.authority = this.config.authOptions.authority;
		        // set performance telemetry client
		        this.performanceClient = performanceClient;
		    }
		    /**
		     * Creates default headers for requests to token endpoint
		     */
		    createTokenRequestHeaders(ccsCred) {
		        const headers = {};
		        headers[HeaderNames.CONTENT_TYPE] = Constants.URL_FORM_CONTENT_TYPE;
		        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
		            switch (ccsCred.type) {
		                case CcsCredentialType.HOME_ACCOUNT_ID:
		                    try {
		                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
		                        headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;
		                    }
		                    catch (e) {
		                        this.logger.verbose("Could not parse home account ID for CCS Header: " +
		                            e);
		                    }
		                    break;
		                case CcsCredentialType.UPN:
		                    headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;
		                    break;
		            }
		        }
		        return headers;
		    }
		    /**
		     * Http post to token endpoint
		     * @param tokenEndpoint
		     * @param queryString
		     * @param headers
		     * @param thumbprint
		     */
		    async executePostToTokenEndpoint(tokenEndpoint, queryString, headers, thumbprint, correlationId, queuedEvent) {
		        if (queuedEvent) {
		            this.performanceClient?.addQueueMeasurement(queuedEvent, correlationId);
		        }
		        const response = await this.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers: headers }, correlationId);
		        if (this.config.serverTelemetryManager &&
		            response.status < 500 &&
		            response.status !== 429) {
		            // Telemetry data successfully logged by server, clear Telemetry cache
		            this.config.serverTelemetryManager.clearTelemetryCache();
		        }
		        return response;
		    }
		    /**
		     * Wraps sendPostRequestAsync with necessary preflight and postflight logic
		     * @param thumbprint - Request thumbprint for throttling
		     * @param tokenEndpoint - Endpoint to make the POST to
		     * @param options - Body and Headers to include on the POST request
		     * @param correlationId - CorrelationId for telemetry
		     */
		    async sendPostRequest(thumbprint, tokenEndpoint, options, correlationId) {
		        ThrottlingUtils.preProcess(this.cacheManager, thumbprint, correlationId);
		        let response;
		        try {
		            response = await invokeAsync((this.networkClient.sendPostRequestAsync.bind(this.networkClient)), PerformanceEvents.NetworkClientSendPostRequestAsync, this.logger, this.performanceClient, correlationId)(tokenEndpoint, options);
		            const responseHeaders = response.headers || {};
		            this.performanceClient?.addFields({
		                refreshTokenSize: response.body.refresh_token?.length || 0,
		                httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
		                requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || "",
		            }, correlationId);
		        }
		        catch (e) {
		            if (e instanceof NetworkError) {
		                const responseHeaders = e.responseHeaders;
		                if (responseHeaders) {
		                    this.performanceClient?.addFields({
		                        httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
		                        requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] ||
		                            "",
		                        contentTypeHeader: responseHeaders[HeaderNames.CONTENT_TYPE] ||
		                            undefined,
		                        contentLengthHeader: responseHeaders[HeaderNames.CONTENT_LENGTH] ||
		                            undefined,
		                        httpStatus: e.httpStatus,
		                    }, correlationId);
		                }
		                throw e.error;
		            }
		            if (e instanceof AuthError) {
		                throw e;
		            }
		            else {
		                throw createClientAuthError(networkError);
		            }
		        }
		        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response, correlationId);
		        return response;
		    }
		    /**
		     * Updates the authority object of the client. Endpoint discovery must be completed.
		     * @param updatedAuthority
		     */
		    async updateAuthority(cloudInstanceHostname, correlationId) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, correlationId);
		        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;
		        const cloudInstanceAuthority = await createDiscoveredInstance(cloudInstanceAuthorityUri, this.networkClient, this.cacheManager, this.authority.options, this.logger, correlationId, this.performanceClient);
		        this.authority = cloudInstanceAuthority;
		    }
		    /**
		     * Creates query string for the /token request
		     * @param request
		     */
		    createTokenQueryParameters(request) {
		        const parameters = new Map();
		        if (request.embeddedClientId) {
		            addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
		        }
		        if (request.tokenQueryParameters) {
		            addExtraQueryParameters(parameters, request.tokenQueryParameters);
		        }
		        addCorrelationId(parameters, request.correlationId);
		        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
		        return mapToQueryString(parameters);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		// Codes defined by MSAL
		const noTokensFound = "no_tokens_found";
		const nativeAccountUnavailable = "native_account_unavailable";
		const refreshTokenExpired = "refresh_token_expired";
		const uxNotAllowed = "ux_not_allowed";
		// Codes potentially returned by server
		const interactionRequired = "interaction_required";
		const consentRequired = "consent_required";
		const loginRequired = "login_required";
		const badToken = "bad_token";

		var InteractionRequiredAuthErrorCodes = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    badToken: badToken,
		    consentRequired: consentRequired,
		    interactionRequired: interactionRequired,
		    loginRequired: loginRequired,
		    nativeAccountUnavailable: nativeAccountUnavailable,
		    noTokensFound: noTokensFound,
		    refreshTokenExpired: refreshTokenExpired,
		    uxNotAllowed: uxNotAllowed
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * InteractionRequiredServerErrorMessage contains string constants used by error codes and messages returned by the server indicating interaction is required
		 */
		const InteractionRequiredServerErrorMessage = [
		    interactionRequired,
		    consentRequired,
		    loginRequired,
		    badToken,
		    uxNotAllowed,
		];
		const InteractionRequiredAuthSubErrorMessage = [
		    "message_only",
		    "additional_action",
		    "basic_action",
		    "user_password_expired",
		    "consent_required",
		    "bad_token",
		];
		const InteractionRequiredAuthErrorMessages = {
		    [noTokensFound]: "No refresh token found in the cache. Please sign-in.",
		    [nativeAccountUnavailable]: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",
		    [refreshTokenExpired]: "Refresh token has expired.",
		    [badToken]: "Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve.",
		    [uxNotAllowed]: "`canShowUI` flag in Edge was set to false. User interaction required on web page. Please invoke an interactive API to resolve.",
		};
		/**
		 * Interaction required errors defined by the SDK
		 * @deprecated Use InteractionRequiredAuthErrorCodes instead
		 */
		const InteractionRequiredAuthErrorMessage = {
		    noTokensFoundError: {
		        code: noTokensFound,
		        desc: InteractionRequiredAuthErrorMessages[noTokensFound],
		    },
		    native_account_unavailable: {
		        code: nativeAccountUnavailable,
		        desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable],
		    },
		    bad_token: {
		        code: badToken,
		        desc: InteractionRequiredAuthErrorMessages[badToken],
		    },
		};
		/**
		 * Error thrown when user interaction is required.
		 */
		class InteractionRequiredAuthError extends AuthError {
		    constructor(errorCode, errorMessage, subError, timestamp, traceId, correlationId, claims, errorNo) {
		        super(errorCode, errorMessage, subError);
		        Object.setPrototypeOf(this, InteractionRequiredAuthError.prototype);
		        this.timestamp = timestamp || Constants.EMPTY_STRING;
		        this.traceId = traceId || Constants.EMPTY_STRING;
		        this.correlationId = correlationId || Constants.EMPTY_STRING;
		        this.claims = claims || Constants.EMPTY_STRING;
		        this.name = "InteractionRequiredAuthError";
		        this.errorNo = errorNo;
		    }
		}
		/**
		 * Helper function used to determine if an error thrown by the server requires interaction to resolve
		 * @param errorCode
		 * @param errorString
		 * @param subError
		 */
		function isInteractionRequiredError(errorCode, errorString, subError) {
		    const isInteractionRequiredErrorCode = !!errorCode &&
		        InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
		    const isInteractionRequiredSubError = !!subError &&
		        InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
		    const isInteractionRequiredErrorDesc = !!errorString &&
		        InteractionRequiredServerErrorMessage.some((irErrorCode) => {
		            return errorString.indexOf(irErrorCode) > -1;
		        });
		    return (isInteractionRequiredErrorCode ||
		        isInteractionRequiredErrorDesc ||
		        isInteractionRequiredSubError);
		}
		/**
		 * Creates an InteractionRequiredAuthError
		 */
		function createInteractionRequiredAuthError(errorCode) {
		    return new InteractionRequiredAuthError(errorCode, InteractionRequiredAuthErrorMessages[errorCode]);
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Class which provides helpers for OAuth 2.0 protocol specific values
		 */
		class ProtocolUtils {
		    /**
		     * Appends user state with random guid, or returns random guid.
		     * @param userState
		     * @param randomGuid
		     */
		    static setRequestState(cryptoObj, userState, meta) {
		        const libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);
		        return userState
		            ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}`
		            : libraryState;
		    }
		    /**
		     * Generates the state value used by the common library.
		     * @param randomGuid
		     * @param cryptoObj
		     */
		    static generateLibraryState(cryptoObj, meta) {
		        if (!cryptoObj) {
		            throw createClientAuthError(noCryptoObject);
		        }
		        // Create a state object containing a unique id and the timestamp of the request creation
		        const stateObj = {
		            id: cryptoObj.createNewGuid(),
		        };
		        if (meta) {
		            stateObj.meta = meta;
		        }
		        const stateString = JSON.stringify(stateObj);
		        return cryptoObj.base64Encode(stateString);
		    }
		    /**
		     * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
		     * @param state
		     * @param cryptoObj
		     */
		    static parseRequestState(cryptoObj, state) {
		        if (!cryptoObj) {
		            throw createClientAuthError(noCryptoObject);
		        }
		        if (!state) {
		            throw createClientAuthError(invalidState);
		        }
		        try {
		            // Split the state between library state and user passed state and decode them separately
		            const splitState = state.split(Constants.RESOURCE_DELIM);
		            const libraryState = splitState[0];
		            const userState = splitState.length > 1
		                ? splitState.slice(1).join(Constants.RESOURCE_DELIM)
		                : Constants.EMPTY_STRING;
		            const libraryStateString = cryptoObj.base64Decode(libraryState);
		            const libraryStateObj = JSON.parse(libraryStateString);
		            return {
		                userRequestState: userState || Constants.EMPTY_STRING,
		                libraryState: libraryStateObj,
		            };
		        }
		        catch (e) {
		            throw createClientAuthError(invalidState);
		        }
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const KeyLocation = {
		    SW: "sw"};
		/** @internal */
		class PopTokenGenerator {
		    constructor(cryptoUtils, performanceClient) {
		        this.cryptoUtils = cryptoUtils;
		        this.performanceClient = performanceClient;
		    }
		    /**
		     * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
		     * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
		     * @param request
		     * @returns
		     */
		    async generateCnf(request, logger) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
		        const reqCnf = await invokeAsync(this.generateKid.bind(this), PerformanceEvents.PopTokenGenerateCnf, logger, this.performanceClient, request.correlationId)(request);
		        const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));
		        return {
		            kid: reqCnf.kid,
		            reqCnfString,
		        };
		    }
		    /**
		     * Generates key_id for a SHR token request
		     * @param request
		     * @returns
		     */
		    async generateKid(request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request.correlationId);
		        const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request);
		        return {
		            kid: kidThumbprint,
		            xms_ksl: KeyLocation.SW,
		        };
		    }
		    /**
		     * Signs the POP access_token with the local generated key-pair
		     * @param accessToken
		     * @param request
		     * @returns
		     */
		    async signPopToken(accessToken, keyId, request) {
		        return this.signPayload(accessToken, keyId, request);
		    }
		    /**
		     * Utility function to generate the signed JWT for an access_token
		     * @param payload
		     * @param kid
		     * @param request
		     * @param claims
		     * @returns
		     */
		    async signPayload(payload, keyId, request, claims) {
		        // Deconstruct request to extract SHR parameters
		        const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions, } = request;
		        const resourceUrlString = resourceRequestUri
		            ? new UrlString(resourceRequestUri)
		            : undefined;
		        const resourceUrlComponents = resourceUrlString?.getUrlComponents();
		        return this.cryptoUtils.signJwt({
		            at: payload,
		            ts: nowSeconds(),
		            m: resourceRequestMethod?.toUpperCase(),
		            u: resourceUrlComponents?.HostNameAndPort,
		            nonce: shrNonce || this.cryptoUtils.createNewGuid(),
		            p: resourceUrlComponents?.AbsolutePath,
		            q: resourceUrlComponents?.QueryString
		                ? [[], resourceUrlComponents.QueryString]
		                : undefined,
		            client_claims: shrClaims || undefined,
		            ...claims,
		        }, keyId, shrOptions, request.correlationId);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * This class instance helps track the memory changes facilitating
		 * decisions to read from and write to the persistent cache
		 */ class TokenCacheContext {
		    constructor(tokenCache, hasChanged) {
		        this.cache = tokenCache;
		        this.hasChanged = hasChanged;
		    }
		    /**
		     * boolean which indicates the changes in cache
		     */
		    get cacheHasChanged() {
		        return this.hasChanged;
		    }
		    /**
		     * function to retrieve the token cache
		     */
		    get tokenCache() {
		        return this.cache;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Class that handles response parsing.
		 * @internal
		 */
		class ResponseHandler {
		    constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {
		        this.clientId = clientId;
		        this.cacheStorage = cacheStorage;
		        this.cryptoObj = cryptoObj;
		        this.logger = logger;
		        this.serializableCache = serializableCache;
		        this.persistencePlugin = persistencePlugin;
		        this.performanceClient = performanceClient;
		    }
		    /**
		     * Function which validates server authorization token response.
		     * @param serverResponse
		     * @param refreshAccessToken
		     */
		    validateTokenResponse(serverResponse, refreshAccessToken) {
		        // Check for error
		        if (serverResponse.error ||
		            serverResponse.error_description ||
		            serverResponse.suberror) {
		            const errString = `Error(s): ${serverResponse.error_codes || Constants.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants.NOT_AVAILABLE}`;
		            const serverErrorNo = serverResponse.error_codes?.length
		                ? serverResponse.error_codes[0]
		                : undefined;
		            const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);
		            // check if 500 error
		            if (refreshAccessToken &&
		                serverResponse.status &&
		                serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START &&
		                serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {
		                this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\n${serverError}`);
		                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed
		                return;
		                // check if 400 error
		            }
		            else if (refreshAccessToken &&
		                serverResponse.status &&
		                serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START &&
		                serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {
		                this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\n${serverError}`);
		                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed
		                return;
		            }
		            if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
		                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING, serverErrorNo);
		            }
		            throw serverError;
		        }
		    }
		    /**
		     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
		     * @param serverTokenResponse
		     * @param authority
		     */
		    async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
		        // create an idToken object (not entity)
		        let idTokenClaims;
		        if (serverTokenResponse.id_token) {
		            idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj.base64Decode);
		            // token nonce check (TODO: Add a warning if no nonce is given?)
		            if (authCodePayload && authCodePayload.nonce) {
		                if (idTokenClaims.nonce !== authCodePayload.nonce) {
		                    throw createClientAuthError(nonceMismatch);
		                }
		            }
		            // token max_age check
		            if (request.maxAge || request.maxAge === 0) {
		                const authTime = idTokenClaims.auth_time;
		                if (!authTime) {
		                    throw createClientAuthError(authTimeNotFound);
		                }
		                checkMaxAge(authTime, request.maxAge);
		            }
		        }
		        // generate homeAccountId
		        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
		        // save the response tokens
		        let requestStateObj;
		        if (!!authCodePayload && !!authCodePayload.state) {
		            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
		        }
		        // Add keyId from request to serverTokenResponse if defined
		        serverTokenResponse.key_id =
		            serverTokenResponse.key_id || request.sshKid || undefined;
		        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);
		        let cacheContext;
		        try {
		            if (this.persistencePlugin && this.serializableCache) {
		                this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
		                cacheContext = new TokenCacheContext(this.serializableCache, true);
		                await this.persistencePlugin.beforeCacheAccess(cacheContext);
		            }
		            /*
		             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.
		             * If not present, we should return null, as it's the case that another application called removeAccount in between
		             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by
		             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.
		             */
		            if (handlingRefreshTokenResponse &&
		                !forceCacheRefreshTokenResponse &&
		                cacheRecord.account) {
		                const key = this.cacheStorage.generateAccountKey(AccountEntity.getAccountInfo(cacheRecord.account));
		                const account = this.cacheStorage.getAccount(key, request.correlationId);
		                if (!account) {
		                    this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
		                    return await ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, undefined, serverRequestId);
		                }
		            }
		            await this.cacheStorage.saveCacheRecord(cacheRecord, request.correlationId, isKmsi(idTokenClaims || {}), request.storeInCache);
		        }
		        finally {
		            if (this.persistencePlugin &&
		                this.serializableCache &&
		                cacheContext) {
		                this.logger.verbose("Persistence enabled, calling afterCacheAccess");
		                await this.persistencePlugin.afterCacheAccess(cacheContext);
		            }
		        }
		        return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);
		    }
		    /**
		     * Generates CacheRecord
		     * @param serverTokenResponse
		     * @param idTokenObj
		     * @param authority
		     */
		    generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {
		        const env = authority.getPreferredCache();
		        if (!env) {
		            throw createClientAuthError(invalidCacheEnvironment);
		        }
		        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);
		        // IdToken: non AAD scenarios can have empty realm
		        let cachedIdToken;
		        let cachedAccount;
		        if (serverTokenResponse.id_token && !!idTokenClaims) {
		            cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || "");
		            cachedAccount = buildAccountToCache(this.cacheStorage, authority, this.homeAccountIdentifier, this.cryptoObj.base64Decode, request.correlationId, idTokenClaims, serverTokenResponse.client_info, env, claimsTenantId, authCodePayload, undefined, // nativeAccountId
		            this.logger);
		        }
		        // AccessToken
		        let cachedAccessToken = null;
		        if (serverTokenResponse.access_token) {
		            // If scopes not returned in server response, use request scopes
		            const responseScopes = serverTokenResponse.scope
		                ? ScopeSet.fromString(serverTokenResponse.scope)
		                : new ScopeSet(request.scopes || []);
		            /*
		             * Use timestamp calculated before request
		             * Server may return timestamps as strings, parse to numbers if so.
		             */
		            const expiresIn = (typeof serverTokenResponse.expires_in === "string"
		                ? parseInt(serverTokenResponse.expires_in, 10)
		                : serverTokenResponse.expires_in) || 0;
		            const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string"
		                ? parseInt(serverTokenResponse.ext_expires_in, 10)
		                : serverTokenResponse.ext_expires_in) || 0;
		            const refreshIn = (typeof serverTokenResponse.refresh_in === "string"
		                ? parseInt(serverTokenResponse.refresh_in, 10)
		                : serverTokenResponse.refresh_in) || undefined;
		            const tokenExpirationSeconds = reqTimestamp + expiresIn;
		            const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
		            const refreshOnSeconds = refreshIn && refreshIn > 0
		                ? reqTimestamp + refreshIn
		                : undefined;
		            // non AAD scenarios can have empty realm
		            cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || "", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
		        }
		        // refreshToken
		        let cachedRefreshToken = null;
		        if (serverTokenResponse.refresh_token) {
		            let rtExpiresOn;
		            if (serverTokenResponse.refresh_token_expires_in) {
		                const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in ===
		                    "string"
		                    ? parseInt(serverTokenResponse.refresh_token_expires_in, 10)
		                    : serverTokenResponse.refresh_token_expires_in;
		                rtExpiresOn = reqTimestamp + rtExpiresIn;
		            }
		            cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);
		        }
		        // appMetadata
		        let cachedAppMetadata = null;
		        if (serverTokenResponse.foci) {
		            cachedAppMetadata = {
		                clientId: this.clientId,
		                environment: env,
		                familyId: serverTokenResponse.foci,
		            };
		        }
		        return {
		            account: cachedAccount,
		            idToken: cachedIdToken,
		            accessToken: cachedAccessToken,
		            refreshToken: cachedRefreshToken,
		            appMetadata: cachedAppMetadata,
		        };
		    }
		    /**
		     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
		     *
		     * Optionally takes a state string that is set as-is in the response.
		     *
		     * @param cacheRecord
		     * @param idTokenObj
		     * @param fromTokenCache
		     * @param stateString
		     */
		    static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {
		        let accessToken = Constants.EMPTY_STRING;
		        let responseScopes = [];
		        let expiresOn = null;
		        let extExpiresOn;
		        let refreshOn;
		        let familyId = Constants.EMPTY_STRING;
		        if (cacheRecord.accessToken) {
		            /*
		             * if the request object has `popKid` property, `signPopToken` will be set to false and
		             * the token will be returned unsigned
		             */
		            if (cacheRecord.accessToken.tokenType ===
		                AuthenticationScheme.POP &&
		                !request.popKid) {
		                const popTokenGenerator = new PopTokenGenerator(cryptoObj);
		                const { secret, keyId } = cacheRecord.accessToken;
		                if (!keyId) {
		                    throw createClientAuthError(keyIdMissing);
		                }
		                accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);
		            }
		            else {
		                accessToken = cacheRecord.accessToken.secret;
		            }
		            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
		            // Access token expiresOn cached in seconds, converting to Date for AuthenticationResult
		            expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);
		            extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
		            if (cacheRecord.accessToken.refreshOn) {
		                refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);
		            }
		        }
		        if (cacheRecord.appMetadata) {
		            familyId =
		                cacheRecord.appMetadata.familyId === THE_FAMILY_ID
		                    ? THE_FAMILY_ID
		                    : "";
		        }
		        const uid = idTokenClaims?.oid || idTokenClaims?.sub || "";
		        const tid = idTokenClaims?.tid || "";
		        // for hybrid + native bridge enablement, send back the native account Id
		        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {
		            cacheRecord.account.nativeAccountId =
		                serverTokenResponse?.spa_accountid;
		        }
		        const accountInfo = cacheRecord.account
		            ? updateAccountTenantProfileData(AccountEntity.getAccountInfo(cacheRecord.account), undefined, // tenantProfile optional
		            idTokenClaims, cacheRecord.idToken?.secret)
		            : null;
		        return {
		            authority: authority.canonicalAuthority,
		            uniqueId: uid,
		            tenantId: tid,
		            scopes: responseScopes,
		            account: accountInfo,
		            idToken: cacheRecord?.idToken?.secret || "",
		            idTokenClaims: idTokenClaims || {},
		            accessToken: accessToken,
		            fromCache: fromTokenCache,
		            expiresOn: expiresOn,
		            extExpiresOn: extExpiresOn,
		            refreshOn: refreshOn,
		            correlationId: request.correlationId,
		            requestId: requestId || Constants.EMPTY_STRING,
		            familyId: familyId,
		            tokenType: cacheRecord.accessToken?.tokenType || Constants.EMPTY_STRING,
		            state: requestState
		                ? requestState.userRequestState
		                : Constants.EMPTY_STRING,
		            cloudGraphHostName: cacheRecord.account?.cloudGraphHostName ||
		                Constants.EMPTY_STRING,
		            msGraphHost: cacheRecord.account?.msGraphHost || Constants.EMPTY_STRING,
		            code: serverTokenResponse?.spa_code,
		            fromNativeBroker: false,
		        };
		    }
		}
		function buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode, correlationId, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger) {
		    logger?.verbose("setCachedAccount called");
		    // Check if base account is already cached
		    const accountKeys = cacheStorage.getAccountKeys();
		    const baseAccountKey = accountKeys.find((accountKey) => {
		        return accountKey.startsWith(homeAccountId);
		    });
		    let cachedAccount = null;
		    if (baseAccountKey) {
		        cachedAccount = cacheStorage.getAccount(baseAccountKey, correlationId);
		    }
		    const baseAccount = cachedAccount ||
		        AccountEntity.createAccount({
		            homeAccountId,
		            idTokenClaims,
		            clientInfo,
		            environment,
		            cloudGraphHostName: authCodePayload?.cloud_graph_host_name,
		            msGraphHost: authCodePayload?.msgraph_host,
		            nativeAccountId: nativeAccountId,
		        }, authority, base64Decode);
		    const tenantProfiles = baseAccount.tenantProfiles || [];
		    const tenantId = claimsTenantId || baseAccount.realm;
		    if (tenantId &&
		        !tenantProfiles.find((tenantProfile) => {
		            return tenantProfile.tenantId === tenantId;
		        })) {
		        const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);
		        tenantProfiles.push(newTenantProfile);
		    }
		    baseAccount.tenantProfiles = tenantProfiles;
		    return baseAccount;
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		async function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {
		    if (typeof clientAssertion === "string") {
		        return clientAssertion;
		    }
		    else {
		        const config = {
		            clientId: clientId,
		            tokenEndpoint: tokenEndpoint,
		        };
		        return clientAssertion(config);
		    }
		}

		var ClientAssertionUtils = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    getClientAssertion: getClientAssertion
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Oauth2.0 Authorization Code client
		 * @internal
		 */
		class AuthorizationCodeClient extends BaseClient {
		    constructor(configuration, performanceClient) {
		        super(configuration, performanceClient);
		        // Flag to indicate if client is for hybrid spa auth code redemption
		        this.includeRedirectUri = true;
		        this.oidcDefaultScopes =
		            this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;
		    }
		    /**
		     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
		     * authorization_code_grant
		     * @param request
		     */
		    async acquireToken(request, authCodePayload) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);
		        if (!request.code) {
		            throw createClientAuthError(requestCannotBeMade);
		        }
		        const reqTimestamp = nowSeconds();
		        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);
		        // Retrieve requestId from response headers
		        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
		        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
		        // Validate response. This function throws a server error if an error is returned by the server.
		        responseHandler.validateTokenResponse(response.body);
		        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId);
		    }
		    /**
		     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
		     * Default behaviour is to redirect the user to `window.location.href`.
		     * @param authorityUri
		     */
		    getLogoutUri(logoutRequest) {
		        // Throw error if logoutRequest is null/undefined
		        if (!logoutRequest) {
		            throw createClientConfigurationError(logoutRequestEmpty);
		        }
		        const queryString = this.createLogoutUrlQueryString(logoutRequest);
		        // Construct logout URI
		        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
		    }
		    /**
		     * Executes POST request to token endpoint
		     * @param authority
		     * @param request
		     */
		    async executeTokenRequest(authority, request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);
		        const queryParametersString = this.createTokenQueryParameters(request);
		        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
		        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
		        let ccsCredential = undefined;
		        if (request.clientInfo) {
		            try {
		                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
		                ccsCredential = {
		                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
		                    type: CcsCredentialType.HOME_ACCOUNT_ID,
		                };
		            }
		            catch (e) {
		                this.logger.verbose("Could not parse client info for CCS Header: " + e);
		            }
		        }
		        const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
		        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
		        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);
		    }
		    /**
		     * Generates a map for all the params to be sent to the service
		     * @param request
		     */
		    async createTokenRequestBody(request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);
		        const parameters = new Map();
		        addClientId(parameters, request.embeddedClientId ||
		            request.tokenBodyParameters?.[CLIENT_ID] ||
		            this.config.authOptions.clientId);
		        /*
		         * For hybrid spa flow, there will be a code but no verifier
		         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI
		         */
		        if (!this.includeRedirectUri) {
		            // Just validate
		            if (!request.redirectUri) {
		                throw createClientConfigurationError(redirectUriEmpty);
		            }
		        }
		        else {
		            // Validate and include redirect uri
		            addRedirectUri(parameters, request.redirectUri);
		        }
		        // Add scope array, parameter builder will add default scopes and dedupe
		        addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);
		        // add code: user set, not validated
		        addAuthorizationCode(parameters, request.code);
		        // Add library metadata
		        addLibraryInfo(parameters, this.config.libraryInfo);
		        addApplicationTelemetry(parameters, this.config.telemetry.application);
		        addThrottling(parameters);
		        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
		            addServerTelemetry(parameters, this.serverTelemetryManager);
		        }
		        // add code_verifier if passed
		        if (request.codeVerifier) {
		            addCodeVerifier(parameters, request.codeVerifier);
		        }
		        if (this.config.clientCredentials.clientSecret) {
		            addClientSecret(parameters, this.config.clientCredentials.clientSecret);
		        }
		        if (this.config.clientCredentials.clientAssertion) {
		            const clientAssertion = this.config.clientCredentials.clientAssertion;
		            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
		            addClientAssertionType(parameters, clientAssertion.assertionType);
		        }
		        addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);
		        addClientInfo(parameters);
		        if (request.authenticationScheme === AuthenticationScheme.POP) {
		            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
		            let reqCnfData;
		            if (!request.popKid) {
		                const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
		                reqCnfData = generatedReqCnfData.reqCnfString;
		            }
		            else {
		                reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
		            }
		            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)
		            addPopToken(parameters, reqCnfData);
		        }
		        else if (request.authenticationScheme === AuthenticationScheme.SSH) {
		            if (request.sshJwk) {
		                addSshJwk(parameters, request.sshJwk);
		            }
		            else {
		                throw createClientConfigurationError(missingSshJwk);
		            }
		        }
		        if (!StringUtils.isEmptyObj(request.claims) ||
		            (this.config.authOptions.clientCapabilities &&
		                this.config.authOptions.clientCapabilities.length > 0)) {
		            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
		        }
		        let ccsCred = undefined;
		        if (request.clientInfo) {
		            try {
		                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
		                ccsCred = {
		                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
		                    type: CcsCredentialType.HOME_ACCOUNT_ID,
		                };
		            }
		            catch (e) {
		                this.logger.verbose("Could not parse client info for CCS Header: " + e);
		            }
		        }
		        else {
		            ccsCred = request.ccsCredential;
		        }
		        // Adds these as parameters in the request instead of headers to prevent CORS preflight request
		        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
		            switch (ccsCred.type) {
		                case CcsCredentialType.HOME_ACCOUNT_ID:
		                    try {
		                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
		                        addCcsOid(parameters, clientInfo);
		                    }
		                    catch (e) {
		                        this.logger.verbose("Could not parse home account ID for CCS Header: " +
		                            e);
		                    }
		                    break;
		                case CcsCredentialType.UPN:
		                    addCcsUpn(parameters, ccsCred.credential);
		                    break;
		            }
		        }
		        if (request.embeddedClientId) {
		            addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
		        }
		        if (request.tokenBodyParameters) {
		            addExtraQueryParameters(parameters, request.tokenBodyParameters);
		        }
		        // Add hybrid spa parameters if not already provided
		        if (request.enableSpaAuthorizationCode &&
		            (!request.tokenBodyParameters ||
		                !request.tokenBodyParameters[RETURN_SPA_CODE])) {
		            addExtraQueryParameters(parameters, {
		                [RETURN_SPA_CODE]: "1",
		            });
		        }
		        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
		        return mapToQueryString(parameters);
		    }
		    /**
		     * This API validates the `EndSessionRequest` and creates a URL
		     * @param request
		     */
		    createLogoutUrlQueryString(request) {
		        const parameters = new Map();
		        if (request.postLogoutRedirectUri) {
		            addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);
		        }
		        if (request.correlationId) {
		            addCorrelationId(parameters, request.correlationId);
		        }
		        if (request.idTokenHint) {
		            addIdTokenHint(parameters, request.idTokenHint);
		        }
		        if (request.state) {
		            addState(parameters, request.state);
		        }
		        if (request.logoutHint) {
		            addLogoutHint(parameters, request.logoutHint);
		        }
		        if (request.extraQueryParameters) {
		            addExtraQueryParameters(parameters, request.extraQueryParameters);
		        }
		        if (this.config.authOptions.instanceAware) {
		            addInstanceAware(parameters);
		        }
		        return mapToQueryString(parameters, this.config.authOptions.encodeExtraQueryParams, request.extraQueryParameters);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300; // 5 Minutes
		/**
		 * OAuth2.0 refresh token client
		 * @internal
		 */
		class RefreshTokenClient extends BaseClient {
		    constructor(configuration, performanceClient) {
		        super(configuration, performanceClient);
		    }
		    async acquireToken(request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
		        const reqTimestamp = nowSeconds();
		        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(request, this.authority);
		        // Retrieve requestId from response headers
		        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
		        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
		        responseHandler.validateTokenResponse(response.body);
		        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, undefined, undefined, true, request.forceCache, requestId);
		    }
		    /**
		     * Gets cached refresh token and attaches to request, then calls acquireToken API
		     * @param request
		     */
		    async acquireTokenByRefreshToken(request) {
		        // Cannot renew token if no request object is given.
		        if (!request) {
		            throw createClientConfigurationError(tokenRequestEmpty);
		        }
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);
		        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases
		        if (!request.account) {
		            throw createClientAuthError(noAccountInSilentRequest);
		        }
		        // try checking if FOCI is enabled for the given application
		        const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);
		        // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest
		        if (isFOCI) {
		            try {
		                return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, true);
		            }
		            catch (e) {
		                const noFamilyRTInCache = e instanceof InteractionRequiredAuthError &&
		                    e.errorCode ===
		                        noTokensFound;
		                const clientMismatchErrorWithFamilyRT = e instanceof ServerError &&
		                    e.errorCode === Errors.INVALID_GRANT_ERROR &&
		                    e.subError === Errors.CLIENT_MISMATCH_ERROR;
		                // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)
		                if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
		                    return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
		                    // throw in all other cases
		                }
		                else {
		                    throw e;
		                }
		            }
		        }
		        // fall back to application refresh token acquisition
		        return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
		    }
		    /**
		     * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
		     * @param request
		     */
		    async acquireTokenWithCachedRefreshToken(request, foci) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
		        // fetches family RT or application RT based on FOCI value
		        const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request.correlationId)(request.account, foci, request.correlationId, undefined, this.performanceClient);
		        if (!refreshToken) {
		            throw createInteractionRequiredAuthError(noTokensFound);
		        }
		        if (refreshToken.expiresOn &&
		            isTokenExpired(refreshToken.expiresOn, request.refreshTokenExpirationOffsetSeconds ||
		                DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS)) {
		            this.performanceClient?.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
		            throw createInteractionRequiredAuthError(refreshTokenExpired);
		        }
		        // attach cached RT size to the current measurement
		        const refreshTokenRequest = {
		            ...request,
		            refreshToken: refreshToken.secret,
		            authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
		            ccsCredential: {
		                credential: request.account.homeAccountId,
		                type: CcsCredentialType.HOME_ACCOUNT_ID,
		            },
		        };
		        try {
		            return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(refreshTokenRequest);
		        }
		        catch (e) {
		            if (e instanceof InteractionRequiredAuthError) {
		                this.performanceClient?.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
		                if (e.subError === badToken) {
		                    // Remove bad refresh token from cache
		                    this.logger.verbose("acquireTokenWithRefreshToken: bad refresh token, removing from cache");
		                    const badRefreshTokenKey = this.cacheManager.generateCredentialKey(refreshToken);
		                    this.cacheManager.removeRefreshToken(badRefreshTokenKey, request.correlationId);
		                }
		            }
		            throw e;
		        }
		    }
		    /**
		     * Constructs the network message and makes a NW call to the underlying secure token service
		     * @param request
		     * @param authority
		     */
		    async executeTokenRequest(request, authority) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
		        const queryParametersString = this.createTokenQueryParameters(request);
		        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
		        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
		        const headers = this.createTokenRequestHeaders(request.ccsCredential);
		        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
		        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);
		    }
		    /**
		     * Helper function to create the token request body
		     * @param request
		     */
		    async createTokenRequestBody(request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);
		        const parameters = new Map();
		        addClientId(parameters, request.embeddedClientId ||
		            request.tokenBodyParameters?.[CLIENT_ID] ||
		            this.config.authOptions.clientId);
		        if (request.redirectUri) {
		            addRedirectUri(parameters, request.redirectUri);
		        }
		        addScopes(parameters, request.scopes, true, this.config.authOptions.authority.options.OIDCOptions?.defaultScopes);
		        addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);
		        addClientInfo(parameters);
		        addLibraryInfo(parameters, this.config.libraryInfo);
		        addApplicationTelemetry(parameters, this.config.telemetry.application);
		        addThrottling(parameters);
		        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
		            addServerTelemetry(parameters, this.serverTelemetryManager);
		        }
		        addRefreshToken(parameters, request.refreshToken);
		        if (this.config.clientCredentials.clientSecret) {
		            addClientSecret(parameters, this.config.clientCredentials.clientSecret);
		        }
		        if (this.config.clientCredentials.clientAssertion) {
		            const clientAssertion = this.config.clientCredentials.clientAssertion;
		            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
		            addClientAssertionType(parameters, clientAssertion.assertionType);
		        }
		        if (request.authenticationScheme === AuthenticationScheme.POP) {
		            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
		            let reqCnfData;
		            if (!request.popKid) {
		                const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
		                reqCnfData = generatedReqCnfData.reqCnfString;
		            }
		            else {
		                reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
		            }
		            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)
		            addPopToken(parameters, reqCnfData);
		        }
		        else if (request.authenticationScheme === AuthenticationScheme.SSH) {
		            if (request.sshJwk) {
		                addSshJwk(parameters, request.sshJwk);
		            }
		            else {
		                throw createClientConfigurationError(missingSshJwk);
		            }
		        }
		        if (!StringUtils.isEmptyObj(request.claims) ||
		            (this.config.authOptions.clientCapabilities &&
		                this.config.authOptions.clientCapabilities.length > 0)) {
		            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
		        }
		        if (this.config.systemOptions.preventCorsPreflight &&
		            request.ccsCredential) {
		            switch (request.ccsCredential.type) {
		                case CcsCredentialType.HOME_ACCOUNT_ID:
		                    try {
		                        const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
		                        addCcsOid(parameters, clientInfo);
		                    }
		                    catch (e) {
		                        this.logger.verbose("Could not parse home account ID for CCS Header: " +
		                            e);
		                    }
		                    break;
		                case CcsCredentialType.UPN:
		                    addCcsUpn(parameters, request.ccsCredential.credential);
		                    break;
		            }
		        }
		        if (request.embeddedClientId) {
		            addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
		        }
		        if (request.tokenBodyParameters) {
		            addExtraQueryParameters(parameters, request.tokenBodyParameters);
		        }
		        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
		        return mapToQueryString(parameters);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/** @internal */
		class SilentFlowClient extends BaseClient {
		    constructor(configuration, performanceClient) {
		        super(configuration, performanceClient);
		    }
		    /**
		     * Retrieves token from cache or throws an error if it must be refreshed.
		     * @param request
		     */
		    async acquireCachedToken(request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);
		        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
		        if (request.forceRefresh ||
		            (!this.config.cacheOptions.claimsBasedCachingEnabled &&
		                !StringUtils.isEmptyObj(request.claims))) {
		            // Must refresh due to present force_refresh flag.
		            this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);
		            throw createClientAuthError(tokenRefreshRequired);
		        }
		        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases
		        if (!request.account) {
		            throw createClientAuthError(noAccountInSilentRequest);
		        }
		        const requestTenantId = request.account.tenantId ||
		            getTenantFromAuthorityString(request.authority);
		        const tokenKeys = this.cacheManager.getTokenKeys();
		        const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId);
		        if (!cachedAccessToken) {
		            // must refresh due to non-existent access_token
		            this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);
		            throw createClientAuthError(tokenRefreshRequired);
		        }
		        else if (wasClockTurnedBack(cachedAccessToken.cachedAt) ||
		            isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
		            // must refresh due to the expires_in value
		            this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);
		            throw createClientAuthError(tokenRefreshRequired);
		        }
		        else if (cachedAccessToken.refreshOn &&
		            isTokenExpired(cachedAccessToken.refreshOn, 0)) {
		            // must refresh (in the background) due to the refresh_in value
		            lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
		            // don't throw ClientAuthError.createRefreshRequiredError(), return cached token instead
		        }
		        const environment = request.authority || this.authority.getPreferredCache();
		        const cacheRecord = {
		            account: this.cacheManager.getAccount(this.cacheManager.generateAccountKey(request.account), request.correlationId),
		            accessToken: cachedAccessToken,
		            idToken: this.cacheManager.getIdToken(request.account, request.correlationId, tokenKeys, requestTenantId, this.performanceClient),
		            refreshToken: null,
		            appMetadata: this.cacheManager.readAppMetadataFromCache(environment),
		        };
		        this.setCacheOutcome(lastCacheOutcome, request.correlationId);
		        if (this.config.serverTelemetryManager) {
		            this.config.serverTelemetryManager.incrementCacheHits();
		        }
		        return [
		            await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request),
		            lastCacheOutcome,
		        ];
		    }
		    setCacheOutcome(cacheOutcome, correlationId) {
		        this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);
		        this.performanceClient?.addFields({
		            cacheOutcome: cacheOutcome,
		        }, correlationId);
		        if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {
		            this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);
		        }
		    }
		    /**
		     * Helper function to build response object from the CacheRecord
		     * @param cacheRecord
		     */
		    async generateResultFromCacheRecord(cacheRecord, request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);
		        let idTokenClaims;
		        if (cacheRecord.idToken) {
		            idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);
		        }
		        // token max_age check
		        if (request.maxAge || request.maxAge === 0) {
		            const authTime = idTokenClaims?.auth_time;
		            if (!authTime) {
		                throw createClientAuthError(authTimeNotFound);
		            }
		            checkMaxAge(authTime, request.maxAge);
		        }
		        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const StubbedNetworkModule = {
		    sendGetRequestAsync: () => {
		        return Promise.reject(createClientAuthError(methodNotImplemented));
		    },
		    sendPostRequestAsync: () => {
		        return Promise.reject(createClientAuthError(methodNotImplemented));
		    },
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Returns map of parameters that are applicable to all calls to /authorize whether using PKCE or EAR
		 * @param config
		 * @param request
		 * @param logger
		 * @param performanceClient
		 * @returns
		 */
		function getStandardAuthorizeRequestParameters(authOptions, request, logger, performanceClient) {
		    // generate the correlationId if not set by the user and add
		    const correlationId = request.correlationId;
		    const parameters = new Map();
		    addClientId(parameters, request.embeddedClientId ||
		        request.extraQueryParameters?.[CLIENT_ID] ||
		        authOptions.clientId);
		    const requestScopes = [
		        ...(request.scopes || []),
		        ...(request.extraScopesToConsent || []),
		    ];
		    addScopes(parameters, requestScopes, true, authOptions.authority.options.OIDCOptions?.defaultScopes);
		    addRedirectUri(parameters, request.redirectUri);
		    addCorrelationId(parameters, correlationId);
		    // add response_mode. If not passed in it defaults to query.
		    addResponseMode(parameters, request.responseMode);
		    // add client_info=1
		    addClientInfo(parameters);
		    if (request.prompt) {
		        addPrompt(parameters, request.prompt);
		        performanceClient?.addFields({ prompt: request.prompt }, correlationId);
		    }
		    if (request.domainHint) {
		        addDomainHint(parameters, request.domainHint);
		        performanceClient?.addFields({ domainHintFromRequest: true }, correlationId);
		    }
		    // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object
		    if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
		        // AAD will throw if prompt=select_account is passed with an account hint
		        if (request.sid && request.prompt === PromptValue.NONE) {
		            // SessionID is only used in silent calls
		            logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
		            addSid(parameters, request.sid);
		            performanceClient?.addFields({ sidFromRequest: true }, correlationId);
		        }
		        else if (request.account) {
		            const accountSid = extractAccountSid(request.account);
		            let accountLoginHintClaim = extractLoginHint(request.account);
		            if (accountLoginHintClaim && request.domainHint) {
		                logger.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`);
		                accountLoginHintClaim = null;
		            }
		            // If login_hint claim is present, use it over sid/username
		            if (accountLoginHintClaim) {
		                logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
		                addLoginHint(parameters, accountLoginHintClaim);
		                performanceClient?.addFields({ loginHintFromClaim: true }, correlationId);
		                try {
		                    const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
		                    addCcsOid(parameters, clientInfo);
		                }
		                catch (e) {
		                    logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
		                }
		            }
		            else if (accountSid && request.prompt === PromptValue.NONE) {
		                /*
		                 * If account and loginHint are provided, we will check account first for sid before adding loginHint
		                 * SessionId is only used in silent calls
		                 */
		                logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
		                addSid(parameters, accountSid);
		                performanceClient?.addFields({ sidFromClaim: true }, correlationId);
		                try {
		                    const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
		                    addCcsOid(parameters, clientInfo);
		                }
		                catch (e) {
		                    logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
		                }
		            }
		            else if (request.loginHint) {
		                logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
		                addLoginHint(parameters, request.loginHint);
		                addCcsUpn(parameters, request.loginHint);
		                performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);
		            }
		            else if (request.account.username) {
		                // Fallback to account username if provided
		                logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
		                addLoginHint(parameters, request.account.username);
		                performanceClient?.addFields({ loginHintFromUpn: true }, correlationId);
		                try {
		                    const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
		                    addCcsOid(parameters, clientInfo);
		                }
		                catch (e) {
		                    logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
		                }
		            }
		        }
		        else if (request.loginHint) {
		            logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
		            addLoginHint(parameters, request.loginHint);
		            addCcsUpn(parameters, request.loginHint);
		            performanceClient?.addFields({ loginHintFromRequest: true }, correlationId);
		        }
		    }
		    else {
		        logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
		    }
		    if (request.nonce) {
		        addNonce(parameters, request.nonce);
		    }
		    if (request.state) {
		        addState(parameters, request.state);
		    }
		    if (request.claims ||
		        (authOptions.clientCapabilities &&
		            authOptions.clientCapabilities.length > 0)) {
		        addClaims(parameters, request.claims, authOptions.clientCapabilities);
		    }
		    if (request.embeddedClientId) {
		        addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);
		    }
		    // If extraQueryParameters includes instance_aware its value will be added when extraQueryParameters are added
		    if (authOptions.instanceAware &&
		        (!request.extraQueryParameters ||
		            !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))) {
		        addInstanceAware(parameters);
		    }
		    return parameters;
		}
		/**
		 * Returns authorize endpoint with given request parameters in the query string
		 * @param authority
		 * @param requestParameters
		 * @returns
		 */
		function getAuthorizeUrl(authority, requestParameters, encodeParams, extraQueryParameters) {
		    const queryString = mapToQueryString(requestParameters, encodeParams, extraQueryParameters);
		    return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);
		}
		/**
		 * Handles the hash fragment response from public client code request. Returns a code response used by
		 * the client to exchange for a token in acquireToken.
		 * @param serverParams
		 * @param cachedState
		 */
		function getAuthorizationCodePayload(serverParams, cachedState) {
		    // Get code response
		    validateAuthorizationResponse(serverParams, cachedState);
		    // throw when there is no auth code in the response
		    if (!serverParams.code) {
		        throw createClientAuthError(authorizationCodeMissingFromServerResponse);
		    }
		    return serverParams;
		}
		/**
		 * Function which validates server authorization code response.
		 * @param serverResponseHash
		 * @param requestState
		 */
		function validateAuthorizationResponse(serverResponse, requestState) {
		    if (!serverResponse.state || !requestState) {
		        throw serverResponse.state
		            ? createClientAuthError(stateNotFound, "Cached State")
		            : createClientAuthError(stateNotFound, "Server State");
		    }
		    let decodedServerResponseState;
		    let decodedRequestState;
		    try {
		        decodedServerResponseState = decodeURIComponent(serverResponse.state);
		    }
		    catch (e) {
		        throw createClientAuthError(invalidState, serverResponse.state);
		    }
		    try {
		        decodedRequestState = decodeURIComponent(requestState);
		    }
		    catch (e) {
		        throw createClientAuthError(invalidState, serverResponse.state);
		    }
		    if (decodedServerResponseState !== decodedRequestState) {
		        throw createClientAuthError(stateMismatch);
		    }
		    // Check for error
		    if (serverResponse.error ||
		        serverResponse.error_description ||
		        serverResponse.suberror) {
		        const serverErrorNo = parseServerErrorNo(serverResponse);
		        if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
		            throw new InteractionRequiredAuthError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || "", serverResponse.trace_id || "", serverResponse.correlation_id || "", serverResponse.claims || "", serverErrorNo);
		        }
		        throw new ServerError(serverResponse.error || "", serverResponse.error_description, serverResponse.suberror, serverErrorNo);
		    }
		}
		/**
		 * Get server error No from the error_uri
		 * @param serverResponse
		 * @returns
		 */
		function parseServerErrorNo(serverResponse) {
		    const errorCodePrefix = "code=";
		    const errorCodePrefixIndex = serverResponse.error_uri?.lastIndexOf(errorCodePrefix);
		    return errorCodePrefixIndex && errorCodePrefixIndex >= 0
		        ? serverResponse.error_uri?.substring(errorCodePrefixIndex + errorCodePrefix.length)
		        : undefined;
		}
		/**
		 * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.
		 * @param account
		 */
		function extractAccountSid(account) {
		    return account.idTokenClaims?.sid || null;
		}
		function extractLoginHint(account) {
		    return account.loginHint || account.idTokenClaims?.login_hint || null;
		}

		var Authorize = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    getAuthorizationCodePayload: getAuthorizationCodePayload,
		    getAuthorizeUrl: getAuthorizeUrl,
		    getStandardAuthorizeRequestParameters: getStandardAuthorizeRequestParameters,
		    validateAuthorizationResponse: validateAuthorizationResponse
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * This is a helper class that parses supported HTTP response authentication headers to extract and return
		 * header challenge values that can be used outside the basic authorization flows.
		 */
		class AuthenticationHeaderParser {
		    constructor(headers) {
		        this.headers = headers;
		    }
		    /**
		     * This method parses the SHR nonce value out of either the Authentication-Info or WWW-Authenticate authentication headers.
		     * @returns
		     */
		    getShrNonce() {
		        // Attempt to parse nonce from Authentiacation-Info
		        const authenticationInfo = this.headers[HeaderNames.AuthenticationInfo];
		        if (authenticationInfo) {
		            const authenticationInfoChallenges = this.parseChallenges(authenticationInfo);
		            if (authenticationInfoChallenges.nextnonce) {
		                return authenticationInfoChallenges.nextnonce;
		            }
		            throw createClientConfigurationError(invalidAuthenticationHeader);
		        }
		        // Attempt to parse nonce from WWW-Authenticate
		        const wwwAuthenticate = this.headers[HeaderNames.WWWAuthenticate];
		        if (wwwAuthenticate) {
		            const wwwAuthenticateChallenges = this.parseChallenges(wwwAuthenticate);
		            if (wwwAuthenticateChallenges.nonce) {
		                return wwwAuthenticateChallenges.nonce;
		            }
		            throw createClientConfigurationError(invalidAuthenticationHeader);
		        }
		        // If neither header is present, throw missing headers error
		        throw createClientConfigurationError(missingNonceAuthenticationHeader);
		    }
		    /**
		     * Parses an HTTP header's challenge set into a key/value map.
		     * @param header
		     * @returns
		     */
		    parseChallenges(header) {
		        const schemeSeparator = header.indexOf(" ");
		        const challenges = header.substr(schemeSeparator + 1).split(",");
		        const challengeMap = {};
		        challenges.forEach((challenge) => {
		            const [key, value] = challenge.split("=");
		            // Remove escaped quotation marks (', ") from challenge string to keep only the challenge value
		            challengeMap[key] = unescape(value.replace(/['"]+/g, Constants.EMPTY_STRING));
		        });
		        return challengeMap;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Converts a numeric tag to a string representation
		 * @param tag - The numeric tag to convert
		 * @returns The string representation of the tag
		 */
		function tagToString(tag) {
		    if (tag === 0) {
		        return "UNTAG";
		    }
		    const tagSymbolSpace = "abcdefghijklmnopqrstuvwxyz0123456789****************************";
		    let tagBuffer = "*****";
		    const chars = [
		        tagSymbolSpace[(tag >> 24) & 0x3f],
		        tagSymbolSpace[(tag >> 18) & 0x3f],
		        tagSymbolSpace[(tag >> 12) & 0x3f],
		        tagSymbolSpace[(tag >> 6) & 0x3f],
		        tagSymbolSpace[(tag >> 0) & 0x3f],
		    ];
		    tagBuffer = chars.join("");
		    return tagBuffer;
		}
		/**
		 * Error class for MSAL Runtime errors that preserves detailed broker information
		 */
		class PlatformBrokerError extends AuthError {
		    constructor(errorStatus, errorContext, errorCode, errorTag) {
		        const tagString = tagToString(errorTag);
		        const enhancedErrorContext = errorContext
		            ? `${errorContext} (Error Code: ${errorCode}, Tag: ${tagString})`
		            : `(Error Code: ${errorCode}, Tag: ${tagString})`;
		        super(errorStatus, enhancedErrorContext);
		        this.name = "PlatformBrokerError";
		        this.statusCode = errorCode;
		        this.tag = tagString;
		        Object.setPrototypeOf(this, PlatformBrokerError.prototype);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const skuGroupSeparator = ",";
		const skuValueSeparator = "|";
		function makeExtraSkuString(params) {
		    const { skus, libraryName, libraryVersion, extensionName, extensionVersion, } = params;
		    const skuMap = new Map([
		        [0, [libraryName, libraryVersion]],
		        [2, [extensionName, extensionVersion]],
		    ]);
		    let skuArr = [];
		    if (skus?.length) {
		        skuArr = skus.split(skuGroupSeparator);
		        // Ignore invalid input sku param
		        if (skuArr.length < 4) {
		            return skus;
		        }
		    }
		    else {
		        skuArr = Array.from({ length: 4 }, () => skuValueSeparator);
		    }
		    skuMap.forEach((value, key) => {
		        if (value.length === 2 && value[0]?.length && value[1]?.length) {
		            setSku({
		                skuArr,
		                index: key,
		                skuName: value[0],
		                skuVersion: value[1],
		            });
		        }
		    });
		    return skuArr.join(skuGroupSeparator);
		}
		function setSku(params) {
		    const { skuArr, index, skuName, skuVersion } = params;
		    if (index >= skuArr.length) {
		        return;
		    }
		    skuArr[index] = [skuName, skuVersion].join(skuValueSeparator);
		}
		/** @internal */
		class ServerTelemetryManager {
		    constructor(telemetryRequest, cacheManager) {
		        this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;
		        this.cacheManager = cacheManager;
		        this.apiId = telemetryRequest.apiId;
		        this.correlationId = telemetryRequest.correlationId;
		        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants.EMPTY_STRING;
		        this.wrapperVer = telemetryRequest.wrapperVer || Constants.EMPTY_STRING;
		        this.telemetryCacheKey =
		            SERVER_TELEM_CONSTANTS.CACHE_KEY +
		                Separators.CACHE_KEY_SEPARATOR +
		                telemetryRequest.clientId;
		    }
		    /**
		     * API to add MSER Telemetry to request
		     */
		    generateCurrentRequestHeaderValue() {
		        const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;
		        const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];
		        const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();
		        if (nativeBrokerErrorCode?.length) {
		            platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);
		        }
		        const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
		        const regionDiscoveryFields = this.getRegionDiscoveryFields();
		        const requestWithRegionDiscoveryFields = [
		            request,
		            regionDiscoveryFields,
		        ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
		        return [
		            SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
		            requestWithRegionDiscoveryFields,
		            platformFields,
		        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
		    }
		    /**
		     * API to add MSER Telemetry for the last failed request
		     */
		    generateLastRequestHeaderValue() {
		        const lastRequests = this.getLastRequests();
		        const maxErrors = ServerTelemetryManager.maxErrorsToSend(lastRequests);
		        const failedRequests = lastRequests.failedRequests
		            .slice(0, 2 * maxErrors)
		            .join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
		        const errors = lastRequests.errors
		            .slice(0, maxErrors)
		            .join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
		        const errorCount = lastRequests.errors.length;
		        // Indicate whether this header contains all data or partial data
		        const overflow = maxErrors < errorCount
		            ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE
		            : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
		        const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
		        return [
		            SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
		            lastRequests.cacheHits,
		            failedRequests,
		            errors,
		            platformFields,
		        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
		    }
		    /**
		     * API to cache token failures for MSER data capture
		     * @param error
		     */
		    cacheFailedRequest(error) {
		        const lastRequests = this.getLastRequests();
		        if (lastRequests.errors.length >=
		            SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
		            // Remove a cached error to make room, first in first out
		            lastRequests.failedRequests.shift(); // apiId
		            lastRequests.failedRequests.shift(); // correlationId
		            lastRequests.errors.shift();
		        }
		        lastRequests.failedRequests.push(this.apiId, this.correlationId);
		        if (error instanceof Error && !!error && error.toString()) {
		            if (error instanceof AuthError) {
		                if (error.subError) {
		                    lastRequests.errors.push(error.subError);
		                }
		                else if (error.errorCode) {
		                    lastRequests.errors.push(error.errorCode);
		                }
		                else {
		                    lastRequests.errors.push(error.toString());
		                }
		            }
		            else {
		                lastRequests.errors.push(error.toString());
		            }
		        }
		        else {
		            lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
		        }
		        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
		        return;
		    }
		    /**
		     * Update server telemetry cache entry by incrementing cache hit counter
		     */
		    incrementCacheHits() {
		        const lastRequests = this.getLastRequests();
		        lastRequests.cacheHits += 1;
		        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
		        return lastRequests.cacheHits;
		    }
		    /**
		     * Get the server telemetry entity from cache or initialize a new one
		     */
		    getLastRequests() {
		        const initialValue = {
		            failedRequests: [],
		            errors: [],
		            cacheHits: 0,
		        };
		        const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
		        return lastRequests || initialValue;
		    }
		    /**
		     * Remove server telemetry cache entry
		     */
		    clearTelemetryCache() {
		        const lastRequests = this.getLastRequests();
		        const numErrorsFlushed = ServerTelemetryManager.maxErrorsToSend(lastRequests);
		        const errorCount = lastRequests.errors.length;
		        if (numErrorsFlushed === errorCount) {
		            // All errors were sent on last request, clear Telemetry cache
		            this.cacheManager.removeItem(this.telemetryCacheKey, this.correlationId);
		        }
		        else {
		            // Partial data was flushed to server, construct a new telemetry cache item with errors that were not flushed
		            const serverTelemEntity = {
		                failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),
		                errors: lastRequests.errors.slice(numErrorsFlushed),
		                cacheHits: 0,
		            };
		            this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity, this.correlationId);
		        }
		    }
		    /**
		     * Returns the maximum number of errors that can be flushed to the server in the next network request
		     * @param serverTelemetryEntity
		     */
		    static maxErrorsToSend(serverTelemetryEntity) {
		        let i;
		        let maxErrors = 0;
		        let dataSize = 0;
		        const errorCount = serverTelemetryEntity.errors.length;
		        for (i = 0; i < errorCount; i++) {
		            // failedRequests parameter contains pairs of apiId and correlationId, multiply index by 2 to preserve pairs
		            const apiId = serverTelemetryEntity.failedRequests[2 * i] ||
		                Constants.EMPTY_STRING;
		            const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] ||
		                Constants.EMPTY_STRING;
		            const errorCode = serverTelemetryEntity.errors[i] || Constants.EMPTY_STRING;
		            // Count number of characters that would be added to header, each character is 1 byte. Add 3 at the end to account for separators
		            dataSize +=
		                apiId.toString().length +
		                    correlationId.toString().length +
		                    errorCode.length +
		                    3;
		            if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
		                // Adding this entry to the header would still keep header size below the limit
		                maxErrors += 1;
		            }
		            else {
		                break;
		            }
		        }
		        return maxErrors;
		    }
		    /**
		     * Get the region discovery fields
		     *
		     * @returns string
		     */
		    getRegionDiscoveryFields() {
		        const regionDiscoveryFields = [];
		        regionDiscoveryFields.push(this.regionUsed || Constants.EMPTY_STRING);
		        regionDiscoveryFields.push(this.regionSource || Constants.EMPTY_STRING);
		        regionDiscoveryFields.push(this.regionOutcome || Constants.EMPTY_STRING);
		        return regionDiscoveryFields.join(",");
		    }
		    /**
		     * Update the region discovery metadata
		     *
		     * @param regionDiscoveryMetadata
		     * @returns void
		     */
		    updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {
		        this.regionUsed = regionDiscoveryMetadata.region_used;
		        this.regionSource = regionDiscoveryMetadata.region_source;
		        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
		    }
		    /**
		     * Set cache outcome
		     */
		    setCacheOutcome(cacheOutcome) {
		        this.cacheOutcome = cacheOutcome;
		    }
		    setNativeBrokerErrorCode(errorCode) {
		        const lastRequests = this.getLastRequests();
		        lastRequests.nativeBrokerErrorCode = errorCode;
		        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
		    }
		    getNativeBrokerErrorCode() {
		        return this.getLastRequests().nativeBrokerErrorCode;
		    }
		    clearNativeBrokerErrorCode() {
		        const lastRequests = this.getLastRequests();
		        delete lastRequests.nativeBrokerErrorCode;
		        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
		    }
		    static makeExtraSkuString(params) {
		        return makeExtraSkuString(params);
		    }
		}

		exports$1.AADAuthorityConstants = AADAuthorityConstants;
		exports$1.AADServerParamKeys = AADServerParamKeys;
		exports$1.AccountEntity = AccountEntity;
		exports$1.AuthError = AuthError;
		exports$1.AuthErrorCodes = AuthErrorCodes;
		exports$1.AuthErrorMessage = AuthErrorMessage;
		exports$1.AuthToken = AuthToken;
		exports$1.AuthenticationHeaderParser = AuthenticationHeaderParser;
		exports$1.AuthenticationScheme = AuthenticationScheme;
		exports$1.Authority = Authority;
		exports$1.AuthorityFactory = AuthorityFactory;
		exports$1.AuthorityType = AuthorityType;
		exports$1.AuthorizationCodeClient = AuthorizationCodeClient;
		exports$1.Authorize = Authorize;
		exports$1.AzureCloudInstance = AzureCloudInstance;
		exports$1.BaseClient = BaseClient;
		exports$1.CacheAccountType = CacheAccountType;
		exports$1.CacheError = CacheError;
		exports$1.CacheErrorCodes = CacheErrorCodes;
		exports$1.CacheHelpers = CacheHelpers;
		exports$1.CacheManager = CacheManager;
		exports$1.CacheOutcome = CacheOutcome;
		exports$1.CacheType = CacheType;
		exports$1.CcsCredentialType = CcsCredentialType;
		exports$1.ClaimsRequestKeys = ClaimsRequestKeys;
		exports$1.ClientAssertionUtils = ClientAssertionUtils;
		exports$1.ClientAuthError = ClientAuthError;
		exports$1.ClientAuthErrorCodes = ClientAuthErrorCodes;
		exports$1.ClientAuthErrorMessage = ClientAuthErrorMessage;
		exports$1.ClientConfigurationError = ClientConfigurationError;
		exports$1.ClientConfigurationErrorCodes = ClientConfigurationErrorCodes;
		exports$1.ClientConfigurationErrorMessage = ClientConfigurationErrorMessage;
		exports$1.CodeChallengeMethodValues = CodeChallengeMethodValues;
		exports$1.Constants = Constants;
		exports$1.CredentialType = CredentialType;
		exports$1.DEFAULT_CRYPTO_IMPLEMENTATION = DEFAULT_CRYPTO_IMPLEMENTATION;
		exports$1.DEFAULT_SYSTEM_OPTIONS = DEFAULT_SYSTEM_OPTIONS;
		exports$1.DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = DEFAULT_TOKEN_RENEWAL_OFFSET_SEC;
		exports$1.DefaultStorageClass = DefaultStorageClass;
		exports$1.EncodingTypes = EncodingTypes;
		exports$1.Errors = Errors;
		exports$1.GrantType = GrantType;
		exports$1.HeaderNames = HeaderNames;
		exports$1.HttpMethod = HttpMethod;
		exports$1.HttpStatus = HttpStatus;
		exports$1.IntFields = IntFields;
		exports$1.InteractionRequiredAuthError = InteractionRequiredAuthError;
		exports$1.InteractionRequiredAuthErrorCodes = InteractionRequiredAuthErrorCodes;
		exports$1.InteractionRequiredAuthErrorMessage = InteractionRequiredAuthErrorMessage;
		exports$1.JsonWebTokenTypes = JsonWebTokenTypes;
		exports$1.Logger = Logger;
		exports$1.NetworkError = NetworkError;
		exports$1.OAuthResponseType = OAuthResponseType;
		exports$1.OIDC_DEFAULT_SCOPES = OIDC_DEFAULT_SCOPES;
		exports$1.ONE_DAY_IN_MS = ONE_DAY_IN_MS;
		exports$1.PasswordGrantConstants = PasswordGrantConstants;
		exports$1.PerformanceEventAbbreviations = PerformanceEventAbbreviations;
		exports$1.PerformanceEventStatus = PerformanceEventStatus;
		exports$1.PerformanceEvents = PerformanceEvents;
		exports$1.PersistentCacheKeys = PersistentCacheKeys;
		exports$1.PlatformBrokerError = PlatformBrokerError;
		exports$1.PopTokenGenerator = PopTokenGenerator;
		exports$1.PromptValue = PromptValue;
		exports$1.ProtocolMode = ProtocolMode;
		exports$1.ProtocolUtils = ProtocolUtils;
		exports$1.RefreshTokenClient = RefreshTokenClient;
		exports$1.RequestParameterBuilder = RequestParameterBuilder;
		exports$1.ResponseHandler = ResponseHandler;
		exports$1.ResponseMode = ResponseMode;
		exports$1.ScopeSet = ScopeSet;
		exports$1.ServerError = ServerError;
		exports$1.ServerResponseType = ServerResponseType;
		exports$1.ServerTelemetryManager = ServerTelemetryManager;
		exports$1.SilentFlowClient = SilentFlowClient;
		exports$1.StringUtils = StringUtils;
		exports$1.StubPerformanceClient = StubPerformanceClient;
		exports$1.StubPerformanceMeasurement = StubPerformanceMeasurement;
		exports$1.StubbedNetworkModule = StubbedNetworkModule;
		exports$1.THE_FAMILY_ID = THE_FAMILY_ID;
		exports$1.ThrottlingConstants = ThrottlingConstants;
		exports$1.ThrottlingUtils = ThrottlingUtils;
		exports$1.TimeUtils = TimeUtils;
		exports$1.TokenCacheContext = TokenCacheContext;
		exports$1.UrlString = UrlString;
		exports$1.UrlUtils = UrlUtils;
		exports$1.buildAccountToCache = buildAccountToCache;
		exports$1.buildClientInfo = buildClientInfo;
		exports$1.buildClientInfoFromHomeAccountId = buildClientInfoFromHomeAccountId;
		exports$1.buildStaticAuthorityOptions = buildStaticAuthorityOptions;
		exports$1.buildTenantProfile = buildTenantProfile;
		exports$1.createAuthError = createAuthError;
		exports$1.createCacheError = createCacheError;
		exports$1.createClientAuthError = createClientAuthError;
		exports$1.createClientConfigurationError = createClientConfigurationError;
		exports$1.createInteractionRequiredAuthError = createInteractionRequiredAuthError;
		exports$1.createNetworkError = createNetworkError;
		exports$1.formatAuthorityUri = formatAuthorityUri;
		exports$1.getClientAssertion = getClientAssertion;
		exports$1.getRequestThumbprint = getRequestThumbprint;
		exports$1.getTenantIdFromIdTokenClaims = getTenantIdFromIdTokenClaims;
		exports$1.invoke = invoke;
		exports$1.invokeAsync = invokeAsync;
		exports$1.tenantIdMatchesHomeTenant = tenantIdMatchesHomeTenant;
		exports$1.updateAccountTenantProfileData = updateAccountTenantProfileData;
		exports$1.version = version;
		
	} (indexNode4Jss3kYh));
	return indexNode4Jss3kYh;
}

var indexBrowser = {};

/*! @azure/msal-common v15.13.3 2025-12-04 */

var hasRequiredIndexBrowser;

function requireIndexBrowser () {
	if (hasRequiredIndexBrowser) return indexBrowser;
	hasRequiredIndexBrowser = 1;
	(function (exports$1) {

		var indexNode = requireIndexNode4Jss3kYh();

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const missingKidError = "missing_kid_error";
		const missingAlgError = "missing_alg_error";

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const JoseHeaderErrorMessages = {
		    [missingKidError]: "The JOSE Header for the requested JWT, JWS or JWK object requires a keyId to be configured as the 'kid' header claim. No 'kid' value was provided.",
		    [missingAlgError]: "The JOSE Header for the requested JWT, JWS or JWK object requires an algorithm to be specified as the 'alg' header claim. No 'alg' value was provided.",
		};
		/**
		 * Error thrown when there is an error in the client code running on the browser.
		 */
		class JoseHeaderError extends indexNode.AuthError {
		    constructor(errorCode, errorMessage) {
		        super(errorCode, errorMessage);
		        this.name = "JoseHeaderError";
		        Object.setPrototypeOf(this, JoseHeaderError.prototype);
		    }
		}
		/** Returns JoseHeaderError object */
		function createJoseHeaderError(code) {
		    return new JoseHeaderError(code, JoseHeaderErrorMessages[code]);
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/** @internal */
		class JoseHeader {
		    constructor(options) {
		        this.typ = options.typ;
		        this.alg = options.alg;
		        this.kid = options.kid;
		    }
		    /**
		     * Builds SignedHttpRequest formatted JOSE Header from the
		     * JOSE Header options provided or previously set on the object and returns
		     * the stringified header object.
		     * Throws if keyId or algorithm aren't provided since they are required for Access Token Binding.
		     * @param shrHeaderOptions
		     * @returns
		     */
		    static getShrHeaderString(shrHeaderOptions) {
		        // KeyID is required on the SHR header
		        if (!shrHeaderOptions.kid) {
		            throw createJoseHeaderError(missingKidError);
		        }
		        // Alg is required on the SHR header
		        if (!shrHeaderOptions.alg) {
		            throw createJoseHeaderError(missingAlgError);
		        }
		        const shrHeader = new JoseHeader({
		            // Access Token PoP headers must have type pop, but the type header can be overriden for special cases
		            typ: shrHeaderOptions.typ || indexNode.JsonWebTokenTypes.Pop,
		            kid: shrHeaderOptions.kid,
		            alg: shrHeaderOptions.alg,
		        });
		        return JSON.stringify(shrHeader);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Starts context by adding payload to the stack
		 * @param event {PerformanceEvent}
		 * @param abbreviations {Map<string, string>} event name abbreviations
		 * @param stack {?PerformanceEventStackedContext[]} stack
		 */
		function startContext(event, abbreviations, stack) {
		    if (!stack) {
		        return;
		    }
		    stack.push({
		        name: abbreviations.get(event.name) || event.name,
		    });
		}
		/**
		 * Ends context by removing payload from the stack and returning parent or self, if stack is empty, payload
		 *
		 * @param event {PerformanceEvent}
		 * @param abbreviations {Map<string, string>} event name abbreviations
		 * @param stack {?PerformanceEventStackedContext[]} stack
		 * @param error {?unknown} error
		 */
		function endContext(event, abbreviations, stack, error) {
		    if (!stack?.length) {
		        return;
		    }
		    const peek = (stack) => {
		        return stack.length ? stack[stack.length - 1] : undefined;
		    };
		    const abbrEventName = abbreviations.get(event.name) || event.name;
		    const top = peek(stack);
		    if (top?.name !== abbrEventName) {
		        return;
		    }
		    const current = stack?.pop();
		    if (!current) {
		        return;
		    }
		    const errorCode = error instanceof indexNode.AuthError
		        ? error.errorCode
		        : error instanceof Error
		            ? error.name
		            : undefined;
		    const subErr = error instanceof indexNode.AuthError ? error.subError : undefined;
		    if (errorCode && current.childErr !== errorCode) {
		        current.err = errorCode;
		        if (subErr) {
		            current.subErr = subErr;
		        }
		    }
		    delete current.name;
		    delete current.childErr;
		    const context = {
		        ...current,
		        dur: event.durationMs,
		    };
		    if (!event.success) {
		        context.fail = 1;
		    }
		    const parent = peek(stack);
		    if (!parent) {
		        return { [abbrEventName]: context };
		    }
		    if (errorCode) {
		        parent.childErr = errorCode;
		    }
		    let childName;
		    if (!parent[abbrEventName]) {
		        childName = abbrEventName;
		    }
		    else {
		        const siblings = Object.keys(parent).filter((key) => key.startsWith(abbrEventName)).length;
		        childName = `${abbrEventName}_${siblings + 1}`;
		    }
		    parent[childName] = context;
		    return parent;
		}
		/**
		 * Adds error name and stack trace to the telemetry event
		 * @param error {Error}
		 * @param logger {Logger}
		 * @param event {PerformanceEvent}
		 * @param stackMaxSize {number} max error stack size to capture
		 */
		function addError(error, logger, event, stackMaxSize = 5) {
		    if (!(error instanceof Error)) {
		        logger.trace("PerformanceClient.addErrorStack: Input error is not instance of Error", event.correlationId);
		        return;
		    }
		    else if (error instanceof indexNode.AuthError) {
		        event.errorCode = error.errorCode;
		        event.subErrorCode = error.subError;
		        if (error instanceof indexNode.ServerError ||
		            error instanceof indexNode.InteractionRequiredAuthError) {
		            event.serverErrorNo = error.errorNo;
		        }
		        return;
		    }
		    else if (error instanceof indexNode.CacheError) {
		        event.errorCode = error.errorCode;
		        return;
		    }
		    else if (event.errorStack?.length) {
		        logger.trace("PerformanceClient.addErrorStack: Stack already exist", event.correlationId);
		        return;
		    }
		    else if (!error.stack?.length) {
		        logger.trace("PerformanceClient.addErrorStack: Input stack is empty", event.correlationId);
		        return;
		    }
		    if (error.stack) {
		        event.errorStack = compactStack(error.stack, stackMaxSize);
		    }
		    event.errorName = error.name;
		}
		/**
		 * Compacts error stack into array by fetching N first entries
		 * @param stack {string} error stack
		 * @param stackMaxSize {number} max error stack size to capture
		 * @returns {string[]}
		 */
		function compactStack(stack, stackMaxSize) {
		    if (stackMaxSize < 0) {
		        return [];
		    }
		    const stackArr = stack.split("\n") || [];
		    const res = [];
		    // Check for a handful of known, common runtime errors and log them (with redaction where applicable).
		    const firstLine = stackArr[0];
		    if (firstLine.startsWith("TypeError: Cannot read property") ||
		        firstLine.startsWith("TypeError: Cannot read properties of") ||
		        firstLine.startsWith("TypeError: Cannot set property") ||
		        firstLine.startsWith("TypeError: Cannot set properties of") ||
		        firstLine.endsWith("is not a function")) {
		        // These types of errors are not at risk of leaking PII. They will indicate unavailable APIs
		        res.push(compactStackLine(firstLine));
		    }
		    else if (firstLine.startsWith("SyntaxError") ||
		        firstLine.startsWith("TypeError")) {
		        // Prevent unintentional leaking of arbitrary info by redacting contents between both single and double quotes
		        res.push(compactStackLine(
		        // Example: SyntaxError: Unexpected token 'e', "test" is not valid JSON -> SyntaxError: Unexpected token <redacted>, <redacted> is not valid JSON
		        firstLine.replace(/['].*[']|["].*["]/g, "<redacted>")));
		    }
		    // Get top N stack lines
		    for (let ix = 1; ix < stackArr.length; ix++) {
		        if (res.length >= stackMaxSize) {
		            break;
		        }
		        const line = stackArr[ix];
		        res.push(compactStackLine(line));
		    }
		    return res;
		}
		/**
		 * Compacts error stack line by shortening file path
		 * Example: https://localhost/msal-common/src/authority/Authority.js:100:1 -> Authority.js:100:1
		 * @param line {string} stack line
		 * @returns {string}
		 */
		function compactStackLine(line) {
		    const filePathIx = line.lastIndexOf(" ") + 1;
		    if (filePathIx < 1) {
		        return line;
		    }
		    const filePath = line.substring(filePathIx);
		    let fileNameIx = filePath.lastIndexOf("/");
		    fileNameIx = fileNameIx < 0 ? filePath.lastIndexOf("\\") : fileNameIx;
		    if (fileNameIx >= 0) {
		        return (line.substring(0, filePathIx) +
		            "(" +
		            filePath.substring(fileNameIx + 1) +
		            (filePath.charAt(filePath.length - 1) === ")" ? "" : ")")).trimStart();
		    }
		    return line.trimStart();
		}
		function getAccountType(account) {
		    const idTokenClaims = account?.idTokenClaims;
		    if (idTokenClaims?.tfp || idTokenClaims?.acr) {
		        return "B2C";
		    }
		    if (!idTokenClaims?.tid) {
		        return undefined;
		    }
		    else if (idTokenClaims?.tid === "9188040d-6c67-4c5b-b112-36a304b66dad") {
		        return "MSA";
		    }
		    return "AAD";
		}
		class PerformanceClient {
		    /**
		     * Creates an instance of PerformanceClient,
		     * an abstract class containing core performance telemetry logic.
		     *
		     * @constructor
		     * @param {string} clientId Client ID of the application
		     * @param {string} authority Authority used by the application
		     * @param {Logger} logger Logger used by the application
		     * @param {string} libraryName Name of the library
		     * @param {string} libraryVersion Version of the library
		     * @param {ApplicationTelemetry} applicationTelemetry application name and version
		     * @param {Set<String>} intFields integer fields to be truncated
		     * @param {Map<string, string>} abbreviations event name abbreviations
		     */
		    constructor(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry, intFields, abbreviations) {
		        this.authority = authority;
		        this.libraryName = libraryName;
		        this.libraryVersion = libraryVersion;
		        this.applicationTelemetry = applicationTelemetry;
		        this.clientId = clientId;
		        this.logger = logger;
		        this.callbacks = new Map();
		        this.eventsByCorrelationId = new Map();
		        this.eventStack = new Map();
		        this.queueMeasurements = new Map();
		        this.preQueueTimeByCorrelationId = new Map();
		        this.intFields = intFields || new Set();
		        for (const item of indexNode.IntFields) {
		            this.intFields.add(item);
		        }
		        this.abbreviations = abbreviations || new Map();
		        for (const [key, value] of indexNode.PerformanceEventAbbreviations) {
		            this.abbreviations.set(key, value);
		        }
		    }
		    /**
		     * Starts and returns an platform-specific implementation of IPerformanceMeasurement.
		     * Note: this function can be changed to abstract at the next major version bump.
		     *
		     * @param {string} measureName
		     * @param {string} correlationId
		     * @returns {IPerformanceMeasurement}
		     * @deprecated This method will be removed in the next major version
		     */
		    startPerformanceMeasurement(measureName, // eslint-disable-line @typescript-eslint/no-unused-vars
		    correlationId // eslint-disable-line @typescript-eslint/no-unused-vars
		    ) {
		        return {};
		    }
		    /**
		     * Gets map of pre-queue times by correlation Id
		     *
		     * @param {PerformanceEvents} eventName
		     * @param {string} correlationId
		     * @returns {number}
		     */
		    getPreQueueTime(eventName, correlationId) {
		        const preQueueEvent = this.preQueueTimeByCorrelationId.get(correlationId);
		        if (!preQueueEvent) {
		            this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue times found for correlationId: ${correlationId}, unable to add queue measurement`);
		            return;
		        }
		        else if (preQueueEvent.name !== eventName) {
		            this.logger.trace(`PerformanceClient.getPreQueueTime: no pre-queue time found for ${eventName}, unable to add queue measurement`);
		            return;
		        }
		        return preQueueEvent.time;
		    }
		    /**
		     * Calculates the difference between current time and time when function was queued.
		     * Note: It is possible to have 0 as the queue time if the current time and the queued time was the same.
		     *
		     * @param {number} preQueueTime
		     * @param {number} currentTime
		     * @returns {number}
		     */
		    calculateQueuedTime(preQueueTime, currentTime) {
		        if (preQueueTime < 1) {
		            this.logger.trace(`PerformanceClient: preQueueTime should be a positive integer and not ${preQueueTime}`);
		            return 0;
		        }
		        if (currentTime < 1) {
		            this.logger.trace(`PerformanceClient: currentTime should be a positive integer and not ${currentTime}`);
		            return 0;
		        }
		        if (currentTime < preQueueTime) {
		            this.logger.trace("PerformanceClient: currentTime is less than preQueueTime, check how time is being retrieved");
		            return 0;
		        }
		        return currentTime - preQueueTime;
		    }
		    /**
		     * Adds queue measurement time to QueueMeasurements array for given correlation ID.
		     *
		     * @param {PerformanceEvents} eventName
		     * @param {?string} correlationId
		     * @param {?number} queueTime
		     * @param {?boolean} manuallyCompleted - indicator for manually completed queue measurements
		     * @returns
		     */
		    addQueueMeasurement(eventName, correlationId, queueTime, manuallyCompleted) {
		        if (!correlationId) {
		            this.logger.trace(`PerformanceClient.addQueueMeasurement: correlationId not provided for ${eventName}, cannot add queue measurement`);
		            return;
		        }
		        if (queueTime === 0) {
		            // Possible for there to be no queue time after calculation
		            this.logger.trace(`PerformanceClient.addQueueMeasurement: queue time provided for ${eventName} is ${queueTime}`);
		        }
		        else if (!queueTime) {
		            this.logger.trace(`PerformanceClient.addQueueMeasurement: no queue time provided for ${eventName}`);
		            return;
		        }
		        const queueMeasurement = {
		            eventName,
		            // Always default queue time to 0 for manually completed (improperly instrumented)
		            queueTime: manuallyCompleted ? 0 : queueTime,
		            manuallyCompleted,
		        };
		        // Adds to existing correlation Id if present in queueMeasurements
		        const existingMeasurements = this.queueMeasurements.get(correlationId);
		        if (existingMeasurements) {
		            existingMeasurements.push(queueMeasurement);
		            this.queueMeasurements.set(correlationId, existingMeasurements);
		        }
		        else {
		            // Sets new correlation Id if not present in queueMeasurements
		            this.logger.trace(`PerformanceClient.addQueueMeasurement: adding correlationId ${correlationId} to queue measurements`);
		            const measurementArray = [queueMeasurement];
		            this.queueMeasurements.set(correlationId, measurementArray);
		        }
		        // Delete processed pre-queue event.
		        this.preQueueTimeByCorrelationId.delete(correlationId);
		    }
		    /**
		     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.
		     *
		     * @param {PerformanceEvents} measureName
		     * @param {?string} [correlationId]
		     * @returns {InProgressPerformanceEvent}
		     */
		    startMeasurement(measureName, correlationId) {
		        // Generate a placeholder correlation if the request does not provide one
		        const eventCorrelationId = correlationId || this.generateId();
		        if (!correlationId) {
		            this.logger.info(`PerformanceClient: No correlation id provided for ${measureName}, generating`, eventCorrelationId);
		        }
		        this.logger.trace(`PerformanceClient: Performance measurement started for ${measureName}`, eventCorrelationId);
		        const inProgressEvent = {
		            eventId: this.generateId(),
		            status: indexNode.PerformanceEventStatus.InProgress,
		            authority: this.authority,
		            libraryName: this.libraryName,
		            libraryVersion: this.libraryVersion,
		            clientId: this.clientId,
		            name: measureName,
		            startTimeMs: Date.now(),
		            correlationId: eventCorrelationId,
		            appName: this.applicationTelemetry?.appName,
		            appVersion: this.applicationTelemetry?.appVersion,
		        };
		        // Store in progress events so they can be discarded if not ended properly
		        this.cacheEventByCorrelationId(inProgressEvent);
		        startContext(inProgressEvent, this.abbreviations, this.eventStack.get(eventCorrelationId));
		        // Return the event and functions the caller can use to properly end/flush the measurement
		        return {
		            end: (event, error, account) => {
		                return this.endMeasurement({
		                    // Initial set of event properties
		                    ...inProgressEvent,
		                    // Properties set when event ends
		                    ...event,
		                }, error, account);
		            },
		            discard: () => {
		                return this.discardMeasurements(inProgressEvent.correlationId);
		            },
		            add: (fields) => {
		                return this.addFields(fields, inProgressEvent.correlationId);
		            },
		            increment: (fields) => {
		                return this.incrementFields(fields, inProgressEvent.correlationId);
		            },
		            event: inProgressEvent,
		            measurement: new indexNode.StubPerformanceMeasurement(),
		        };
		    }
		    /**
		     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,
		     * as consumers should instead use the function returned by startMeasurement.
		     * Adds a new field named as "[event name]DurationMs" for sub-measurements, completes and emits an event
		     * otherwise.
		     *
		     * @param {PerformanceEvent} event
		     * @param {unknown} error
		     * @param {AccountInfo?} account
		     * @returns {(PerformanceEvent | null)}
		     */
		    endMeasurement(event, error, account) {
		        const rootEvent = this.eventsByCorrelationId.get(event.correlationId);
		        if (!rootEvent) {
		            this.logger.trace(`PerformanceClient: Measurement not found for ${event.eventId}`, event.correlationId);
		            return null;
		        }
		        const isRoot = event.eventId === rootEvent.eventId;
		        let queueInfo = {
		            totalQueueTime: 0,
		            totalQueueCount: 0,
		            manuallyCompletedCount: 0,
		        };
		        event.durationMs = Math.round(event.durationMs || this.getDurationMs(event.startTimeMs));
		        const context = JSON.stringify(endContext(event, this.abbreviations, this.eventStack.get(rootEvent.correlationId), error));
		        if (isRoot) {
		            queueInfo = this.getQueueInfo(event.correlationId);
		            this.discardMeasurements(rootEvent.correlationId);
		        }
		        else {
		            rootEvent.incompleteSubMeasurements?.delete(event.eventId);
		        }
		        this.logger.trace(`PerformanceClient: Performance measurement ended for ${event.name}: ${event.durationMs} ms`, event.correlationId);
		        if (error) {
		            addError(error, this.logger, rootEvent);
		        }
		        // Add sub-measurement attribute to root event.
		        if (!isRoot) {
		            rootEvent[event.name + "DurationMs"] = Math.floor(event.durationMs);
		            return { ...rootEvent };
		        }
		        if (isRoot &&
		            !error &&
		            (rootEvent.errorCode || rootEvent.subErrorCode)) {
		            this.logger.trace(`PerformanceClient: Remove error and sub-error codes for root event ${event.name} as intermediate error was successfully handled`, event.correlationId);
		            rootEvent.errorCode = undefined;
		            rootEvent.subErrorCode = undefined;
		        }
		        let finalEvent = { ...rootEvent, ...event };
		        let incompleteSubsCount = 0;
		        // Incomplete sub-measurements are discarded. They are likely an instrumentation bug that should be fixed.
		        finalEvent.incompleteSubMeasurements?.forEach((subMeasurement) => {
		            this.logger.trace(`PerformanceClient: Incomplete submeasurement ${subMeasurement.name} found for ${event.name}`, finalEvent.correlationId);
		            incompleteSubsCount++;
		        });
		        finalEvent.incompleteSubMeasurements = undefined;
		        finalEvent = {
		            ...finalEvent,
		            queuedTimeMs: queueInfo.totalQueueTime,
		            queuedCount: queueInfo.totalQueueCount,
		            queuedManuallyCompletedCount: queueInfo.manuallyCompletedCount,
		            status: indexNode.PerformanceEventStatus.Completed,
		            incompleteSubsCount,
		            context,
		        };
		        if (account) {
		            finalEvent.accountType = getAccountType(account);
		            finalEvent.dataBoundary = account.dataBoundary;
		        }
		        this.truncateIntegralFields(finalEvent);
		        this.emitEvents([finalEvent], event.correlationId);
		        return finalEvent;
		    }
		    /**
		     * Saves extra information to be emitted when the measurements are flushed
		     * @param fields
		     * @param correlationId
		     */
		    addFields(fields, correlationId) {
		        this.logger.trace("PerformanceClient: Updating static fields");
		        const event = this.eventsByCorrelationId.get(correlationId);
		        if (event) {
		            this.eventsByCorrelationId.set(correlationId, {
		                ...event,
		                ...fields,
		            });
		        }
		        else {
		            this.logger.trace("PerformanceClient: Event not found for", correlationId);
		        }
		    }
		    /**
		     * Increment counters to be emitted when the measurements are flushed
		     * @param fields {string[]}
		     * @param correlationId {string} correlation identifier
		     */
		    incrementFields(fields, correlationId) {
		        this.logger.trace("PerformanceClient: Updating counters");
		        const event = this.eventsByCorrelationId.get(correlationId);
		        if (event) {
		            for (const counter in fields) {
		                if (!event.hasOwnProperty(counter)) {
		                    event[counter] = 0;
		                }
		                else if (isNaN(Number(event[counter]))) {
		                    return;
		                }
		                event[counter] += fields[counter];
		            }
		        }
		        else {
		            this.logger.trace("PerformanceClient: Event not found for", correlationId);
		        }
		    }
		    /**
		     * Upserts event into event cache.
		     * First key is the correlation id, second key is the event id.
		     * Allows for events to be grouped by correlation id,
		     * and to easily allow for properties on them to be updated.
		     *
		     * @private
		     * @param {PerformanceEvent} event
		     */
		    cacheEventByCorrelationId(event) {
		        const rootEvent = this.eventsByCorrelationId.get(event.correlationId);
		        if (rootEvent) {
		            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} added/updated`, event.correlationId);
		            rootEvent.incompleteSubMeasurements =
		                rootEvent.incompleteSubMeasurements || new Map();
		            rootEvent.incompleteSubMeasurements.set(event.eventId, {
		                name: event.name,
		                startTimeMs: event.startTimeMs,
		            });
		        }
		        else {
		            this.logger.trace(`PerformanceClient: Performance measurement for ${event.name} started`, event.correlationId);
		            this.eventsByCorrelationId.set(event.correlationId, { ...event });
		            this.eventStack.set(event.correlationId, []);
		        }
		    }
		    getQueueInfo(correlationId) {
		        const queueMeasurementForCorrelationId = this.queueMeasurements.get(correlationId);
		        if (!queueMeasurementForCorrelationId) {
		            this.logger.trace(`PerformanceClient: no queue measurements found for for correlationId: ${correlationId}`);
		        }
		        let totalQueueTime = 0;
		        let totalQueueCount = 0;
		        let manuallyCompletedCount = 0;
		        queueMeasurementForCorrelationId?.forEach((measurement) => {
		            totalQueueTime += measurement.queueTime;
		            totalQueueCount++;
		            manuallyCompletedCount += measurement.manuallyCompleted ? 1 : 0;
		        });
		        return {
		            totalQueueTime,
		            totalQueueCount,
		            manuallyCompletedCount,
		        };
		    }
		    /**
		     * Removes measurements and aux data for a given correlation id.
		     *
		     * @param {string} correlationId
		     */
		    discardMeasurements(correlationId) {
		        this.logger.trace("PerformanceClient: Performance measurements discarded", correlationId);
		        this.eventsByCorrelationId.delete(correlationId);
		        this.logger.trace("PerformanceClient: QueueMeasurements discarded", correlationId);
		        this.queueMeasurements.delete(correlationId);
		        this.logger.trace("PerformanceClient: Pre-queue times discarded", correlationId);
		        this.preQueueTimeByCorrelationId.delete(correlationId);
		        this.logger.trace("PerformanceClient: Event stack discarded", correlationId);
		        this.eventStack.delete(correlationId);
		    }
		    /**
		     * Registers a callback function to receive performance events.
		     *
		     * @param {PerformanceCallbackFunction} callback
		     * @returns {string}
		     */
		    addPerformanceCallback(callback) {
		        for (const [id, cb] of this.callbacks) {
		            if (cb.toString() === callback.toString()) {
		                this.logger.warning(`PerformanceClient: Performance callback is already registered with id: ${id}`);
		                return id;
		            }
		        }
		        const callbackId = this.generateId();
		        this.callbacks.set(callbackId, callback);
		        this.logger.verbose(`PerformanceClient: Performance callback registered with id: ${callbackId}`);
		        return callbackId;
		    }
		    /**
		     * Removes a callback registered with addPerformanceCallback.
		     *
		     * @param {string} callbackId
		     * @returns {boolean}
		     */
		    removePerformanceCallback(callbackId) {
		        const result = this.callbacks.delete(callbackId);
		        if (result) {
		            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} removed.`);
		        }
		        else {
		            this.logger.verbose(`PerformanceClient: Performance callback ${callbackId} not removed.`);
		        }
		        return result;
		    }
		    /**
		     * Emits events to all registered callbacks.
		     *
		     * @param {PerformanceEvent[]} events
		     * @param {?string} [correlationId]
		     */
		    emitEvents(events, correlationId) {
		        this.logger.verbose("PerformanceClient: Emitting performance events", correlationId);
		        this.callbacks.forEach((callback, callbackId) => {
		            this.logger.trace(`PerformanceClient: Emitting event to callback ${callbackId}`, correlationId);
		            callback.apply(null, [events]);
		        });
		    }
		    /**
		     * Enforce truncation of integral fields in performance event.
		     * @param {PerformanceEvent} event performance event to update.
		     */
		    truncateIntegralFields(event) {
		        this.intFields.forEach((key) => {
		            if (key in event && typeof event[key] === "number") {
		                event[key] = Math.floor(event[key]);
		            }
		        });
		    }
		    /**
		     * Returns event duration in milliseconds
		     * @param startTimeMs {number}
		     * @returns {number}
		     */
		    getDurationMs(startTimeMs) {
		        const durationMs = Date.now() - startTimeMs;
		        // Handle clock skew
		        return durationMs < 0 ? durationMs : 0;
		    }
		}

		exports$1.AADAuthorityConstants = indexNode.AADAuthorityConstants;
		exports$1.AADServerParamKeys = indexNode.AADServerParamKeys;
		exports$1.AccountEntity = indexNode.AccountEntity;
		exports$1.AuthError = indexNode.AuthError;
		exports$1.AuthErrorCodes = indexNode.AuthErrorCodes;
		exports$1.AuthErrorMessage = indexNode.AuthErrorMessage;
		exports$1.AuthToken = indexNode.AuthToken;
		exports$1.AuthenticationHeaderParser = indexNode.AuthenticationHeaderParser;
		exports$1.AuthenticationScheme = indexNode.AuthenticationScheme;
		exports$1.Authority = indexNode.Authority;
		exports$1.AuthorityFactory = indexNode.AuthorityFactory;
		exports$1.AuthorityType = indexNode.AuthorityType;
		exports$1.AuthorizationCodeClient = indexNode.AuthorizationCodeClient;
		exports$1.AuthorizeProtocol = indexNode.Authorize;
		exports$1.AzureCloudInstance = indexNode.AzureCloudInstance;
		exports$1.BaseClient = indexNode.BaseClient;
		exports$1.CacheAccountType = indexNode.CacheAccountType;
		exports$1.CacheError = indexNode.CacheError;
		exports$1.CacheErrorCodes = indexNode.CacheErrorCodes;
		exports$1.CacheHelpers = indexNode.CacheHelpers;
		exports$1.CacheManager = indexNode.CacheManager;
		exports$1.CacheOutcome = indexNode.CacheOutcome;
		exports$1.CacheType = indexNode.CacheType;
		exports$1.CcsCredentialType = indexNode.CcsCredentialType;
		exports$1.ClaimsRequestKeys = indexNode.ClaimsRequestKeys;
		exports$1.ClientAuthError = indexNode.ClientAuthError;
		exports$1.ClientAuthErrorCodes = indexNode.ClientAuthErrorCodes;
		exports$1.ClientAuthErrorMessage = indexNode.ClientAuthErrorMessage;
		exports$1.ClientConfigurationError = indexNode.ClientConfigurationError;
		exports$1.ClientConfigurationErrorCodes = indexNode.ClientConfigurationErrorCodes;
		exports$1.ClientConfigurationErrorMessage = indexNode.ClientConfigurationErrorMessage;
		exports$1.CodeChallengeMethodValues = indexNode.CodeChallengeMethodValues;
		exports$1.Constants = indexNode.Constants;
		exports$1.CredentialType = indexNode.CredentialType;
		exports$1.DEFAULT_CRYPTO_IMPLEMENTATION = indexNode.DEFAULT_CRYPTO_IMPLEMENTATION;
		exports$1.DEFAULT_SYSTEM_OPTIONS = indexNode.DEFAULT_SYSTEM_OPTIONS;
		exports$1.DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = indexNode.DEFAULT_TOKEN_RENEWAL_OFFSET_SEC;
		exports$1.DefaultStorageClass = indexNode.DefaultStorageClass;
		exports$1.EncodingTypes = indexNode.EncodingTypes;
		exports$1.Errors = indexNode.Errors;
		exports$1.GrantType = indexNode.GrantType;
		exports$1.HeaderNames = indexNode.HeaderNames;
		exports$1.HttpMethod = indexNode.HttpMethod;
		exports$1.HttpStatus = indexNode.HttpStatus;
		exports$1.IntFields = indexNode.IntFields;
		exports$1.InteractionRequiredAuthError = indexNode.InteractionRequiredAuthError;
		exports$1.InteractionRequiredAuthErrorCodes = indexNode.InteractionRequiredAuthErrorCodes;
		exports$1.InteractionRequiredAuthErrorMessage = indexNode.InteractionRequiredAuthErrorMessage;
		exports$1.JsonWebTokenTypes = indexNode.JsonWebTokenTypes;
		Object.defineProperty(exports$1, "LogLevel", {
		    enumerable: true,
		    get: function () { return indexNode.LogLevel; }
		});
		exports$1.Logger = indexNode.Logger;
		exports$1.NetworkError = indexNode.NetworkError;
		exports$1.OAuthResponseType = indexNode.OAuthResponseType;
		exports$1.OIDC_DEFAULT_SCOPES = indexNode.OIDC_DEFAULT_SCOPES;
		exports$1.ONE_DAY_IN_MS = indexNode.ONE_DAY_IN_MS;
		exports$1.PasswordGrantConstants = indexNode.PasswordGrantConstants;
		exports$1.PerformanceEventStatus = indexNode.PerformanceEventStatus;
		exports$1.PerformanceEvents = indexNode.PerformanceEvents;
		exports$1.PersistentCacheKeys = indexNode.PersistentCacheKeys;
		exports$1.PlatformBrokerError = indexNode.PlatformBrokerError;
		exports$1.PopTokenGenerator = indexNode.PopTokenGenerator;
		exports$1.PromptValue = indexNode.PromptValue;
		exports$1.ProtocolMode = indexNode.ProtocolMode;
		exports$1.ProtocolUtils = indexNode.ProtocolUtils;
		exports$1.RefreshTokenClient = indexNode.RefreshTokenClient;
		exports$1.RequestParameterBuilder = indexNode.RequestParameterBuilder;
		exports$1.ResponseHandler = indexNode.ResponseHandler;
		exports$1.ResponseMode = indexNode.ResponseMode;
		exports$1.ScopeSet = indexNode.ScopeSet;
		exports$1.ServerError = indexNode.ServerError;
		exports$1.ServerResponseType = indexNode.ServerResponseType;
		exports$1.ServerTelemetryManager = indexNode.ServerTelemetryManager;
		exports$1.SilentFlowClient = indexNode.SilentFlowClient;
		exports$1.StringUtils = indexNode.StringUtils;
		exports$1.StubPerformanceClient = indexNode.StubPerformanceClient;
		exports$1.StubbedNetworkModule = indexNode.StubbedNetworkModule;
		exports$1.THE_FAMILY_ID = indexNode.THE_FAMILY_ID;
		exports$1.ThrottlingConstants = indexNode.ThrottlingConstants;
		exports$1.ThrottlingUtils = indexNode.ThrottlingUtils;
		exports$1.TimeUtils = indexNode.TimeUtils;
		exports$1.UrlString = indexNode.UrlString;
		exports$1.UrlUtils = indexNode.UrlUtils;
		exports$1.buildAccountToCache = indexNode.buildAccountToCache;
		exports$1.buildClientInfo = indexNode.buildClientInfo;
		exports$1.buildClientInfoFromHomeAccountId = indexNode.buildClientInfoFromHomeAccountId;
		exports$1.buildStaticAuthorityOptions = indexNode.buildStaticAuthorityOptions;
		exports$1.buildTenantProfile = indexNode.buildTenantProfile;
		exports$1.createAuthError = indexNode.createAuthError;
		exports$1.createCacheError = indexNode.createCacheError;
		exports$1.createClientAuthError = indexNode.createClientAuthError;
		exports$1.createClientConfigurationError = indexNode.createClientConfigurationError;
		exports$1.createInteractionRequiredAuthError = indexNode.createInteractionRequiredAuthError;
		exports$1.createNetworkError = indexNode.createNetworkError;
		exports$1.formatAuthorityUri = indexNode.formatAuthorityUri;
		exports$1.getRequestThumbprint = indexNode.getRequestThumbprint;
		exports$1.getTenantIdFromIdTokenClaims = indexNode.getTenantIdFromIdTokenClaims;
		exports$1.invoke = indexNode.invoke;
		exports$1.invokeAsync = indexNode.invokeAsync;
		exports$1.tenantIdMatchesHomeTenant = indexNode.tenantIdMatchesHomeTenant;
		exports$1.updateAccountTenantProfileData = indexNode.updateAccountTenantProfileData;
		exports$1.version = indexNode.version;
		exports$1.JoseHeader = JoseHeader;
		exports$1.PerformanceClient = PerformanceClient;
		
	} (indexBrowser));
	return indexBrowser;
}

/*! @azure/msal-common v15.13.3 2025-12-04 */

var hasRequiredLib$1;

function requireLib$1 () {
	if (hasRequiredLib$1) return lib$1;
	hasRequiredLib$1 = 1;
	(function (exports$1) {

		var indexNode = requireIndexNode4Jss3kYh();
		var indexBrowser = requireIndexBrowser();



		exports$1.AADAuthorityConstants = indexNode.AADAuthorityConstants;
		exports$1.AADServerParamKeys = indexNode.AADServerParamKeys;
		exports$1.AccountEntity = indexNode.AccountEntity;
		exports$1.AuthError = indexNode.AuthError;
		exports$1.AuthErrorCodes = indexNode.AuthErrorCodes;
		exports$1.AuthErrorMessage = indexNode.AuthErrorMessage;
		exports$1.AuthToken = indexNode.AuthToken;
		exports$1.AuthenticationHeaderParser = indexNode.AuthenticationHeaderParser;
		exports$1.AuthenticationScheme = indexNode.AuthenticationScheme;
		exports$1.Authority = indexNode.Authority;
		exports$1.AuthorityFactory = indexNode.AuthorityFactory;
		exports$1.AuthorityType = indexNode.AuthorityType;
		exports$1.AuthorizationCodeClient = indexNode.AuthorizationCodeClient;
		exports$1.AuthorizeProtocol = indexNode.Authorize;
		exports$1.AzureCloudInstance = indexNode.AzureCloudInstance;
		exports$1.BaseClient = indexNode.BaseClient;
		exports$1.CacheAccountType = indexNode.CacheAccountType;
		exports$1.CacheError = indexNode.CacheError;
		exports$1.CacheErrorCodes = indexNode.CacheErrorCodes;
		exports$1.CacheHelpers = indexNode.CacheHelpers;
		exports$1.CacheManager = indexNode.CacheManager;
		exports$1.CacheOutcome = indexNode.CacheOutcome;
		exports$1.CacheType = indexNode.CacheType;
		exports$1.CcsCredentialType = indexNode.CcsCredentialType;
		exports$1.ClaimsRequestKeys = indexNode.ClaimsRequestKeys;
		exports$1.ClientAssertionUtils = indexNode.ClientAssertionUtils;
		exports$1.ClientAuthError = indexNode.ClientAuthError;
		exports$1.ClientAuthErrorCodes = indexNode.ClientAuthErrorCodes;
		exports$1.ClientAuthErrorMessage = indexNode.ClientAuthErrorMessage;
		exports$1.ClientConfigurationError = indexNode.ClientConfigurationError;
		exports$1.ClientConfigurationErrorCodes = indexNode.ClientConfigurationErrorCodes;
		exports$1.ClientConfigurationErrorMessage = indexNode.ClientConfigurationErrorMessage;
		exports$1.CodeChallengeMethodValues = indexNode.CodeChallengeMethodValues;
		exports$1.Constants = indexNode.Constants;
		exports$1.CredentialType = indexNode.CredentialType;
		exports$1.DEFAULT_CRYPTO_IMPLEMENTATION = indexNode.DEFAULT_CRYPTO_IMPLEMENTATION;
		exports$1.DEFAULT_SYSTEM_OPTIONS = indexNode.DEFAULT_SYSTEM_OPTIONS;
		exports$1.DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = indexNode.DEFAULT_TOKEN_RENEWAL_OFFSET_SEC;
		exports$1.DefaultStorageClass = indexNode.DefaultStorageClass;
		exports$1.EncodingTypes = indexNode.EncodingTypes;
		exports$1.Errors = indexNode.Errors;
		exports$1.GrantType = indexNode.GrantType;
		exports$1.HeaderNames = indexNode.HeaderNames;
		exports$1.HttpMethod = indexNode.HttpMethod;
		exports$1.HttpStatus = indexNode.HttpStatus;
		exports$1.IntFields = indexNode.IntFields;
		exports$1.InteractionRequiredAuthError = indexNode.InteractionRequiredAuthError;
		exports$1.InteractionRequiredAuthErrorCodes = indexNode.InteractionRequiredAuthErrorCodes;
		exports$1.InteractionRequiredAuthErrorMessage = indexNode.InteractionRequiredAuthErrorMessage;
		exports$1.JsonWebTokenTypes = indexNode.JsonWebTokenTypes;
		Object.defineProperty(exports$1, "LogLevel", {
			enumerable: true,
			get: function () { return indexNode.LogLevel; }
		});
		exports$1.Logger = indexNode.Logger;
		exports$1.NetworkError = indexNode.NetworkError;
		exports$1.OAuthResponseType = indexNode.OAuthResponseType;
		exports$1.OIDC_DEFAULT_SCOPES = indexNode.OIDC_DEFAULT_SCOPES;
		exports$1.ONE_DAY_IN_MS = indexNode.ONE_DAY_IN_MS;
		exports$1.PasswordGrantConstants = indexNode.PasswordGrantConstants;
		exports$1.PerformanceEventStatus = indexNode.PerformanceEventStatus;
		exports$1.PerformanceEvents = indexNode.PerformanceEvents;
		exports$1.PersistentCacheKeys = indexNode.PersistentCacheKeys;
		exports$1.PlatformBrokerError = indexNode.PlatformBrokerError;
		exports$1.PopTokenGenerator = indexNode.PopTokenGenerator;
		exports$1.PromptValue = indexNode.PromptValue;
		exports$1.ProtocolMode = indexNode.ProtocolMode;
		exports$1.ProtocolUtils = indexNode.ProtocolUtils;
		exports$1.RefreshTokenClient = indexNode.RefreshTokenClient;
		exports$1.RequestParameterBuilder = indexNode.RequestParameterBuilder;
		exports$1.ResponseHandler = indexNode.ResponseHandler;
		exports$1.ResponseMode = indexNode.ResponseMode;
		exports$1.ScopeSet = indexNode.ScopeSet;
		exports$1.ServerError = indexNode.ServerError;
		exports$1.ServerResponseType = indexNode.ServerResponseType;
		exports$1.ServerTelemetryManager = indexNode.ServerTelemetryManager;
		exports$1.SilentFlowClient = indexNode.SilentFlowClient;
		exports$1.StringUtils = indexNode.StringUtils;
		exports$1.StubPerformanceClient = indexNode.StubPerformanceClient;
		exports$1.StubbedNetworkModule = indexNode.StubbedNetworkModule;
		exports$1.THE_FAMILY_ID = indexNode.THE_FAMILY_ID;
		exports$1.ThrottlingConstants = indexNode.ThrottlingConstants;
		exports$1.ThrottlingUtils = indexNode.ThrottlingUtils;
		exports$1.TimeUtils = indexNode.TimeUtils;
		exports$1.TokenCacheContext = indexNode.TokenCacheContext;
		exports$1.UrlString = indexNode.UrlString;
		exports$1.UrlUtils = indexNode.UrlUtils;
		exports$1.buildAccountToCache = indexNode.buildAccountToCache;
		exports$1.buildClientInfo = indexNode.buildClientInfo;
		exports$1.buildClientInfoFromHomeAccountId = indexNode.buildClientInfoFromHomeAccountId;
		exports$1.buildStaticAuthorityOptions = indexNode.buildStaticAuthorityOptions;
		exports$1.buildTenantProfile = indexNode.buildTenantProfile;
		exports$1.createAuthError = indexNode.createAuthError;
		exports$1.createCacheError = indexNode.createCacheError;
		exports$1.createClientAuthError = indexNode.createClientAuthError;
		exports$1.createClientConfigurationError = indexNode.createClientConfigurationError;
		exports$1.createInteractionRequiredAuthError = indexNode.createInteractionRequiredAuthError;
		exports$1.createNetworkError = indexNode.createNetworkError;
		exports$1.formatAuthorityUri = indexNode.formatAuthorityUri;
		exports$1.getClientAssertion = indexNode.getClientAssertion;
		exports$1.getRequestThumbprint = indexNode.getRequestThumbprint;
		exports$1.getTenantIdFromIdTokenClaims = indexNode.getTenantIdFromIdTokenClaims;
		exports$1.invoke = indexNode.invoke;
		exports$1.invokeAsync = indexNode.invokeAsync;
		exports$1.tenantIdMatchesHomeTenant = indexNode.tenantIdMatchesHomeTenant;
		exports$1.updateAccountTenantProfileData = indexNode.updateAccountTenantProfileData;
		exports$1.version = indexNode.version;
		exports$1.JoseHeader = indexBrowser.JoseHeader;
		exports$1.PerformanceClient = indexBrowser.PerformanceClient;
		
	} (lib$1));
	return lib$1;
}

var jws = {};

var safeBuffer = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports$1) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = require$$0$7;
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports$1);
		  exports$1.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

/*global module, process*/

var dataStream;
var hasRequiredDataStream;

function requireDataStream () {
	if (hasRequiredDataStream) return dataStream;
	hasRequiredDataStream = 1;
	var Buffer = requireSafeBuffer().Buffer;
	var Stream = require$$0$6;
	var util = require$$5$1;

	function DataStream(data) {
	  this.buffer = null;
	  this.writable = true;
	  this.readable = true;

	  // No input
	  if (!data) {
	    this.buffer = Buffer.alloc(0);
	    return this;
	  }

	  // Stream
	  if (typeof data.pipe === 'function') {
	    this.buffer = Buffer.alloc(0);
	    data.pipe(this);
	    return this;
	  }

	  // Buffer or String
	  // or Object (assumedly a passworded key)
	  if (data.length || typeof data === 'object') {
	    this.buffer = data;
	    this.writable = false;
	    process.nextTick(function () {
	      this.emit('end', data);
	      this.readable = false;
	      this.emit('close');
	    }.bind(this));
	    return this;
	  }

	  throw new TypeError('Unexpected data type ('+ typeof data + ')');
	}
	util.inherits(DataStream, Stream);

	DataStream.prototype.write = function write(data) {
	  this.buffer = Buffer.concat([this.buffer, Buffer.from(data)]);
	  this.emit('data', data);
	};

	DataStream.prototype.end = function end(data) {
	  if (data)
	    this.write(data);
	  this.emit('end', data);
	  this.emit('close');
	  this.writable = false;
	  this.readable = false;
	};

	dataStream = DataStream;
	return dataStream;
}

var paramBytesForAlg_1;
var hasRequiredParamBytesForAlg;

function requireParamBytesForAlg () {
	if (hasRequiredParamBytesForAlg) return paramBytesForAlg_1;
	hasRequiredParamBytesForAlg = 1;

	function getParamSize(keySize) {
		var result = ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1);
		return result;
	}

	var paramBytesForAlg = {
		ES256: getParamSize(256),
		ES384: getParamSize(384),
		ES512: getParamSize(521)
	};

	function getParamBytesForAlg(alg) {
		var paramBytes = paramBytesForAlg[alg];
		if (paramBytes) {
			return paramBytes;
		}

		throw new Error('Unknown algorithm "' + alg + '"');
	}

	paramBytesForAlg_1 = getParamBytesForAlg;
	return paramBytesForAlg_1;
}

var ecdsaSigFormatter;
var hasRequiredEcdsaSigFormatter;

function requireEcdsaSigFormatter () {
	if (hasRequiredEcdsaSigFormatter) return ecdsaSigFormatter;
	hasRequiredEcdsaSigFormatter = 1;

	var Buffer = requireSafeBuffer().Buffer;

	var getParamBytesForAlg = requireParamBytesForAlg();

	var MAX_OCTET = 0x80,
		CLASS_UNIVERSAL = 0,
		PRIMITIVE_BIT = 0x20,
		TAG_SEQ = 0x10,
		TAG_INT = 0x02,
		ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6),
		ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6);

	function base64Url(base64) {
		return base64
			.replace(/=/g, '')
			.replace(/\+/g, '-')
			.replace(/\//g, '_');
	}

	function signatureAsBuffer(signature) {
		if (Buffer.isBuffer(signature)) {
			return signature;
		} else if ('string' === typeof signature) {
			return Buffer.from(signature, 'base64');
		}

		throw new TypeError('ECDSA signature must be a Base64 string or a Buffer');
	}

	function derToJose(signature, alg) {
		signature = signatureAsBuffer(signature);
		var paramBytes = getParamBytesForAlg(alg);

		// the DER encoded param should at most be the param size, plus a padding
		// zero, since due to being a signed integer
		var maxEncodedParamLength = paramBytes + 1;

		var inputLength = signature.length;

		var offset = 0;
		if (signature[offset++] !== ENCODED_TAG_SEQ) {
			throw new Error('Could not find expected "seq"');
		}

		var seqLength = signature[offset++];
		if (seqLength === (MAX_OCTET | 1)) {
			seqLength = signature[offset++];
		}

		if (inputLength - offset < seqLength) {
			throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
		}

		if (signature[offset++] !== ENCODED_TAG_INT) {
			throw new Error('Could not find expected "int" for "r"');
		}

		var rLength = signature[offset++];

		if (inputLength - offset - 2 < rLength) {
			throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
		}

		if (maxEncodedParamLength < rLength) {
			throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
		}

		var rOffset = offset;
		offset += rLength;

		if (signature[offset++] !== ENCODED_TAG_INT) {
			throw new Error('Could not find expected "int" for "s"');
		}

		var sLength = signature[offset++];

		if (inputLength - offset !== sLength) {
			throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
		}

		if (maxEncodedParamLength < sLength) {
			throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
		}

		var sOffset = offset;
		offset += sLength;

		if (offset !== inputLength) {
			throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
		}

		var rPadding = paramBytes - rLength,
			sPadding = paramBytes - sLength;

		var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);

		for (offset = 0; offset < rPadding; ++offset) {
			dst[offset] = 0;
		}
		signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);

		offset = paramBytes;

		for (var o = offset; offset < o + sPadding; ++offset) {
			dst[offset] = 0;
		}
		signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);

		dst = dst.toString('base64');
		dst = base64Url(dst);

		return dst;
	}

	function countPadding(buf, start, stop) {
		var padding = 0;
		while (start + padding < stop && buf[start + padding] === 0) {
			++padding;
		}

		var needsSign = buf[start + padding] >= MAX_OCTET;
		if (needsSign) {
			--padding;
		}

		return padding;
	}

	function joseToDer(signature, alg) {
		signature = signatureAsBuffer(signature);
		var paramBytes = getParamBytesForAlg(alg);

		var signatureBytes = signature.length;
		if (signatureBytes !== paramBytes * 2) {
			throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
		}

		var rPadding = countPadding(signature, 0, paramBytes);
		var sPadding = countPadding(signature, paramBytes, signature.length);
		var rLength = paramBytes - rPadding;
		var sLength = paramBytes - sPadding;

		var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;

		var shortLength = rsBytes < MAX_OCTET;

		var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);

		var offset = 0;
		dst[offset++] = ENCODED_TAG_SEQ;
		if (shortLength) {
			// Bit 8 has value "0"
			// bits 7-1 give the length.
			dst[offset++] = rsBytes;
		} else {
			// Bit 8 of first octet has value "1"
			// bits 7-1 give the number of additional length octets.
			dst[offset++] = MAX_OCTET	| 1;
			// length, base 256
			dst[offset++] = rsBytes & 0xff;
		}
		dst[offset++] = ENCODED_TAG_INT;
		dst[offset++] = rLength;
		if (rPadding < 0) {
			dst[offset++] = 0;
			offset += signature.copy(dst, offset, 0, paramBytes);
		} else {
			offset += signature.copy(dst, offset, rPadding, paramBytes);
		}
		dst[offset++] = ENCODED_TAG_INT;
		dst[offset++] = sLength;
		if (sPadding < 0) {
			dst[offset++] = 0;
			signature.copy(dst, offset, paramBytes);
		} else {
			signature.copy(dst, offset, paramBytes + sPadding);
		}

		return dst;
	}

	ecdsaSigFormatter = {
		derToJose: derToJose,
		joseToDer: joseToDer
	};
	return ecdsaSigFormatter;
}

/*jshint node:true */

var bufferEqualConstantTime;
var hasRequiredBufferEqualConstantTime;

function requireBufferEqualConstantTime () {
	if (hasRequiredBufferEqualConstantTime) return bufferEqualConstantTime;
	hasRequiredBufferEqualConstantTime = 1;
	var Buffer = require$$0$7.Buffer; // browserify
	var SlowBuffer = require$$0$7.SlowBuffer;

	bufferEqualConstantTime = bufferEq;

	function bufferEq(a, b) {

	  // shortcutting on type is necessary for correctness
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    return false;
	  }

	  // buffer sizes should be well-known information, so despite this
	  // shortcutting, it doesn't leak any information about the *contents* of the
	  // buffers.
	  if (a.length !== b.length) {
	    return false;
	  }

	  var c = 0;
	  for (var i = 0; i < a.length; i++) {
	    /*jshint bitwise:false */
	    c |= a[i] ^ b[i]; // XOR
	  }
	  return c === 0;
	}

	bufferEq.install = function() {
	  Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
	    return bufferEq(this, that);
	  };
	};

	var origBufEqual = Buffer.prototype.equal;
	var origSlowBufEqual = SlowBuffer.prototype.equal;
	bufferEq.restore = function() {
	  Buffer.prototype.equal = origBufEqual;
	  SlowBuffer.prototype.equal = origSlowBufEqual;
	};
	return bufferEqualConstantTime;
}

var jwa;
var hasRequiredJwa;

function requireJwa () {
	if (hasRequiredJwa) return jwa;
	hasRequiredJwa = 1;
	var Buffer = requireSafeBuffer().Buffer;
	var crypto = crypto$1;
	var formatEcdsa = requireEcdsaSigFormatter();
	var util = require$$5$1;

	var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
	var MSG_INVALID_SECRET = 'secret must be a string or buffer';
	var MSG_INVALID_VERIFIER_KEY = 'key must be a string or a buffer';
	var MSG_INVALID_SIGNER_KEY = 'key must be a string, a buffer or an object';

	var supportsKeyObjects = typeof crypto.createPublicKey === 'function';
	if (supportsKeyObjects) {
	  MSG_INVALID_VERIFIER_KEY += ' or a KeyObject';
	  MSG_INVALID_SECRET += 'or a KeyObject';
	}

	function checkIsPublicKey(key) {
	  if (Buffer.isBuffer(key)) {
	    return;
	  }

	  if (typeof key === 'string') {
	    return;
	  }

	  if (!supportsKeyObjects) {
	    throw typeError(MSG_INVALID_VERIFIER_KEY);
	  }

	  if (typeof key !== 'object') {
	    throw typeError(MSG_INVALID_VERIFIER_KEY);
	  }

	  if (typeof key.type !== 'string') {
	    throw typeError(MSG_INVALID_VERIFIER_KEY);
	  }

	  if (typeof key.asymmetricKeyType !== 'string') {
	    throw typeError(MSG_INVALID_VERIFIER_KEY);
	  }

	  if (typeof key.export !== 'function') {
	    throw typeError(MSG_INVALID_VERIFIER_KEY);
	  }
	}
	function checkIsPrivateKey(key) {
	  if (Buffer.isBuffer(key)) {
	    return;
	  }

	  if (typeof key === 'string') {
	    return;
	  }

	  if (typeof key === 'object') {
	    return;
	  }

	  throw typeError(MSG_INVALID_SIGNER_KEY);
	}
	function checkIsSecretKey(key) {
	  if (Buffer.isBuffer(key)) {
	    return;
	  }

	  if (typeof key === 'string') {
	    return key;
	  }

	  if (!supportsKeyObjects) {
	    throw typeError(MSG_INVALID_SECRET);
	  }

	  if (typeof key !== 'object') {
	    throw typeError(MSG_INVALID_SECRET);
	  }

	  if (key.type !== 'secret') {
	    throw typeError(MSG_INVALID_SECRET);
	  }

	  if (typeof key.export !== 'function') {
	    throw typeError(MSG_INVALID_SECRET);
	  }
	}

	function fromBase64(base64) {
	  return base64
	    .replace(/=/g, '')
	    .replace(/\+/g, '-')
	    .replace(/\//g, '_');
	}

	function toBase64(base64url) {
	  base64url = base64url.toString();

	  var padding = 4 - base64url.length % 4;
	  if (padding !== 4) {
	    for (var i = 0; i < padding; ++i) {
	      base64url += '=';
	    }
	  }

	  return base64url
	    .replace(/\-/g, '+')
	    .replace(/_/g, '/');
	}

	function typeError(template) {
	  var args = [].slice.call(arguments, 1);
	  var errMsg = util.format.bind(util, template).apply(null, args);
	  return new TypeError(errMsg);
	}

	function bufferOrString(obj) {
	  return Buffer.isBuffer(obj) || typeof obj === 'string';
	}

	function normalizeInput(thing) {
	  if (!bufferOrString(thing))
	    thing = JSON.stringify(thing);
	  return thing;
	}

	function createHmacSigner(bits) {
	  return function sign(thing, secret) {
	    checkIsSecretKey(secret);
	    thing = normalizeInput(thing);
	    var hmac = crypto.createHmac('sha' + bits, secret);
	    var sig = (hmac.update(thing), hmac.digest('base64'));
	    return fromBase64(sig);
	  }
	}

	var bufferEqual;
	var timingSafeEqual = 'timingSafeEqual' in crypto ? function timingSafeEqual(a, b) {
	  if (a.byteLength !== b.byteLength) {
	    return false;
	  }

	  return crypto.timingSafeEqual(a, b)
	} : function timingSafeEqual(a, b) {
	  if (!bufferEqual) {
	    bufferEqual = requireBufferEqualConstantTime();
	  }

	  return bufferEqual(a, b)
	};

	function createHmacVerifier(bits) {
	  return function verify(thing, signature, secret) {
	    var computedSig = createHmacSigner(bits)(thing, secret);
	    return timingSafeEqual(Buffer.from(signature), Buffer.from(computedSig));
	  }
	}

	function createKeySigner(bits) {
	 return function sign(thing, privateKey) {
	    checkIsPrivateKey(privateKey);
	    thing = normalizeInput(thing);
	    // Even though we are specifying "RSA" here, this works with ECDSA
	    // keys as well.
	    var signer = crypto.createSign('RSA-SHA' + bits);
	    var sig = (signer.update(thing), signer.sign(privateKey, 'base64'));
	    return fromBase64(sig);
	  }
	}

	function createKeyVerifier(bits) {
	  return function verify(thing, signature, publicKey) {
	    checkIsPublicKey(publicKey);
	    thing = normalizeInput(thing);
	    signature = toBase64(signature);
	    var verifier = crypto.createVerify('RSA-SHA' + bits);
	    verifier.update(thing);
	    return verifier.verify(publicKey, signature, 'base64');
	  }
	}

	function createPSSKeySigner(bits) {
	  return function sign(thing, privateKey) {
	    checkIsPrivateKey(privateKey);
	    thing = normalizeInput(thing);
	    var signer = crypto.createSign('RSA-SHA' + bits);
	    var sig = (signer.update(thing), signer.sign({
	      key: privateKey,
	      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
	      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
	    }, 'base64'));
	    return fromBase64(sig);
	  }
	}

	function createPSSKeyVerifier(bits) {
	  return function verify(thing, signature, publicKey) {
	    checkIsPublicKey(publicKey);
	    thing = normalizeInput(thing);
	    signature = toBase64(signature);
	    var verifier = crypto.createVerify('RSA-SHA' + bits);
	    verifier.update(thing);
	    return verifier.verify({
	      key: publicKey,
	      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
	      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
	    }, signature, 'base64');
	  }
	}

	function createECDSASigner(bits) {
	  var inner = createKeySigner(bits);
	  return function sign() {
	    var signature = inner.apply(null, arguments);
	    signature = formatEcdsa.derToJose(signature, 'ES' + bits);
	    return signature;
	  };
	}

	function createECDSAVerifer(bits) {
	  var inner = createKeyVerifier(bits);
	  return function verify(thing, signature, publicKey) {
	    signature = formatEcdsa.joseToDer(signature, 'ES' + bits).toString('base64');
	    var result = inner(thing, signature, publicKey);
	    return result;
	  };
	}

	function createNoneSigner() {
	  return function sign() {
	    return '';
	  }
	}

	function createNoneVerifier() {
	  return function verify(thing, signature) {
	    return signature === '';
	  }
	}

	jwa = function jwa(algorithm) {
	  var signerFactories = {
	    hs: createHmacSigner,
	    rs: createKeySigner,
	    ps: createPSSKeySigner,
	    es: createECDSASigner,
	    none: createNoneSigner,
	  };
	  var verifierFactories = {
	    hs: createHmacVerifier,
	    rs: createKeyVerifier,
	    ps: createPSSKeyVerifier,
	    es: createECDSAVerifer,
	    none: createNoneVerifier,
	  };
	  var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
	  if (!match)
	    throw typeError(MSG_INVALID_ALGORITHM, algorithm);
	  var algo = (match[1] || match[3]).toLowerCase();
	  var bits = match[2];

	  return {
	    sign: signerFactories[algo](bits),
	    verify: verifierFactories[algo](bits),
	  }
	};
	return jwa;
}

/*global module*/

var tostring;
var hasRequiredTostring;

function requireTostring () {
	if (hasRequiredTostring) return tostring;
	hasRequiredTostring = 1;
	var Buffer = require$$0$7.Buffer;

	tostring = function toString(obj) {
	  if (typeof obj === 'string')
	    return obj;
	  if (typeof obj === 'number' || Buffer.isBuffer(obj))
	    return obj.toString();
	  return JSON.stringify(obj);
	};
	return tostring;
}

/*global module*/

var signStream;
var hasRequiredSignStream;

function requireSignStream () {
	if (hasRequiredSignStream) return signStream;
	hasRequiredSignStream = 1;
	var Buffer = requireSafeBuffer().Buffer;
	var DataStream = requireDataStream();
	var jwa = requireJwa();
	var Stream = require$$0$6;
	var toString = requireTostring();
	var util = require$$5$1;

	function base64url(string, encoding) {
	  return Buffer
	    .from(string, encoding)
	    .toString('base64')
	    .replace(/=/g, '')
	    .replace(/\+/g, '-')
	    .replace(/\//g, '_');
	}

	function jwsSecuredInput(header, payload, encoding) {
	  encoding = encoding || 'utf8';
	  var encodedHeader = base64url(toString(header), 'binary');
	  var encodedPayload = base64url(toString(payload), encoding);
	  return util.format('%s.%s', encodedHeader, encodedPayload);
	}

	function jwsSign(opts) {
	  var header = opts.header;
	  var payload = opts.payload;
	  var secretOrKey = opts.secret || opts.privateKey;
	  var encoding = opts.encoding;
	  var algo = jwa(header.alg);
	  var securedInput = jwsSecuredInput(header, payload, encoding);
	  var signature = algo.sign(securedInput, secretOrKey);
	  return util.format('%s.%s', securedInput, signature);
	}

	function SignStream(opts) {
	  var secret = opts.secret;
	  secret = secret == null ? opts.privateKey : secret;
	  secret = secret == null ? opts.key : secret;
	  if (/^hs/i.test(opts.header.alg) === true && secret == null) {
	    throw new TypeError('secret must be a string or buffer or a KeyObject')
	  }
	  var secretStream = new DataStream(secret);
	  this.readable = true;
	  this.header = opts.header;
	  this.encoding = opts.encoding;
	  this.secret = this.privateKey = this.key = secretStream;
	  this.payload = new DataStream(opts.payload);
	  this.secret.once('close', function () {
	    if (!this.payload.writable && this.readable)
	      this.sign();
	  }.bind(this));

	  this.payload.once('close', function () {
	    if (!this.secret.writable && this.readable)
	      this.sign();
	  }.bind(this));
	}
	util.inherits(SignStream, Stream);

	SignStream.prototype.sign = function sign() {
	  try {
	    var signature = jwsSign({
	      header: this.header,
	      payload: this.payload.buffer,
	      secret: this.secret.buffer,
	      encoding: this.encoding
	    });
	    this.emit('done', signature);
	    this.emit('data', signature);
	    this.emit('end');
	    this.readable = false;
	    return signature;
	  } catch (e) {
	    this.readable = false;
	    this.emit('error', e);
	    this.emit('close');
	  }
	};

	SignStream.sign = jwsSign;

	signStream = SignStream;
	return signStream;
}

/*global module*/

var verifyStream;
var hasRequiredVerifyStream;

function requireVerifyStream () {
	if (hasRequiredVerifyStream) return verifyStream;
	hasRequiredVerifyStream = 1;
	var Buffer = requireSafeBuffer().Buffer;
	var DataStream = requireDataStream();
	var jwa = requireJwa();
	var Stream = require$$0$6;
	var toString = requireTostring();
	var util = require$$5$1;
	var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;

	function isObject(thing) {
	  return Object.prototype.toString.call(thing) === '[object Object]';
	}

	function safeJsonParse(thing) {
	  if (isObject(thing))
	    return thing;
	  try { return JSON.parse(thing); }
	  catch (e) { return undefined; }
	}

	function headerFromJWS(jwsSig) {
	  var encodedHeader = jwsSig.split('.', 1)[0];
	  return safeJsonParse(Buffer.from(encodedHeader, 'base64').toString('binary'));
	}

	function securedInputFromJWS(jwsSig) {
	  return jwsSig.split('.', 2).join('.');
	}

	function signatureFromJWS(jwsSig) {
	  return jwsSig.split('.')[2];
	}

	function payloadFromJWS(jwsSig, encoding) {
	  encoding = encoding || 'utf8';
	  var payload = jwsSig.split('.')[1];
	  return Buffer.from(payload, 'base64').toString(encoding);
	}

	function isValidJws(string) {
	  return JWS_REGEX.test(string) && !!headerFromJWS(string);
	}

	function jwsVerify(jwsSig, algorithm, secretOrKey) {
	  if (!algorithm) {
	    var err = new Error("Missing algorithm parameter for jws.verify");
	    err.code = "MISSING_ALGORITHM";
	    throw err;
	  }
	  jwsSig = toString(jwsSig);
	  var signature = signatureFromJWS(jwsSig);
	  var securedInput = securedInputFromJWS(jwsSig);
	  var algo = jwa(algorithm);
	  return algo.verify(securedInput, signature, secretOrKey);
	}

	function jwsDecode(jwsSig, opts) {
	  opts = opts || {};
	  jwsSig = toString(jwsSig);

	  if (!isValidJws(jwsSig))
	    return null;

	  var header = headerFromJWS(jwsSig);

	  if (!header)
	    return null;

	  var payload = payloadFromJWS(jwsSig);
	  if (header.typ === 'JWT' || opts.json)
	    payload = JSON.parse(payload, opts.encoding);

	  return {
	    header: header,
	    payload: payload,
	    signature: signatureFromJWS(jwsSig)
	  };
	}

	function VerifyStream(opts) {
	  opts = opts || {};
	  var secretOrKey = opts.secret;
	  secretOrKey = secretOrKey == null ? opts.publicKey : secretOrKey;
	  secretOrKey = secretOrKey == null ? opts.key : secretOrKey;
	  if (/^hs/i.test(opts.algorithm) === true && secretOrKey == null) {
	    throw new TypeError('secret must be a string or buffer or a KeyObject')
	  }
	  var secretStream = new DataStream(secretOrKey);
	  this.readable = true;
	  this.algorithm = opts.algorithm;
	  this.encoding = opts.encoding;
	  this.secret = this.publicKey = this.key = secretStream;
	  this.signature = new DataStream(opts.signature);
	  this.secret.once('close', function () {
	    if (!this.signature.writable && this.readable)
	      this.verify();
	  }.bind(this));

	  this.signature.once('close', function () {
	    if (!this.secret.writable && this.readable)
	      this.verify();
	  }.bind(this));
	}
	util.inherits(VerifyStream, Stream);
	VerifyStream.prototype.verify = function verify() {
	  try {
	    var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
	    var obj = jwsDecode(this.signature.buffer, this.encoding);
	    this.emit('done', valid, obj);
	    this.emit('data', valid);
	    this.emit('end');
	    this.readable = false;
	    return valid;
	  } catch (e) {
	    this.readable = false;
	    this.emit('error', e);
	    this.emit('close');
	  }
	};

	VerifyStream.decode = jwsDecode;
	VerifyStream.isValid = isValidJws;
	VerifyStream.verify = jwsVerify;

	verifyStream = VerifyStream;
	return verifyStream;
}

/*global exports*/

var hasRequiredJws;

function requireJws () {
	if (hasRequiredJws) return jws;
	hasRequiredJws = 1;
	var SignStream = requireSignStream();
	var VerifyStream = requireVerifyStream();

	var ALGORITHMS = [
	  'HS256', 'HS384', 'HS512',
	  'RS256', 'RS384', 'RS512',
	  'PS256', 'PS384', 'PS512',
	  'ES256', 'ES384', 'ES512'
	];

	jws.ALGORITHMS = ALGORITHMS;
	jws.sign = SignStream.sign;
	jws.verify = VerifyStream.verify;
	jws.decode = VerifyStream.decode;
	jws.isValid = VerifyStream.isValid;
	jws.createSign = function createSign(opts) {
	  return new SignStream(opts);
	};
	jws.createVerify = function createVerify(opts) {
	  return new VerifyStream(opts);
	};
	return jws;
}

var decode;
var hasRequiredDecode;

function requireDecode () {
	if (hasRequiredDecode) return decode;
	hasRequiredDecode = 1;
	var jws = requireJws();

	decode = function (jwt, options) {
	  options = options || {};
	  var decoded = jws.decode(jwt, options);
	  if (!decoded) { return null; }
	  var payload = decoded.payload;

	  //try parse the payload
	  if(typeof payload === 'string') {
	    try {
	      var obj = JSON.parse(payload);
	      if(obj !== null && typeof obj === 'object') {
	        payload = obj;
	      }
	    } catch (e) { }
	  }

	  //return header if `complete` option is enabled.  header includes claims
	  //such as `kid` and `alg` used to select the key within a JWKS needed to
	  //verify the signature
	  if (options.complete === true) {
	    return {
	      header: decoded.header,
	      payload: payload,
	      signature: decoded.signature
	    };
	  }
	  return payload;
	};
	return decode;
}

var JsonWebTokenError_1;
var hasRequiredJsonWebTokenError;

function requireJsonWebTokenError () {
	if (hasRequiredJsonWebTokenError) return JsonWebTokenError_1;
	hasRequiredJsonWebTokenError = 1;
	var JsonWebTokenError = function (message, error) {
	  Error.call(this, message);
	  if(Error.captureStackTrace) {
	    Error.captureStackTrace(this, this.constructor);
	  }
	  this.name = 'JsonWebTokenError';
	  this.message = message;
	  if (error) this.inner = error;
	};

	JsonWebTokenError.prototype = Object.create(Error.prototype);
	JsonWebTokenError.prototype.constructor = JsonWebTokenError;

	JsonWebTokenError_1 = JsonWebTokenError;
	return JsonWebTokenError_1;
}

var NotBeforeError_1;
var hasRequiredNotBeforeError;

function requireNotBeforeError () {
	if (hasRequiredNotBeforeError) return NotBeforeError_1;
	hasRequiredNotBeforeError = 1;
	var JsonWebTokenError = requireJsonWebTokenError();

	var NotBeforeError = function (message, date) {
	  JsonWebTokenError.call(this, message);
	  this.name = 'NotBeforeError';
	  this.date = date;
	};

	NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);

	NotBeforeError.prototype.constructor = NotBeforeError;

	NotBeforeError_1 = NotBeforeError;
	return NotBeforeError_1;
}

var TokenExpiredError_1;
var hasRequiredTokenExpiredError;

function requireTokenExpiredError () {
	if (hasRequiredTokenExpiredError) return TokenExpiredError_1;
	hasRequiredTokenExpiredError = 1;
	var JsonWebTokenError = requireJsonWebTokenError();

	var TokenExpiredError = function (message, expiredAt) {
	  JsonWebTokenError.call(this, message);
	  this.name = 'TokenExpiredError';
	  this.expiredAt = expiredAt;
	};

	TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);

	TokenExpiredError.prototype.constructor = TokenExpiredError;

	TokenExpiredError_1 = TokenExpiredError;
	return TokenExpiredError_1;
}

var timespan;
var hasRequiredTimespan;

function requireTimespan () {
	if (hasRequiredTimespan) return timespan;
	hasRequiredTimespan = 1;
	var ms = requireMs();

	timespan = function (time, iat) {
	  var timestamp = iat || Math.floor(Date.now() / 1000);

	  if (typeof time === 'string') {
	    var milliseconds = ms(time);
	    if (typeof milliseconds === 'undefined') {
	      return;
	    }
	    return Math.floor(timestamp + milliseconds / 1000);
	  } else if (typeof time === 'number') {
	    return timestamp + time;
	  } else {
	    return;
	  }

	};
	return timespan;
}

var re = {exports: {}};

var constants$2;
var hasRequiredConstants$2;

function requireConstants$2 () {
	if (hasRequiredConstants$2) return constants$2;
	hasRequiredConstants$2 = 1;

	// Note: this is the semver.org version of the spec that it implements
	// Not necessarily the package version of this code.
	const SEMVER_SPEC_VERSION = '2.0.0';

	const MAX_LENGTH = 256;
	const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
	/* istanbul ignore next */ 9007199254740991;

	// Max safe segment length for coercion.
	const MAX_SAFE_COMPONENT_LENGTH = 16;

	// Max safe length for a build identifier. The max length minus 6 characters for
	// the shortest version with a build 0.0.0+BUILD.
	const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;

	const RELEASE_TYPES = [
	  'major',
	  'premajor',
	  'minor',
	  'preminor',
	  'patch',
	  'prepatch',
	  'prerelease',
	];

	constants$2 = {
	  MAX_LENGTH,
	  MAX_SAFE_COMPONENT_LENGTH,
	  MAX_SAFE_BUILD_LENGTH,
	  MAX_SAFE_INTEGER,
	  RELEASE_TYPES,
	  SEMVER_SPEC_VERSION,
	  FLAG_INCLUDE_PRERELEASE: 0b001,
	  FLAG_LOOSE: 0b010,
	};
	return constants$2;
}

var debug_1;
var hasRequiredDebug$1;

function requireDebug$1 () {
	if (hasRequiredDebug$1) return debug_1;
	hasRequiredDebug$1 = 1;

	const debug = (
	  typeof process === 'object' &&
	  process.env &&
	  process.env.NODE_DEBUG &&
	  /\bsemver\b/i.test(process.env.NODE_DEBUG)
	) ? (...args) => console.error('SEMVER', ...args)
	  : () => {};

	debug_1 = debug;
	return debug_1;
}

var hasRequiredRe;

function requireRe () {
	if (hasRequiredRe) return re.exports;
	hasRequiredRe = 1;
	(function (module, exports$1) {

		const {
		  MAX_SAFE_COMPONENT_LENGTH,
		  MAX_SAFE_BUILD_LENGTH,
		  MAX_LENGTH,
		} = requireConstants$2();
		const debug = requireDebug$1();
		exports$1 = module.exports = {};

		// The actual regexps go on exports.re
		const re = exports$1.re = [];
		const safeRe = exports$1.safeRe = [];
		const src = exports$1.src = [];
		const safeSrc = exports$1.safeSrc = [];
		const t = exports$1.t = {};
		let R = 0;

		const LETTERDASHNUMBER = '[a-zA-Z0-9-]';

		// Replace some greedy regex tokens to prevent regex dos issues. These regex are
		// used internally via the safeRe object since all inputs in this library get
		// normalized first to trim and collapse all extra whitespace. The original
		// regexes are exported for userland consumption and lower level usage. A
		// future breaking change could export the safer regex only with a note that
		// all input should have extra whitespace removed.
		const safeRegexReplacements = [
		  ['\\s', 1],
		  ['\\d', MAX_LENGTH],
		  [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
		];

		const makeSafeRegex = (value) => {
		  for (const [token, max] of safeRegexReplacements) {
		    value = value
		      .split(`${token}*`).join(`${token}{0,${max}}`)
		      .split(`${token}+`).join(`${token}{1,${max}}`);
		  }
		  return value
		};

		const createToken = (name, value, isGlobal) => {
		  const safe = makeSafeRegex(value);
		  const index = R++;
		  debug(name, index, value);
		  t[name] = index;
		  src[index] = value;
		  safeSrc[index] = safe;
		  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
		  safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
		};

		// The following Regular Expressions can be used for tokenizing,
		// validating, and parsing SemVer version strings.

		// ## Numeric Identifier
		// A single `0`, or a non-zero digit followed by zero or more digits.

		createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
		createToken('NUMERICIDENTIFIERLOOSE', '\\d+');

		// ## Non-numeric Identifier
		// Zero or more digits, followed by a letter or hyphen, and then zero or
		// more letters, digits, or hyphens.

		createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);

		// ## Main Version
		// Three dot-separated numeric identifiers.

		createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
		                   `(${src[t.NUMERICIDENTIFIER]})`);

		createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
		                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`);

		// ## Pre-release Version Identifier
		// A numeric identifier, or a non-numeric identifier.
		// Non-numberic identifiers include numberic identifiers but can be longer.
		// Therefore non-numberic identifiers must go first.

		createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIER]})`);

		createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]
		}|${src[t.NUMERICIDENTIFIERLOOSE]})`);

		// ## Pre-release Version
		// Hyphen, followed by one or more dot-separated pre-release version
		// identifiers.

		createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
		}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);

		createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
		}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);

		// ## Build Metadata Identifier
		// Any combination of digits, letters, or hyphens.

		createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);

		// ## Build Metadata
		// Plus sign, followed by one or more period-separated build metadata
		// identifiers.

		createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
		}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);

		// ## Full Version String
		// A main version, followed optionally by a pre-release version and
		// build metadata.

		// Note that the only major, minor, patch, and pre-release sections of
		// the version string are capturing groups.  The build metadata is not a
		// capturing group, because it should not ever be used in version
		// comparison.

		createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
		}${src[t.PRERELEASE]}?${
		  src[t.BUILD]}?`);

		createToken('FULL', `^${src[t.FULLPLAIN]}$`);

		// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
		// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
		// common in the npm registry.
		createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
		}${src[t.PRERELEASELOOSE]}?${
		  src[t.BUILD]}?`);

		createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);

		createToken('GTLT', '((?:<|>)?=?)');

		// Something like "2.*" or "1.2.x".
		// Note that "x.x" is a valid xRange identifer, meaning "any version"
		// Only the first item is strictly required.
		createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
		createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);

		createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
		                   `(?:${src[t.PRERELEASE]})?${
		                     src[t.BUILD]}?` +
		                   `)?)?`);

		createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
		                        `(?:${src[t.PRERELEASELOOSE]})?${
		                          src[t.BUILD]}?` +
		                        `)?)?`);

		createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
		createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);

		// Coercion.
		// Extract anything that could conceivably be a part of a valid semver
		createToken('COERCEPLAIN', `${'(^|[^\\d])' +
		              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
		              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
		createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
		createToken('COERCEFULL', src[t.COERCEPLAIN] +
		              `(?:${src[t.PRERELEASE]})?` +
		              `(?:${src[t.BUILD]})?` +
		              `(?:$|[^\\d])`);
		createToken('COERCERTL', src[t.COERCE], true);
		createToken('COERCERTLFULL', src[t.COERCEFULL], true);

		// Tilde ranges.
		// Meaning is "reasonably at or greater than"
		createToken('LONETILDE', '(?:~>?)');

		createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
		exports$1.tildeTrimReplace = '$1~';

		createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
		createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);

		// Caret ranges.
		// Meaning is "at least and backwards compatible with"
		createToken('LONECARET', '(?:\\^)');

		createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
		exports$1.caretTrimReplace = '$1^';

		createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
		createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);

		// A simple gt/lt/eq thing, or just "" to indicate "any version"
		createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
		createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);

		// An expression to strip any whitespace between the gtlt and the thing
		// it modifies, so that `> 1.2.3` ==> `>1.2.3`
		createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
		}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
		exports$1.comparatorTrimReplace = '$1$2$3';

		// Something like `1.2.3 - 1.2.4`
		// Note that these all use the loose form, because they'll be
		// checked against either the strict or loose comparator form
		// later.
		createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
		                   `\\s+-\\s+` +
		                   `(${src[t.XRANGEPLAIN]})` +
		                   `\\s*$`);

		createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s+-\\s+` +
		                        `(${src[t.XRANGEPLAINLOOSE]})` +
		                        `\\s*$`);

		// Star ranges basically just allow anything at all.
		createToken('STAR', '(<|>)?=?\\s*\\*');
		// >=0.0.0 is like a star
		createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
		createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$'); 
	} (re, re.exports));
	return re.exports;
}

var parseOptions_1;
var hasRequiredParseOptions;

function requireParseOptions () {
	if (hasRequiredParseOptions) return parseOptions_1;
	hasRequiredParseOptions = 1;

	// parse out just the options we care about
	const looseOption = Object.freeze({ loose: true });
	const emptyOpts = Object.freeze({ });
	const parseOptions = options => {
	  if (!options) {
	    return emptyOpts
	  }

	  if (typeof options !== 'object') {
	    return looseOption
	  }

	  return options
	};
	parseOptions_1 = parseOptions;
	return parseOptions_1;
}

var identifiers;
var hasRequiredIdentifiers;

function requireIdentifiers () {
	if (hasRequiredIdentifiers) return identifiers;
	hasRequiredIdentifiers = 1;

	const numeric = /^[0-9]+$/;
	const compareIdentifiers = (a, b) => {
	  if (typeof a === 'number' && typeof b === 'number') {
	    return a === b ? 0 : a < b ? -1 : 1
	  }

	  const anum = numeric.test(a);
	  const bnum = numeric.test(b);

	  if (anum && bnum) {
	    a = +a;
	    b = +b;
	  }

	  return a === b ? 0
	    : (anum && !bnum) ? -1
	    : (bnum && !anum) ? 1
	    : a < b ? -1
	    : 1
	};

	const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);

	identifiers = {
	  compareIdentifiers,
	  rcompareIdentifiers,
	};
	return identifiers;
}

var semver$1;
var hasRequiredSemver$1;

function requireSemver$1 () {
	if (hasRequiredSemver$1) return semver$1;
	hasRequiredSemver$1 = 1;

	const debug = requireDebug$1();
	const { MAX_LENGTH, MAX_SAFE_INTEGER } = requireConstants$2();
	const { safeRe: re, t } = requireRe();

	const parseOptions = requireParseOptions();
	const { compareIdentifiers } = requireIdentifiers();
	class SemVer {
	  constructor (version, options) {
	    options = parseOptions(options);

	    if (version instanceof SemVer) {
	      if (version.loose === !!options.loose &&
	        version.includePrerelease === !!options.includePrerelease) {
	        return version
	      } else {
	        version = version.version;
	      }
	    } else if (typeof version !== 'string') {
	      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`)
	    }

	    if (version.length > MAX_LENGTH) {
	      throw new TypeError(
	        `version is longer than ${MAX_LENGTH} characters`
	      )
	    }

	    debug('SemVer', version, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    // this isn't actually relevant for versions, but keep it so that we
	    // don't run into trouble passing this.options around.
	    this.includePrerelease = !!options.includePrerelease;

	    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

	    if (!m) {
	      throw new TypeError(`Invalid Version: ${version}`)
	    }

	    this.raw = version;

	    // these are actually numbers
	    this.major = +m[1];
	    this.minor = +m[2];
	    this.patch = +m[3];

	    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
	      throw new TypeError('Invalid major version')
	    }

	    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
	      throw new TypeError('Invalid minor version')
	    }

	    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
	      throw new TypeError('Invalid patch version')
	    }

	    // numberify any prerelease numeric ids
	    if (!m[4]) {
	      this.prerelease = [];
	    } else {
	      this.prerelease = m[4].split('.').map((id) => {
	        if (/^[0-9]+$/.test(id)) {
	          const num = +id;
	          if (num >= 0 && num < MAX_SAFE_INTEGER) {
	            return num
	          }
	        }
	        return id
	      });
	    }

	    this.build = m[5] ? m[5].split('.') : [];
	    this.format();
	  }

	  format () {
	    this.version = `${this.major}.${this.minor}.${this.patch}`;
	    if (this.prerelease.length) {
	      this.version += `-${this.prerelease.join('.')}`;
	    }
	    return this.version
	  }

	  toString () {
	    return this.version
	  }

	  compare (other) {
	    debug('SemVer.compare', this.version, this.options, other);
	    if (!(other instanceof SemVer)) {
	      if (typeof other === 'string' && other === this.version) {
	        return 0
	      }
	      other = new SemVer(other, this.options);
	    }

	    if (other.version === this.version) {
	      return 0
	    }

	    return this.compareMain(other) || this.comparePre(other)
	  }

	  compareMain (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    if (this.major < other.major) {
	      return -1
	    }
	    if (this.major > other.major) {
	      return 1
	    }
	    if (this.minor < other.minor) {
	      return -1
	    }
	    if (this.minor > other.minor) {
	      return 1
	    }
	    if (this.patch < other.patch) {
	      return -1
	    }
	    if (this.patch > other.patch) {
	      return 1
	    }
	    return 0
	  }

	  comparePre (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    // NOT having a prerelease is > having one
	    if (this.prerelease.length && !other.prerelease.length) {
	      return -1
	    } else if (!this.prerelease.length && other.prerelease.length) {
	      return 1
	    } else if (!this.prerelease.length && !other.prerelease.length) {
	      return 0
	    }

	    let i = 0;
	    do {
	      const a = this.prerelease[i];
	      const b = other.prerelease[i];
	      debug('prerelease compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }

	  compareBuild (other) {
	    if (!(other instanceof SemVer)) {
	      other = new SemVer(other, this.options);
	    }

	    let i = 0;
	    do {
	      const a = this.build[i];
	      const b = other.build[i];
	      debug('build compare', i, a, b);
	      if (a === undefined && b === undefined) {
	        return 0
	      } else if (b === undefined) {
	        return 1
	      } else if (a === undefined) {
	        return -1
	      } else if (a === b) {
	        continue
	      } else {
	        return compareIdentifiers(a, b)
	      }
	    } while (++i)
	  }

	  // preminor will bump the version up to the next minor release, and immediately
	  // down to pre-release. premajor and prepatch work the same way.
	  inc (release, identifier, identifierBase) {
	    if (release.startsWith('pre')) {
	      if (!identifier && identifierBase === false) {
	        throw new Error('invalid increment argument: identifier is empty')
	      }
	      // Avoid an invalid semver results
	      if (identifier) {
	        const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
	        if (!match || match[1] !== identifier) {
	          throw new Error(`invalid identifier: ${identifier}`)
	        }
	      }
	    }

	    switch (release) {
	      case 'premajor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor = 0;
	        this.major++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'preminor':
	        this.prerelease.length = 0;
	        this.patch = 0;
	        this.minor++;
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'prepatch':
	        // If this is already a prerelease, it will bump to the next version
	        // drop any prereleases that might already exist, since they are not
	        // relevant at this point.
	        this.prerelease.length = 0;
	        this.inc('patch', identifier, identifierBase);
	        this.inc('pre', identifier, identifierBase);
	        break
	      // If the input is a non-prerelease version, this acts the same as
	      // prepatch.
	      case 'prerelease':
	        if (this.prerelease.length === 0) {
	          this.inc('patch', identifier, identifierBase);
	        }
	        this.inc('pre', identifier, identifierBase);
	        break
	      case 'release':
	        if (this.prerelease.length === 0) {
	          throw new Error(`version ${this.raw} is not a prerelease`)
	        }
	        this.prerelease.length = 0;
	        break

	      case 'major':
	        // If this is a pre-major version, bump up to the same major version.
	        // Otherwise increment major.
	        // 1.0.0-5 bumps to 1.0.0
	        // 1.1.0 bumps to 2.0.0
	        if (
	          this.minor !== 0 ||
	          this.patch !== 0 ||
	          this.prerelease.length === 0
	        ) {
	          this.major++;
	        }
	        this.minor = 0;
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'minor':
	        // If this is a pre-minor version, bump up to the same minor version.
	        // Otherwise increment minor.
	        // 1.2.0-5 bumps to 1.2.0
	        // 1.2.1 bumps to 1.3.0
	        if (this.patch !== 0 || this.prerelease.length === 0) {
	          this.minor++;
	        }
	        this.patch = 0;
	        this.prerelease = [];
	        break
	      case 'patch':
	        // If this is not a pre-release version, it will increment the patch.
	        // If it is a pre-release it will bump up to the same patch version.
	        // 1.2.0-5 patches to 1.2.0
	        // 1.2.0 patches to 1.2.1
	        if (this.prerelease.length === 0) {
	          this.patch++;
	        }
	        this.prerelease = [];
	        break
	      // This probably shouldn't be used publicly.
	      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
	      case 'pre': {
	        const base = Number(identifierBase) ? 1 : 0;

	        if (this.prerelease.length === 0) {
	          this.prerelease = [base];
	        } else {
	          let i = this.prerelease.length;
	          while (--i >= 0) {
	            if (typeof this.prerelease[i] === 'number') {
	              this.prerelease[i]++;
	              i = -2;
	            }
	          }
	          if (i === -1) {
	            // didn't increment anything
	            if (identifier === this.prerelease.join('.') && identifierBase === false) {
	              throw new Error('invalid increment argument: identifier already exists')
	            }
	            this.prerelease.push(base);
	          }
	        }
	        if (identifier) {
	          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
	          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
	          let prerelease = [identifier, base];
	          if (identifierBase === false) {
	            prerelease = [identifier];
	          }
	          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
	            if (isNaN(this.prerelease[1])) {
	              this.prerelease = prerelease;
	            }
	          } else {
	            this.prerelease = prerelease;
	          }
	        }
	        break
	      }
	      default:
	        throw new Error(`invalid increment argument: ${release}`)
	    }
	    this.raw = this.format();
	    if (this.build.length) {
	      this.raw += `+${this.build.join('.')}`;
	    }
	    return this
	  }
	}

	semver$1 = SemVer;
	return semver$1;
}

var parse_1;
var hasRequiredParse;

function requireParse () {
	if (hasRequiredParse) return parse_1;
	hasRequiredParse = 1;

	const SemVer = requireSemver$1();
	const parse = (version, options, throwErrors = false) => {
	  if (version instanceof SemVer) {
	    return version
	  }
	  try {
	    return new SemVer(version, options)
	  } catch (er) {
	    if (!throwErrors) {
	      return null
	    }
	    throw er
	  }
	};

	parse_1 = parse;
	return parse_1;
}

var valid_1;
var hasRequiredValid$1;

function requireValid$1 () {
	if (hasRequiredValid$1) return valid_1;
	hasRequiredValid$1 = 1;

	const parse = requireParse();
	const valid = (version, options) => {
	  const v = parse(version, options);
	  return v ? v.version : null
	};
	valid_1 = valid;
	return valid_1;
}

var clean_1;
var hasRequiredClean;

function requireClean () {
	if (hasRequiredClean) return clean_1;
	hasRequiredClean = 1;

	const parse = requireParse();
	const clean = (version, options) => {
	  const s = parse(version.trim().replace(/^[=v]+/, ''), options);
	  return s ? s.version : null
	};
	clean_1 = clean;
	return clean_1;
}

var inc_1;
var hasRequiredInc;

function requireInc () {
	if (hasRequiredInc) return inc_1;
	hasRequiredInc = 1;

	const SemVer = requireSemver$1();

	const inc = (version, release, options, identifier, identifierBase) => {
	  if (typeof (options) === 'string') {
	    identifierBase = identifier;
	    identifier = options;
	    options = undefined;
	  }

	  try {
	    return new SemVer(
	      version instanceof SemVer ? version.version : version,
	      options
	    ).inc(release, identifier, identifierBase).version
	  } catch (er) {
	    return null
	  }
	};
	inc_1 = inc;
	return inc_1;
}

var diff_1;
var hasRequiredDiff;

function requireDiff () {
	if (hasRequiredDiff) return diff_1;
	hasRequiredDiff = 1;

	const parse = requireParse();

	const diff = (version1, version2) => {
	  const v1 = parse(version1, null, true);
	  const v2 = parse(version2, null, true);
	  const comparison = v1.compare(v2);

	  if (comparison === 0) {
	    return null
	  }

	  const v1Higher = comparison > 0;
	  const highVersion = v1Higher ? v1 : v2;
	  const lowVersion = v1Higher ? v2 : v1;
	  const highHasPre = !!highVersion.prerelease.length;
	  const lowHasPre = !!lowVersion.prerelease.length;

	  if (lowHasPre && !highHasPre) {
	    // Going from prerelease -> no prerelease requires some special casing

	    // If the low version has only a major, then it will always be a major
	    // Some examples:
	    // 1.0.0-1 -> 1.0.0
	    // 1.0.0-1 -> 1.1.1
	    // 1.0.0-1 -> 2.0.0
	    if (!lowVersion.patch && !lowVersion.minor) {
	      return 'major'
	    }

	    // If the main part has no difference
	    if (lowVersion.compareMain(highVersion) === 0) {
	      if (lowVersion.minor && !lowVersion.patch) {
	        return 'minor'
	      }
	      return 'patch'
	    }
	  }

	  // add the `pre` prefix if we are going to a prerelease version
	  const prefix = highHasPre ? 'pre' : '';

	  if (v1.major !== v2.major) {
	    return prefix + 'major'
	  }

	  if (v1.minor !== v2.minor) {
	    return prefix + 'minor'
	  }

	  if (v1.patch !== v2.patch) {
	    return prefix + 'patch'
	  }

	  // high and low are preleases
	  return 'prerelease'
	};

	diff_1 = diff;
	return diff_1;
}

var major_1;
var hasRequiredMajor;

function requireMajor () {
	if (hasRequiredMajor) return major_1;
	hasRequiredMajor = 1;

	const SemVer = requireSemver$1();
	const major = (a, loose) => new SemVer(a, loose).major;
	major_1 = major;
	return major_1;
}

var minor_1;
var hasRequiredMinor;

function requireMinor () {
	if (hasRequiredMinor) return minor_1;
	hasRequiredMinor = 1;

	const SemVer = requireSemver$1();
	const minor = (a, loose) => new SemVer(a, loose).minor;
	minor_1 = minor;
	return minor_1;
}

var patch_1;
var hasRequiredPatch;

function requirePatch () {
	if (hasRequiredPatch) return patch_1;
	hasRequiredPatch = 1;

	const SemVer = requireSemver$1();
	const patch = (a, loose) => new SemVer(a, loose).patch;
	patch_1 = patch;
	return patch_1;
}

var prerelease_1;
var hasRequiredPrerelease;

function requirePrerelease () {
	if (hasRequiredPrerelease) return prerelease_1;
	hasRequiredPrerelease = 1;

	const parse = requireParse();
	const prerelease = (version, options) => {
	  const parsed = parse(version, options);
	  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
	};
	prerelease_1 = prerelease;
	return prerelease_1;
}

var compare_1;
var hasRequiredCompare;

function requireCompare () {
	if (hasRequiredCompare) return compare_1;
	hasRequiredCompare = 1;

	const SemVer = requireSemver$1();
	const compare = (a, b, loose) =>
	  new SemVer(a, loose).compare(new SemVer(b, loose));

	compare_1 = compare;
	return compare_1;
}

var rcompare_1;
var hasRequiredRcompare;

function requireRcompare () {
	if (hasRequiredRcompare) return rcompare_1;
	hasRequiredRcompare = 1;

	const compare = requireCompare();
	const rcompare = (a, b, loose) => compare(b, a, loose);
	rcompare_1 = rcompare;
	return rcompare_1;
}

var compareLoose_1;
var hasRequiredCompareLoose;

function requireCompareLoose () {
	if (hasRequiredCompareLoose) return compareLoose_1;
	hasRequiredCompareLoose = 1;

	const compare = requireCompare();
	const compareLoose = (a, b) => compare(a, b, true);
	compareLoose_1 = compareLoose;
	return compareLoose_1;
}

var compareBuild_1;
var hasRequiredCompareBuild;

function requireCompareBuild () {
	if (hasRequiredCompareBuild) return compareBuild_1;
	hasRequiredCompareBuild = 1;

	const SemVer = requireSemver$1();
	const compareBuild = (a, b, loose) => {
	  const versionA = new SemVer(a, loose);
	  const versionB = new SemVer(b, loose);
	  return versionA.compare(versionB) || versionA.compareBuild(versionB)
	};
	compareBuild_1 = compareBuild;
	return compareBuild_1;
}

var sort_1;
var hasRequiredSort;

function requireSort () {
	if (hasRequiredSort) return sort_1;
	hasRequiredSort = 1;

	const compareBuild = requireCompareBuild();
	const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
	sort_1 = sort;
	return sort_1;
}

var rsort_1;
var hasRequiredRsort;

function requireRsort () {
	if (hasRequiredRsort) return rsort_1;
	hasRequiredRsort = 1;

	const compareBuild = requireCompareBuild();
	const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
	rsort_1 = rsort;
	return rsort_1;
}

var gt_1;
var hasRequiredGt;

function requireGt () {
	if (hasRequiredGt) return gt_1;
	hasRequiredGt = 1;

	const compare = requireCompare();
	const gt = (a, b, loose) => compare(a, b, loose) > 0;
	gt_1 = gt;
	return gt_1;
}

var lt_1;
var hasRequiredLt;

function requireLt () {
	if (hasRequiredLt) return lt_1;
	hasRequiredLt = 1;

	const compare = requireCompare();
	const lt = (a, b, loose) => compare(a, b, loose) < 0;
	lt_1 = lt;
	return lt_1;
}

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;

	const compare = requireCompare();
	const eq = (a, b, loose) => compare(a, b, loose) === 0;
	eq_1 = eq;
	return eq_1;
}

var neq_1;
var hasRequiredNeq;

function requireNeq () {
	if (hasRequiredNeq) return neq_1;
	hasRequiredNeq = 1;

	const compare = requireCompare();
	const neq = (a, b, loose) => compare(a, b, loose) !== 0;
	neq_1 = neq;
	return neq_1;
}

var gte_1;
var hasRequiredGte;

function requireGte () {
	if (hasRequiredGte) return gte_1;
	hasRequiredGte = 1;

	const compare = requireCompare();
	const gte = (a, b, loose) => compare(a, b, loose) >= 0;
	gte_1 = gte;
	return gte_1;
}

var lte_1;
var hasRequiredLte;

function requireLte () {
	if (hasRequiredLte) return lte_1;
	hasRequiredLte = 1;

	const compare = requireCompare();
	const lte = (a, b, loose) => compare(a, b, loose) <= 0;
	lte_1 = lte;
	return lte_1;
}

var cmp_1;
var hasRequiredCmp;

function requireCmp () {
	if (hasRequiredCmp) return cmp_1;
	hasRequiredCmp = 1;

	const eq = requireEq();
	const neq = requireNeq();
	const gt = requireGt();
	const gte = requireGte();
	const lt = requireLt();
	const lte = requireLte();

	const cmp = (a, op, b, loose) => {
	  switch (op) {
	    case '===':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a === b

	    case '!==':
	      if (typeof a === 'object') {
	        a = a.version;
	      }
	      if (typeof b === 'object') {
	        b = b.version;
	      }
	      return a !== b

	    case '':
	    case '=':
	    case '==':
	      return eq(a, b, loose)

	    case '!=':
	      return neq(a, b, loose)

	    case '>':
	      return gt(a, b, loose)

	    case '>=':
	      return gte(a, b, loose)

	    case '<':
	      return lt(a, b, loose)

	    case '<=':
	      return lte(a, b, loose)

	    default:
	      throw new TypeError(`Invalid operator: ${op}`)
	  }
	};
	cmp_1 = cmp;
	return cmp_1;
}

var coerce_1;
var hasRequiredCoerce;

function requireCoerce () {
	if (hasRequiredCoerce) return coerce_1;
	hasRequiredCoerce = 1;

	const SemVer = requireSemver$1();
	const parse = requireParse();
	const { safeRe: re, t } = requireRe();

	const coerce = (version, options) => {
	  if (version instanceof SemVer) {
	    return version
	  }

	  if (typeof version === 'number') {
	    version = String(version);
	  }

	  if (typeof version !== 'string') {
	    return null
	  }

	  options = options || {};

	  let match = null;
	  if (!options.rtl) {
	    match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
	  } else {
	    // Find the right-most coercible string that does not share
	    // a terminus with a more left-ward coercible string.
	    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
	    // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
	    //
	    // Walk through the string checking with a /g regexp
	    // Manually set the index so as to pick up overlapping matches.
	    // Stop when we get a match that ends at the string end, since no
	    // coercible string can be more right-ward without the same terminus.
	    const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
	    let next;
	    while ((next = coerceRtlRegex.exec(version)) &&
	        (!match || match.index + match[0].length !== version.length)
	    ) {
	      if (!match ||
	            next.index + next[0].length !== match.index + match[0].length) {
	        match = next;
	      }
	      coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
	    }
	    // leave it in a clean state
	    coerceRtlRegex.lastIndex = -1;
	  }

	  if (match === null) {
	    return null
	  }

	  const major = match[2];
	  const minor = match[3] || '0';
	  const patch = match[4] || '0';
	  const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
	  const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';

	  return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options)
	};
	coerce_1 = coerce;
	return coerce_1;
}

var lrucache;
var hasRequiredLrucache;

function requireLrucache () {
	if (hasRequiredLrucache) return lrucache;
	hasRequiredLrucache = 1;

	class LRUCache {
	  constructor () {
	    this.max = 1000;
	    this.map = new Map();
	  }

	  get (key) {
	    const value = this.map.get(key);
	    if (value === undefined) {
	      return undefined
	    } else {
	      // Remove the key from the map and add it to the end
	      this.map.delete(key);
	      this.map.set(key, value);
	      return value
	    }
	  }

	  delete (key) {
	    return this.map.delete(key)
	  }

	  set (key, value) {
	    const deleted = this.delete(key);

	    if (!deleted && value !== undefined) {
	      // If cache is full, delete the least recently used item
	      if (this.map.size >= this.max) {
	        const firstKey = this.map.keys().next().value;
	        this.delete(firstKey);
	      }

	      this.map.set(key, value);
	    }

	    return this
	  }
	}

	lrucache = LRUCache;
	return lrucache;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	const SPACE_CHARACTERS = /\s+/g;

	// hoisted class for cyclic dependency
	class Range {
	  constructor (range, options) {
	    options = parseOptions(options);

	    if (range instanceof Range) {
	      if (
	        range.loose === !!options.loose &&
	        range.includePrerelease === !!options.includePrerelease
	      ) {
	        return range
	      } else {
	        return new Range(range.raw, options)
	      }
	    }

	    if (range instanceof Comparator) {
	      // just put it in the set and return
	      this.raw = range.value;
	      this.set = [[range]];
	      this.formatted = undefined;
	      return this
	    }

	    this.options = options;
	    this.loose = !!options.loose;
	    this.includePrerelease = !!options.includePrerelease;

	    // First reduce all whitespace as much as possible so we do not have to rely
	    // on potentially slow regexes like \s*. This is then stored and used for
	    // future error messages as well.
	    this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');

	    // First, split on ||
	    this.set = this.raw
	      .split('||')
	      // map the range to a 2d array of comparators
	      .map(r => this.parseRange(r.trim()))
	      // throw out any comparator lists that are empty
	      // this generally means that it was not a valid range, which is allowed
	      // in loose mode, but will still throw if the WHOLE range is invalid.
	      .filter(c => c.length);

	    if (!this.set.length) {
	      throw new TypeError(`Invalid SemVer Range: ${this.raw}`)
	    }

	    // if we have any that are not the null set, throw out null sets.
	    if (this.set.length > 1) {
	      // keep the first one, in case they're all null sets
	      const first = this.set[0];
	      this.set = this.set.filter(c => !isNullSet(c[0]));
	      if (this.set.length === 0) {
	        this.set = [first];
	      } else if (this.set.length > 1) {
	        // if we have any that are *, then the range is just *
	        for (const c of this.set) {
	          if (c.length === 1 && isAny(c[0])) {
	            this.set = [c];
	            break
	          }
	        }
	      }
	    }

	    this.formatted = undefined;
	  }

	  get range () {
	    if (this.formatted === undefined) {
	      this.formatted = '';
	      for (let i = 0; i < this.set.length; i++) {
	        if (i > 0) {
	          this.formatted += '||';
	        }
	        const comps = this.set[i];
	        for (let k = 0; k < comps.length; k++) {
	          if (k > 0) {
	            this.formatted += ' ';
	          }
	          this.formatted += comps[k].toString().trim();
	        }
	      }
	    }
	    return this.formatted
	  }

	  format () {
	    return this.range
	  }

	  toString () {
	    return this.range
	  }

	  parseRange (range) {
	    // memoize range parsing for performance.
	    // this is a very hot path, and fully deterministic.
	    const memoOpts =
	      (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) |
	      (this.options.loose && FLAG_LOOSE);
	    const memoKey = memoOpts + ':' + range;
	    const cached = cache.get(memoKey);
	    if (cached) {
	      return cached
	    }

	    const loose = this.options.loose;
	    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
	    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
	    range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
	    debug('hyphen replace', range);

	    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
	    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
	    debug('comparator trim', range);

	    // `~ 1.2.3` => `~1.2.3`
	    range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
	    debug('tilde trim', range);

	    // `^ 1.2.3` => `^1.2.3`
	    range = range.replace(re[t.CARETTRIM], caretTrimReplace);
	    debug('caret trim', range);

	    // At this point, the range is completely trimmed and
	    // ready to be split into comparators.

	    let rangeList = range
	      .split(' ')
	      .map(comp => parseComparator(comp, this.options))
	      .join(' ')
	      .split(/\s+/)
	      // >=0.0.0 is equivalent to *
	      .map(comp => replaceGTE0(comp, this.options));

	    if (loose) {
	      // in loose mode, throw out any that are not valid comparators
	      rangeList = rangeList.filter(comp => {
	        debug('loose invalid filter', comp, this.options);
	        return !!comp.match(re[t.COMPARATORLOOSE])
	      });
	    }
	    debug('range list', rangeList);

	    // if any comparators are the null set, then replace with JUST null set
	    // if more than one comparator, remove any * comparators
	    // also, don't include the same comparator more than once
	    const rangeMap = new Map();
	    const comparators = rangeList.map(comp => new Comparator(comp, this.options));
	    for (const comp of comparators) {
	      if (isNullSet(comp)) {
	        return [comp]
	      }
	      rangeMap.set(comp.value, comp);
	    }
	    if (rangeMap.size > 1 && rangeMap.has('')) {
	      rangeMap.delete('');
	    }

	    const result = [...rangeMap.values()];
	    cache.set(memoKey, result);
	    return result
	  }

	  intersects (range, options) {
	    if (!(range instanceof Range)) {
	      throw new TypeError('a Range is required')
	    }

	    return this.set.some((thisComparators) => {
	      return (
	        isSatisfiable(thisComparators, options) &&
	        range.set.some((rangeComparators) => {
	          return (
	            isSatisfiable(rangeComparators, options) &&
	            thisComparators.every((thisComparator) => {
	              return rangeComparators.every((rangeComparator) => {
	                return thisComparator.intersects(rangeComparator, options)
	              })
	            })
	          )
	        })
	      )
	    })
	  }

	  // if ANY of the sets match ALL of its comparators, then pass
	  test (version) {
	    if (!version) {
	      return false
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    for (let i = 0; i < this.set.length; i++) {
	      if (testSet(this.set[i], version, this.options)) {
	        return true
	      }
	    }
	    return false
	  }
	}

	range = Range;

	const LRU = requireLrucache();
	const cache = new LRU();

	const parseOptions = requireParseOptions();
	const Comparator = requireComparator();
	const debug = requireDebug$1();
	const SemVer = requireSemver$1();
	const {
	  safeRe: re,
	  t,
	  comparatorTrimReplace,
	  tildeTrimReplace,
	  caretTrimReplace,
	} = requireRe();
	const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = requireConstants$2();

	const isNullSet = c => c.value === '<0.0.0-0';
	const isAny = c => c.value === '';

	// take a set of comparators and determine whether there
	// exists a version which can satisfy it
	const isSatisfiable = (comparators, options) => {
	  let result = true;
	  const remainingComparators = comparators.slice();
	  let testComparator = remainingComparators.pop();

	  while (result && remainingComparators.length) {
	    result = remainingComparators.every((otherComparator) => {
	      return testComparator.intersects(otherComparator, options)
	    });

	    testComparator = remainingComparators.pop();
	  }

	  return result
	};

	// comprised of xranges, tildes, stars, and gtlt's at this point.
	// already replaced the hyphen ranges
	// turn into a set of JUST comparators.
	const parseComparator = (comp, options) => {
	  comp = comp.replace(re[t.BUILD], '');
	  debug('comp', comp, options);
	  comp = replaceCarets(comp, options);
	  debug('caret', comp);
	  comp = replaceTildes(comp, options);
	  debug('tildes', comp);
	  comp = replaceXRanges(comp, options);
	  debug('xrange', comp);
	  comp = replaceStars(comp, options);
	  debug('stars', comp);
	  return comp
	};

	const isX = id => !id || id.toLowerCase() === 'x' || id === '*';

	// ~, ~> --> * (any, kinda silly)
	// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
	// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
	// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
	// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
	// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
	// ~0.0.1 --> >=0.0.1 <0.1.0-0
	const replaceTildes = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceTilde(c, options))
	    .join(' ')
	};

	const replaceTilde = (comp, options) => {
	  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('tilde', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      // ~1.2 == >=1.2.0 <1.3.0-0
	      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
	    } else if (pr) {
	      debug('replaceTilde pr', pr);
	      ret = `>=${M}.${m}.${p}-${pr
	      } <${M}.${+m + 1}.0-0`;
	    } else {
	      // ~1.2.3 == >=1.2.3 <1.3.0-0
	      ret = `>=${M}.${m}.${p
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('tilde return', ret);
	    return ret
	  })
	};

	// ^ --> * (any, kinda silly)
	// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
	// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
	// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
	// ^1.2.3 --> >=1.2.3 <2.0.0-0
	// ^1.2.0 --> >=1.2.0 <2.0.0-0
	// ^0.0.1 --> >=0.0.1 <0.0.2-0
	// ^0.1.0 --> >=0.1.0 <0.2.0-0
	const replaceCarets = (comp, options) => {
	  return comp
	    .trim()
	    .split(/\s+/)
	    .map((c) => replaceCaret(c, options))
	    .join(' ')
	};

	const replaceCaret = (comp, options) => {
	  debug('caret', comp, options);
	  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
	  const z = options.includePrerelease ? '-0' : '';
	  return comp.replace(r, (_, M, m, p, pr) => {
	    debug('caret', comp, _, M, m, p, pr);
	    let ret;

	    if (isX(M)) {
	      ret = '';
	    } else if (isX(m)) {
	      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
	    } else if (isX(p)) {
	      if (M === '0') {
	        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
	      } else {
	        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
	      }
	    } else if (pr) {
	      debug('replaceCaret pr', pr);
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p}-${pr
	          } <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p}-${pr
	        } <${+M + 1}.0.0-0`;
	      }
	    } else {
	      debug('no pr');
	      if (M === '0') {
	        if (m === '0') {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${m}.${+p + 1}-0`;
	        } else {
	          ret = `>=${M}.${m}.${p
	          }${z} <${M}.${+m + 1}.0-0`;
	        }
	      } else {
	        ret = `>=${M}.${m}.${p
	        } <${+M + 1}.0.0-0`;
	      }
	    }

	    debug('caret return', ret);
	    return ret
	  })
	};

	const replaceXRanges = (comp, options) => {
	  debug('replaceXRanges', comp, options);
	  return comp
	    .split(/\s+/)
	    .map((c) => replaceXRange(c, options))
	    .join(' ')
	};

	const replaceXRange = (comp, options) => {
	  comp = comp.trim();
	  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
	  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
	    debug('xRange', comp, ret, gtlt, M, m, p, pr);
	    const xM = isX(M);
	    const xm = xM || isX(m);
	    const xp = xm || isX(p);
	    const anyX = xp;

	    if (gtlt === '=' && anyX) {
	      gtlt = '';
	    }

	    // if we're including prereleases in the match, then we need
	    // to fix this to -0, the lowest possible prerelease value
	    pr = options.includePrerelease ? '-0' : '';

	    if (xM) {
	      if (gtlt === '>' || gtlt === '<') {
	        // nothing is allowed
	        ret = '<0.0.0-0';
	      } else {
	        // nothing is forbidden
	        ret = '*';
	      }
	    } else if (gtlt && anyX) {
	      // we know patch is an x, because we have any x at all.
	      // replace X with 0
	      if (xm) {
	        m = 0;
	      }
	      p = 0;

	      if (gtlt === '>') {
	        // >1 => >=2.0.0
	        // >1.2 => >=1.3.0
	        gtlt = '>=';
	        if (xm) {
	          M = +M + 1;
	          m = 0;
	          p = 0;
	        } else {
	          m = +m + 1;
	          p = 0;
	        }
	      } else if (gtlt === '<=') {
	        // <=0.7.x is actually <0.8.0, since any 0.7.x should
	        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
	        gtlt = '<';
	        if (xm) {
	          M = +M + 1;
	        } else {
	          m = +m + 1;
	        }
	      }

	      if (gtlt === '<') {
	        pr = '-0';
	      }

	      ret = `${gtlt + M}.${m}.${p}${pr}`;
	    } else if (xm) {
	      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
	    } else if (xp) {
	      ret = `>=${M}.${m}.0${pr
	      } <${M}.${+m + 1}.0-0`;
	    }

	    debug('xRange return', ret);

	    return ret
	  })
	};

	// Because * is AND-ed with everything else in the comparator,
	// and '' means "any version", just remove the *s entirely.
	const replaceStars = (comp, options) => {
	  debug('replaceStars', comp, options);
	  // Looseness is ignored here.  star is always as loose as it gets!
	  return comp
	    .trim()
	    .replace(re[t.STAR], '')
	};

	const replaceGTE0 = (comp, options) => {
	  debug('replaceGTE0', comp, options);
	  return comp
	    .trim()
	    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
	};

	// This function is passed to string.replace(re[t.HYPHENRANGE])
	// M, m, patch, prerelease, build
	// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
	// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
	// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
	// TODO build?
	const hyphenReplace = incPr => ($0,
	  from, fM, fm, fp, fpr, fb,
	  to, tM, tm, tp, tpr) => {
	  if (isX(fM)) {
	    from = '';
	  } else if (isX(fm)) {
	    from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
	  } else if (isX(fp)) {
	    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
	  } else if (fpr) {
	    from = `>=${from}`;
	  } else {
	    from = `>=${from}${incPr ? '-0' : ''}`;
	  }

	  if (isX(tM)) {
	    to = '';
	  } else if (isX(tm)) {
	    to = `<${+tM + 1}.0.0-0`;
	  } else if (isX(tp)) {
	    to = `<${tM}.${+tm + 1}.0-0`;
	  } else if (tpr) {
	    to = `<=${tM}.${tm}.${tp}-${tpr}`;
	  } else if (incPr) {
	    to = `<${tM}.${tm}.${+tp + 1}-0`;
	  } else {
	    to = `<=${to}`;
	  }

	  return `${from} ${to}`.trim()
	};

	const testSet = (set, version, options) => {
	  for (let i = 0; i < set.length; i++) {
	    if (!set[i].test(version)) {
	      return false
	    }
	  }

	  if (version.prerelease.length && !options.includePrerelease) {
	    // Find the set of versions that are allowed to have prereleases
	    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
	    // That should allow `1.2.3-pr.2` to pass.
	    // However, `1.2.4-alpha.notready` should NOT be allowed,
	    // even though it's within the range set by the comparators.
	    for (let i = 0; i < set.length; i++) {
	      debug(set[i].semver);
	      if (set[i].semver === Comparator.ANY) {
	        continue
	      }

	      if (set[i].semver.prerelease.length > 0) {
	        const allowed = set[i].semver;
	        if (allowed.major === version.major &&
	            allowed.minor === version.minor &&
	            allowed.patch === version.patch) {
	          return true
	        }
	      }
	    }

	    // Version has a -pre, but it's not one of the ones we like.
	    return false
	  }

	  return true
	};
	return range;
}

var comparator;
var hasRequiredComparator;

function requireComparator () {
	if (hasRequiredComparator) return comparator;
	hasRequiredComparator = 1;

	const ANY = Symbol('SemVer ANY');
	// hoisted class for cyclic dependency
	class Comparator {
	  static get ANY () {
	    return ANY
	  }

	  constructor (comp, options) {
	    options = parseOptions(options);

	    if (comp instanceof Comparator) {
	      if (comp.loose === !!options.loose) {
	        return comp
	      } else {
	        comp = comp.value;
	      }
	    }

	    comp = comp.trim().split(/\s+/).join(' ');
	    debug('comparator', comp, options);
	    this.options = options;
	    this.loose = !!options.loose;
	    this.parse(comp);

	    if (this.semver === ANY) {
	      this.value = '';
	    } else {
	      this.value = this.operator + this.semver.version;
	    }

	    debug('comp', this);
	  }

	  parse (comp) {
	    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
	    const m = comp.match(r);

	    if (!m) {
	      throw new TypeError(`Invalid comparator: ${comp}`)
	    }

	    this.operator = m[1] !== undefined ? m[1] : '';
	    if (this.operator === '=') {
	      this.operator = '';
	    }

	    // if it literally is just '>' or '' then allow anything.
	    if (!m[2]) {
	      this.semver = ANY;
	    } else {
	      this.semver = new SemVer(m[2], this.options.loose);
	    }
	  }

	  toString () {
	    return this.value
	  }

	  test (version) {
	    debug('Comparator.test', version, this.options.loose);

	    if (this.semver === ANY || version === ANY) {
	      return true
	    }

	    if (typeof version === 'string') {
	      try {
	        version = new SemVer(version, this.options);
	      } catch (er) {
	        return false
	      }
	    }

	    return cmp(version, this.operator, this.semver, this.options)
	  }

	  intersects (comp, options) {
	    if (!(comp instanceof Comparator)) {
	      throw new TypeError('a Comparator is required')
	    }

	    if (this.operator === '') {
	      if (this.value === '') {
	        return true
	      }
	      return new Range(comp.value, options).test(this.value)
	    } else if (comp.operator === '') {
	      if (comp.value === '') {
	        return true
	      }
	      return new Range(this.value, options).test(comp.semver)
	    }

	    options = parseOptions(options);

	    // Special cases where nothing can possibly be lower
	    if (options.includePrerelease &&
	      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
	      return false
	    }
	    if (!options.includePrerelease &&
	      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
	      return false
	    }

	    // Same direction increasing (> or >=)
	    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
	      return true
	    }
	    // Same direction decreasing (< or <=)
	    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // same SemVer and both sides are inclusive (<= or >=)
	    if (
	      (this.semver.version === comp.semver.version) &&
	      this.operator.includes('=') && comp.operator.includes('=')) {
	      return true
	    }
	    // opposite directions less than
	    if (cmp(this.semver, '<', comp.semver, options) &&
	      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
	      return true
	    }
	    // opposite directions greater than
	    if (cmp(this.semver, '>', comp.semver, options) &&
	      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
	      return true
	    }
	    return false
	  }
	}

	comparator = Comparator;

	const parseOptions = requireParseOptions();
	const { safeRe: re, t } = requireRe();
	const cmp = requireCmp();
	const debug = requireDebug$1();
	const SemVer = requireSemver$1();
	const Range = requireRange();
	return comparator;
}

var satisfies_1;
var hasRequiredSatisfies;

function requireSatisfies () {
	if (hasRequiredSatisfies) return satisfies_1;
	hasRequiredSatisfies = 1;

	const Range = requireRange();
	const satisfies = (version, range, options) => {
	  try {
	    range = new Range(range, options);
	  } catch (er) {
	    return false
	  }
	  return range.test(version)
	};
	satisfies_1 = satisfies;
	return satisfies_1;
}

var toComparators_1;
var hasRequiredToComparators;

function requireToComparators () {
	if (hasRequiredToComparators) return toComparators_1;
	hasRequiredToComparators = 1;

	const Range = requireRange();

	// Mostly just for testing and legacy API reasons
	const toComparators = (range, options) =>
	  new Range(range, options).set
	    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '));

	toComparators_1 = toComparators;
	return toComparators_1;
}

var maxSatisfying_1;
var hasRequiredMaxSatisfying;

function requireMaxSatisfying () {
	if (hasRequiredMaxSatisfying) return maxSatisfying_1;
	hasRequiredMaxSatisfying = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();

	const maxSatisfying = (versions, range, options) => {
	  let max = null;
	  let maxSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      // satisfies(v, range, options)
	      if (!max || maxSV.compare(v) === -1) {
	        // compare(max, v, true)
	        max = v;
	        maxSV = new SemVer(max, options);
	      }
	    }
	  });
	  return max
	};
	maxSatisfying_1 = maxSatisfying;
	return maxSatisfying_1;
}

var minSatisfying_1;
var hasRequiredMinSatisfying;

function requireMinSatisfying () {
	if (hasRequiredMinSatisfying) return minSatisfying_1;
	hasRequiredMinSatisfying = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();
	const minSatisfying = (versions, range, options) => {
	  let min = null;
	  let minSV = null;
	  let rangeObj = null;
	  try {
	    rangeObj = new Range(range, options);
	  } catch (er) {
	    return null
	  }
	  versions.forEach((v) => {
	    if (rangeObj.test(v)) {
	      // satisfies(v, range, options)
	      if (!min || minSV.compare(v) === 1) {
	        // compare(min, v, true)
	        min = v;
	        minSV = new SemVer(min, options);
	      }
	    }
	  });
	  return min
	};
	minSatisfying_1 = minSatisfying;
	return minSatisfying_1;
}

var minVersion_1;
var hasRequiredMinVersion;

function requireMinVersion () {
	if (hasRequiredMinVersion) return minVersion_1;
	hasRequiredMinVersion = 1;

	const SemVer = requireSemver$1();
	const Range = requireRange();
	const gt = requireGt();

	const minVersion = (range, loose) => {
	  range = new Range(range, loose);

	  let minver = new SemVer('0.0.0');
	  if (range.test(minver)) {
	    return minver
	  }

	  minver = new SemVer('0.0.0-0');
	  if (range.test(minver)) {
	    return minver
	  }

	  minver = null;
	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];

	    let setMin = null;
	    comparators.forEach((comparator) => {
	      // Clone to avoid manipulating the comparator's semver object.
	      const compver = new SemVer(comparator.semver.version);
	      switch (comparator.operator) {
	        case '>':
	          if (compver.prerelease.length === 0) {
	            compver.patch++;
	          } else {
	            compver.prerelease.push(0);
	          }
	          compver.raw = compver.format();
	          /* fallthrough */
	        case '':
	        case '>=':
	          if (!setMin || gt(compver, setMin)) {
	            setMin = compver;
	          }
	          break
	        case '<':
	        case '<=':
	          /* Ignore maximum versions */
	          break
	        /* istanbul ignore next */
	        default:
	          throw new Error(`Unexpected operation: ${comparator.operator}`)
	      }
	    });
	    if (setMin && (!minver || gt(minver, setMin))) {
	      minver = setMin;
	    }
	  }

	  if (minver && range.test(minver)) {
	    return minver
	  }

	  return null
	};
	minVersion_1 = minVersion;
	return minVersion_1;
}

var valid;
var hasRequiredValid;

function requireValid () {
	if (hasRequiredValid) return valid;
	hasRequiredValid = 1;

	const Range = requireRange();
	const validRange = (range, options) => {
	  try {
	    // Return '*' instead of '' so that truthiness works.
	    // This will throw if it's invalid anyway
	    return new Range(range, options).range || '*'
	  } catch (er) {
	    return null
	  }
	};
	valid = validRange;
	return valid;
}

var outside_1;
var hasRequiredOutside;

function requireOutside () {
	if (hasRequiredOutside) return outside_1;
	hasRequiredOutside = 1;

	const SemVer = requireSemver$1();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const gt = requireGt();
	const lt = requireLt();
	const lte = requireLte();
	const gte = requireGte();

	const outside = (version, range, hilo, options) => {
	  version = new SemVer(version, options);
	  range = new Range(range, options);

	  let gtfn, ltefn, ltfn, comp, ecomp;
	  switch (hilo) {
	    case '>':
	      gtfn = gt;
	      ltefn = lte;
	      ltfn = lt;
	      comp = '>';
	      ecomp = '>=';
	      break
	    case '<':
	      gtfn = lt;
	      ltefn = gte;
	      ltfn = gt;
	      comp = '<';
	      ecomp = '<=';
	      break
	    default:
	      throw new TypeError('Must provide a hilo val of "<" or ">"')
	  }

	  // If it satisfies the range it is not outside
	  if (satisfies(version, range, options)) {
	    return false
	  }

	  // From now on, variable terms are as if we're in "gtr" mode.
	  // but note that everything is flipped for the "ltr" function.

	  for (let i = 0; i < range.set.length; ++i) {
	    const comparators = range.set[i];

	    let high = null;
	    let low = null;

	    comparators.forEach((comparator) => {
	      if (comparator.semver === ANY) {
	        comparator = new Comparator('>=0.0.0');
	      }
	      high = high || comparator;
	      low = low || comparator;
	      if (gtfn(comparator.semver, high.semver, options)) {
	        high = comparator;
	      } else if (ltfn(comparator.semver, low.semver, options)) {
	        low = comparator;
	      }
	    });

	    // If the edge version comparator has a operator then our version
	    // isn't outside it
	    if (high.operator === comp || high.operator === ecomp) {
	      return false
	    }

	    // If the lowest version comparator has an operator and our version
	    // is less than it then it isn't higher than the range
	    if ((!low.operator || low.operator === comp) &&
	        ltefn(version, low.semver)) {
	      return false
	    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
	      return false
	    }
	  }
	  return true
	};

	outside_1 = outside;
	return outside_1;
}

var gtr_1;
var hasRequiredGtr;

function requireGtr () {
	if (hasRequiredGtr) return gtr_1;
	hasRequiredGtr = 1;

	// Determine if version is greater than all the versions possible in the range.
	const outside = requireOutside();
	const gtr = (version, range, options) => outside(version, range, '>', options);
	gtr_1 = gtr;
	return gtr_1;
}

var ltr_1;
var hasRequiredLtr;

function requireLtr () {
	if (hasRequiredLtr) return ltr_1;
	hasRequiredLtr = 1;

	const outside = requireOutside();
	// Determine if version is less than all the versions possible in the range
	const ltr = (version, range, options) => outside(version, range, '<', options);
	ltr_1 = ltr;
	return ltr_1;
}

var intersects_1;
var hasRequiredIntersects;

function requireIntersects () {
	if (hasRequiredIntersects) return intersects_1;
	hasRequiredIntersects = 1;

	const Range = requireRange();
	const intersects = (r1, r2, options) => {
	  r1 = new Range(r1, options);
	  r2 = new Range(r2, options);
	  return r1.intersects(r2, options)
	};
	intersects_1 = intersects;
	return intersects_1;
}

var simplify;
var hasRequiredSimplify;

function requireSimplify () {
	if (hasRequiredSimplify) return simplify;
	hasRequiredSimplify = 1;

	// given a set of versions and a range, create a "simplified" range
	// that includes the same versions that the original range does
	// If the original range is shorter than the simplified one, return that.
	const satisfies = requireSatisfies();
	const compare = requireCompare();
	simplify = (versions, range, options) => {
	  const set = [];
	  let first = null;
	  let prev = null;
	  const v = versions.sort((a, b) => compare(a, b, options));
	  for (const version of v) {
	    const included = satisfies(version, range, options);
	    if (included) {
	      prev = version;
	      if (!first) {
	        first = version;
	      }
	    } else {
	      if (prev) {
	        set.push([first, prev]);
	      }
	      prev = null;
	      first = null;
	    }
	  }
	  if (first) {
	    set.push([first, null]);
	  }

	  const ranges = [];
	  for (const [min, max] of set) {
	    if (min === max) {
	      ranges.push(min);
	    } else if (!max && min === v[0]) {
	      ranges.push('*');
	    } else if (!max) {
	      ranges.push(`>=${min}`);
	    } else if (min === v[0]) {
	      ranges.push(`<=${max}`);
	    } else {
	      ranges.push(`${min} - ${max}`);
	    }
	  }
	  const simplified = ranges.join(' || ');
	  const original = typeof range.raw === 'string' ? range.raw : String(range);
	  return simplified.length < original.length ? simplified : range
	};
	return simplify;
}

var subset_1;
var hasRequiredSubset;

function requireSubset () {
	if (hasRequiredSubset) return subset_1;
	hasRequiredSubset = 1;

	const Range = requireRange();
	const Comparator = requireComparator();
	const { ANY } = Comparator;
	const satisfies = requireSatisfies();
	const compare = requireCompare();

	// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
	// - Every simple range `r1, r2, ...` is a null set, OR
	// - Every simple range `r1, r2, ...` which is not a null set is a subset of
	//   some `R1, R2, ...`
	//
	// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
	// - If c is only the ANY comparator
	//   - If C is only the ANY comparator, return true
	//   - Else if in prerelease mode, return false
	//   - else replace c with `[>=0.0.0]`
	// - If C is only the ANY comparator
	//   - if in prerelease mode, return true
	//   - else replace C with `[>=0.0.0]`
	// - Let EQ be the set of = comparators in c
	// - If EQ is more than one, return true (null set)
	// - Let GT be the highest > or >= comparator in c
	// - Let LT be the lowest < or <= comparator in c
	// - If GT and LT, and GT.semver > LT.semver, return true (null set)
	// - If any C is a = range, and GT or LT are set, return false
	// - If EQ
	//   - If GT, and EQ does not satisfy GT, return true (null set)
	//   - If LT, and EQ does not satisfy LT, return true (null set)
	//   - If EQ satisfies every C, return true
	//   - Else return false
	// - If GT
	//   - If GT.semver is lower than any > or >= comp in C, return false
	//   - If GT is >=, and GT.semver does not satisfy every C, return false
	//   - If GT.semver has a prerelease, and not in prerelease mode
	//     - If no C has a prerelease and the GT.semver tuple, return false
	// - If LT
	//   - If LT.semver is greater than any < or <= comp in C, return false
	//   - If LT is <=, and LT.semver does not satisfy every C, return false
	//   - If GT.semver has a prerelease, and not in prerelease mode
	//     - If no C has a prerelease and the LT.semver tuple, return false
	// - Else return true

	const subset = (sub, dom, options = {}) => {
	  if (sub === dom) {
	    return true
	  }

	  sub = new Range(sub, options);
	  dom = new Range(dom, options);
	  let sawNonNull = false;

	  OUTER: for (const simpleSub of sub.set) {
	    for (const simpleDom of dom.set) {
	      const isSub = simpleSubset(simpleSub, simpleDom, options);
	      sawNonNull = sawNonNull || isSub !== null;
	      if (isSub) {
	        continue OUTER
	      }
	    }
	    // the null set is a subset of everything, but null simple ranges in
	    // a complex range should be ignored.  so if we saw a non-null range,
	    // then we know this isn't a subset, but if EVERY simple range was null,
	    // then it is a subset.
	    if (sawNonNull) {
	      return false
	    }
	  }
	  return true
	};

	const minimumVersionWithPreRelease = [new Comparator('>=0.0.0-0')];
	const minimumVersion = [new Comparator('>=0.0.0')];

	const simpleSubset = (sub, dom, options) => {
	  if (sub === dom) {
	    return true
	  }

	  if (sub.length === 1 && sub[0].semver === ANY) {
	    if (dom.length === 1 && dom[0].semver === ANY) {
	      return true
	    } else if (options.includePrerelease) {
	      sub = minimumVersionWithPreRelease;
	    } else {
	      sub = minimumVersion;
	    }
	  }

	  if (dom.length === 1 && dom[0].semver === ANY) {
	    if (options.includePrerelease) {
	      return true
	    } else {
	      dom = minimumVersion;
	    }
	  }

	  const eqSet = new Set();
	  let gt, lt;
	  for (const c of sub) {
	    if (c.operator === '>' || c.operator === '>=') {
	      gt = higherGT(gt, c, options);
	    } else if (c.operator === '<' || c.operator === '<=') {
	      lt = lowerLT(lt, c, options);
	    } else {
	      eqSet.add(c.semver);
	    }
	  }

	  if (eqSet.size > 1) {
	    return null
	  }

	  let gtltComp;
	  if (gt && lt) {
	    gtltComp = compare(gt.semver, lt.semver, options);
	    if (gtltComp > 0) {
	      return null
	    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
	      return null
	    }
	  }

	  // will iterate one or zero times
	  for (const eq of eqSet) {
	    if (gt && !satisfies(eq, String(gt), options)) {
	      return null
	    }

	    if (lt && !satisfies(eq, String(lt), options)) {
	      return null
	    }

	    for (const c of dom) {
	      if (!satisfies(eq, String(c), options)) {
	        return false
	      }
	    }

	    return true
	  }

	  let higher, lower;
	  let hasDomLT, hasDomGT;
	  // if the subset has a prerelease, we need a comparator in the superset
	  // with the same tuple and a prerelease, or it's not a subset
	  let needDomLTPre = lt &&
	    !options.includePrerelease &&
	    lt.semver.prerelease.length ? lt.semver : false;
	  let needDomGTPre = gt &&
	    !options.includePrerelease &&
	    gt.semver.prerelease.length ? gt.semver : false;
	  // exception: <1.2.3-0 is the same as <1.2.3
	  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
	      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
	    needDomLTPre = false;
	  }

	  for (const c of dom) {
	    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
	    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
	    if (gt) {
	      if (needDomGTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomGTPre.major &&
	            c.semver.minor === needDomGTPre.minor &&
	            c.semver.patch === needDomGTPre.patch) {
	          needDomGTPre = false;
	        }
	      }
	      if (c.operator === '>' || c.operator === '>=') {
	        higher = higherGT(gt, c, options);
	        if (higher === c && higher !== gt) {
	          return false
	        }
	      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (lt) {
	      if (needDomLTPre) {
	        if (c.semver.prerelease && c.semver.prerelease.length &&
	            c.semver.major === needDomLTPre.major &&
	            c.semver.minor === needDomLTPre.minor &&
	            c.semver.patch === needDomLTPre.patch) {
	          needDomLTPre = false;
	        }
	      }
	      if (c.operator === '<' || c.operator === '<=') {
	        lower = lowerLT(lt, c, options);
	        if (lower === c && lower !== lt) {
	          return false
	        }
	      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
	        return false
	      }
	    }
	    if (!c.operator && (lt || gt) && gtltComp !== 0) {
	      return false
	    }
	  }

	  // if there was a < or >, and nothing in the dom, then must be false
	  // UNLESS it was limited by another range in the other direction.
	  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
	  if (gt && hasDomLT && !lt && gtltComp !== 0) {
	    return false
	  }

	  if (lt && hasDomGT && !gt && gtltComp !== 0) {
	    return false
	  }

	  // we needed a prerelease range in a specific tuple, but didn't get one
	  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
	  // because it includes prereleases in the 1.2.3 tuple
	  if (needDomGTPre || needDomLTPre) {
	    return false
	  }

	  return true
	};

	// >=1.2.3 is lower than >1.2.3
	const higherGT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp > 0 ? a
	    : comp < 0 ? b
	    : b.operator === '>' && a.operator === '>=' ? b
	    : a
	};

	// <=1.2.3 is higher than <1.2.3
	const lowerLT = (a, b, options) => {
	  if (!a) {
	    return b
	  }
	  const comp = compare(a.semver, b.semver, options);
	  return comp < 0 ? a
	    : comp > 0 ? b
	    : b.operator === '<' && a.operator === '<=' ? b
	    : a
	};

	subset_1 = subset;
	return subset_1;
}

var semver;
var hasRequiredSemver;

function requireSemver () {
	if (hasRequiredSemver) return semver;
	hasRequiredSemver = 1;

	// just pre-load all the stuff that index.js lazily exports
	const internalRe = requireRe();
	const constants = requireConstants$2();
	const SemVer = requireSemver$1();
	const identifiers = requireIdentifiers();
	const parse = requireParse();
	const valid = requireValid$1();
	const clean = requireClean();
	const inc = requireInc();
	const diff = requireDiff();
	const major = requireMajor();
	const minor = requireMinor();
	const patch = requirePatch();
	const prerelease = requirePrerelease();
	const compare = requireCompare();
	const rcompare = requireRcompare();
	const compareLoose = requireCompareLoose();
	const compareBuild = requireCompareBuild();
	const sort = requireSort();
	const rsort = requireRsort();
	const gt = requireGt();
	const lt = requireLt();
	const eq = requireEq();
	const neq = requireNeq();
	const gte = requireGte();
	const lte = requireLte();
	const cmp = requireCmp();
	const coerce = requireCoerce();
	const Comparator = requireComparator();
	const Range = requireRange();
	const satisfies = requireSatisfies();
	const toComparators = requireToComparators();
	const maxSatisfying = requireMaxSatisfying();
	const minSatisfying = requireMinSatisfying();
	const minVersion = requireMinVersion();
	const validRange = requireValid();
	const outside = requireOutside();
	const gtr = requireGtr();
	const ltr = requireLtr();
	const intersects = requireIntersects();
	const simplifyRange = requireSimplify();
	const subset = requireSubset();
	semver = {
	  parse,
	  valid,
	  clean,
	  inc,
	  diff,
	  major,
	  minor,
	  patch,
	  prerelease,
	  compare,
	  rcompare,
	  compareLoose,
	  compareBuild,
	  sort,
	  rsort,
	  gt,
	  lt,
	  eq,
	  neq,
	  gte,
	  lte,
	  cmp,
	  coerce,
	  Comparator,
	  Range,
	  satisfies,
	  toComparators,
	  maxSatisfying,
	  minSatisfying,
	  minVersion,
	  validRange,
	  outside,
	  gtr,
	  ltr,
	  intersects,
	  simplifyRange,
	  subset,
	  SemVer,
	  re: internalRe.re,
	  src: internalRe.src,
	  tokens: internalRe.t,
	  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
	  RELEASE_TYPES: constants.RELEASE_TYPES,
	  compareIdentifiers: identifiers.compareIdentifiers,
	  rcompareIdentifiers: identifiers.rcompareIdentifiers,
	};
	return semver;
}

var asymmetricKeyDetailsSupported;
var hasRequiredAsymmetricKeyDetailsSupported;

function requireAsymmetricKeyDetailsSupported () {
	if (hasRequiredAsymmetricKeyDetailsSupported) return asymmetricKeyDetailsSupported;
	hasRequiredAsymmetricKeyDetailsSupported = 1;
	const semver = requireSemver();

	asymmetricKeyDetailsSupported = semver.satisfies(process.version, '>=15.7.0');
	return asymmetricKeyDetailsSupported;
}

var rsaPssKeyDetailsSupported;
var hasRequiredRsaPssKeyDetailsSupported;

function requireRsaPssKeyDetailsSupported () {
	if (hasRequiredRsaPssKeyDetailsSupported) return rsaPssKeyDetailsSupported;
	hasRequiredRsaPssKeyDetailsSupported = 1;
	const semver = requireSemver();

	rsaPssKeyDetailsSupported = semver.satisfies(process.version, '>=16.9.0');
	return rsaPssKeyDetailsSupported;
}

var validateAsymmetricKey;
var hasRequiredValidateAsymmetricKey;

function requireValidateAsymmetricKey () {
	if (hasRequiredValidateAsymmetricKey) return validateAsymmetricKey;
	hasRequiredValidateAsymmetricKey = 1;
	const ASYMMETRIC_KEY_DETAILS_SUPPORTED = requireAsymmetricKeyDetailsSupported();
	const RSA_PSS_KEY_DETAILS_SUPPORTED = requireRsaPssKeyDetailsSupported();

	const allowedAlgorithmsForKeys = {
	  'ec': ['ES256', 'ES384', 'ES512'],
	  'rsa': ['RS256', 'PS256', 'RS384', 'PS384', 'RS512', 'PS512'],
	  'rsa-pss': ['PS256', 'PS384', 'PS512']
	};

	const allowedCurves = {
	  ES256: 'prime256v1',
	  ES384: 'secp384r1',
	  ES512: 'secp521r1',
	};

	validateAsymmetricKey = function(algorithm, key) {
	  if (!algorithm || !key) return;

	  const keyType = key.asymmetricKeyType;
	  if (!keyType) return;

	  const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];

	  if (!allowedAlgorithms) {
	    throw new Error(`Unknown key type "${keyType}".`);
	  }

	  if (!allowedAlgorithms.includes(algorithm)) {
	    throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(', ')}.`)
	  }

	  /*
	   * Ignore the next block from test coverage because it gets executed
	   * conditionally depending on the Node version. Not ignoring it would
	   * prevent us from reaching the target % of coverage for versions of
	   * Node under 15.7.0.
	   */
	  /* istanbul ignore next */
	  if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
	    switch (keyType) {
	    case 'ec':
	      const keyCurve = key.asymmetricKeyDetails.namedCurve;
	      const allowedCurve = allowedCurves[algorithm];

	      if (keyCurve !== allowedCurve) {
	        throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
	      }
	      break;

	    case 'rsa-pss':
	      if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
	        const length = parseInt(algorithm.slice(-3), 10);
	        const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;

	        if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
	          throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
	        }

	        if (saltLength !== undefined && saltLength > length >> 3) {
	          throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`)
	        }
	      }
	      break;
	    }
	  }
	};
	return validateAsymmetricKey;
}

var psSupported;
var hasRequiredPsSupported;

function requirePsSupported () {
	if (hasRequiredPsSupported) return psSupported;
	hasRequiredPsSupported = 1;
	var semver = requireSemver();

	psSupported = semver.satisfies(process.version, '^6.12.0 || >=8.0.0');
	return psSupported;
}

var verify;
var hasRequiredVerify;

function requireVerify () {
	if (hasRequiredVerify) return verify;
	hasRequiredVerify = 1;
	const JsonWebTokenError = requireJsonWebTokenError();
	const NotBeforeError = requireNotBeforeError();
	const TokenExpiredError = requireTokenExpiredError();
	const decode = requireDecode();
	const timespan = requireTimespan();
	const validateAsymmetricKey = requireValidateAsymmetricKey();
	const PS_SUPPORTED = requirePsSupported();
	const jws = requireJws();
	const {KeyObject, createSecretKey, createPublicKey} = crypto$1;

	const PUB_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
	const EC_KEY_ALGS = ['ES256', 'ES384', 'ES512'];
	const RSA_KEY_ALGS = ['RS256', 'RS384', 'RS512'];
	const HS_ALGS = ['HS256', 'HS384', 'HS512'];

	if (PS_SUPPORTED) {
	  PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');
	  RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, 'PS256', 'PS384', 'PS512');
	}

	verify = function (jwtString, secretOrPublicKey, options, callback) {
	  if ((typeof options === 'function') && !callback) {
	    callback = options;
	    options = {};
	  }

	  if (!options) {
	    options = {};
	  }

	  //clone this object since we are going to mutate it.
	  options = Object.assign({}, options);

	  let done;

	  if (callback) {
	    done = callback;
	  } else {
	    done = function(err, data) {
	      if (err) throw err;
	      return data;
	    };
	  }

	  if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {
	    return done(new JsonWebTokenError('clockTimestamp must be a number'));
	  }

	  if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {
	    return done(new JsonWebTokenError('nonce must be a non-empty string'));
	  }

	  if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== 'boolean') {
	    return done(new JsonWebTokenError('allowInvalidAsymmetricKeyTypes must be a boolean'));
	  }

	  const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);

	  if (!jwtString){
	    return done(new JsonWebTokenError('jwt must be provided'));
	  }

	  if (typeof jwtString !== 'string') {
	    return done(new JsonWebTokenError('jwt must be a string'));
	  }

	  const parts = jwtString.split('.');

	  if (parts.length !== 3){
	    return done(new JsonWebTokenError('jwt malformed'));
	  }

	  let decodedToken;

	  try {
	    decodedToken = decode(jwtString, { complete: true });
	  } catch(err) {
	    return done(err);
	  }

	  if (!decodedToken) {
	    return done(new JsonWebTokenError('invalid token'));
	  }

	  const header = decodedToken.header;
	  let getSecret;

	  if(typeof secretOrPublicKey === 'function') {
	    if(!callback) {
	      return done(new JsonWebTokenError('verify must be called asynchronous if secret or public key is provided as a callback'));
	    }

	    getSecret = secretOrPublicKey;
	  }
	  else {
	    getSecret = function(header, secretCallback) {
	      return secretCallback(null, secretOrPublicKey);
	    };
	  }

	  return getSecret(header, function(err, secretOrPublicKey) {
	    if(err) {
	      return done(new JsonWebTokenError('error in secret or public key callback: ' + err.message));
	    }

	    const hasSignature = parts[2].trim() !== '';

	    if (!hasSignature && secretOrPublicKey){
	      return done(new JsonWebTokenError('jwt signature is required'));
	    }

	    if (hasSignature && !secretOrPublicKey) {
	      return done(new JsonWebTokenError('secret or public key must be provided'));
	    }

	    if (!hasSignature && !options.algorithms) {
	      return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
	    }

	    if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) {
	      try {
	        secretOrPublicKey = createPublicKey(secretOrPublicKey);
	      } catch (_) {
	        try {
	          secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === 'string' ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);
	        } catch (_) {
	          return done(new JsonWebTokenError('secretOrPublicKey is not valid key material'))
	        }
	      }
	    }

	    if (!options.algorithms) {
	      if (secretOrPublicKey.type === 'secret') {
	        options.algorithms = HS_ALGS;
	      } else if (['rsa', 'rsa-pss'].includes(secretOrPublicKey.asymmetricKeyType)) {
	        options.algorithms = RSA_KEY_ALGS;
	      } else if (secretOrPublicKey.asymmetricKeyType === 'ec') {
	        options.algorithms = EC_KEY_ALGS;
	      } else {
	        options.algorithms = PUB_KEY_ALGS;
	      }
	    }

	    if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
	      return done(new JsonWebTokenError('invalid algorithm'));
	    }

	    if (header.alg.startsWith('HS') && secretOrPublicKey.type !== 'secret') {
	      return done(new JsonWebTokenError((`secretOrPublicKey must be a symmetric key when using ${header.alg}`)))
	    } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== 'public') {
	      return done(new JsonWebTokenError((`secretOrPublicKey must be an asymmetric key when using ${header.alg}`)))
	    }

	    if (!options.allowInvalidAsymmetricKeyTypes) {
	      try {
	        validateAsymmetricKey(header.alg, secretOrPublicKey);
	      } catch (e) {
	        return done(e);
	      }
	    }

	    let valid;

	    try {
	      valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);
	    } catch (e) {
	      return done(e);
	    }

	    if (!valid) {
	      return done(new JsonWebTokenError('invalid signature'));
	    }

	    const payload = decodedToken.payload;

	    if (typeof payload.nbf !== 'undefined' && !options.ignoreNotBefore) {
	      if (typeof payload.nbf !== 'number') {
	        return done(new JsonWebTokenError('invalid nbf value'));
	      }
	      if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
	        return done(new NotBeforeError('jwt not active', new Date(payload.nbf * 1000)));
	      }
	    }

	    if (typeof payload.exp !== 'undefined' && !options.ignoreExpiration) {
	      if (typeof payload.exp !== 'number') {
	        return done(new JsonWebTokenError('invalid exp value'));
	      }
	      if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
	        return done(new TokenExpiredError('jwt expired', new Date(payload.exp * 1000)));
	      }
	    }

	    if (options.audience) {
	      const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
	      const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];

	      const match = target.some(function (targetAudience) {
	        return audiences.some(function (audience) {
	          return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
	        });
	      });

	      if (!match) {
	        return done(new JsonWebTokenError('jwt audience invalid. expected: ' + audiences.join(' or ')));
	      }
	    }

	    if (options.issuer) {
	      const invalid_issuer =
	              (typeof options.issuer === 'string' && payload.iss !== options.issuer) ||
	              (Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1);

	      if (invalid_issuer) {
	        return done(new JsonWebTokenError('jwt issuer invalid. expected: ' + options.issuer));
	      }
	    }

	    if (options.subject) {
	      if (payload.sub !== options.subject) {
	        return done(new JsonWebTokenError('jwt subject invalid. expected: ' + options.subject));
	      }
	    }

	    if (options.jwtid) {
	      if (payload.jti !== options.jwtid) {
	        return done(new JsonWebTokenError('jwt jwtid invalid. expected: ' + options.jwtid));
	      }
	    }

	    if (options.nonce) {
	      if (payload.nonce !== options.nonce) {
	        return done(new JsonWebTokenError('jwt nonce invalid. expected: ' + options.nonce));
	      }
	    }

	    if (options.maxAge) {
	      if (typeof payload.iat !== 'number') {
	        return done(new JsonWebTokenError('iat required when maxAge is specified'));
	      }

	      const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
	      if (typeof maxAgeTimestamp === 'undefined') {
	        return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
	      }
	      if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
	        return done(new TokenExpiredError('maxAge exceeded', new Date(maxAgeTimestamp * 1000)));
	      }
	    }

	    if (options.complete === true) {
	      const signature = decodedToken.signature;

	      return done(null, {
	        header: header,
	        payload: payload,
	        signature: signature
	      });
	    }

	    return done(null, payload);
	  });
	};
	return verify;
}

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

var lodash_includes;
var hasRequiredLodash_includes;

function requireLodash_includes () {
	if (hasRequiredLodash_includes) return lodash_includes;
	hasRequiredLodash_includes = 1;
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991,
	    MAX_INTEGER = 1.7976931348623157e+308,
	    NAN = 0 / 0;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]';

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array ? array.length : 0,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (-1);

	  while ((++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  if (value !== value) {
	    return baseFindIndex(array, baseIsNaN, fromIndex);
	  }
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  return arrayMap(props, function(key) {
	    return object[key];
	  });
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object),
	    nativeMax = Math.max;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];

	  var length = result.length,
	      skipIndexes = !!length;

	  for (var key in value) {
	    if ((hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Checks if `value` is in `collection`. If `collection` is a string, it's
	 * checked for a substring of `value`, otherwise
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * is used for equality comparisons. If `fromIndex` is negative, it's used as
	 * the offset from the end of `collection`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	 * @returns {boolean} Returns `true` if `value` is found, else `false`.
	 * @example
	 *
	 * _.includes([1, 2, 3], 1);
	 * // => true
	 *
	 * _.includes([1, 2, 3], 1, 2);
	 * // => false
	 *
	 * _.includes({ 'a': 1, 'b': 2 }, 1);
	 * // => true
	 *
	 * _.includes('abcd', 'bc');
	 * // => true
	 */
	function includes(collection, value, fromIndex, guard) {
	  collection = isArrayLike(collection) ? collection : values(collection);
	  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

	  var length = collection.length;
	  if (fromIndex < 0) {
	    fromIndex = nativeMax(length + fromIndex, 0);
	  }
	  return isString(collection)
	    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * Creates an array of the own enumerable string keyed property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */
	function values(object) {
	  return object ? baseValues(object, keys(object)) : [];
	}

	lodash_includes = includes;
	return lodash_includes;
}

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

var lodash_isboolean;
var hasRequiredLodash_isboolean;

function requireLodash_isboolean () {
	if (hasRequiredLodash_isboolean) return lodash_isboolean;
	hasRequiredLodash_isboolean = 1;
	/** `Object#toString` result references. */
	var boolTag = '[object Boolean]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as a boolean primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isBoolean(false);
	 * // => true
	 *
	 * _.isBoolean(null);
	 * // => false
	 */
	function isBoolean(value) {
	  return value === true || value === false ||
	    (isObjectLike(value) && objectToString.call(value) == boolTag);
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	lodash_isboolean = isBoolean;
	return lodash_isboolean;
}

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

var lodash_isinteger;
var hasRequiredLodash_isinteger;

function requireLodash_isinteger () {
	if (hasRequiredLodash_isinteger) return lodash_isinteger;
	hasRequiredLodash_isinteger = 1;
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308,
	    NAN = 0 / 0;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is an integer.
	 *
	 * **Note:** This method is based on
	 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	 * @example
	 *
	 * _.isInteger(3);
	 * // => true
	 *
	 * _.isInteger(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isInteger(Infinity);
	 * // => false
	 *
	 * _.isInteger('3');
	 * // => false
	 */
	function isInteger(value) {
	  return typeof value == 'number' && value == toInteger(value);
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	lodash_isinteger = isInteger;
	return lodash_isinteger;
}

/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

var lodash_isnumber;
var hasRequiredLodash_isnumber;

function requireLodash_isnumber () {
	if (hasRequiredLodash_isnumber) return lodash_isnumber;
	hasRequiredLodash_isnumber = 1;
	/** `Object#toString` result references. */
	var numberTag = '[object Number]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Number` primitive or object.
	 *
	 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
	 * as numbers, use the `_.isFinite` method.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isNumber(3);
	 * // => true
	 *
	 * _.isNumber(Number.MIN_VALUE);
	 * // => true
	 *
	 * _.isNumber(Infinity);
	 * // => true
	 *
	 * _.isNumber('3');
	 * // => false
	 */
	function isNumber(value) {
	  return typeof value == 'number' ||
	    (isObjectLike(value) && objectToString.call(value) == numberTag);
	}

	lodash_isnumber = isNumber;
	return lodash_isnumber;
}

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

var lodash_isplainobject;
var hasRequiredLodash_isplainobject;

function requireLodash_isplainobject () {
	if (hasRequiredLodash_isplainobject) return lodash_isplainobject;
	hasRequiredLodash_isplainobject = 1;
	/** `Object#toString` result references. */
	var objectTag = '[object Object]';

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) ||
	      objectToString.call(value) != objectTag || isHostObject(value)) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return (typeof Ctor == 'function' &&
	    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);
	}

	lodash_isplainobject = isPlainObject;
	return lodash_isplainobject;
}

/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

var lodash_isstring;
var hasRequiredLodash_isstring;

function requireLodash_isstring () {
	if (hasRequiredLodash_isstring) return lodash_isstring;
	hasRequiredLodash_isstring = 1;
	/** `Object#toString` result references. */
	var stringTag = '[object String]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @type Function
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);
	}

	lodash_isstring = isString;
	return lodash_isstring;
}

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

var lodash_once;
var hasRequiredLodash_once;

function requireLodash_once () {
	if (hasRequiredLodash_once) return lodash_once;
	hasRequiredLodash_once = 1;
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308,
	    NAN = 0 / 0;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/**
	 * Creates a function that invokes `func`, with the `this` binding and arguments
	 * of the created function, while it's called less than `n` times. Subsequent
	 * calls to the created function return the result of the last `func` invocation.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {number} n The number of calls at which `func` is no longer invoked.
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * jQuery(element).on('click', _.before(5, addContactToList));
	 * // => Allows adding up to 4 contacts to the list.
	 */
	function before(n, func) {
	  var result;
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  n = toInteger(n);
	  return function() {
	    if (--n > 0) {
	      result = func.apply(this, arguments);
	    }
	    if (n <= 1) {
	      func = undefined;
	    }
	    return result;
	  };
	}

	/**
	 * Creates a function that is restricted to invoking `func` once. Repeat calls
	 * to the function return the value of the first invocation. The `func` is
	 * invoked with the `this` binding and arguments of the created function.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * var initialize = _.once(createApplication);
	 * initialize();
	 * initialize();
	 * // => `createApplication` is invoked once
	 */
	function once(func) {
	  return before(2, func);
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY || value === -INFINITY) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN : +value);
	}

	lodash_once = once;
	return lodash_once;
}

var sign;
var hasRequiredSign;

function requireSign () {
	if (hasRequiredSign) return sign;
	hasRequiredSign = 1;
	const timespan = requireTimespan();
	const PS_SUPPORTED = requirePsSupported();
	const validateAsymmetricKey = requireValidateAsymmetricKey();
	const jws = requireJws();
	const includes = requireLodash_includes();
	const isBoolean = requireLodash_isboolean();
	const isInteger = requireLodash_isinteger();
	const isNumber = requireLodash_isnumber();
	const isPlainObject = requireLodash_isplainobject();
	const isString = requireLodash_isstring();
	const once = requireLodash_once();
	const { KeyObject, createSecretKey, createPrivateKey } = crypto$1;

	const SUPPORTED_ALGS = ['RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'HS256', 'HS384', 'HS512', 'none'];
	if (PS_SUPPORTED) {
	  SUPPORTED_ALGS.splice(3, 0, 'PS256', 'PS384', 'PS512');
	}

	const sign_options_schema = {
	  expiresIn: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
	  notBefore: { isValid: function(value) { return isInteger(value) || (isString(value) && value); }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
	  audience: { isValid: function(value) { return isString(value) || Array.isArray(value); }, message: '"audience" must be a string or array' },
	  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
	  header: { isValid: isPlainObject, message: '"header" must be an object' },
	  encoding: { isValid: isString, message: '"encoding" must be a string' },
	  issuer: { isValid: isString, message: '"issuer" must be a string' },
	  subject: { isValid: isString, message: '"subject" must be a string' },
	  jwtid: { isValid: isString, message: '"jwtid" must be a string' },
	  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
	  keyid: { isValid: isString, message: '"keyid" must be a string' },
	  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
	  allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean'},
	  allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean'}
	};

	const registered_claims_schema = {
	  iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
	  exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
	  nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
	};

	function validate(schema, allowUnknown, object, parameterName) {
	  if (!isPlainObject(object)) {
	    throw new Error('Expected "' + parameterName + '" to be a plain object.');
	  }
	  Object.keys(object)
	    .forEach(function(key) {
	      const validator = schema[key];
	      if (!validator) {
	        if (!allowUnknown) {
	          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
	        }
	        return;
	      }
	      if (!validator.isValid(object[key])) {
	        throw new Error(validator.message);
	      }
	    });
	}

	function validateOptions(options) {
	  return validate(sign_options_schema, false, options, 'options');
	}

	function validatePayload(payload) {
	  return validate(registered_claims_schema, true, payload, 'payload');
	}

	const options_to_payload = {
	  'audience': 'aud',
	  'issuer': 'iss',
	  'subject': 'sub',
	  'jwtid': 'jti'
	};

	const options_for_objects = [
	  'expiresIn',
	  'notBefore',
	  'noTimestamp',
	  'audience',
	  'issuer',
	  'subject',
	  'jwtid',
	];

	sign = function (payload, secretOrPrivateKey, options, callback) {
	  if (typeof options === 'function') {
	    callback = options;
	    options = {};
	  } else {
	    options = options || {};
	  }

	  const isObjectPayload = typeof payload === 'object' &&
	                        !Buffer.isBuffer(payload);

	  const header = Object.assign({
	    alg: options.algorithm || 'HS256',
	    typ: isObjectPayload ? 'JWT' : undefined,
	    kid: options.keyid
	  }, options.header);

	  function failure(err) {
	    if (callback) {
	      return callback(err);
	    }
	    throw err;
	  }

	  if (!secretOrPrivateKey && options.algorithm !== 'none') {
	    return failure(new Error('secretOrPrivateKey must have a value'));
	  }

	  if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
	    try {
	      secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
	    } catch (_) {
	      try {
	        secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === 'string' ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
	      } catch (_) {
	        return failure(new Error('secretOrPrivateKey is not valid key material'));
	      }
	    }
	  }

	  if (header.alg.startsWith('HS') && secretOrPrivateKey.type !== 'secret') {
	    return failure(new Error((`secretOrPrivateKey must be a symmetric key when using ${header.alg}`)))
	  } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
	    if (secretOrPrivateKey.type !== 'private') {
	      return failure(new Error((`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`)))
	    }
	    if (!options.allowInsecureKeySizes &&
	      !header.alg.startsWith('ES') &&
	      secretOrPrivateKey.asymmetricKeyDetails !== undefined && //KeyObject.asymmetricKeyDetails is supported in Node 15+
	      secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
	      return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
	    }
	  }

	  if (typeof payload === 'undefined') {
	    return failure(new Error('payload is required'));
	  } else if (isObjectPayload) {
	    try {
	      validatePayload(payload);
	    }
	    catch (error) {
	      return failure(error);
	    }
	    if (!options.mutatePayload) {
	      payload = Object.assign({},payload);
	    }
	  } else {
	    const invalid_options = options_for_objects.filter(function (opt) {
	      return typeof options[opt] !== 'undefined';
	    });

	    if (invalid_options.length > 0) {
	      return failure(new Error('invalid ' + invalid_options.join(',') + ' option for ' + (typeof payload ) + ' payload'));
	    }
	  }

	  if (typeof payload.exp !== 'undefined' && typeof options.expiresIn !== 'undefined') {
	    return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
	  }

	  if (typeof payload.nbf !== 'undefined' && typeof options.notBefore !== 'undefined') {
	    return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
	  }

	  try {
	    validateOptions(options);
	  }
	  catch (error) {
	    return failure(error);
	  }

	  if (!options.allowInvalidAsymmetricKeyTypes) {
	    try {
	      validateAsymmetricKey(header.alg, secretOrPrivateKey);
	    } catch (error) {
	      return failure(error);
	    }
	  }

	  const timestamp = payload.iat || Math.floor(Date.now() / 1000);

	  if (options.noTimestamp) {
	    delete payload.iat;
	  } else if (isObjectPayload) {
	    payload.iat = timestamp;
	  }

	  if (typeof options.notBefore !== 'undefined') {
	    try {
	      payload.nbf = timespan(options.notBefore, timestamp);
	    }
	    catch (err) {
	      return failure(err);
	    }
	    if (typeof payload.nbf === 'undefined') {
	      return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
	    }
	  }

	  if (typeof options.expiresIn !== 'undefined' && typeof payload === 'object') {
	    try {
	      payload.exp = timespan(options.expiresIn, timestamp);
	    }
	    catch (err) {
	      return failure(err);
	    }
	    if (typeof payload.exp === 'undefined') {
	      return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
	    }
	  }

	  Object.keys(options_to_payload).forEach(function (key) {
	    const claim = options_to_payload[key];
	    if (typeof options[key] !== 'undefined') {
	      if (typeof payload[claim] !== 'undefined') {
	        return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
	      }
	      payload[claim] = options[key];
	    }
	  });

	  const encoding = options.encoding || 'utf8';

	  if (typeof callback === 'function') {
	    callback = callback && once(callback);

	    jws.createSign({
	      header: header,
	      privateKey: secretOrPrivateKey,
	      payload: payload,
	      encoding: encoding
	    }).once('error', callback)
	      .once('done', function (signature) {
	        // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version
	        if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
	          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`))
	        }
	        callback(null, signature);
	      });
	  } else {
	    let signature = jws.sign({header: header, payload: payload, secret: secretOrPrivateKey, encoding: encoding});
	    // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version
	    if(!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
	      throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`)
	    }
	    return signature
	  }
	};
	return sign;
}

var jsonwebtoken;
var hasRequiredJsonwebtoken;

function requireJsonwebtoken () {
	if (hasRequiredJsonwebtoken) return jsonwebtoken;
	hasRequiredJsonwebtoken = 1;
	jsonwebtoken = {
	  decode: requireDecode(),
	  verify: requireVerify(),
	  sign: requireSign(),
	  JsonWebTokenError: requireJsonWebTokenError(),
	  NotBeforeError: requireNotBeforeError(),
	  TokenExpiredError: requireTokenExpiredError(),
	};
	return jsonwebtoken;
}

/*! @azure/msal-node v3.8.4 2025-12-04 */

var hasRequiredMsalNode;

function requireMsalNode () {
	if (hasRequiredMsalNode) return msalNode;
	hasRequiredMsalNode = 1;
	(function (exports$1) {

		var http = require$$0$8;
		var https = require$$1$2;
		var uuid = require$$2$1;
		var crypto = crypto$1;
		var msalCommon = /*@__PURE__*/ requireLib$1();
		var jwt = requireJsonwebtoken();
		var fs = require$$6$1;
		var path = require$$7$1;

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * This class serializes cache entities to be saved into in-memory object types defined internally
		 * @internal
		 */
		class Serializer {
		    /**
		     * serialize the JSON blob
		     * @param data - JSON blob cache
		     */
		    static serializeJSONBlob(data) {
		        return JSON.stringify(data);
		    }
		    /**
		     * Serialize Accounts
		     * @param accCache - cache of accounts
		     */
		    static serializeAccounts(accCache) {
		        const accounts = {};
		        Object.keys(accCache).map(function (key) {
		            const accountEntity = accCache[key];
		            accounts[key] = {
		                home_account_id: accountEntity.homeAccountId,
		                environment: accountEntity.environment,
		                realm: accountEntity.realm,
		                local_account_id: accountEntity.localAccountId,
		                username: accountEntity.username,
		                authority_type: accountEntity.authorityType,
		                name: accountEntity.name,
		                client_info: accountEntity.clientInfo,
		                last_modification_time: accountEntity.lastModificationTime,
		                last_modification_app: accountEntity.lastModificationApp,
		                tenantProfiles: accountEntity.tenantProfiles?.map((tenantProfile) => {
		                    return JSON.stringify(tenantProfile);
		                }),
		            };
		        });
		        return accounts;
		    }
		    /**
		     * Serialize IdTokens
		     * @param idTCache - cache of ID tokens
		     */
		    static serializeIdTokens(idTCache) {
		        const idTokens = {};
		        Object.keys(idTCache).map(function (key) {
		            const idTEntity = idTCache[key];
		            idTokens[key] = {
		                home_account_id: idTEntity.homeAccountId,
		                environment: idTEntity.environment,
		                credential_type: idTEntity.credentialType,
		                client_id: idTEntity.clientId,
		                secret: idTEntity.secret,
		                realm: idTEntity.realm,
		            };
		        });
		        return idTokens;
		    }
		    /**
		     * Serializes AccessTokens
		     * @param atCache - cache of access tokens
		     */
		    static serializeAccessTokens(atCache) {
		        const accessTokens = {};
		        Object.keys(atCache).map(function (key) {
		            const atEntity = atCache[key];
		            accessTokens[key] = {
		                home_account_id: atEntity.homeAccountId,
		                environment: atEntity.environment,
		                credential_type: atEntity.credentialType,
		                client_id: atEntity.clientId,
		                secret: atEntity.secret,
		                realm: atEntity.realm,
		                target: atEntity.target,
		                cached_at: atEntity.cachedAt,
		                expires_on: atEntity.expiresOn,
		                extended_expires_on: atEntity.extendedExpiresOn,
		                refresh_on: atEntity.refreshOn,
		                key_id: atEntity.keyId,
		                token_type: atEntity.tokenType,
		                requestedClaims: atEntity.requestedClaims,
		                requestedClaimsHash: atEntity.requestedClaimsHash,
		                userAssertionHash: atEntity.userAssertionHash,
		            };
		        });
		        return accessTokens;
		    }
		    /**
		     * Serialize refreshTokens
		     * @param rtCache - cache of refresh tokens
		     */
		    static serializeRefreshTokens(rtCache) {
		        const refreshTokens = {};
		        Object.keys(rtCache).map(function (key) {
		            const rtEntity = rtCache[key];
		            refreshTokens[key] = {
		                home_account_id: rtEntity.homeAccountId,
		                environment: rtEntity.environment,
		                credential_type: rtEntity.credentialType,
		                client_id: rtEntity.clientId,
		                secret: rtEntity.secret,
		                family_id: rtEntity.familyId,
		                target: rtEntity.target,
		                realm: rtEntity.realm,
		            };
		        });
		        return refreshTokens;
		    }
		    /**
		     * Serialize amdtCache
		     * @param amdtCache - cache of app metadata
		     */
		    static serializeAppMetadata(amdtCache) {
		        const appMetadata = {};
		        Object.keys(amdtCache).map(function (key) {
		            const amdtEntity = amdtCache[key];
		            appMetadata[key] = {
		                client_id: amdtEntity.clientId,
		                environment: amdtEntity.environment,
		                family_id: amdtEntity.familyId,
		            };
		        });
		        return appMetadata;
		    }
		    /**
		     * Serialize the cache
		     * @param inMemCache - itemised cache read from the JSON
		     */
		    static serializeAllCache(inMemCache) {
		        return {
		            Account: this.serializeAccounts(inMemCache.accounts),
		            IdToken: this.serializeIdTokens(inMemCache.idTokens),
		            AccessToken: this.serializeAccessTokens(inMemCache.accessTokens),
		            RefreshToken: this.serializeRefreshTokens(inMemCache.refreshTokens),
		            AppMetadata: this.serializeAppMetadata(inMemCache.appMetadata),
		        };
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const Constants$1 = {
		    LIBRARY_NAME: "MSAL.JS",
		    SKU: "msal.js.common",
		    // default authority
		    DEFAULT_AUTHORITY: "https://login.microsoftonline.com/common/",
		    DEFAULT_AUTHORITY_HOST: "login.microsoftonline.com",
		    DEFAULT_COMMON_TENANT: "common",
		    // ADFS String
		    ADFS: "adfs",
		    DSTS: "dstsv2",
		    // Default AAD Instance Discovery Endpoint
		    AAD_INSTANCE_DISCOVERY_ENDPT: "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=",
		    // CIAM URL
		    CIAM_AUTH_URL: ".ciamlogin.com",
		    AAD_TENANT_DOMAIN_SUFFIX: ".onmicrosoft.com",
		    // Resource delimiter - used for certain cache entries
		    RESOURCE_DELIM: "|",
		    // Placeholder for non-existent account ids/objects
		    NO_ACCOUNT: "NO_ACCOUNT",
		    // Claims
		    CLAIMS: "claims",
		    // Consumer UTID
		    CONSUMER_UTID: "9188040d-6c67-4c5b-b112-36a304b66dad",
		    // Default scopes
		    OPENID_SCOPE: "openid",
		    PROFILE_SCOPE: "profile",
		    OFFLINE_ACCESS_SCOPE: "offline_access",
		    EMAIL_SCOPE: "email",
		    CODE_GRANT_TYPE: "authorization_code",
		    RT_GRANT_TYPE: "refresh_token",
		    S256_CODE_CHALLENGE_METHOD: "S256",
		    URL_FORM_CONTENT_TYPE: "application/x-www-form-urlencoded;charset=utf-8",
		    AUTHORIZATION_PENDING: "authorization_pending",
		    NOT_DEFINED: "not_defined",
		    EMPTY_STRING: "",
		    NOT_APPLICABLE: "N/A",
		    NOT_AVAILABLE: "Not Available",
		    FORWARD_SLASH: "/",
		    IMDS_ENDPOINT: "http://169.254.169.254/metadata/instance/compute/location",
		    IMDS_VERSION: "2020-06-01",
		    IMDS_TIMEOUT: 2000,
		    AZURE_REGION_AUTO_DISCOVER_FLAG: "TryAutoDetect",
		    REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX: "login.microsoft.com",
		    KNOWN_PUBLIC_CLOUDS: [
		        "login.microsoftonline.com",
		        "login.windows.net",
		        "login.microsoft.com",
		        "sts.windows.net",
		    ],
		    SHR_NONCE_VALIDITY: 240,
		    INVALID_INSTANCE: "invalid_instance",
		};
		const HttpStatus = {
		    SUCCESS: 200,
		    SUCCESS_RANGE_START: 200,
		    SUCCESS_RANGE_END: 299,
		    REDIRECT: 302,
		    CLIENT_ERROR: 400,
		    CLIENT_ERROR_RANGE_START: 400,
		    BAD_REQUEST: 400,
		    UNAUTHORIZED: 401,
		    NOT_FOUND: 404,
		    REQUEST_TIMEOUT: 408,
		    GONE: 410,
		    TOO_MANY_REQUESTS: 429,
		    CLIENT_ERROR_RANGE_END: 499,
		    SERVER_ERROR: 500,
		    SERVER_ERROR_RANGE_START: 500,
		    SERVICE_UNAVAILABLE: 503,
		    GATEWAY_TIMEOUT: 504,
		    SERVER_ERROR_RANGE_END: 599,
		    MULTI_SIDED_ERROR: 600,
		};
		const OIDC_DEFAULT_SCOPES = [
		    Constants$1.OPENID_SCOPE,
		    Constants$1.PROFILE_SCOPE,
		    Constants$1.OFFLINE_ACCESS_SCOPE,
		];
		const OIDC_SCOPES = [...OIDC_DEFAULT_SCOPES, Constants$1.EMAIL_SCOPE];
		/**
		 * Request header names
		 */
		const HeaderNames = {
		    CONTENT_TYPE: "Content-Type",
		    CONTENT_LENGTH: "Content-Length",
		    RETRY_AFTER: "Retry-After",
		    CCS_HEADER: "X-AnchorMailbox",
		    WWWAuthenticate: "WWW-Authenticate",
		    AuthenticationInfo: "Authentication-Info",
		    X_MS_REQUEST_ID: "x-ms-request-id",
		    X_MS_HTTP_VERSION: "x-ms-httpver",
		};
		/**
		 * String constants related to AAD Authority
		 */
		const AADAuthorityConstants = {
		    COMMON: "common",
		    ORGANIZATIONS: "organizations",
		    CONSUMERS: "consumers",
		};
		/**
		 * Claims request keys
		 */
		const ClaimsRequestKeys = {
		    ACCESS_TOKEN: "access_token",
		    XMS_CC: "xms_cc",
		};
		/**
		 * we considered making this "enum" in the request instead of string, however it looks like the allowed list of
		 * prompt values kept changing over past couple of years. There are some undocumented prompt values for some
		 * internal partners too, hence the choice of generic "string" type instead of the "enum"
		 */
		const PromptValue = {
		    LOGIN: "login",
		    SELECT_ACCOUNT: "select_account",
		    CONSENT: "consent",
		    NONE: "none",
		    CREATE: "create",
		    NO_SESSION: "no_session",
		};
		/**
		 * allowed values for codeVerifier
		 */
		const CodeChallengeMethodValues = {
		    PLAIN: "plain",
		    S256: "S256",
		};
		/**
		 * Allowed values for response_type
		 */
		const OAuthResponseType = {
		    CODE: "code",
		    IDTOKEN_TOKEN: "id_token token"};
		/**
		 * allowed values for response_mode
		 */
		const ResponseMode = {
		    QUERY: "query",
		    FRAGMENT: "fragment",
		    FORM_POST: "form_post",
		};
		/**
		 * allowed grant_type
		 */
		const GrantType = {
		    AUTHORIZATION_CODE_GRANT: "authorization_code",
		    CLIENT_CREDENTIALS_GRANT: "client_credentials",
		    RESOURCE_OWNER_PASSWORD_GRANT: "password",
		    REFRESH_TOKEN_GRANT: "refresh_token",
		    DEVICE_CODE_GRANT: "device_code",
		    JWT_BEARER: "urn:ietf:params:oauth:grant-type:jwt-bearer",
		};
		/**
		 * Account types in Cache
		 */
		const CacheAccountType = {
		    MSSTS_ACCOUNT_TYPE: "MSSTS",
		    ADFS_ACCOUNT_TYPE: "ADFS",
		    GENERIC_ACCOUNT_TYPE: "Generic", // NTLM, Kerberos, FBA, Basic etc
		};
		/**
		 * Separators used in cache
		 */
		const Separators = {
		    CACHE_KEY_SEPARATOR: "-",
		    CLIENT_INFO_SEPARATOR: ".",
		};
		/**
		 * Credential Type stored in the cache
		 */
		const CredentialType = {
		    ID_TOKEN: "IdToken",
		    ACCESS_TOKEN: "AccessToken",
		    ACCESS_TOKEN_WITH_AUTH_SCHEME: "AccessToken_With_AuthScheme",
		    REFRESH_TOKEN: "RefreshToken",
		};
		/**
		 * More Cache related constants
		 */
		const APP_METADATA = "appmetadata";
		const CLIENT_INFO = "client_info";
		const THE_FAMILY_ID = "1";
		const AUTHORITY_METADATA_CONSTANTS = {
		    CACHE_KEY: "authority-metadata",
		    REFRESH_TIME_SECONDS: 3600 * 24, // 24 Hours
		};
		const AuthorityMetadataSource = {
		    CONFIG: "config",
		    CACHE: "cache",
		    NETWORK: "network",
		    HARDCODED_VALUES: "hardcoded_values",
		};
		const SERVER_TELEM_CONSTANTS = {
		    SCHEMA_VERSION: 5,
		    MAX_LAST_HEADER_BYTES: 330,
		    MAX_CACHED_ERRORS: 50,
		    CACHE_KEY: "server-telemetry",
		    CATEGORY_SEPARATOR: "|",
		    VALUE_SEPARATOR: ",",
		    OVERFLOW_TRUE: "1",
		    OVERFLOW_FALSE: "0",
		    UNKNOWN_ERROR: "unknown_error",
		};
		/**
		 * Type of the authentication request
		 */
		const AuthenticationScheme = {
		    BEARER: "Bearer",
		    POP: "pop",
		    SSH: "ssh-cert",
		};
		/**
		 * Constants related to throttling
		 */
		const ThrottlingConstants = {
		    // Default time to throttle RequestThumbprint in seconds
		    DEFAULT_THROTTLE_TIME_SECONDS: 60,
		    // Default maximum time to throttle in seconds, overrides what the server sends back
		    DEFAULT_MAX_THROTTLE_TIME_SECONDS: 3600,
		    // Prefix for storing throttling entries
		    THROTTLING_PREFIX: "throttling",
		    // Value assigned to the x-ms-lib-capability header to indicate to the server the library supports throttling
		    X_MS_LIB_CAPABILITY_VALUE: "retry-after, h429",
		};
		const Errors = {
		    INVALID_GRANT_ERROR: "invalid_grant",
		    CLIENT_MISMATCH_ERROR: "client_mismatch",
		};
		/**
		 * Password grant parameters
		 */
		const PasswordGrantConstants = {
		    username: "username",
		    password: "password",
		};
		/**
		 * Region Discovery Sources
		 */
		const RegionDiscoverySources = {
		    FAILED_AUTO_DETECTION: "1",
		    INTERNAL_CACHE: "2",
		    ENVIRONMENT_VARIABLE: "3",
		    IMDS: "4",
		};
		/**
		 * Region Discovery Outcomes
		 */
		const RegionDiscoveryOutcomes = {
		    CONFIGURED_NO_AUTO_DETECTION: "2",
		    AUTO_DETECTION_REQUESTED_SUCCESSFUL: "4",
		    AUTO_DETECTION_REQUESTED_FAILED: "5",
		};
		/**
		 * Specifies the reason for fetching the access token from the identity provider
		 */
		const CacheOutcome = {
		    // When a token is found in the cache or the cache is not supposed to be hit when making the request
		    NOT_APPLICABLE: "0",
		    // When the token request goes to the identity provider because force_refresh was set to true. Also occurs if claims were requested
		    FORCE_REFRESH_OR_CLAIMS: "1",
		    // When the token request goes to the identity provider because no cached access token exists
		    NO_CACHED_ACCESS_TOKEN: "2",
		    // When the token request goes to the identity provider because cached access token expired
		    CACHED_ACCESS_TOKEN_EXPIRED: "3",
		    // When the token request goes to the identity provider because refresh_in was used and the existing token needs to be refreshed
		    PROACTIVELY_REFRESHED: "4",
		};
		// Token renewal offset default in seconds
		const DEFAULT_TOKEN_RENEWAL_OFFSET_SEC = 300;
		const EncodingTypes = {
		    BASE64: "base64",
		    HEX: "hex",
		    UTF8: "utf-8",
		};

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * AuthErrorMessage class containing string constants used by error codes and messages.
		 */
		const unexpectedError = "unexpected_error";
		const postRequestFailed = "post_request_failed";

		var AuthErrorCodes = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    postRequestFailed: postRequestFailed,
		    unexpectedError: unexpectedError
		});

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const AuthErrorMessages = {
		    [unexpectedError]: "Unexpected error in authentication.",
		    [postRequestFailed]: "Post request failed from the network, could be a 4xx/5xx or a network unavailability. Please check the exact error code for details.",
		};
		/**
		 * AuthErrorMessage class containing string constants used by error codes and messages.
		 * @deprecated Use AuthErrorCodes instead
		 */
		const AuthErrorMessage = {
		    unexpectedError: {
		        code: unexpectedError,
		        desc: AuthErrorMessages[unexpectedError],
		    },
		    postRequestFailed: {
		        code: postRequestFailed,
		        desc: AuthErrorMessages[postRequestFailed],
		    },
		};
		/**
		 * General error class thrown by the MSAL.js library.
		 */
		class AuthError extends Error {
		    constructor(errorCode, errorMessage, suberror) {
		        const errorString = errorMessage
		            ? `${errorCode}: ${errorMessage}`
		            : errorCode;
		        super(errorString);
		        Object.setPrototypeOf(this, AuthError.prototype);
		        this.errorCode = errorCode || Constants$1.EMPTY_STRING;
		        this.errorMessage = errorMessage || Constants$1.EMPTY_STRING;
		        this.subError = suberror || Constants$1.EMPTY_STRING;
		        this.name = "AuthError";
		    }
		    setCorrelationId(correlationId) {
		        this.correlationId = correlationId;
		    }
		}
		function createAuthError(code, additionalMessage) {
		    return new AuthError(code, additionalMessage
		        ? `${AuthErrorMessages[code]} ${additionalMessage}`
		        : AuthErrorMessages[code]);
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const clientInfoDecodingError = "client_info_decoding_error";
		const clientInfoEmptyError = "client_info_empty_error";
		const tokenParsingError = "token_parsing_error";
		const nullOrEmptyToken = "null_or_empty_token";
		const endpointResolutionError = "endpoints_resolution_error";
		const networkError = "network_error";
		const openIdConfigError = "openid_config_error";
		const hashNotDeserialized = "hash_not_deserialized";
		const invalidState = "invalid_state";
		const stateMismatch = "state_mismatch";
		const stateNotFound = "state_not_found";
		const nonceMismatch = "nonce_mismatch";
		const authTimeNotFound = "auth_time_not_found";
		const maxAgeTranspired = "max_age_transpired";
		const multipleMatchingTokens = "multiple_matching_tokens";
		const multipleMatchingAccounts = "multiple_matching_accounts";
		const multipleMatchingAppMetadata = "multiple_matching_appMetadata";
		const requestCannotBeMade = "request_cannot_be_made";
		const cannotRemoveEmptyScope = "cannot_remove_empty_scope";
		const cannotAppendScopeSet = "cannot_append_scopeset";
		const emptyInputScopeSet = "empty_input_scopeset";
		const deviceCodePollingCancelled = "device_code_polling_cancelled";
		const deviceCodeExpired = "device_code_expired";
		const deviceCodeUnknownError = "device_code_unknown_error";
		const noAccountInSilentRequest = "no_account_in_silent_request";
		const invalidCacheRecord = "invalid_cache_record";
		const invalidCacheEnvironment = "invalid_cache_environment";
		const noAccountFound = "no_account_found";
		const noCryptoObject = "no_crypto_object";
		const unexpectedCredentialType = "unexpected_credential_type";
		const invalidAssertion = "invalid_assertion";
		const invalidClientCredential = "invalid_client_credential";
		const tokenRefreshRequired = "token_refresh_required";
		const userTimeoutReached = "user_timeout_reached";
		const tokenClaimsCnfRequiredForSignedJwt = "token_claims_cnf_required_for_signedjwt";
		const authorizationCodeMissingFromServerResponse = "authorization_code_missing_from_server_response";
		const bindingKeyNotRemoved = "binding_key_not_removed";
		const endSessionEndpointNotSupported = "end_session_endpoint_not_supported";
		const keyIdMissing = "key_id_missing";
		const noNetworkConnectivity = "no_network_connectivity";
		const userCanceled = "user_canceled";
		const missingTenantIdError = "missing_tenant_id_error";
		const methodNotImplemented = "method_not_implemented";
		const nestedAppAuthBridgeDisabled = "nested_app_auth_bridge_disabled";
		const platformBrokerError = "platform_broker_error";

		var ClientAuthErrorCodes = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    authTimeNotFound: authTimeNotFound,
		    authorizationCodeMissingFromServerResponse: authorizationCodeMissingFromServerResponse,
		    bindingKeyNotRemoved: bindingKeyNotRemoved,
		    cannotAppendScopeSet: cannotAppendScopeSet,
		    cannotRemoveEmptyScope: cannotRemoveEmptyScope,
		    clientInfoDecodingError: clientInfoDecodingError,
		    clientInfoEmptyError: clientInfoEmptyError,
		    deviceCodeExpired: deviceCodeExpired,
		    deviceCodePollingCancelled: deviceCodePollingCancelled,
		    deviceCodeUnknownError: deviceCodeUnknownError,
		    emptyInputScopeSet: emptyInputScopeSet,
		    endSessionEndpointNotSupported: endSessionEndpointNotSupported,
		    endpointResolutionError: endpointResolutionError,
		    hashNotDeserialized: hashNotDeserialized,
		    invalidAssertion: invalidAssertion,
		    invalidCacheEnvironment: invalidCacheEnvironment,
		    invalidCacheRecord: invalidCacheRecord,
		    invalidClientCredential: invalidClientCredential,
		    invalidState: invalidState,
		    keyIdMissing: keyIdMissing,
		    maxAgeTranspired: maxAgeTranspired,
		    methodNotImplemented: methodNotImplemented,
		    missingTenantIdError: missingTenantIdError,
		    multipleMatchingAccounts: multipleMatchingAccounts,
		    multipleMatchingAppMetadata: multipleMatchingAppMetadata,
		    multipleMatchingTokens: multipleMatchingTokens,
		    nestedAppAuthBridgeDisabled: nestedAppAuthBridgeDisabled,
		    networkError: networkError,
		    noAccountFound: noAccountFound,
		    noAccountInSilentRequest: noAccountInSilentRequest,
		    noCryptoObject: noCryptoObject,
		    noNetworkConnectivity: noNetworkConnectivity,
		    nonceMismatch: nonceMismatch,
		    nullOrEmptyToken: nullOrEmptyToken,
		    openIdConfigError: openIdConfigError,
		    platformBrokerError: platformBrokerError,
		    requestCannotBeMade: requestCannotBeMade,
		    stateMismatch: stateMismatch,
		    stateNotFound: stateNotFound,
		    tokenClaimsCnfRequiredForSignedJwt: tokenClaimsCnfRequiredForSignedJwt,
		    tokenParsingError: tokenParsingError,
		    tokenRefreshRequired: tokenRefreshRequired,
		    unexpectedCredentialType: unexpectedCredentialType,
		    userCanceled: userCanceled,
		    userTimeoutReached: userTimeoutReached
		});

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * ClientAuthErrorMessage class containing string constants used by error codes and messages.
		 */
		const ClientAuthErrorMessages = {
		    [clientInfoDecodingError]: "The client info could not be parsed/decoded correctly",
		    [clientInfoEmptyError]: "The client info was empty",
		    [tokenParsingError]: "Token cannot be parsed",
		    [nullOrEmptyToken]: "The token is null or empty",
		    [endpointResolutionError]: "Endpoints cannot be resolved",
		    [networkError]: "Network request failed",
		    [openIdConfigError]: "Could not retrieve endpoints. Check your authority and verify the .well-known/openid-configuration endpoint returns the required endpoints.",
		    [hashNotDeserialized]: "The hash parameters could not be deserialized",
		    [invalidState]: "State was not the expected format",
		    [stateMismatch]: "State mismatch error",
		    [stateNotFound]: "State not found",
		    [nonceMismatch]: "Nonce mismatch error",
		    [authTimeNotFound]: "Max Age was requested and the ID token is missing the auth_time variable." +
		        " auth_time is an optional claim and is not enabled by default - it must be enabled." +
		        " See https://aka.ms/msaljs/optional-claims for more information.",
		    [maxAgeTranspired]: "Max Age is set to 0, or too much time has elapsed since the last end-user authentication.",
		    [multipleMatchingTokens]: "The cache contains multiple tokens satisfying the requirements. " +
		        "Call AcquireToken again providing more requirements such as authority or account.",
		    [multipleMatchingAccounts]: "The cache contains multiple accounts satisfying the given parameters. Please pass more info to obtain the correct account",
		    [multipleMatchingAppMetadata]: "The cache contains multiple appMetadata satisfying the given parameters. Please pass more info to obtain the correct appMetadata",
		    [requestCannotBeMade]: "Token request cannot be made without authorization code or refresh token.",
		    [cannotRemoveEmptyScope]: "Cannot remove null or empty scope from ScopeSet",
		    [cannotAppendScopeSet]: "Cannot append ScopeSet",
		    [emptyInputScopeSet]: "Empty input ScopeSet cannot be processed",
		    [deviceCodePollingCancelled]: "Caller has cancelled token endpoint polling during device code flow by setting DeviceCodeRequest.cancel = true.",
		    [deviceCodeExpired]: "Device code is expired.",
		    [deviceCodeUnknownError]: "Device code stopped polling for unknown reasons.",
		    [noAccountInSilentRequest]: "Please pass an account object, silent flow is not supported without account information",
		    [invalidCacheRecord]: "Cache record object was null or undefined.",
		    [invalidCacheEnvironment]: "Invalid environment when attempting to create cache entry",
		    [noAccountFound]: "No account found in cache for given key.",
		    [noCryptoObject]: "No crypto object detected.",
		    [unexpectedCredentialType]: "Unexpected credential type.",
		    [invalidAssertion]: "Client assertion must meet requirements described in https://tools.ietf.org/html/rfc7515",
		    [invalidClientCredential]: "Client credential (secret, certificate, or assertion) must not be empty when creating a confidential client. An application should at most have one credential",
		    [tokenRefreshRequired]: "Cannot return token from cache because it must be refreshed. This may be due to one of the following reasons: forceRefresh parameter is set to true, claims have been requested, there is no cached access token or it is expired.",
		    [userTimeoutReached]: "User defined timeout for device code polling reached",
		    [tokenClaimsCnfRequiredForSignedJwt]: "Cannot generate a POP jwt if the token_claims are not populated",
		    [authorizationCodeMissingFromServerResponse]: "Server response does not contain an authorization code to proceed",
		    [bindingKeyNotRemoved]: "Could not remove the credential's binding key from storage.",
		    [endSessionEndpointNotSupported]: "The provided authority does not support logout",
		    [keyIdMissing]: "A keyId value is missing from the requested bound token's cache record and is required to match the token to it's stored binding key.",
		    [noNetworkConnectivity]: "No network connectivity. Check your internet connection.",
		    [userCanceled]: "User cancelled the flow.",
		    [missingTenantIdError]: "A tenant id - not common, organizations, or consumers - must be specified when using the client_credentials flow.",
		    [methodNotImplemented]: "This method has not been implemented",
		    [nestedAppAuthBridgeDisabled]: "The nested app auth bridge is disabled",
		    [platformBrokerError]: "An error occurred in the native broker. See the platformBrokerError property for details.",
		};
		/**
		 * String constants used by error codes and messages.
		 * @deprecated Use ClientAuthErrorCodes instead
		 */
		const ClientAuthErrorMessage = {
		    clientInfoDecodingError: {
		        code: clientInfoDecodingError,
		        desc: ClientAuthErrorMessages[clientInfoDecodingError],
		    },
		    clientInfoEmptyError: {
		        code: clientInfoEmptyError,
		        desc: ClientAuthErrorMessages[clientInfoEmptyError],
		    },
		    tokenParsingError: {
		        code: tokenParsingError,
		        desc: ClientAuthErrorMessages[tokenParsingError],
		    },
		    nullOrEmptyToken: {
		        code: nullOrEmptyToken,
		        desc: ClientAuthErrorMessages[nullOrEmptyToken],
		    },
		    endpointResolutionError: {
		        code: endpointResolutionError,
		        desc: ClientAuthErrorMessages[endpointResolutionError],
		    },
		    networkError: {
		        code: networkError,
		        desc: ClientAuthErrorMessages[networkError],
		    },
		    unableToGetOpenidConfigError: {
		        code: openIdConfigError,
		        desc: ClientAuthErrorMessages[openIdConfigError],
		    },
		    hashNotDeserialized: {
		        code: hashNotDeserialized,
		        desc: ClientAuthErrorMessages[hashNotDeserialized],
		    },
		    invalidStateError: {
		        code: invalidState,
		        desc: ClientAuthErrorMessages[invalidState],
		    },
		    stateMismatchError: {
		        code: stateMismatch,
		        desc: ClientAuthErrorMessages[stateMismatch],
		    },
		    stateNotFoundError: {
		        code: stateNotFound,
		        desc: ClientAuthErrorMessages[stateNotFound],
		    },
		    nonceMismatchError: {
		        code: nonceMismatch,
		        desc: ClientAuthErrorMessages[nonceMismatch],
		    },
		    authTimeNotFoundError: {
		        code: authTimeNotFound,
		        desc: ClientAuthErrorMessages[authTimeNotFound],
		    },
		    maxAgeTranspired: {
		        code: maxAgeTranspired,
		        desc: ClientAuthErrorMessages[maxAgeTranspired],
		    },
		    multipleMatchingTokens: {
		        code: multipleMatchingTokens,
		        desc: ClientAuthErrorMessages[multipleMatchingTokens],
		    },
		    multipleMatchingAccounts: {
		        code: multipleMatchingAccounts,
		        desc: ClientAuthErrorMessages[multipleMatchingAccounts],
		    },
		    multipleMatchingAppMetadata: {
		        code: multipleMatchingAppMetadata,
		        desc: ClientAuthErrorMessages[multipleMatchingAppMetadata],
		    },
		    tokenRequestCannotBeMade: {
		        code: requestCannotBeMade,
		        desc: ClientAuthErrorMessages[requestCannotBeMade],
		    },
		    removeEmptyScopeError: {
		        code: cannotRemoveEmptyScope,
		        desc: ClientAuthErrorMessages[cannotRemoveEmptyScope],
		    },
		    appendScopeSetError: {
		        code: cannotAppendScopeSet,
		        desc: ClientAuthErrorMessages[cannotAppendScopeSet],
		    },
		    emptyInputScopeSetError: {
		        code: emptyInputScopeSet,
		        desc: ClientAuthErrorMessages[emptyInputScopeSet],
		    },
		    DeviceCodePollingCancelled: {
		        code: deviceCodePollingCancelled,
		        desc: ClientAuthErrorMessages[deviceCodePollingCancelled],
		    },
		    DeviceCodeExpired: {
		        code: deviceCodeExpired,
		        desc: ClientAuthErrorMessages[deviceCodeExpired],
		    },
		    DeviceCodeUnknownError: {
		        code: deviceCodeUnknownError,
		        desc: ClientAuthErrorMessages[deviceCodeUnknownError],
		    },
		    NoAccountInSilentRequest: {
		        code: noAccountInSilentRequest,
		        desc: ClientAuthErrorMessages[noAccountInSilentRequest],
		    },
		    invalidCacheRecord: {
		        code: invalidCacheRecord,
		        desc: ClientAuthErrorMessages[invalidCacheRecord],
		    },
		    invalidCacheEnvironment: {
		        code: invalidCacheEnvironment,
		        desc: ClientAuthErrorMessages[invalidCacheEnvironment],
		    },
		    noAccountFound: {
		        code: noAccountFound,
		        desc: ClientAuthErrorMessages[noAccountFound],
		    },
		    noCryptoObj: {
		        code: noCryptoObject,
		        desc: ClientAuthErrorMessages[noCryptoObject],
		    },
		    unexpectedCredentialType: {
		        code: unexpectedCredentialType,
		        desc: ClientAuthErrorMessages[unexpectedCredentialType],
		    },
		    invalidAssertion: {
		        code: invalidAssertion,
		        desc: ClientAuthErrorMessages[invalidAssertion],
		    },
		    invalidClientCredential: {
		        code: invalidClientCredential,
		        desc: ClientAuthErrorMessages[invalidClientCredential],
		    },
		    tokenRefreshRequired: {
		        code: tokenRefreshRequired,
		        desc: ClientAuthErrorMessages[tokenRefreshRequired],
		    },
		    userTimeoutReached: {
		        code: userTimeoutReached,
		        desc: ClientAuthErrorMessages[userTimeoutReached],
		    },
		    tokenClaimsRequired: {
		        code: tokenClaimsCnfRequiredForSignedJwt,
		        desc: ClientAuthErrorMessages[tokenClaimsCnfRequiredForSignedJwt],
		    },
		    noAuthorizationCodeFromServer: {
		        code: authorizationCodeMissingFromServerResponse,
		        desc: ClientAuthErrorMessages[authorizationCodeMissingFromServerResponse],
		    },
		    bindingKeyNotRemovedError: {
		        code: bindingKeyNotRemoved,
		        desc: ClientAuthErrorMessages[bindingKeyNotRemoved],
		    },
		    logoutNotSupported: {
		        code: endSessionEndpointNotSupported,
		        desc: ClientAuthErrorMessages[endSessionEndpointNotSupported],
		    },
		    keyIdMissing: {
		        code: keyIdMissing,
		        desc: ClientAuthErrorMessages[keyIdMissing],
		    },
		    noNetworkConnectivity: {
		        code: noNetworkConnectivity,
		        desc: ClientAuthErrorMessages[noNetworkConnectivity],
		    },
		    userCanceledError: {
		        code: userCanceled,
		        desc: ClientAuthErrorMessages[userCanceled],
		    },
		    missingTenantIdError: {
		        code: missingTenantIdError,
		        desc: ClientAuthErrorMessages[missingTenantIdError],
		    },
		    nestedAppAuthBridgeDisabled: {
		        code: nestedAppAuthBridgeDisabled,
		        desc: ClientAuthErrorMessages[nestedAppAuthBridgeDisabled],
		    },
		    platformBrokerError: {
		        code: platformBrokerError,
		        desc: ClientAuthErrorMessages[platformBrokerError],
		    },
		};
		/**
		 * Error thrown when there is an error in the client code running on the browser.
		 */
		class ClientAuthError extends AuthError {
		    constructor(errorCode, additionalMessage) {
		        super(errorCode, additionalMessage
		            ? `${ClientAuthErrorMessages[errorCode]}: ${additionalMessage}`
		            : ClientAuthErrorMessages[errorCode]);
		        this.name = "ClientAuthError";
		        Object.setPrototypeOf(this, ClientAuthError.prototype);
		    }
		}
		function createClientAuthError(errorCode, additionalMessage) {
		    return new ClientAuthError(errorCode, additionalMessage);
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const DEFAULT_CRYPTO_IMPLEMENTATION = {
		    createNewGuid: () => {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    base64Decode: () => {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    base64Encode: () => {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    base64UrlEncode: () => {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    encodeKid: () => {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async getPublicKeyThumbprint() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async removeTokenBindingKey() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async clearKeystore() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async signJwt() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async hashString() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		};

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Log message level.
		 */
		exports$1.LogLevel = void 0;
		(function (LogLevel) {
		    LogLevel[LogLevel["Error"] = 0] = "Error";
		    LogLevel[LogLevel["Warning"] = 1] = "Warning";
		    LogLevel[LogLevel["Info"] = 2] = "Info";
		    LogLevel[LogLevel["Verbose"] = 3] = "Verbose";
		    LogLevel[LogLevel["Trace"] = 4] = "Trace";
		})(exports$1.LogLevel || (exports$1.LogLevel = {}));
		/**
		 * Class which facilitates logging of messages to a specific place.
		 */
		class Logger {
		    constructor(loggerOptions, packageName, packageVersion) {
		        // Current log level, defaults to info.
		        this.level = exports$1.LogLevel.Info;
		        const defaultLoggerCallback = () => {
		            return;
		        };
		        const setLoggerOptions = loggerOptions || Logger.createDefaultLoggerOptions();
		        this.localCallback =
		            setLoggerOptions.loggerCallback || defaultLoggerCallback;
		        this.piiLoggingEnabled = setLoggerOptions.piiLoggingEnabled || false;
		        this.level =
		            typeof setLoggerOptions.logLevel === "number"
		                ? setLoggerOptions.logLevel
		                : exports$1.LogLevel.Info;
		        this.correlationId =
		            setLoggerOptions.correlationId || Constants$1.EMPTY_STRING;
		        this.packageName = packageName || Constants$1.EMPTY_STRING;
		        this.packageVersion = packageVersion || Constants$1.EMPTY_STRING;
		    }
		    static createDefaultLoggerOptions() {
		        return {
		            loggerCallback: () => {
		                // allow users to not set loggerCallback
		            },
		            piiLoggingEnabled: false,
		            logLevel: exports$1.LogLevel.Info,
		        };
		    }
		    /**
		     * Create new Logger with existing configurations.
		     */
		    clone(packageName, packageVersion, correlationId) {
		        return new Logger({
		            loggerCallback: this.localCallback,
		            piiLoggingEnabled: this.piiLoggingEnabled,
		            logLevel: this.level,
		            correlationId: correlationId || this.correlationId,
		        }, packageName, packageVersion);
		    }
		    /**
		     * Log message with required options.
		     */
		    logMessage(logMessage, options) {
		        if (options.logLevel > this.level ||
		            (!this.piiLoggingEnabled && options.containsPii)) {
		            return;
		        }
		        const timestamp = new Date().toUTCString();
		        // Add correlationId to logs if set, correlationId provided on log messages take precedence
		        const logHeader = `[${timestamp}] : [${options.correlationId || this.correlationId || ""}]`;
		        const log = `${logHeader} : ${this.packageName}@${this.packageVersion} : ${exports$1.LogLevel[options.logLevel]} - ${logMessage}`;
		        // debug(`msal:${LogLevel[options.logLevel]}${options.containsPii ? "-Pii": Constants.EMPTY_STRING}${options.context ? `:${options.context}` : Constants.EMPTY_STRING}`)(logMessage);
		        this.executeCallback(options.logLevel, log, options.containsPii || false);
		    }
		    /**
		     * Execute callback with message.
		     */
		    executeCallback(level, message, containsPii) {
		        if (this.localCallback) {
		            this.localCallback(level, message, containsPii);
		        }
		    }
		    /**
		     * Logs error messages.
		     */
		    error(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Error,
		            containsPii: false,
		            correlationId: correlationId || Constants$1.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs error messages with PII.
		     */
		    errorPii(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Error,
		            containsPii: true,
		            correlationId: correlationId || Constants$1.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs warning messages.
		     */
		    warning(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Warning,
		            containsPii: false,
		            correlationId: correlationId || Constants$1.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs warning messages with PII.
		     */
		    warningPii(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Warning,
		            containsPii: true,
		            correlationId: correlationId || Constants$1.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs info messages.
		     */
		    info(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Info,
		            containsPii: false,
		            correlationId: correlationId || Constants$1.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs info messages with PII.
		     */
		    infoPii(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Info,
		            containsPii: true,
		            correlationId: correlationId || Constants$1.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs verbose messages.
		     */
		    verbose(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Verbose,
		            containsPii: false,
		            correlationId: correlationId || Constants$1.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs verbose messages with PII.
		     */
		    verbosePii(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Verbose,
		            containsPii: true,
		            correlationId: correlationId || Constants$1.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs trace messages.
		     */
		    trace(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Trace,
		            containsPii: false,
		            correlationId: correlationId || Constants$1.EMPTY_STRING,
		        });
		    }
		    /**
		     * Logs trace messages with PII.
		     */
		    tracePii(message, correlationId) {
		        this.logMessage(message, {
		            logLevel: exports$1.LogLevel.Trace,
		            containsPii: true,
		            correlationId: correlationId || Constants$1.EMPTY_STRING,
		        });
		    }
		    /**
		     * Returns whether PII Logging is enabled or not.
		     */
		    isPiiLoggingEnabled() {
		        return this.piiLoggingEnabled || false;
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/* eslint-disable header/header */
		const name$1 = "@azure/msal-common";
		const version$1 = "15.13.3";

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const AzureCloudInstance = {
		    // AzureCloudInstance is not specified.
		    None: "none",
		    // Microsoft Azure public cloud
		    AzurePublic: "https://login.microsoftonline.com",
		    // Microsoft PPE
		    AzurePpe: "https://login.windows-ppe.net",
		    // Microsoft Chinese national/regional cloud
		    AzureChina: "https://login.chinacloudapi.cn",
		    // Microsoft German national/regional cloud ("Black Forest")
		    AzureGermany: "https://login.microsoftonline.de",
		    // US Government cloud
		    AzureUsGovernment: "https://login.microsoftonline.us",
		};

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const redirectUriEmpty = "redirect_uri_empty";
		const claimsRequestParsingError = "claims_request_parsing_error";
		const authorityUriInsecure = "authority_uri_insecure";
		const urlParseError = "url_parse_error";
		const urlEmptyError = "empty_url_error";
		const emptyInputScopesError = "empty_input_scopes_error";
		const invalidClaims = "invalid_claims";
		const tokenRequestEmpty = "token_request_empty";
		const logoutRequestEmpty = "logout_request_empty";
		const invalidCodeChallengeMethod = "invalid_code_challenge_method";
		const pkceParamsMissing = "pkce_params_missing";
		const invalidCloudDiscoveryMetadata = "invalid_cloud_discovery_metadata";
		const invalidAuthorityMetadata = "invalid_authority_metadata";
		const untrustedAuthority = "untrusted_authority";
		const missingSshJwk = "missing_ssh_jwk";
		const missingSshKid = "missing_ssh_kid";
		const missingNonceAuthenticationHeader = "missing_nonce_authentication_header";
		const invalidAuthenticationHeader = "invalid_authentication_header";
		const cannotSetOIDCOptions = "cannot_set_OIDCOptions";
		const cannotAllowPlatformBroker = "cannot_allow_platform_broker";
		const authorityMismatch = "authority_mismatch";
		const invalidRequestMethodForEAR = "invalid_request_method_for_EAR";
		const invalidAuthorizePostBodyParameters = "invalid_authorize_post_body_parameters";
		const invalidPlatformBrokerConfiguration = "invalid_platform_broker_configuration";

		var ClientConfigurationErrorCodes = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    authorityMismatch: authorityMismatch,
		    authorityUriInsecure: authorityUriInsecure,
		    cannotAllowPlatformBroker: cannotAllowPlatformBroker,
		    cannotSetOIDCOptions: cannotSetOIDCOptions,
		    claimsRequestParsingError: claimsRequestParsingError,
		    emptyInputScopesError: emptyInputScopesError,
		    invalidAuthenticationHeader: invalidAuthenticationHeader,
		    invalidAuthorityMetadata: invalidAuthorityMetadata,
		    invalidAuthorizePostBodyParameters: invalidAuthorizePostBodyParameters,
		    invalidClaims: invalidClaims,
		    invalidCloudDiscoveryMetadata: invalidCloudDiscoveryMetadata,
		    invalidCodeChallengeMethod: invalidCodeChallengeMethod,
		    invalidPlatformBrokerConfiguration: invalidPlatformBrokerConfiguration,
		    invalidRequestMethodForEAR: invalidRequestMethodForEAR,
		    logoutRequestEmpty: logoutRequestEmpty,
		    missingNonceAuthenticationHeader: missingNonceAuthenticationHeader,
		    missingSshJwk: missingSshJwk,
		    missingSshKid: missingSshKid,
		    pkceParamsMissing: pkceParamsMissing,
		    redirectUriEmpty: redirectUriEmpty,
		    tokenRequestEmpty: tokenRequestEmpty,
		    untrustedAuthority: untrustedAuthority,
		    urlEmptyError: urlEmptyError,
		    urlParseError: urlParseError
		});

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const ClientConfigurationErrorMessages = {
		    [redirectUriEmpty]: "A redirect URI is required for all calls, and none has been set.",
		    [claimsRequestParsingError]: "Could not parse the given claims request object.",
		    [authorityUriInsecure]: "Authority URIs must use https.  Please see here for valid authority configuration options: https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-js-initializing-client-applications#configuration-options",
		    [urlParseError]: "URL could not be parsed into appropriate segments.",
		    [urlEmptyError]: "URL was empty or null.",
		    [emptyInputScopesError]: "Scopes cannot be passed as null, undefined or empty array because they are required to obtain an access token.",
		    [invalidClaims]: "Given claims parameter must be a stringified JSON object.",
		    [tokenRequestEmpty]: "Token request was empty and not found in cache.",
		    [logoutRequestEmpty]: "The logout request was null or undefined.",
		    [invalidCodeChallengeMethod]: 'code_challenge_method passed is invalid. Valid values are "plain" and "S256".',
		    [pkceParamsMissing]: "Both params: code_challenge and code_challenge_method are to be passed if to be sent in the request",
		    [invalidCloudDiscoveryMetadata]: "Invalid cloudDiscoveryMetadata provided. Must be a stringified JSON object containing tenant_discovery_endpoint and metadata fields",
		    [invalidAuthorityMetadata]: "Invalid authorityMetadata provided. Must by a stringified JSON object containing authorization_endpoint, token_endpoint, issuer fields.",
		    [untrustedAuthority]: "The provided authority is not a trusted authority. Please include this authority in the knownAuthorities config parameter.",
		    [missingSshJwk]: "Missing sshJwk in SSH certificate request. A stringified JSON Web Key is required when using the SSH authentication scheme.",
		    [missingSshKid]: "Missing sshKid in SSH certificate request. A string that uniquely identifies the public SSH key is required when using the SSH authentication scheme.",
		    [missingNonceAuthenticationHeader]: "Unable to find an authentication header containing server nonce. Either the Authentication-Info or WWW-Authenticate headers must be present in order to obtain a server nonce.",
		    [invalidAuthenticationHeader]: "Invalid authentication header provided",
		    [cannotSetOIDCOptions]: "Cannot set OIDCOptions parameter. Please change the protocol mode to OIDC or use a non-Microsoft authority.",
		    [cannotAllowPlatformBroker]: "Cannot set allowPlatformBroker parameter to true when not in AAD protocol mode.",
		    [authorityMismatch]: "Authority mismatch error. Authority provided in login request or PublicClientApplication config does not match the environment of the provided account. Please use a matching account or make an interactive request to login to this authority.",
		    [invalidAuthorizePostBodyParameters]: "Invalid authorize post body parameters provided. If you are using authorizePostBodyParameters, the request method must be POST. Please check the request method and parameters.",
		    [invalidRequestMethodForEAR]: "Invalid request method for EAR protocol mode. The request method cannot be GET when using EAR protocol mode. Please change the request method to POST.",
		    [invalidPlatformBrokerConfiguration]: "Invalid platform broker configuration. `allowPlatformBrokerWithDOM` can only be enabled when `allowPlatformBroker` is enabled.",
		};
		/**
		 * ClientConfigurationErrorMessage class containing string constants used by error codes and messages.
		 * @deprecated Use ClientConfigurationErrorCodes instead
		 */
		const ClientConfigurationErrorMessage = {
		    redirectUriNotSet: {
		        code: redirectUriEmpty,
		        desc: ClientConfigurationErrorMessages[redirectUriEmpty],
		    },
		    claimsRequestParsingError: {
		        code: claimsRequestParsingError,
		        desc: ClientConfigurationErrorMessages[claimsRequestParsingError],
		    },
		    authorityUriInsecure: {
		        code: authorityUriInsecure,
		        desc: ClientConfigurationErrorMessages[authorityUriInsecure],
		    },
		    urlParseError: {
		        code: urlParseError,
		        desc: ClientConfigurationErrorMessages[urlParseError],
		    },
		    urlEmptyError: {
		        code: urlEmptyError,
		        desc: ClientConfigurationErrorMessages[urlEmptyError],
		    },
		    emptyScopesError: {
		        code: emptyInputScopesError,
		        desc: ClientConfigurationErrorMessages[emptyInputScopesError],
		    },
		    invalidClaimsRequest: {
		        code: invalidClaims,
		        desc: ClientConfigurationErrorMessages[invalidClaims],
		    },
		    tokenRequestEmptyError: {
		        code: tokenRequestEmpty,
		        desc: ClientConfigurationErrorMessages[tokenRequestEmpty],
		    },
		    logoutRequestEmptyError: {
		        code: logoutRequestEmpty,
		        desc: ClientConfigurationErrorMessages[logoutRequestEmpty],
		    },
		    invalidCodeChallengeMethod: {
		        code: invalidCodeChallengeMethod,
		        desc: ClientConfigurationErrorMessages[invalidCodeChallengeMethod],
		    },
		    invalidCodeChallengeParams: {
		        code: pkceParamsMissing,
		        desc: ClientConfigurationErrorMessages[pkceParamsMissing],
		    },
		    invalidCloudDiscoveryMetadata: {
		        code: invalidCloudDiscoveryMetadata,
		        desc: ClientConfigurationErrorMessages[invalidCloudDiscoveryMetadata],
		    },
		    invalidAuthorityMetadata: {
		        code: invalidAuthorityMetadata,
		        desc: ClientConfigurationErrorMessages[invalidAuthorityMetadata],
		    },
		    untrustedAuthority: {
		        code: untrustedAuthority,
		        desc: ClientConfigurationErrorMessages[untrustedAuthority],
		    },
		    missingSshJwk: {
		        code: missingSshJwk,
		        desc: ClientConfigurationErrorMessages[missingSshJwk],
		    },
		    missingSshKid: {
		        code: missingSshKid,
		        desc: ClientConfigurationErrorMessages[missingSshKid],
		    },
		    missingNonceAuthenticationHeader: {
		        code: missingNonceAuthenticationHeader,
		        desc: ClientConfigurationErrorMessages[missingNonceAuthenticationHeader],
		    },
		    invalidAuthenticationHeader: {
		        code: invalidAuthenticationHeader,
		        desc: ClientConfigurationErrorMessages[invalidAuthenticationHeader],
		    },
		    cannotSetOIDCOptions: {
		        code: cannotSetOIDCOptions,
		        desc: ClientConfigurationErrorMessages[cannotSetOIDCOptions],
		    },
		    cannotAllowPlatformBroker: {
		        code: cannotAllowPlatformBroker,
		        desc: ClientConfigurationErrorMessages[cannotAllowPlatformBroker],
		    },
		    authorityMismatch: {
		        code: authorityMismatch,
		        desc: ClientConfigurationErrorMessages[authorityMismatch],
		    },
		    invalidAuthorizePostBodyParameters: {
		        code: invalidAuthorizePostBodyParameters,
		        desc: ClientConfigurationErrorMessages[invalidAuthorizePostBodyParameters],
		    },
		    invalidRequestMethodForEAR: {
		        code: invalidRequestMethodForEAR,
		        desc: ClientConfigurationErrorMessages[invalidRequestMethodForEAR],
		    },
		    invalidPlatformBrokerConfiguration: {
		        code: invalidPlatformBrokerConfiguration,
		        desc: ClientConfigurationErrorMessages[invalidPlatformBrokerConfiguration],
		    },
		};
		/**
		 * Error thrown when there is an error in configuration of the MSAL.js library.
		 */
		class ClientConfigurationError extends AuthError {
		    constructor(errorCode) {
		        super(errorCode, ClientConfigurationErrorMessages[errorCode]);
		        this.name = "ClientConfigurationError";
		        Object.setPrototypeOf(this, ClientConfigurationError.prototype);
		    }
		}
		function createClientConfigurationError(errorCode) {
		    return new ClientConfigurationError(errorCode);
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * @hidden
		 */
		class StringUtils {
		    /**
		     * Check if stringified object is empty
		     * @param strObj
		     */
		    static isEmptyObj(strObj) {
		        if (strObj) {
		            try {
		                const obj = JSON.parse(strObj);
		                return Object.keys(obj).length === 0;
		            }
		            catch (e) { }
		        }
		        return true;
		    }
		    static startsWith(str, search) {
		        return str.indexOf(search) === 0;
		    }
		    static endsWith(str, search) {
		        return (str.length >= search.length &&
		            str.lastIndexOf(search) === str.length - search.length);
		    }
		    /**
		     * Parses string into an object.
		     *
		     * @param query
		     */
		    static queryStringToObject(query) {
		        const obj = {};
		        const params = query.split("&");
		        const decode = (s) => decodeURIComponent(s.replace(/\+/g, " "));
		        params.forEach((pair) => {
		            if (pair.trim()) {
		                const [key, value] = pair.split(/=(.+)/g, 2); // Split on the first occurence of the '=' character
		                if (key && value) {
		                    obj[decode(key)] = decode(value);
		                }
		            }
		        });
		        return obj;
		    }
		    /**
		     * Trims entries in an array.
		     *
		     * @param arr
		     */
		    static trimArrayEntries(arr) {
		        return arr.map((entry) => entry.trim());
		    }
		    /**
		     * Removes empty strings from array
		     * @param arr
		     */
		    static removeEmptyStringsFromArray(arr) {
		        return arr.filter((entry) => {
		            return !!entry;
		        });
		    }
		    /**
		     * Attempts to parse a string into JSON
		     * @param str
		     */
		    static jsonParseHelper(str) {
		        try {
		            return JSON.parse(str);
		        }
		        catch (e) {
		            return null;
		        }
		    }
		    /**
		     * Tests if a given string matches a given pattern, with support for wildcards and queries.
		     * @param pattern Wildcard pattern to string match. Supports "*" for wildcards and "?" for queries
		     * @param input String to match against
		     */
		    static matchPattern(pattern, input) {
		        /**
		         * Wildcard support: https://stackoverflow.com/a/3117248/4888559
		         * Queries: replaces "?" in string with escaped "\?" for regex test
		         */
		        // eslint-disable-next-line security/detect-non-literal-regexp
		        const regex = new RegExp(pattern
		            .replace(/\\/g, "\\\\")
		            .replace(/\*/g, "[^ ]*")
		            .replace(/\?/g, "\\?"));
		        return regex.test(input);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * The ScopeSet class creates a set of scopes. Scopes are case-insensitive, unique values, so the Set object in JS makes
		 * the most sense to implement for this class. All scopes are trimmed and converted to lower case strings in intersection and union functions
		 * to ensure uniqueness of strings.
		 */
		class ScopeSet {
		    constructor(inputScopes) {
		        // Filter empty string and null/undefined array items
		        const scopeArr = inputScopes
		            ? StringUtils.trimArrayEntries([...inputScopes])
		            : [];
		        const filteredInput = scopeArr
		            ? StringUtils.removeEmptyStringsFromArray(scopeArr)
		            : [];
		        // Check if scopes array has at least one member
		        if (!filteredInput || !filteredInput.length) {
		            throw createClientConfigurationError(emptyInputScopesError);
		        }
		        this.scopes = new Set(); // Iterator in constructor not supported by IE11
		        filteredInput.forEach((scope) => this.scopes.add(scope));
		    }
		    /**
		     * Factory method to create ScopeSet from space-delimited string
		     * @param inputScopeString
		     * @param appClientId
		     * @param scopesRequired
		     */
		    static fromString(inputScopeString) {
		        const scopeString = inputScopeString || Constants$1.EMPTY_STRING;
		        const inputScopes = scopeString.split(" ");
		        return new ScopeSet(inputScopes);
		    }
		    /**
		     * Creates the set of scopes to search for in cache lookups
		     * @param inputScopeString
		     * @returns
		     */
		    static createSearchScopes(inputScopeString) {
		        // Handle empty scopes by using default OIDC scopes for cache lookup
		        const scopesToUse = inputScopeString && inputScopeString.length > 0
		            ? inputScopeString
		            : [...OIDC_DEFAULT_SCOPES];
		        const scopeSet = new ScopeSet(scopesToUse);
		        if (!scopeSet.containsOnlyOIDCScopes()) {
		            scopeSet.removeOIDCScopes();
		        }
		        else {
		            scopeSet.removeScope(Constants$1.OFFLINE_ACCESS_SCOPE);
		        }
		        return scopeSet;
		    }
		    /**
		     * Check if a given scope is present in this set of scopes.
		     * @param scope
		     */
		    containsScope(scope) {
		        const lowerCaseScopes = this.printScopesLowerCase().split(" ");
		        const lowerCaseScopesSet = new ScopeSet(lowerCaseScopes);
		        // compare lowercase scopes
		        return scope
		            ? lowerCaseScopesSet.scopes.has(scope.toLowerCase())
		            : false;
		    }
		    /**
		     * Check if a set of scopes is present in this set of scopes.
		     * @param scopeSet
		     */
		    containsScopeSet(scopeSet) {
		        if (!scopeSet || scopeSet.scopes.size <= 0) {
		            return false;
		        }
		        return (this.scopes.size >= scopeSet.scopes.size &&
		            scopeSet.asArray().every((scope) => this.containsScope(scope)));
		    }
		    /**
		     * Check if set of scopes contains only the defaults
		     */
		    containsOnlyOIDCScopes() {
		        let defaultScopeCount = 0;
		        OIDC_SCOPES.forEach((defaultScope) => {
		            if (this.containsScope(defaultScope)) {
		                defaultScopeCount += 1;
		            }
		        });
		        return this.scopes.size === defaultScopeCount;
		    }
		    /**
		     * Appends single scope if passed
		     * @param newScope
		     */
		    appendScope(newScope) {
		        if (newScope) {
		            this.scopes.add(newScope.trim());
		        }
		    }
		    /**
		     * Appends multiple scopes if passed
		     * @param newScopes
		     */
		    appendScopes(newScopes) {
		        try {
		            newScopes.forEach((newScope) => this.appendScope(newScope));
		        }
		        catch (e) {
		            throw createClientAuthError(cannotAppendScopeSet);
		        }
		    }
		    /**
		     * Removes element from set of scopes.
		     * @param scope
		     */
		    removeScope(scope) {
		        if (!scope) {
		            throw createClientAuthError(cannotRemoveEmptyScope);
		        }
		        this.scopes.delete(scope.trim());
		    }
		    /**
		     * Removes default scopes from set of scopes
		     * Primarily used to prevent cache misses if the default scopes are not returned from the server
		     */
		    removeOIDCScopes() {
		        OIDC_SCOPES.forEach((defaultScope) => {
		            this.scopes.delete(defaultScope);
		        });
		    }
		    /**
		     * Combines an array of scopes with the current set of scopes.
		     * @param otherScopes
		     */
		    unionScopeSets(otherScopes) {
		        if (!otherScopes) {
		            throw createClientAuthError(emptyInputScopeSet);
		        }
		        const unionScopes = new Set(); // Iterator in constructor not supported in IE11
		        otherScopes.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
		        this.scopes.forEach((scope) => unionScopes.add(scope.toLowerCase()));
		        return unionScopes;
		    }
		    /**
		     * Check if scopes intersect between this set and another.
		     * @param otherScopes
		     */
		    intersectingScopeSets(otherScopes) {
		        if (!otherScopes) {
		            throw createClientAuthError(emptyInputScopeSet);
		        }
		        // Do not allow OIDC scopes to be the only intersecting scopes
		        if (!otherScopes.containsOnlyOIDCScopes()) {
		            otherScopes.removeOIDCScopes();
		        }
		        const unionScopes = this.unionScopeSets(otherScopes);
		        const sizeOtherScopes = otherScopes.getScopeCount();
		        const sizeThisScopes = this.getScopeCount();
		        const sizeUnionScopes = unionScopes.size;
		        return sizeUnionScopes < sizeThisScopes + sizeOtherScopes;
		    }
		    /**
		     * Returns size of set of scopes.
		     */
		    getScopeCount() {
		        return this.scopes.size;
		    }
		    /**
		     * Returns the scopes as an array of string values
		     */
		    asArray() {
		        const array = [];
		        this.scopes.forEach((val) => array.push(val));
		        return array;
		    }
		    /**
		     * Prints scopes into a space-delimited string
		     */
		    printScopes() {
		        if (this.scopes) {
		            const scopeArr = this.asArray();
		            return scopeArr.join(" ");
		        }
		        return Constants$1.EMPTY_STRING;
		    }
		    /**
		     * Prints scopes into a space-delimited lower-case string (used for caching)
		     */
		    printScopesLowerCase() {
		        return this.printScopes().toLowerCase();
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Function to build a client info object from server clientInfo string
		 * @param rawClientInfo
		 * @param crypto
		 */
		function buildClientInfo(rawClientInfo, base64Decode) {
		    if (!rawClientInfo) {
		        throw createClientAuthError(clientInfoEmptyError);
		    }
		    try {
		        const decodedClientInfo = base64Decode(rawClientInfo);
		        return JSON.parse(decodedClientInfo);
		    }
		    catch (e) {
		        throw createClientAuthError(clientInfoDecodingError);
		    }
		}
		/**
		 * Function to build a client info object from cached homeAccountId string
		 * @param homeAccountId
		 */
		function buildClientInfoFromHomeAccountId(homeAccountId) {
		    if (!homeAccountId) {
		        throw createClientAuthError(clientInfoDecodingError);
		    }
		    const clientInfoParts = homeAccountId.split(Separators.CLIENT_INFO_SEPARATOR, 2);
		    return {
		        uid: clientInfoParts[0],
		        utid: clientInfoParts.length < 2
		            ? Constants$1.EMPTY_STRING
		            : clientInfoParts[1],
		    };
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Returns true if tenantId matches the utid portion of homeAccountId
		 * @param tenantId
		 * @param homeAccountId
		 * @returns
		 */
		function tenantIdMatchesHomeTenant(tenantId, homeAccountId) {
		    return (!!tenantId &&
		        !!homeAccountId &&
		        tenantId === homeAccountId.split(".")[1]);
		}
		/**
		 * Build tenant profile
		 * @param homeAccountId - Home account identifier for this account object
		 * @param localAccountId - Local account identifer for this account object
		 * @param tenantId - Full tenant or organizational id that this account belongs to
		 * @param idTokenClaims - Claims from the ID token
		 * @returns
		 */
		function buildTenantProfile(homeAccountId, localAccountId, tenantId, idTokenClaims) {
		    if (idTokenClaims) {
		        const { oid, sub, tid, name, tfp, acr, preferred_username, upn, login_hint, } = idTokenClaims;
		        /**
		         * Since there is no way to determine if the authority is AAD or B2C, we exhaust all the possible claims that can serve as tenant ID with the following precedence:
		         * tid - TenantID claim that identifies the tenant that issued the token in AAD. Expected in all AAD ID tokens, not present in B2C ID Tokens.
		         * tfp - Trust Framework Policy claim that identifies the policy that was used to authenticate the user. Functions as tenant for B2C scenarios.
		         * acr - Authentication Context Class Reference claim used only with older B2C policies. Fallback in case tfp is not present, but likely won't be present anyway.
		         */
		        const tenantId = tid || tfp || acr || "";
		        return {
		            tenantId: tenantId,
		            localAccountId: oid || sub || "",
		            name: name,
		            username: preferred_username || upn || "",
		            loginHint: login_hint,
		            isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId),
		        };
		    }
		    else {
		        return {
		            tenantId,
		            localAccountId,
		            username: "",
		            isHomeTenant: tenantIdMatchesHomeTenant(tenantId, homeAccountId),
		        };
		    }
		}
		/**
		 * Replaces account info that varies by tenant profile sourced from the ID token claims passed in with the tenant-specific account info
		 * @param baseAccountInfo
		 * @param idTokenClaims
		 * @returns
		 */
		function updateAccountTenantProfileData(baseAccountInfo, tenantProfile, idTokenClaims, idTokenSecret) {
		    let updatedAccountInfo = baseAccountInfo;
		    // Tenant Profile overrides passed in account info
		    if (tenantProfile) {
		        // eslint-disable-next-line @typescript-eslint/no-unused-vars
		        const { isHomeTenant, ...tenantProfileOverride } = tenantProfile;
		        updatedAccountInfo = { ...baseAccountInfo, ...tenantProfileOverride };
		    }
		    // ID token claims override passed in account info and tenant profile
		    if (idTokenClaims) {
		        // Ignore isHomeTenant, loginHint, and sid which are part of tenant profile but not base account info
		        // eslint-disable-next-line @typescript-eslint/no-unused-vars
		        const { isHomeTenant, ...claimsSourcedTenantProfile } = buildTenantProfile(baseAccountInfo.homeAccountId, baseAccountInfo.localAccountId, baseAccountInfo.tenantId, idTokenClaims);
		        updatedAccountInfo = {
		            ...updatedAccountInfo,
		            ...claimsSourcedTenantProfile,
		            idTokenClaims: idTokenClaims,
		            idToken: idTokenSecret,
		        };
		        return updatedAccountInfo;
		    }
		    return updatedAccountInfo;
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Authority types supported by MSAL.
		 */
		const AuthorityType = {
		    Default: 0,
		    Adfs: 1,
		    Dsts: 2,
		    Ciam: 3,
		};

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Gets tenantId from available ID token claims to set as credential realm with the following precedence:
		 * 1. tid - if the token is acquired from an Azure AD tenant tid will be present
		 * 2. tfp - if the token is acquired from a modern B2C tenant tfp should be present
		 * 3. acr - if the token is acquired from a legacy B2C tenant acr should be present
		 * Downcased to match the realm case-insensitive comparison requirements
		 * @param idTokenClaims
		 * @returns
		 */
		function getTenantIdFromIdTokenClaims(idTokenClaims) {
		    if (idTokenClaims) {
		        const tenantId = idTokenClaims.tid || idTokenClaims.tfp || idTokenClaims.acr;
		        return tenantId || null;
		    }
		    return null;
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Protocol modes supported by MSAL.
		 */
		const ProtocolMode = {
		    /**
		     * Auth Code + PKCE with Entra ID (formerly AAD) specific optimizations and features
		     */
		    AAD: "AAD",
		    /**
		     * Auth Code + PKCE without Entra ID specific optimizations and features. For use only with non-Microsoft owned authorities.
		     * Support is limited for this mode.
		     */
		    OIDC: "OIDC",
		    /**
		     * Encrypted Authorize Response (EAR) with Entra ID specific optimizations and features
		     */
		    EAR: "EAR",
		};

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).
		 *
		 * Key : Value Schema
		 *
		 * Key: <home_account_id>-<environment>-<realm*>
		 *
		 * Value Schema:
		 * {
		 *      homeAccountId: home account identifier for the auth scheme,
		 *      environment: entity that issued the token, represented as a full host
		 *      realm: Full tenant or organizational identifier that the account belongs to
		 *      localAccountId: Original tenant-specific accountID, usually used for legacy cases
		 *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt
		 *      authorityType: Accounts authority type as a string
		 *      name: Full name for the account, including given name and family name,
		 *      lastModificationTime: last time this entity was modified in the cache
		 *      lastModificationApp:
		 *      nativeAccountId: Account identifier on the native device
		 *      tenantProfiles: Array of tenant profile objects for each tenant that the account has authenticated with in the browser
		 * }
		 * @internal
		 */
		class AccountEntity {
		    /**
		     * Returns the AccountInfo interface for this account.
		     */
		    static getAccountInfo(accountEntity) {
		        return {
		            homeAccountId: accountEntity.homeAccountId,
		            environment: accountEntity.environment,
		            tenantId: accountEntity.realm,
		            username: accountEntity.username,
		            localAccountId: accountEntity.localAccountId,
		            loginHint: accountEntity.loginHint,
		            name: accountEntity.name,
		            nativeAccountId: accountEntity.nativeAccountId,
		            authorityType: accountEntity.authorityType,
		            // Deserialize tenant profiles array into a Map
		            tenantProfiles: new Map((accountEntity.tenantProfiles || []).map((tenantProfile) => {
		                return [tenantProfile.tenantId, tenantProfile];
		            })),
		            dataBoundary: accountEntity.dataBoundary,
		        };
		    }
		    /**
		     * Returns true if the account entity is in single tenant format (outdated), false otherwise
		     */
		    isSingleTenant() {
		        return !this.tenantProfiles;
		    }
		    /**
		     * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.
		     * @param accountDetails
		     */
		    static createAccount(accountDetails, authority, base64Decode) {
		        const account = new AccountEntity();
		        if (authority.authorityType === AuthorityType.Adfs) {
		            account.authorityType = CacheAccountType.ADFS_ACCOUNT_TYPE;
		        }
		        else if (authority.protocolMode === ProtocolMode.OIDC) {
		            account.authorityType = CacheAccountType.GENERIC_ACCOUNT_TYPE;
		        }
		        else {
		            account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;
		        }
		        let clientInfo;
		        if (accountDetails.clientInfo && base64Decode) {
		            clientInfo = buildClientInfo(accountDetails.clientInfo, base64Decode);
		            if (clientInfo.xms_tdbr) {
		                account.dataBoundary =
		                    clientInfo.xms_tdbr === "EU" ? "EU" : "None";
		            }
		        }
		        account.clientInfo = accountDetails.clientInfo;
		        account.homeAccountId = accountDetails.homeAccountId;
		        account.nativeAccountId = accountDetails.nativeAccountId;
		        const env = accountDetails.environment ||
		            (authority && authority.getPreferredCache());
		        if (!env) {
		            throw createClientAuthError(invalidCacheEnvironment);
		        }
		        account.environment = env;
		        // non AAD scenarios can have empty realm
		        account.realm =
		            clientInfo?.utid ||
		                getTenantIdFromIdTokenClaims(accountDetails.idTokenClaims) ||
		                "";
		        // How do you account for MSA CID here?
		        account.localAccountId =
		            clientInfo?.uid ||
		                accountDetails.idTokenClaims?.oid ||
		                accountDetails.idTokenClaims?.sub ||
		                "";
		        /*
		         * In B2C scenarios the emails claim is used instead of preferred_username and it is an array.
		         * In most cases it will contain a single email. This field should not be relied upon if a custom
		         * policy is configured to return more than 1 email.
		         */
		        const preferredUsername = accountDetails.idTokenClaims?.preferred_username ||
		            accountDetails.idTokenClaims?.upn;
		        const email = accountDetails.idTokenClaims?.emails
		            ? accountDetails.idTokenClaims.emails[0]
		            : null;
		        account.username = preferredUsername || email || "";
		        account.loginHint = accountDetails.idTokenClaims?.login_hint;
		        account.name = accountDetails.idTokenClaims?.name || "";
		        account.cloudGraphHostName = accountDetails.cloudGraphHostName;
		        account.msGraphHost = accountDetails.msGraphHost;
		        if (accountDetails.tenantProfiles) {
		            account.tenantProfiles = accountDetails.tenantProfiles;
		        }
		        else {
		            const tenantProfile = buildTenantProfile(accountDetails.homeAccountId, account.localAccountId, account.realm, accountDetails.idTokenClaims);
		            account.tenantProfiles = [tenantProfile];
		        }
		        return account;
		    }
		    /**
		     * Creates an AccountEntity object from AccountInfo
		     * @param accountInfo
		     * @param cloudGraphHostName
		     * @param msGraphHost
		     * @returns
		     */
		    static createFromAccountInfo(accountInfo, cloudGraphHostName, msGraphHost) {
		        const account = new AccountEntity();
		        account.authorityType =
		            accountInfo.authorityType || CacheAccountType.GENERIC_ACCOUNT_TYPE;
		        account.homeAccountId = accountInfo.homeAccountId;
		        account.localAccountId = accountInfo.localAccountId;
		        account.nativeAccountId = accountInfo.nativeAccountId;
		        account.realm = accountInfo.tenantId;
		        account.environment = accountInfo.environment;
		        account.username = accountInfo.username;
		        account.name = accountInfo.name;
		        account.loginHint = accountInfo.loginHint;
		        account.cloudGraphHostName = cloudGraphHostName;
		        account.msGraphHost = msGraphHost;
		        // Serialize tenant profiles map into an array
		        account.tenantProfiles = Array.from(accountInfo.tenantProfiles?.values() || []);
		        account.dataBoundary = accountInfo.dataBoundary;
		        return account;
		    }
		    /**
		     * Generate HomeAccountId from server response
		     * @param serverClientInfo
		     * @param authType
		     */
		    static generateHomeAccountId(serverClientInfo, authType, logger, cryptoObj, idTokenClaims) {
		        // since ADFS/DSTS do not have tid and does not set client_info
		        if (!(authType === AuthorityType.Adfs ||
		            authType === AuthorityType.Dsts)) {
		            // for cases where there is clientInfo
		            if (serverClientInfo) {
		                try {
		                    const clientInfo = buildClientInfo(serverClientInfo, cryptoObj.base64Decode);
		                    if (clientInfo.uid && clientInfo.utid) {
		                        return `${clientInfo.uid}.${clientInfo.utid}`;
		                    }
		                }
		                catch (e) { }
		            }
		            logger.warning("No client info in response");
		        }
		        // default to "sub" claim
		        return idTokenClaims?.sub || "";
		    }
		    /**
		     * Validates an entity: checks for all expected params
		     * @param entity
		     */
		    static isAccountEntity(entity) {
		        if (!entity) {
		            return false;
		        }
		        return (entity.hasOwnProperty("homeAccountId") &&
		            entity.hasOwnProperty("environment") &&
		            entity.hasOwnProperty("realm") &&
		            entity.hasOwnProperty("localAccountId") &&
		            entity.hasOwnProperty("username") &&
		            entity.hasOwnProperty("authorityType"));
		    }
		    /**
		     * Helper function to determine whether 2 accountInfo objects represent the same account
		     * @param accountA
		     * @param accountB
		     * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality
		     */
		    static accountInfoIsEqual(accountA, accountB, compareClaims) {
		        if (!accountA || !accountB) {
		            return false;
		        }
		        let claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false
		        if (compareClaims) {
		            const accountAClaims = (accountA.idTokenClaims ||
		                {});
		            const accountBClaims = (accountB.idTokenClaims ||
		                {});
		            // issued at timestamp and nonce are expected to change each time a new id token is acquired
		            claimsMatch =
		                accountAClaims.iat === accountBClaims.iat &&
		                    accountAClaims.nonce === accountBClaims.nonce;
		        }
		        return (accountA.homeAccountId === accountB.homeAccountId &&
		            accountA.localAccountId === accountB.localAccountId &&
		            accountA.username === accountB.username &&
		            accountA.tenantId === accountB.tenantId &&
		            accountA.loginHint === accountB.loginHint &&
		            accountA.environment === accountB.environment &&
		            accountA.nativeAccountId === accountB.nativeAccountId &&
		            claimsMatch);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Extract token by decoding the rawToken
		 *
		 * @param encodedToken
		 */
		function extractTokenClaims(encodedToken, base64Decode) {
		    const jswPayload = getJWSPayload(encodedToken);
		    // token will be decoded to get the username
		    try {
		        // base64Decode() should throw an error if there is an issue
		        const base64Decoded = base64Decode(jswPayload);
		        return JSON.parse(base64Decoded);
		    }
		    catch (err) {
		        throw createClientAuthError(tokenParsingError);
		    }
		}
		/**
		 * Check if the signin_state claim contains "kmsi"
		 * @param idTokenClaims
		 * @returns
		 */
		function isKmsi(idTokenClaims) {
		    if (!idTokenClaims.signin_state) {
		        return false;
		    }
		    /**
		     * Signin_state claim known values:
		     * dvc_mngd - device is managed
		     * dvc_dmjd - device is domain joined
		     * kmsi - user opted to "keep me signed in"
		     * inknownntwk - Request made inside a known network. Don't use this, use CAE instead.
		     */
		    const kmsiClaims = ["kmsi", "dvc_dmjd"]; // There are some cases where kmsi may not be returned but persistent storage is still OK - allow dvc_dmjd as well
		    const kmsi = idTokenClaims.signin_state.some((value) => kmsiClaims.includes(value.trim().toLowerCase()));
		    return kmsi;
		}
		/**
		 * decode a JWT
		 *
		 * @param authToken
		 */
		function getJWSPayload(authToken) {
		    if (!authToken) {
		        throw createClientAuthError(nullOrEmptyToken);
		    }
		    const tokenPartsRegex = /^([^\.\s]*)\.([^\.\s]+)\.([^\.\s]*)$/;
		    const matches = tokenPartsRegex.exec(authToken);
		    if (!matches || matches.length < 4) {
		        throw createClientAuthError(tokenParsingError);
		    }
		    /**
		     * const crackedToken = {
		     *  header: matches[1],
		     *  JWSPayload: matches[2],
		     *  JWSSig: matches[3],
		     * };
		     */
		    return matches[2];
		}
		/**
		 * Determine if the token's max_age has transpired
		 */
		function checkMaxAge(authTime, maxAge) {
		    /*
		     * per https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
		     * To force an immediate re-authentication: If an app requires that a user re-authenticate prior to access,
		     * provide a value of 0 for the max_age parameter and the AS will force a fresh login.
		     */
		    const fiveMinuteSkew = 300000; // five minutes in milliseconds
		    if (maxAge === 0 || Date.now() - fiveMinuteSkew > authTime + maxAge) {
		        throw createClientAuthError(maxAgeTranspired);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/**
		 * Parses hash string from given string. Returns empty string if no hash symbol is found.
		 * @param hashString
		 */
		function stripLeadingHashOrQuery(responseString) {
		    if (responseString.startsWith("#/")) {
		        return responseString.substring(2);
		    }
		    else if (responseString.startsWith("#") ||
		        responseString.startsWith("?")) {
		        return responseString.substring(1);
		    }
		    return responseString;
		}
		/**
		 * Returns URL hash as server auth code response object.
		 */
		function getDeserializedResponse(responseString) {
		    // Check if given hash is empty
		    if (!responseString || responseString.indexOf("=") < 0) {
		        return null;
		    }
		    try {
		        // Strip the # or ? symbol if present
		        const normalizedResponse = stripLeadingHashOrQuery(responseString);
		        // If # symbol was not present, above will return empty string, so give original hash value
		        const deserializedHash = Object.fromEntries(new URLSearchParams(normalizedResponse));
		        // Check for known response properties
		        if (deserializedHash.code ||
		            deserializedHash.ear_jwe ||
		            deserializedHash.error ||
		            deserializedHash.error_description ||
		            deserializedHash.state) {
		            return deserializedHash;
		        }
		    }
		    catch (e) {
		        throw createClientAuthError(hashNotDeserialized);
		    }
		    return null;
		}
		/**
		 * Utility to create a URL from the params map
		 */
		function mapToQueryString(parameters, encodeExtraParams = true, extraQueryParameters) {
		    const queryParameterArray = new Array();
		    parameters.forEach((value, key) => {
		        if (!encodeExtraParams &&
		            extraQueryParameters &&
		            key in extraQueryParameters) {
		            queryParameterArray.push(`${key}=${value}`);
		        }
		        else {
		            queryParameterArray.push(`${key}=${encodeURIComponent(value)}`);
		        }
		    });
		    return queryParameterArray.join("&");
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Url object class which can perform various transformations on url strings.
		 */
		class UrlString {
		    get urlString() {
		        return this._urlString;
		    }
		    constructor(url) {
		        this._urlString = url;
		        if (!this._urlString) {
		            // Throws error if url is empty
		            throw createClientConfigurationError(urlEmptyError);
		        }
		        if (!url.includes("#")) {
		            this._urlString = UrlString.canonicalizeUri(url);
		        }
		    }
		    /**
		     * Ensure urls are lower case and end with a / character.
		     * @param url
		     */
		    static canonicalizeUri(url) {
		        if (url) {
		            let lowerCaseUrl = url.toLowerCase();
		            if (StringUtils.endsWith(lowerCaseUrl, "?")) {
		                lowerCaseUrl = lowerCaseUrl.slice(0, -1);
		            }
		            else if (StringUtils.endsWith(lowerCaseUrl, "?/")) {
		                lowerCaseUrl = lowerCaseUrl.slice(0, -2);
		            }
		            if (!StringUtils.endsWith(lowerCaseUrl, "/")) {
		                lowerCaseUrl += "/";
		            }
		            return lowerCaseUrl;
		        }
		        return url;
		    }
		    /**
		     * Throws if urlString passed is not a valid authority URI string.
		     */
		    validateAsUri() {
		        // Attempts to parse url for uri components
		        let components;
		        try {
		            components = this.getUrlComponents();
		        }
		        catch (e) {
		            throw createClientConfigurationError(urlParseError);
		        }
		        // Throw error if URI or path segments are not parseable.
		        if (!components.HostNameAndPort || !components.PathSegments) {
		            throw createClientConfigurationError(urlParseError);
		        }
		        // Throw error if uri is insecure.
		        if (!components.Protocol ||
		            components.Protocol.toLowerCase() !== "https:") {
		            throw createClientConfigurationError(authorityUriInsecure);
		        }
		    }
		    /**
		     * Given a url and a query string return the url with provided query string appended
		     * @param url
		     * @param queryString
		     */
		    static appendQueryString(url, queryString) {
		        if (!queryString) {
		            return url;
		        }
		        return url.indexOf("?") < 0
		            ? `${url}?${queryString}`
		            : `${url}&${queryString}`;
		    }
		    /**
		     * Returns a url with the hash removed
		     * @param url
		     */
		    static removeHashFromUrl(url) {
		        return UrlString.canonicalizeUri(url.split("#")[0]);
		    }
		    /**
		     * Given a url like https://a:b/common/d?e=f#g, and a tenantId, returns https://a:b/tenantId/d
		     * @param href The url
		     * @param tenantId The tenant id to replace
		     */
		    replaceTenantPath(tenantId) {
		        const urlObject = this.getUrlComponents();
		        const pathArray = urlObject.PathSegments;
		        if (tenantId &&
		            pathArray.length !== 0 &&
		            (pathArray[0] === AADAuthorityConstants.COMMON ||
		                pathArray[0] === AADAuthorityConstants.ORGANIZATIONS)) {
		            pathArray[0] = tenantId;
		        }
		        return UrlString.constructAuthorityUriFromObject(urlObject);
		    }
		    /**
		     * Parses out the components from a url string.
		     * @returns An object with the various components. Please cache this value insted of calling this multiple times on the same url.
		     */
		    getUrlComponents() {
		        // https://gist.github.com/curtisz/11139b2cfcaef4a261e0
		        const regEx = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
		        // If url string does not match regEx, we throw an error
		        const match = this.urlString.match(regEx);
		        if (!match) {
		            throw createClientConfigurationError(urlParseError);
		        }
		        // Url component object
		        const urlComponents = {
		            Protocol: match[1],
		            HostNameAndPort: match[4],
		            AbsolutePath: match[5],
		            QueryString: match[7],
		        };
		        let pathSegments = urlComponents.AbsolutePath.split("/");
		        pathSegments = pathSegments.filter((val) => val && val.length > 0); // remove empty elements
		        urlComponents.PathSegments = pathSegments;
		        if (urlComponents.QueryString &&
		            urlComponents.QueryString.endsWith("/")) {
		            urlComponents.QueryString = urlComponents.QueryString.substring(0, urlComponents.QueryString.length - 1);
		        }
		        return urlComponents;
		    }
		    static getDomainFromUrl(url) {
		        const regEx = RegExp("^([^:/?#]+://)?([^/?#]*)");
		        const match = url.match(regEx);
		        if (!match) {
		            throw createClientConfigurationError(urlParseError);
		        }
		        return match[2];
		    }
		    static getAbsoluteUrl(relativeUrl, baseUrl) {
		        if (relativeUrl[0] === Constants$1.FORWARD_SLASH) {
		            const url = new UrlString(baseUrl);
		            const baseComponents = url.getUrlComponents();
		            return (baseComponents.Protocol +
		                "//" +
		                baseComponents.HostNameAndPort +
		                relativeUrl);
		        }
		        return relativeUrl;
		    }
		    static constructAuthorityUriFromObject(urlObject) {
		        return new UrlString(urlObject.Protocol +
		            "//" +
		            urlObject.HostNameAndPort +
		            "/" +
		            urlObject.PathSegments.join("/"));
		    }
		    /**
		     * Check if the hash of the URL string contains known properties
		     * @deprecated This API will be removed in a future version
		     */
		    static hashContainsKnownProperties(response) {
		        return !!getDeserializedResponse(response);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const rawMetdataJSON = {
		    endpointMetadata: {
		        "login.microsoftonline.com": {
		            token_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/token",
		            jwks_uri: "https://login.microsoftonline.com/{tenantid}/discovery/v2.0/keys",
		            issuer: "https://login.microsoftonline.com/{tenantid}/v2.0",
		            authorization_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/authorize",
		            end_session_endpoint: "https://login.microsoftonline.com/{tenantid}/oauth2/v2.0/logout",
		        },
		        "login.chinacloudapi.cn": {
		            token_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/token",
		            jwks_uri: "https://login.chinacloudapi.cn/{tenantid}/discovery/v2.0/keys",
		            issuer: "https://login.partner.microsoftonline.cn/{tenantid}/v2.0",
		            authorization_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/authorize",
		            end_session_endpoint: "https://login.chinacloudapi.cn/{tenantid}/oauth2/v2.0/logout",
		        },
		        "login.microsoftonline.us": {
		            token_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/token",
		            jwks_uri: "https://login.microsoftonline.us/{tenantid}/discovery/v2.0/keys",
		            issuer: "https://login.microsoftonline.us/{tenantid}/v2.0",
		            authorization_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/authorize",
		            end_session_endpoint: "https://login.microsoftonline.us/{tenantid}/oauth2/v2.0/logout",
		        },
		    },
		    instanceDiscoveryMetadata: {
		        metadata: [
		            {
		                preferred_network: "login.microsoftonline.com",
		                preferred_cache: "login.windows.net",
		                aliases: [
		                    "login.microsoftonline.com",
		                    "login.windows.net",
		                    "login.microsoft.com",
		                    "sts.windows.net",
		                ],
		            },
		            {
		                preferred_network: "login.partner.microsoftonline.cn",
		                preferred_cache: "login.partner.microsoftonline.cn",
		                aliases: [
		                    "login.partner.microsoftonline.cn",
		                    "login.chinacloudapi.cn",
		                ],
		            },
		            {
		                preferred_network: "login.microsoftonline.de",
		                preferred_cache: "login.microsoftonline.de",
		                aliases: ["login.microsoftonline.de"],
		            },
		            {
		                preferred_network: "login.microsoftonline.us",
		                preferred_cache: "login.microsoftonline.us",
		                aliases: [
		                    "login.microsoftonline.us",
		                    "login.usgovcloudapi.net",
		                ],
		            },
		            {
		                preferred_network: "login-us.microsoftonline.com",
		                preferred_cache: "login-us.microsoftonline.com",
		                aliases: ["login-us.microsoftonline.com"],
		            },
		        ],
		    },
		};
		const EndpointMetadata = rawMetdataJSON.endpointMetadata;
		const InstanceDiscoveryMetadata = rawMetdataJSON.instanceDiscoveryMetadata;
		const InstanceDiscoveryMetadataAliases = new Set();
		InstanceDiscoveryMetadata.metadata.forEach((metadataEntry) => {
		    metadataEntry.aliases.forEach((alias) => {
		        InstanceDiscoveryMetadataAliases.add(alias);
		    });
		});
		/**
		 * Attempts to get an aliases array from the static authority metadata sources based on the canonical authority host
		 * @param staticAuthorityOptions
		 * @param logger
		 * @returns
		 */
		function getAliasesFromStaticSources(staticAuthorityOptions, logger) {
		    let staticAliases;
		    const canonicalAuthority = staticAuthorityOptions.canonicalAuthority;
		    if (canonicalAuthority) {
		        const authorityHost = new UrlString(canonicalAuthority).getUrlComponents().HostNameAndPort;
		        staticAliases =
		            getAliasesFromMetadata(authorityHost, staticAuthorityOptions.cloudDiscoveryMetadata?.metadata, AuthorityMetadataSource.CONFIG, logger) ||
		                getAliasesFromMetadata(authorityHost, InstanceDiscoveryMetadata.metadata, AuthorityMetadataSource.HARDCODED_VALUES, logger) ||
		                staticAuthorityOptions.knownAuthorities;
		    }
		    return staticAliases || [];
		}
		/**
		 * Returns aliases for from the raw cloud discovery metadata passed in
		 * @param authorityHost
		 * @param rawCloudDiscoveryMetadata
		 * @returns
		 */
		function getAliasesFromMetadata(authorityHost, cloudDiscoveryMetadata, source, logger) {
		    logger?.trace(`getAliasesFromMetadata called with source: ${source}`);
		    if (authorityHost && cloudDiscoveryMetadata) {
		        const metadata = getCloudDiscoveryMetadataFromNetworkResponse(cloudDiscoveryMetadata, authorityHost);
		        if (metadata) {
		            logger?.trace(`getAliasesFromMetadata: found cloud discovery metadata in ${source}, returning aliases`);
		            return metadata.aliases;
		        }
		        else {
		            logger?.trace(`getAliasesFromMetadata: did not find cloud discovery metadata in ${source}`);
		        }
		    }
		    return null;
		}
		/**
		 * Get cloud discovery metadata for common authorities
		 */
		function getCloudDiscoveryMetadataFromHardcodedValues(authorityHost) {
		    const metadata = getCloudDiscoveryMetadataFromNetworkResponse(InstanceDiscoveryMetadata.metadata, authorityHost);
		    return metadata;
		}
		/**
		 * Searches instance discovery network response for the entry that contains the host in the aliases list
		 * @param response
		 * @param authority
		 */
		function getCloudDiscoveryMetadataFromNetworkResponse(response, authorityHost) {
		    for (let i = 0; i < response.length; i++) {
		        const metadata = response[i];
		        if (metadata.aliases.includes(authorityHost)) {
		            return metadata;
		        }
		    }
		    return null;
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const cacheQuotaExceeded = "cache_quota_exceeded";
		const cacheErrorUnknown = "cache_error_unknown";

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const CacheErrorMessages = {
		    [cacheQuotaExceeded]: "Exceeded cache storage capacity.",
		    [cacheErrorUnknown]: "Unexpected error occurred when using cache storage.",
		};
		/**
		 * Error thrown when there is an error with the cache
		 */
		class CacheError extends AuthError {
		    constructor(errorCode, errorMessage) {
		        const message = errorMessage ||
		            (CacheErrorMessages[errorCode]
		                ? CacheErrorMessages[errorCode]
		                : CacheErrorMessages[cacheErrorUnknown]);
		        super(`${errorCode}: ${message}`);
		        Object.setPrototypeOf(this, CacheError.prototype);
		        this.name = "CacheError";
		        this.errorCode = errorCode;
		        this.errorMessage = message;
		    }
		}
		/**
		 * Helper function to wrap browser errors in a CacheError object
		 * @param e
		 * @returns
		 */
		function createCacheError(e) {
		    if (!(e instanceof Error)) {
		        return new CacheError(cacheErrorUnknown);
		    }
		    if (e.name === "QuotaExceededError" ||
		        e.name === "NS_ERROR_DOM_QUOTA_REACHED" ||
		        e.message.includes("exceeded the quota")) {
		        return new CacheError(cacheQuotaExceeded);
		    }
		    else {
		        return new CacheError(e.name, e.message);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.
		 * @internal
		 */
		class CacheManager {
		    constructor(clientId, cryptoImpl, logger, performanceClient, staticAuthorityOptions) {
		        this.clientId = clientId;
		        this.cryptoImpl = cryptoImpl;
		        this.commonLogger = logger.clone(name$1, version$1);
		        this.staticAuthorityOptions = staticAuthorityOptions;
		        this.performanceClient = performanceClient;
		    }
		    /**
		     * Returns all the accounts in the cache that match the optional filter. If no filter is provided, all accounts are returned.
		     * @param accountFilter - (Optional) filter to narrow down the accounts returned
		     * @returns Array of AccountInfo objects in cache
		     */
		    getAllAccounts(accountFilter, correlationId) {
		        return this.buildTenantProfiles(this.getAccountsFilteredBy(accountFilter, correlationId), correlationId, accountFilter);
		    }
		    /**
		     * Gets first tenanted AccountInfo object found based on provided filters
		     */
		    getAccountInfoFilteredBy(accountFilter, correlationId) {
		        if (Object.keys(accountFilter).length === 0 ||
		            Object.values(accountFilter).every((value) => !value)) {
		            this.commonLogger.warning("getAccountInfoFilteredBy: Account filter is empty or invalid, returning null");
		            return null;
		        }
		        const allAccounts = this.getAllAccounts(accountFilter, correlationId);
		        if (allAccounts.length > 1) {
		            // If one or more accounts are found, prioritize accounts that have an ID token
		            const sortedAccounts = allAccounts.sort((account) => {
		                return account.idTokenClaims ? -1 : 1;
		            });
		            return sortedAccounts[0];
		        }
		        else if (allAccounts.length === 1) {
		            // If only one account is found, return it regardless of whether a matching ID token was found
		            return allAccounts[0];
		        }
		        else {
		            return null;
		        }
		    }
		    /**
		     * Returns a single matching
		     * @param accountFilter
		     * @returns
		     */
		    getBaseAccountInfo(accountFilter, correlationId) {
		        const accountEntities = this.getAccountsFilteredBy(accountFilter, correlationId);
		        if (accountEntities.length > 0) {
		            return AccountEntity.getAccountInfo(accountEntities[0]);
		        }
		        else {
		            return null;
		        }
		    }
		    /**
		     * Matches filtered account entities with cached ID tokens that match the tenant profile-specific account filters
		     * and builds the account info objects from the matching ID token's claims
		     * @param cachedAccounts
		     * @param accountFilter
		     * @returns Array of AccountInfo objects that match account and tenant profile filters
		     */
		    buildTenantProfiles(cachedAccounts, correlationId, accountFilter) {
		        return cachedAccounts.flatMap((accountEntity) => {
		            return this.getTenantProfilesFromAccountEntity(accountEntity, correlationId, accountFilter?.tenantId, accountFilter);
		        });
		    }
		    getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter) {
		        let tenantedAccountInfo = null;
		        let idTokenClaims;
		        if (tenantProfileFilter) {
		            if (!this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter)) {
		                return null;
		            }
		        }
		        const idToken = this.getIdToken(accountInfo, correlationId, tokenKeys, tenantProfile.tenantId);
		        if (idToken) {
		            idTokenClaims = extractTokenClaims(idToken.secret, this.cryptoImpl.base64Decode);
		            if (!this.idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter)) {
		                // ID token sourced claims don't match so this tenant profile is not a match
		                return null;
		            }
		        }
		        // Expand tenant profile into account info based on matching tenant profile and if available matching ID token claims
		        tenantedAccountInfo = updateAccountTenantProfileData(accountInfo, tenantProfile, idTokenClaims, idToken?.secret);
		        return tenantedAccountInfo;
		    }
		    getTenantProfilesFromAccountEntity(accountEntity, correlationId, targetTenantId, tenantProfileFilter) {
		        const accountInfo = AccountEntity.getAccountInfo(accountEntity);
		        let searchTenantProfiles = accountInfo.tenantProfiles || new Map();
		        const tokenKeys = this.getTokenKeys();
		        // If a tenant ID was provided, only return the tenant profile for that tenant ID if it exists
		        if (targetTenantId) {
		            const tenantProfile = searchTenantProfiles.get(targetTenantId);
		            if (tenantProfile) {
		                // Reduce search field to just this tenant profile
		                searchTenantProfiles = new Map([
		                    [targetTenantId, tenantProfile],
		                ]);
		            }
		            else {
		                // No tenant profile for search tenant ID, return empty array
		                return [];
		            }
		        }
		        const matchingTenantProfiles = [];
		        searchTenantProfiles.forEach((tenantProfile) => {
		            const tenantedAccountInfo = this.getTenantedAccountInfoByFilter(accountInfo, tokenKeys, tenantProfile, correlationId, tenantProfileFilter);
		            if (tenantedAccountInfo) {
		                matchingTenantProfiles.push(tenantedAccountInfo);
		            }
		        });
		        return matchingTenantProfiles;
		    }
		    tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter) {
		        if (!!tenantProfileFilter.localAccountId &&
		            !this.matchLocalAccountIdFromTenantProfile(tenantProfile, tenantProfileFilter.localAccountId)) {
		            return false;
		        }
		        if (!!tenantProfileFilter.name &&
		            !(tenantProfile.name === tenantProfileFilter.name)) {
		            return false;
		        }
		        if (tenantProfileFilter.isHomeTenant !== undefined &&
		            !(tenantProfile.isHomeTenant === tenantProfileFilter.isHomeTenant)) {
		            return false;
		        }
		        return true;
		    }
		    idTokenClaimsMatchTenantProfileFilter(idTokenClaims, tenantProfileFilter) {
		        // Tenant Profile filtering
		        if (tenantProfileFilter) {
		            if (!!tenantProfileFilter.localAccountId &&
		                !this.matchLocalAccountIdFromTokenClaims(idTokenClaims, tenantProfileFilter.localAccountId)) {
		                return false;
		            }
		            if (!!tenantProfileFilter.loginHint &&
		                !this.matchLoginHintFromTokenClaims(idTokenClaims, tenantProfileFilter.loginHint)) {
		                return false;
		            }
		            if (!!tenantProfileFilter.username &&
		                !this.matchUsername(idTokenClaims.preferred_username, tenantProfileFilter.username)) {
		                return false;
		            }
		            if (!!tenantProfileFilter.name &&
		                !this.matchName(idTokenClaims, tenantProfileFilter.name)) {
		                return false;
		            }
		            if (!!tenantProfileFilter.sid &&
		                !this.matchSid(idTokenClaims, tenantProfileFilter.sid)) {
		                return false;
		            }
		        }
		        return true;
		    }
		    /**
		     * saves a cache record
		     * @param cacheRecord {CacheRecord}
		     * @param correlationId {?string} correlation id
		     * @param kmsi - Keep Me Signed In
		     * @param storeInCache {?StoreInCache}
		     */
		    async saveCacheRecord(cacheRecord, correlationId, kmsi, storeInCache) {
		        if (!cacheRecord) {
		            throw createClientAuthError(invalidCacheRecord);
		        }
		        try {
		            if (!!cacheRecord.account) {
		                await this.setAccount(cacheRecord.account, correlationId, kmsi);
		            }
		            if (!!cacheRecord.idToken && storeInCache?.idToken !== false) {
		                await this.setIdTokenCredential(cacheRecord.idToken, correlationId, kmsi);
		            }
		            if (!!cacheRecord.accessToken &&
		                storeInCache?.accessToken !== false) {
		                await this.saveAccessToken(cacheRecord.accessToken, correlationId, kmsi);
		            }
		            if (!!cacheRecord.refreshToken &&
		                storeInCache?.refreshToken !== false) {
		                await this.setRefreshTokenCredential(cacheRecord.refreshToken, correlationId, kmsi);
		            }
		            if (!!cacheRecord.appMetadata) {
		                this.setAppMetadata(cacheRecord.appMetadata, correlationId);
		            }
		        }
		        catch (e) {
		            this.commonLogger?.error(`CacheManager.saveCacheRecord: failed`);
		            if (e instanceof AuthError) {
		                throw e;
		            }
		            else {
		                throw createCacheError(e);
		            }
		        }
		    }
		    /**
		     * saves access token credential
		     * @param credential
		     */
		    async saveAccessToken(credential, correlationId, kmsi) {
		        const accessTokenFilter = {
		            clientId: credential.clientId,
		            credentialType: credential.credentialType,
		            environment: credential.environment,
		            homeAccountId: credential.homeAccountId,
		            realm: credential.realm,
		            tokenType: credential.tokenType,
		            requestedClaimsHash: credential.requestedClaimsHash,
		        };
		        const tokenKeys = this.getTokenKeys();
		        const currentScopes = ScopeSet.fromString(credential.target);
		        tokenKeys.accessToken.forEach((key) => {
		            if (!this.accessTokenKeyMatchesFilter(key, accessTokenFilter, false)) {
		                return;
		            }
		            const tokenEntity = this.getAccessTokenCredential(key, correlationId);
		            if (tokenEntity &&
		                this.credentialMatchesFilter(tokenEntity, accessTokenFilter)) {
		                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);
		                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {
		                    this.removeAccessToken(key, correlationId);
		                }
		            }
		        });
		        await this.setAccessTokenCredential(credential, correlationId, kmsi);
		    }
		    /**
		     * Retrieve account entities matching all provided tenant-agnostic filters; if no filter is set, get all account entities in the cache
		     * Not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared
		     * @param accountFilter - An object containing Account properties to filter by
		     */
		    getAccountsFilteredBy(accountFilter, correlationId) {
		        const allAccountKeys = this.getAccountKeys();
		        const matchingAccounts = [];
		        allAccountKeys.forEach((cacheKey) => {
		            const entity = this.getAccount(cacheKey, correlationId);
		            // Match base account fields
		            if (!entity) {
		                return;
		            }
		            if (!!accountFilter.homeAccountId &&
		                !this.matchHomeAccountId(entity, accountFilter.homeAccountId)) {
		                return;
		            }
		            if (!!accountFilter.username &&
		                !this.matchUsername(entity.username, accountFilter.username)) {
		                return;
		            }
		            if (!!accountFilter.environment &&
		                !this.matchEnvironment(entity, accountFilter.environment)) {
		                return;
		            }
		            if (!!accountFilter.realm &&
		                !this.matchRealm(entity, accountFilter.realm)) {
		                return;
		            }
		            if (!!accountFilter.nativeAccountId &&
		                !this.matchNativeAccountId(entity, accountFilter.nativeAccountId)) {
		                return;
		            }
		            if (!!accountFilter.authorityType &&
		                !this.matchAuthorityType(entity, accountFilter.authorityType)) {
		                return;
		            }
		            // If at least one tenant profile matches the tenant profile filter, add the account to the list of matching accounts
		            const tenantProfileFilter = {
		                localAccountId: accountFilter?.localAccountId,
		                name: accountFilter?.name,
		            };
		            const matchingTenantProfiles = entity.tenantProfiles?.filter((tenantProfile) => {
		                return this.tenantProfileMatchesFilter(tenantProfile, tenantProfileFilter);
		            });
		            if (matchingTenantProfiles && matchingTenantProfiles.length === 0) {
		                // No tenant profile for this account matches filter, don't add to list of matching accounts
		                return;
		            }
		            matchingAccounts.push(entity);
		        });
		        return matchingAccounts;
		    }
		    /**
		     * Returns whether or not the given credential entity matches the filter
		     * @param entity
		     * @param filter
		     * @returns
		     */
		    credentialMatchesFilter(entity, filter) {
		        if (!!filter.clientId && !this.matchClientId(entity, filter.clientId)) {
		            return false;
		        }
		        if (!!filter.userAssertionHash &&
		            !this.matchUserAssertionHash(entity, filter.userAssertionHash)) {
		            return false;
		        }
		        /*
		         * homeAccountId can be undefined, and we want to filter out cached items that have a homeAccountId of ""
		         * because we don't want a client_credential request to return a cached token that has a homeAccountId
		         */
		        if (typeof filter.homeAccountId === "string" &&
		            !this.matchHomeAccountId(entity, filter.homeAccountId)) {
		            return false;
		        }
		        if (!!filter.environment &&
		            !this.matchEnvironment(entity, filter.environment)) {
		            return false;
		        }
		        if (!!filter.realm && !this.matchRealm(entity, filter.realm)) {
		            return false;
		        }
		        if (!!filter.credentialType &&
		            !this.matchCredentialType(entity, filter.credentialType)) {
		            return false;
		        }
		        if (!!filter.familyId && !this.matchFamilyId(entity, filter.familyId)) {
		            return false;
		        }
		        /*
		         * idTokens do not have "target", target specific refreshTokens do exist for some types of authentication
		         * Resource specific refresh tokens case will be added when the support is deemed necessary
		         */
		        if (!!filter.target && !this.matchTarget(entity, filter.target)) {
		            return false;
		        }
		        // If request OR cached entity has requested Claims Hash, check if they match
		        if (filter.requestedClaimsHash || entity.requestedClaimsHash) {
		            // Don't match if either is undefined or they are different
		            if (entity.requestedClaimsHash !== filter.requestedClaimsHash) {
		                return false;
		            }
		        }
		        // Access Token with Auth Scheme specific matching
		        if (entity.credentialType ===
		            CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {
		            if (!!filter.tokenType &&
		                !this.matchTokenType(entity, filter.tokenType)) {
		                return false;
		            }
		            // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key
		            if (filter.tokenType === AuthenticationScheme.SSH) {
		                if (filter.keyId && !this.matchKeyId(entity, filter.keyId)) {
		                    return false;
		                }
		            }
		        }
		        return true;
		    }
		    /**
		     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata
		     * @param filter
		     */
		    getAppMetadataFilteredBy(filter) {
		        const allCacheKeys = this.getKeys();
		        const matchingAppMetadata = {};
		        allCacheKeys.forEach((cacheKey) => {
		            // don't parse any non-appMetadata type cache entities
		            if (!this.isAppMetadata(cacheKey)) {
		                return;
		            }
		            // Attempt retrieval
		            const entity = this.getAppMetadata(cacheKey);
		            if (!entity) {
		                return;
		            }
		            if (!!filter.environment &&
		                !this.matchEnvironment(entity, filter.environment)) {
		                return;
		            }
		            if (!!filter.clientId &&
		                !this.matchClientId(entity, filter.clientId)) {
		                return;
		            }
		            matchingAppMetadata[cacheKey] = entity;
		        });
		        return matchingAppMetadata;
		    }
		    /**
		     * retrieve authorityMetadata that contains a matching alias
		     * @param filter
		     */
		    getAuthorityMetadataByAlias(host) {
		        const allCacheKeys = this.getAuthorityMetadataKeys();
		        let matchedEntity = null;
		        allCacheKeys.forEach((cacheKey) => {
		            // don't parse any non-authorityMetadata type cache entities
		            if (!this.isAuthorityMetadata(cacheKey) ||
		                cacheKey.indexOf(this.clientId) === -1) {
		                return;
		            }
		            // Attempt retrieval
		            const entity = this.getAuthorityMetadata(cacheKey);
		            if (!entity) {
		                return;
		            }
		            if (entity.aliases.indexOf(host) === -1) {
		                return;
		            }
		            matchedEntity = entity;
		        });
		        return matchedEntity;
		    }
		    /**
		     * Removes all accounts and related tokens from cache.
		     */
		    removeAllAccounts(correlationId) {
		        const accounts = this.getAllAccounts({}, correlationId);
		        accounts.forEach((account) => {
		            this.removeAccount(account, correlationId);
		        });
		    }
		    /**
		     * Removes the account and related tokens for a given account key
		     * @param account
		     */
		    removeAccount(account, correlationId) {
		        this.removeAccountContext(account, correlationId);
		        const accountKeys = this.getAccountKeys();
		        const keyFilter = (key) => {
		            return (key.includes(account.homeAccountId) &&
		                key.includes(account.environment));
		        };
		        accountKeys.filter(keyFilter).forEach((key) => {
		            this.removeItem(key, correlationId);
		            this.performanceClient.incrementFields({ accountsRemoved: 1 }, correlationId);
		        });
		    }
		    /**
		     * Removes credentials associated with the provided account
		     * @param account
		     */
		    removeAccountContext(account, correlationId) {
		        const allTokenKeys = this.getTokenKeys();
		        const keyFilter = (key) => {
		            return (key.includes(account.homeAccountId) &&
		                key.includes(account.environment));
		        };
		        allTokenKeys.idToken.filter(keyFilter).forEach((key) => {
		            this.removeIdToken(key, correlationId);
		        });
		        allTokenKeys.accessToken.filter(keyFilter).forEach((key) => {
		            this.removeAccessToken(key, correlationId);
		        });
		        allTokenKeys.refreshToken.filter(keyFilter).forEach((key) => {
		            this.removeRefreshToken(key, correlationId);
		        });
		    }
		    /**
		     * Removes accessToken from the cache
		     * @param key
		     * @param correlationId
		     */
		    removeAccessToken(key, correlationId) {
		        const credential = this.getAccessTokenCredential(key, correlationId);
		        this.removeItem(key, correlationId);
		        this.performanceClient.incrementFields({ accessTokensRemoved: 1 }, correlationId);
		        if (!credential ||
		            credential.credentialType.toLowerCase() !==
		                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase() ||
		            credential.tokenType !== AuthenticationScheme.POP) {
		            // If the credential is not a PoP token, we can return
		            return;
		        }
		        // Remove Token Binding Key from key store for PoP Tokens Credentials
		        const kid = credential.keyId;
		        if (kid) {
		            void this.cryptoImpl.removeTokenBindingKey(kid).catch(() => {
		                this.commonLogger.error(`Failed to remove token binding key ${kid}`, correlationId);
		                this.performanceClient?.incrementFields({ removeTokenBindingKeyFailure: 1 }, correlationId);
		            });
		        }
		    }
		    /**
		     * Removes all app metadata objects from cache.
		     */
		    removeAppMetadata(correlationId) {
		        const allCacheKeys = this.getKeys();
		        allCacheKeys.forEach((cacheKey) => {
		            if (this.isAppMetadata(cacheKey)) {
		                this.removeItem(cacheKey, correlationId);
		            }
		        });
		        return true;
		    }
		    /**
		     * Retrieve IdTokenEntity from cache
		     * @param account {AccountInfo}
		     * @param tokenKeys {?TokenKeys}
		     * @param targetRealm {?string}
		     * @param performanceClient {?IPerformanceClient}
		     * @param correlationId {?string}
		     */
		    getIdToken(account, correlationId, tokenKeys, targetRealm, performanceClient) {
		        this.commonLogger.trace("CacheManager - getIdToken called");
		        const idTokenFilter = {
		            homeAccountId: account.homeAccountId,
		            environment: account.environment,
		            credentialType: CredentialType.ID_TOKEN,
		            clientId: this.clientId,
		            realm: targetRealm,
		        };
		        const idTokenMap = this.getIdTokensByFilter(idTokenFilter, correlationId, tokenKeys);
		        const numIdTokens = idTokenMap.size;
		        if (numIdTokens < 1) {
		            this.commonLogger.info("CacheManager:getIdToken - No token found");
		            return null;
		        }
		        else if (numIdTokens > 1) {
		            let tokensToBeRemoved = idTokenMap;
		            // Multiple tenant profiles and no tenant specified, pick home account
		            if (!targetRealm) {
		                const homeIdTokenMap = new Map();
		                idTokenMap.forEach((idToken, key) => {
		                    if (idToken.realm === account.tenantId) {
		                        homeIdTokenMap.set(key, idToken);
		                    }
		                });
		                const numHomeIdTokens = homeIdTokenMap.size;
		                if (numHomeIdTokens < 1) {
		                    this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account but none match account entity tenant id, returning first result");
		                    return idTokenMap.values().next().value;
		                }
		                else if (numHomeIdTokens === 1) {
		                    this.commonLogger.info("CacheManager:getIdToken - Multiple ID tokens found for account, defaulting to home tenant profile");
		                    return homeIdTokenMap.values().next().value;
		                }
		                else {
		                    // Multiple ID tokens for home tenant profile, remove all and return null
		                    tokensToBeRemoved = homeIdTokenMap;
		                }
		            }
		            // Multiple tokens for a single tenant profile, remove all and return null
		            this.commonLogger.info("CacheManager:getIdToken - Multiple matching ID tokens found, clearing them");
		            tokensToBeRemoved.forEach((idToken, key) => {
		                this.removeIdToken(key, correlationId);
		            });
		            if (performanceClient && correlationId) {
		                performanceClient.addFields({ multiMatchedID: idTokenMap.size }, correlationId);
		            }
		            return null;
		        }
		        this.commonLogger.info("CacheManager:getIdToken - Returning ID token");
		        return idTokenMap.values().next().value;
		    }
		    /**
		     * Gets all idTokens matching the given filter
		     * @param filter
		     * @returns
		     */
		    getIdTokensByFilter(filter, correlationId, tokenKeys) {
		        const idTokenKeys = (tokenKeys && tokenKeys.idToken) || this.getTokenKeys().idToken;
		        const idTokens = new Map();
		        idTokenKeys.forEach((key) => {
		            if (!this.idTokenKeyMatchesFilter(key, {
		                clientId: this.clientId,
		                ...filter,
		            })) {
		                return;
		            }
		            const idToken = this.getIdTokenCredential(key, correlationId);
		            if (idToken && this.credentialMatchesFilter(idToken, filter)) {
		                idTokens.set(key, idToken);
		            }
		        });
		        return idTokens;
		    }
		    /**
		     * Validate the cache key against filter before retrieving and parsing cache value
		     * @param key
		     * @param filter
		     * @returns
		     */
		    idTokenKeyMatchesFilter(inputKey, filter) {
		        const key = inputKey.toLowerCase();
		        if (filter.clientId &&
		            key.indexOf(filter.clientId.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.homeAccountId &&
		            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
		            return false;
		        }
		        return true;
		    }
		    /**
		     * Removes idToken from the cache
		     * @param key
		     */
		    removeIdToken(key, correlationId) {
		        this.removeItem(key, correlationId);
		    }
		    /**
		     * Removes refresh token from the cache
		     * @param key
		     */
		    removeRefreshToken(key, correlationId) {
		        this.removeItem(key, correlationId);
		    }
		    /**
		     * Retrieve AccessTokenEntity from cache
		     * @param account {AccountInfo}
		     * @param request {BaseAuthRequest}
		     * @param correlationId {?string}
		     * @param tokenKeys {?TokenKeys}
		     * @param performanceClient {?IPerformanceClient}
		     */
		    getAccessToken(account, request, tokenKeys, targetRealm) {
		        const correlationId = request.correlationId;
		        this.commonLogger.trace("CacheManager - getAccessToken called", correlationId);
		        const scopes = ScopeSet.createSearchScopes(request.scopes);
		        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
		        /*
		         * Distinguish between Bearer and PoP/SSH token cache types
		         * Cast to lowercase to handle "bearer" from ADFS
		         */
		        const credentialType = authScheme.toLowerCase() !==
		                AuthenticationScheme.BEARER.toLowerCase()
		            ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME
		            : CredentialType.ACCESS_TOKEN;
		        const accessTokenFilter = {
		            homeAccountId: account.homeAccountId,
		            environment: account.environment,
		            credentialType: credentialType,
		            clientId: this.clientId,
		            realm: targetRealm || account.tenantId,
		            target: scopes,
		            tokenType: authScheme,
		            keyId: request.sshKid,
		            requestedClaimsHash: request.requestedClaimsHash,
		        };
		        const accessTokenKeys = (tokenKeys && tokenKeys.accessToken) ||
		            this.getTokenKeys().accessToken;
		        const accessTokens = [];
		        accessTokenKeys.forEach((key) => {
		            // Validate key
		            if (this.accessTokenKeyMatchesFilter(key, accessTokenFilter, true)) {
		                const accessToken = this.getAccessTokenCredential(key, correlationId);
		                // Validate value
		                if (accessToken &&
		                    this.credentialMatchesFilter(accessToken, accessTokenFilter)) {
		                    accessTokens.push(accessToken);
		                }
		            }
		        });
		        const numAccessTokens = accessTokens.length;
		        if (numAccessTokens < 1) {
		            this.commonLogger.info("CacheManager:getAccessToken - No token found", correlationId);
		            return null;
		        }
		        else if (numAccessTokens > 1) {
		            this.commonLogger.info("CacheManager:getAccessToken - Multiple access tokens found, clearing them", correlationId);
		            accessTokens.forEach((accessToken) => {
		                this.removeAccessToken(this.generateCredentialKey(accessToken), correlationId);
		            });
		            this.performanceClient.addFields({ multiMatchedAT: accessTokens.length }, correlationId);
		            return null;
		        }
		        this.commonLogger.info("CacheManager:getAccessToken - Returning access token", correlationId);
		        return accessTokens[0];
		    }
		    /**
		     * Validate the cache key against filter before retrieving and parsing cache value
		     * @param key
		     * @param filter
		     * @param keyMustContainAllScopes
		     * @returns
		     */
		    accessTokenKeyMatchesFilter(inputKey, filter, keyMustContainAllScopes) {
		        const key = inputKey.toLowerCase();
		        if (filter.clientId &&
		            key.indexOf(filter.clientId.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.homeAccountId &&
		            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.realm && key.indexOf(filter.realm.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.requestedClaimsHash &&
		            key.indexOf(filter.requestedClaimsHash.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.target) {
		            const scopes = filter.target.asArray();
		            for (let i = 0; i < scopes.length; i++) {
		                if (keyMustContainAllScopes &&
		                    !key.includes(scopes[i].toLowerCase())) {
		                    // When performing a cache lookup a missing scope would be a cache miss
		                    return false;
		                }
		                else if (!keyMustContainAllScopes &&
		                    key.includes(scopes[i].toLowerCase())) {
		                    // When performing a cache write, any token with a subset of requested scopes should be replaced
		                    return true;
		                }
		            }
		        }
		        return true;
		    }
		    /**
		     * Gets all access tokens matching the filter
		     * @param filter
		     * @returns
		     */
		    getAccessTokensByFilter(filter, correlationId) {
		        const tokenKeys = this.getTokenKeys();
		        const accessTokens = [];
		        tokenKeys.accessToken.forEach((key) => {
		            if (!this.accessTokenKeyMatchesFilter(key, filter, true)) {
		                return;
		            }
		            const accessToken = this.getAccessTokenCredential(key, correlationId);
		            if (accessToken &&
		                this.credentialMatchesFilter(accessToken, filter)) {
		                accessTokens.push(accessToken);
		            }
		        });
		        return accessTokens;
		    }
		    /**
		     * Helper to retrieve the appropriate refresh token from cache
		     * @param account {AccountInfo}
		     * @param familyRT {boolean}
		     * @param correlationId {?string}
		     * @param tokenKeys {?TokenKeys}
		     * @param performanceClient {?IPerformanceClient}
		     */
		    getRefreshToken(account, familyRT, correlationId, tokenKeys, performanceClient) {
		        this.commonLogger.trace("CacheManager - getRefreshToken called");
		        const id = familyRT ? THE_FAMILY_ID : undefined;
		        const refreshTokenFilter = {
		            homeAccountId: account.homeAccountId,
		            environment: account.environment,
		            credentialType: CredentialType.REFRESH_TOKEN,
		            clientId: this.clientId,
		            familyId: id,
		        };
		        const refreshTokenKeys = (tokenKeys && tokenKeys.refreshToken) ||
		            this.getTokenKeys().refreshToken;
		        const refreshTokens = [];
		        refreshTokenKeys.forEach((key) => {
		            // Validate key
		            if (this.refreshTokenKeyMatchesFilter(key, refreshTokenFilter)) {
		                const refreshToken = this.getRefreshTokenCredential(key, correlationId);
		                // Validate value
		                if (refreshToken &&
		                    this.credentialMatchesFilter(refreshToken, refreshTokenFilter)) {
		                    refreshTokens.push(refreshToken);
		                }
		            }
		        });
		        const numRefreshTokens = refreshTokens.length;
		        if (numRefreshTokens < 1) {
		            this.commonLogger.info("CacheManager:getRefreshToken - No refresh token found.");
		            return null;
		        }
		        // address the else case after remove functions address environment aliases
		        if (numRefreshTokens > 1 && performanceClient && correlationId) {
		            performanceClient.addFields({ multiMatchedRT: numRefreshTokens }, correlationId);
		        }
		        this.commonLogger.info("CacheManager:getRefreshToken - returning refresh token");
		        return refreshTokens[0];
		    }
		    /**
		     * Validate the cache key against filter before retrieving and parsing cache value
		     * @param key
		     * @param filter
		     */
		    refreshTokenKeyMatchesFilter(inputKey, filter) {
		        const key = inputKey.toLowerCase();
		        if (filter.familyId &&
		            key.indexOf(filter.familyId.toLowerCase()) === -1) {
		            return false;
		        }
		        // If familyId is used, clientId is not in the key
		        if (!filter.familyId &&
		            filter.clientId &&
		            key.indexOf(filter.clientId.toLowerCase()) === -1) {
		            return false;
		        }
		        if (filter.homeAccountId &&
		            key.indexOf(filter.homeAccountId.toLowerCase()) === -1) {
		            return false;
		        }
		        return true;
		    }
		    /**
		     * Retrieve AppMetadataEntity from cache
		     */
		    readAppMetadataFromCache(environment) {
		        const appMetadataFilter = {
		            environment,
		            clientId: this.clientId,
		        };
		        const appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);
		        const appMetadataEntries = Object.keys(appMetadata).map((key) => appMetadata[key]);
		        const numAppMetadata = appMetadataEntries.length;
		        if (numAppMetadata < 1) {
		            return null;
		        }
		        else if (numAppMetadata > 1) {
		            throw createClientAuthError(multipleMatchingAppMetadata);
		        }
		        return appMetadataEntries[0];
		    }
		    /**
		     * Return the family_id value associated  with FOCI
		     * @param environment
		     * @param clientId
		     */
		    isAppMetadataFOCI(environment) {
		        const appMetadata = this.readAppMetadataFromCache(environment);
		        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);
		    }
		    /**
		     * helper to match account ids
		     * @param value
		     * @param homeAccountId
		     */
		    matchHomeAccountId(entity, homeAccountId) {
		        return !!(typeof entity.homeAccountId === "string" &&
		            homeAccountId === entity.homeAccountId);
		    }
		    /**
		     * helper to match account ids
		     * @param entity
		     * @param localAccountId
		     * @returns
		     */
		    matchLocalAccountIdFromTokenClaims(tokenClaims, localAccountId) {
		        const idTokenLocalAccountId = tokenClaims.oid || tokenClaims.sub;
		        return localAccountId === idTokenLocalAccountId;
		    }
		    matchLocalAccountIdFromTenantProfile(tenantProfile, localAccountId) {
		        return tenantProfile.localAccountId === localAccountId;
		    }
		    /**
		     * helper to match names
		     * @param entity
		     * @param name
		     * @returns true if the downcased name properties are present and match in the filter and the entity
		     */
		    matchName(claims, name) {
		        return !!(name.toLowerCase() === claims.name?.toLowerCase());
		    }
		    /**
		     * helper to match usernames
		     * @param entity
		     * @param username
		     * @returns
		     */
		    matchUsername(cachedUsername, filterUsername) {
		        return !!(cachedUsername &&
		            typeof cachedUsername === "string" &&
		            filterUsername?.toLowerCase() === cachedUsername.toLowerCase());
		    }
		    /**
		     * helper to match assertion
		     * @param value
		     * @param oboAssertion
		     */
		    matchUserAssertionHash(entity, userAssertionHash) {
		        return !!(entity.userAssertionHash &&
		            userAssertionHash === entity.userAssertionHash);
		    }
		    /**
		     * helper to match environment
		     * @param value
		     * @param environment
		     */
		    matchEnvironment(entity, environment) {
		        // Check static authority options first for cases where authority metadata has not been resolved and cached yet
		        if (this.staticAuthorityOptions) {
		            const staticAliases = getAliasesFromStaticSources(this.staticAuthorityOptions, this.commonLogger);
		            if (staticAliases.includes(environment) &&
		                staticAliases.includes(entity.environment)) {
		                return true;
		            }
		        }
		        // Query metadata cache if no static authority configuration has aliases that match enviroment
		        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);
		        if (cloudMetadata &&
		            cloudMetadata.aliases.indexOf(entity.environment) > -1) {
		            return true;
		        }
		        return false;
		    }
		    /**
		     * helper to match credential type
		     * @param entity
		     * @param credentialType
		     */
		    matchCredentialType(entity, credentialType) {
		        return (entity.credentialType &&
		            credentialType.toLowerCase() === entity.credentialType.toLowerCase());
		    }
		    /**
		     * helper to match client ids
		     * @param entity
		     * @param clientId
		     */
		    matchClientId(entity, clientId) {
		        return !!(entity.clientId && clientId === entity.clientId);
		    }
		    /**
		     * helper to match family ids
		     * @param entity
		     * @param familyId
		     */
		    matchFamilyId(entity, familyId) {
		        return !!(entity.familyId && familyId === entity.familyId);
		    }
		    /**
		     * helper to match realm
		     * @param entity
		     * @param realm
		     */
		    matchRealm(entity, realm) {
		        return !!(entity.realm?.toLowerCase() === realm.toLowerCase());
		    }
		    /**
		     * helper to match nativeAccountId
		     * @param entity
		     * @param nativeAccountId
		     * @returns boolean indicating the match result
		     */
		    matchNativeAccountId(entity, nativeAccountId) {
		        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);
		    }
		    /**
		     * helper to match loginHint which can be either:
		     * 1. login_hint ID token claim
		     * 2. username in cached account object
		     * 3. upn in ID token claims
		     * @param entity
		     * @param loginHint
		     * @returns
		     */
		    matchLoginHintFromTokenClaims(tokenClaims, loginHint) {
		        if (tokenClaims.login_hint === loginHint) {
		            return true;
		        }
		        if (tokenClaims.preferred_username === loginHint) {
		            return true;
		        }
		        if (tokenClaims.upn === loginHint) {
		            return true;
		        }
		        return false;
		    }
		    /**
		     * Helper to match sid
		     * @param entity
		     * @param sid
		     * @returns true if the sid claim is present and matches the filter
		     */
		    matchSid(idTokenClaims, sid) {
		        return idTokenClaims.sid === sid;
		    }
		    matchAuthorityType(entity, authorityType) {
		        return !!(entity.authorityType &&
		            authorityType.toLowerCase() === entity.authorityType.toLowerCase());
		    }
		    /**
		     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.
		     * @param entity
		     * @param target
		     */
		    matchTarget(entity, target) {
		        const isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN &&
		            entity.credentialType !==
		                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
		        if (isNotAccessTokenCredential || !entity.target) {
		            return false;
		        }
		        const entityScopeSet = ScopeSet.fromString(entity.target);
		        return entityScopeSet.containsScopeSet(target);
		    }
		    /**
		     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise
		     * @param entity
		     * @param tokenType
		     */
		    matchTokenType(entity, tokenType) {
		        return !!(entity.tokenType && entity.tokenType === tokenType);
		    }
		    /**
		     * Returns true if the credential's keyId matches the one in the request, false otherwise
		     * @param entity
		     * @param keyId
		     */
		    matchKeyId(entity, keyId) {
		        return !!(entity.keyId && entity.keyId === keyId);
		    }
		    /**
		     * returns if a given cache entity is of the type appmetadata
		     * @param key
		     */
		    isAppMetadata(key) {
		        return key.indexOf(APP_METADATA) !== -1;
		    }
		    /**
		     * returns if a given cache entity is of the type authoritymetadata
		     * @param key
		     */
		    isAuthorityMetadata(key) {
		        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;
		    }
		    /**
		     * returns cache key used for cloud instance metadata
		     */
		    generateAuthorityMetadataCacheKey(authority) {
		        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;
		    }
		    /**
		     * Helper to convert serialized data to object
		     * @param obj
		     * @param json
		     */
		    static toObject(obj, json) {
		        for (const propertyName in json) {
		            obj[propertyName] = json[propertyName];
		        }
		        return obj;
		    }
		}
		/** @internal */
		class DefaultStorageClass extends CacheManager {
		    async setAccount() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAccount() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    async setIdTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getIdTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    async setAccessTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAccessTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    async setRefreshTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getRefreshTokenCredential() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    setAppMetadata() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAppMetadata() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    setServerTelemetry() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getServerTelemetry() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    setAuthorityMetadata() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAuthorityMetadata() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAuthorityMetadataKeys() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    setThrottlingCache() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getThrottlingCache() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    removeItem() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getKeys() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getAccountKeys() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    getTokenKeys() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    generateCredentialKey() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		    generateAccountKey() {
		        throw createClientAuthError(methodNotImplemented);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Enumeration of operations that are instrumented by have their performance measured by the PerformanceClient.
		 *
		 * @export
		 * @enum {number}
		 */
		const PerformanceEvents = {
		    /**
		     * acquireTokenByCode API (msal-browser and msal-node).
		     * Used to acquire tokens by trading an authorization code against the token endpoint.
		     */
		    AcquireTokenByCode: "acquireTokenByCode",
		    /**
		     * acquireTokenByRefreshToken API (msal-browser and msal-node).
		     * Used to renew an access token using a refresh token against the token endpoint.
		     */
		    AcquireTokenByRefreshToken: "acquireTokenByRefreshToken",
		    /**
		     * acquireTokenSilent API (msal-browser and msal-node).
		     * Used to silently acquire a new access token (from the cache or the network).
		     */
		    AcquireTokenSilent: "acquireTokenSilent",
		    /**
		     * acquireTokenSilentAsync (msal-browser).
		     * Internal API for acquireTokenSilent.
		     */
		    AcquireTokenSilentAsync: "acquireTokenSilentAsync",
		    /**
		     * acquireTokenPopup (msal-browser).
		     * Used to acquire a new access token interactively through pop ups
		     */
		    AcquireTokenPopup: "acquireTokenPopup",
		    /**
		     * acquireTokenPreRedirect (msal-browser).
		     * First part of the redirect flow.
		     * Used to acquire a new access token interactively through redirects.
		     */
		    AcquireTokenPreRedirect: "acquireTokenPreRedirect",
		    /**
		     * acquireTokenRedirect (msal-browser).
		     * Second part of the redirect flow.
		     * Used to acquire a new access token interactively through redirects.
		     */
		    AcquireTokenRedirect: "acquireTokenRedirect",
		    /**
		     * getPublicKeyThumbprint API in CryptoOpts class (msal-browser).
		     * Used to generate a public/private keypair and generate a public key thumbprint for pop requests.
		     */
		    CryptoOptsGetPublicKeyThumbprint: "cryptoOptsGetPublicKeyThumbprint",
		    /**
		     * signJwt API in CryptoOpts class (msal-browser).
		     * Used to signed a pop token.
		     */
		    CryptoOptsSignJwt: "cryptoOptsSignJwt",
		    /**
		     * acquireToken API in the SilentCacheClient class (msal-browser).
		     * Used to read access tokens from the cache.
		     */
		    SilentCacheClientAcquireToken: "silentCacheClientAcquireToken",
		    /**
		     * acquireToken API in the SilentIframeClient class (msal-browser).
		     * Used to acquire a new set of tokens from the authorize endpoint in a hidden iframe.
		     */
		    SilentIframeClientAcquireToken: "silentIframeClientAcquireToken",
		    AwaitConcurrentIframe: "awaitConcurrentIframe",
		    /**
		     * acquireToken API in SilentRereshClient (msal-browser).
		     * Used to acquire a new set of tokens from the token endpoint using a refresh token.
		     */
		    SilentRefreshClientAcquireToken: "silentRefreshClientAcquireToken",
		    /**
		     * ssoSilent API (msal-browser).
		     * Used to silently acquire an authorization code and set of tokens using a hidden iframe.
		     */
		    SsoSilent: "ssoSilent",
		    /**
		     * getDiscoveredAuthority API in StandardInteractionClient class (msal-browser).
		     * Used to load authority metadata for a request.
		     */
		    StandardInteractionClientGetDiscoveredAuthority: "standardInteractionClientGetDiscoveredAuthority",
		    /**
		     * acquireToken APIs in msal-browser.
		     * Used to make an /authorize endpoint call with native brokering enabled.
		     */
		    FetchAccountIdWithNativeBroker: "fetchAccountIdWithNativeBroker",
		    /**
		     * acquireToken API in NativeInteractionClient class (msal-browser).
		     * Used to acquire a token from Native component when native brokering is enabled.
		     */
		    NativeInteractionClientAcquireToken: "nativeInteractionClientAcquireToken",
		    /**
		     * Time spent creating default headers for requests to token endpoint
		     */
		    BaseClientCreateTokenRequestHeaders: "baseClientCreateTokenRequestHeaders",
		    /**
		     * Time spent sending/waiting for the response of a request to the token endpoint
		     */
		    NetworkClientSendPostRequestAsync: "networkClientSendPostRequestAsync",
		    RefreshTokenClientExecutePostToTokenEndpoint: "refreshTokenClientExecutePostToTokenEndpoint",
		    AuthorizationCodeClientExecutePostToTokenEndpoint: "authorizationCodeClientExecutePostToTokenEndpoint",
		    /**
		     * Used to measure the time taken for completing embedded-broker handshake (PW-Broker).
		     */
		    BrokerHandhshake: "brokerHandshake",
		    /**
		     * acquireTokenByRefreshToken API in BrokerClientApplication (PW-Broker) .
		     */
		    AcquireTokenByRefreshTokenInBroker: "acquireTokenByRefreshTokenInBroker",
		    /**
		     * Time taken for token acquisition by broker
		     */
		    AcquireTokenByBroker: "acquireTokenByBroker",
		    /**
		     * Time spent on the network for refresh token acquisition
		     */
		    RefreshTokenClientExecuteTokenRequest: "refreshTokenClientExecuteTokenRequest",
		    /**
		     * Time taken for acquiring refresh token , records RT size
		     */
		    RefreshTokenClientAcquireToken: "refreshTokenClientAcquireToken",
		    /**
		     * Time taken for acquiring cached refresh token
		     */
		    RefreshTokenClientAcquireTokenWithCachedRefreshToken: "refreshTokenClientAcquireTokenWithCachedRefreshToken",
		    /**
		     * acquireTokenByRefreshToken API in RefreshTokenClient (msal-common).
		     */
		    RefreshTokenClientAcquireTokenByRefreshToken: "refreshTokenClientAcquireTokenByRefreshToken",
		    /**
		     * Helper function to create token request body in RefreshTokenClient (msal-common).
		     */
		    RefreshTokenClientCreateTokenRequestBody: "refreshTokenClientCreateTokenRequestBody",
		    /**
		     * acquireTokenFromCache (msal-browser).
		     * Internal API for acquiring token from cache
		     */
		    AcquireTokenFromCache: "acquireTokenFromCache",
		    SilentFlowClientAcquireCachedToken: "silentFlowClientAcquireCachedToken",
		    SilentFlowClientGenerateResultFromCacheRecord: "silentFlowClientGenerateResultFromCacheRecord",
		    /**
		     * acquireTokenBySilentIframe (msal-browser).
		     * Internal API for acquiring token by silent Iframe
		     */
		    AcquireTokenBySilentIframe: "acquireTokenBySilentIframe",
		    /**
		     * Internal API for initializing base request in BaseInteractionClient (msal-browser)
		     */
		    InitializeBaseRequest: "initializeBaseRequest",
		    /**
		     * Internal API for initializing silent request in SilentCacheClient (msal-browser)
		     */
		    InitializeSilentRequest: "initializeSilentRequest",
		    InitializeClientApplication: "initializeClientApplication",
		    InitializeCache: "initializeCache",
		    /**
		     * Helper function in SilentIframeClient class (msal-browser).
		     */
		    SilentIframeClientTokenHelper: "silentIframeClientTokenHelper",
		    /**
		     * SilentHandler
		     */
		    SilentHandlerInitiateAuthRequest: "silentHandlerInitiateAuthRequest",
		    SilentHandlerMonitorIframeForHash: "silentHandlerMonitorIframeForHash",
		    SilentHandlerLoadFrame: "silentHandlerLoadFrame",
		    SilentHandlerLoadFrameSync: "silentHandlerLoadFrameSync",
		    /**
		     * Helper functions in StandardInteractionClient class (msal-browser)
		     */
		    StandardInteractionClientCreateAuthCodeClient: "standardInteractionClientCreateAuthCodeClient",
		    StandardInteractionClientGetClientConfiguration: "standardInteractionClientGetClientConfiguration",
		    StandardInteractionClientInitializeAuthorizationRequest: "standardInteractionClientInitializeAuthorizationRequest",
		    /**
		     * getAuthCodeUrl API (msal-browser and msal-node).
		     */
		    GetAuthCodeUrl: "getAuthCodeUrl",
		    GetStandardParams: "getStandardParams",
		    /**
		     * Functions from InteractionHandler (msal-browser)
		     */
		    HandleCodeResponseFromServer: "handleCodeResponseFromServer",
		    HandleCodeResponse: "handleCodeResponse",
		    HandleResponseEar: "handleResponseEar",
		    HandleResponsePlatformBroker: "handleResponsePlatformBroker",
		    HandleResponseCode: "handleResponseCode",
		    UpdateTokenEndpointAuthority: "updateTokenEndpointAuthority",
		    /**
		     * APIs in Authorization Code Client (msal-common)
		     */
		    AuthClientAcquireToken: "authClientAcquireToken",
		    AuthClientExecuteTokenRequest: "authClientExecuteTokenRequest",
		    AuthClientCreateTokenRequestBody: "authClientCreateTokenRequestBody",
		    /**
		     * Generate functions in PopTokenGenerator (msal-common)
		     */
		    PopTokenGenerateCnf: "popTokenGenerateCnf",
		    PopTokenGenerateKid: "popTokenGenerateKid",
		    /**
		     * handleServerTokenResponse API in ResponseHandler (msal-common)
		     */
		    HandleServerTokenResponse: "handleServerTokenResponse",
		    DeserializeResponse: "deserializeResponse",
		    /**
		     * Authority functions
		     */
		    AuthorityFactoryCreateDiscoveredInstance: "authorityFactoryCreateDiscoveredInstance",
		    AuthorityResolveEndpointsAsync: "authorityResolveEndpointsAsync",
		    AuthorityResolveEndpointsFromLocalSources: "authorityResolveEndpointsFromLocalSources",
		    AuthorityGetCloudDiscoveryMetadataFromNetwork: "authorityGetCloudDiscoveryMetadataFromNetwork",
		    AuthorityUpdateCloudDiscoveryMetadata: "authorityUpdateCloudDiscoveryMetadata",
		    AuthorityGetEndpointMetadataFromNetwork: "authorityGetEndpointMetadataFromNetwork",
		    AuthorityUpdateEndpointMetadata: "authorityUpdateEndpointMetadata",
		    AuthorityUpdateMetadataWithRegionalInformation: "authorityUpdateMetadataWithRegionalInformation",
		    /**
		     * Region Discovery functions
		     */
		    RegionDiscoveryDetectRegion: "regionDiscoveryDetectRegion",
		    RegionDiscoveryGetRegionFromIMDS: "regionDiscoveryGetRegionFromIMDS",
		    RegionDiscoveryGetCurrentVersion: "regionDiscoveryGetCurrentVersion",
		    AcquireTokenByCodeAsync: "acquireTokenByCodeAsync",
		    GetEndpointMetadataFromNetwork: "getEndpointMetadataFromNetwork",
		    GetCloudDiscoveryMetadataFromNetworkMeasurement: "getCloudDiscoveryMetadataFromNetworkMeasurement",
		    HandleRedirectPromiseMeasurement: "handleRedirectPromise",
		    HandleNativeRedirectPromiseMeasurement: "handleNativeRedirectPromise",
		    UpdateCloudDiscoveryMetadataMeasurement: "updateCloudDiscoveryMetadataMeasurement",
		    UsernamePasswordClientAcquireToken: "usernamePasswordClientAcquireToken",
		    NativeMessageHandlerHandshake: "nativeMessageHandlerHandshake",
		    NativeGenerateAuthResult: "nativeGenerateAuthResult",
		    RemoveHiddenIframe: "removeHiddenIframe",
		    /**
		     * Cache operations
		     */
		    ClearTokensAndKeysWithClaims: "clearTokensAndKeysWithClaims",
		    CacheManagerGetRefreshToken: "cacheManagerGetRefreshToken",
		    ImportExistingCache: "importExistingCache",
		    SetUserData: "setUserData",
		    LocalStorageUpdated: "localStorageUpdated",
		    /**
		     * Crypto Operations
		     */
		    GeneratePkceCodes: "generatePkceCodes",
		    GenerateCodeVerifier: "generateCodeVerifier",
		    GenerateCodeChallengeFromVerifier: "generateCodeChallengeFromVerifier",
		    Sha256Digest: "sha256Digest",
		    GetRandomValues: "getRandomValues",
		    GenerateHKDF: "generateHKDF",
		    GenerateBaseKey: "generateBaseKey",
		    Base64Decode: "base64Decode",
		    UrlEncodeArr: "urlEncodeArr",
		    Encrypt: "encrypt",
		    Decrypt: "decrypt",
		    GenerateEarKey: "generateEarKey",
		    DecryptEarResponse: "decryptEarResponse",
		};
		/**
		 * State of the performance event.
		 *
		 * @export
		 * @enum {number}
		 */
		const PerformanceEventStatus = {
		    InProgress: 1};

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class StubPerformanceMeasurement {
		    startMeasurement() {
		        return;
		    }
		    endMeasurement() {
		        return;
		    }
		    flushMeasurement() {
		        return null;
		    }
		}
		class StubPerformanceClient {
		    generateId() {
		        return "callback-id";
		    }
		    startMeasurement(measureName, correlationId) {
		        return {
		            end: () => null,
		            discard: () => { },
		            add: () => { },
		            increment: () => { },
		            event: {
		                eventId: this.generateId(),
		                status: PerformanceEventStatus.InProgress,
		                authority: "",
		                libraryName: "",
		                libraryVersion: "",
		                clientId: "",
		                name: measureName,
		                startTimeMs: Date.now(),
		                correlationId: correlationId || "",
		            },
		            measurement: new StubPerformanceMeasurement(),
		        };
		    }
		    startPerformanceMeasurement() {
		        return new StubPerformanceMeasurement();
		    }
		    calculateQueuedTime() {
		        return 0;
		    }
		    addQueueMeasurement() {
		        return;
		    }
		    setPreQueueTime() {
		        return;
		    }
		    endMeasurement() {
		        return null;
		    }
		    discardMeasurements() {
		        return;
		    }
		    removePerformanceCallback() {
		        return true;
		    }
		    addPerformanceCallback() {
		        return "";
		    }
		    emitEvents() {
		        return;
		    }
		    addFields() {
		        return;
		    }
		    incrementFields() {
		        return;
		    }
		    cacheEventByCorrelationId() {
		        return;
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const DEFAULT_SYSTEM_OPTIONS$1 = {
		    tokenRenewalOffsetSeconds: DEFAULT_TOKEN_RENEWAL_OFFSET_SEC,
		    preventCorsPreflight: false,
		};
		const DEFAULT_LOGGER_IMPLEMENTATION = {
		    loggerCallback: () => {
		        // allow users to not set loggerCallback
		    },
		    piiLoggingEnabled: false,
		    logLevel: exports$1.LogLevel.Info,
		    correlationId: Constants$1.EMPTY_STRING,
		};
		const DEFAULT_CACHE_OPTIONS$1 = {
		    claimsBasedCachingEnabled: false,
		};
		const DEFAULT_NETWORK_IMPLEMENTATION = {
		    async sendGetRequestAsync() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		    async sendPostRequestAsync() {
		        throw createClientAuthError(methodNotImplemented);
		    },
		};
		const DEFAULT_LIBRARY_INFO = {
		    sku: Constants$1.SKU,
		    version: version$1,
		    cpu: Constants$1.EMPTY_STRING,
		    os: Constants$1.EMPTY_STRING,
		};
		const DEFAULT_CLIENT_CREDENTIALS = {
		    clientSecret: Constants$1.EMPTY_STRING,
		    clientAssertion: undefined,
		};
		const DEFAULT_AZURE_CLOUD_OPTIONS = {
		    azureCloudInstance: AzureCloudInstance.None,
		    tenant: `${Constants$1.DEFAULT_COMMON_TENANT}`,
		};
		const DEFAULT_TELEMETRY_OPTIONS$1 = {
		    application: {
		        appName: "",
		        appVersion: "",
		    },
		};
		/**
		 * Function that sets the default options when not explicitly configured from app developer
		 *
		 * @param Configuration
		 *
		 * @returns Configuration
		 */
		function buildClientConfiguration({ authOptions: userAuthOptions, systemOptions: userSystemOptions, loggerOptions: userLoggerOption, cacheOptions: userCacheOptions, storageInterface: storageImplementation, networkInterface: networkImplementation, cryptoInterface: cryptoImplementation, clientCredentials: clientCredentials, libraryInfo: libraryInfo, telemetry: telemetry, serverTelemetryManager: serverTelemetryManager, persistencePlugin: persistencePlugin, serializableCache: serializableCache, }) {
		    const loggerOptions = {
		        ...DEFAULT_LOGGER_IMPLEMENTATION,
		        ...userLoggerOption,
		    };
		    return {
		        authOptions: buildAuthOptions(userAuthOptions),
		        systemOptions: { ...DEFAULT_SYSTEM_OPTIONS$1, ...userSystemOptions },
		        loggerOptions: loggerOptions,
		        cacheOptions: { ...DEFAULT_CACHE_OPTIONS$1, ...userCacheOptions },
		        storageInterface: storageImplementation ||
		            new DefaultStorageClass(userAuthOptions.clientId, DEFAULT_CRYPTO_IMPLEMENTATION, new Logger(loggerOptions), new StubPerformanceClient()),
		        networkInterface: networkImplementation || DEFAULT_NETWORK_IMPLEMENTATION,
		        cryptoInterface: cryptoImplementation || DEFAULT_CRYPTO_IMPLEMENTATION,
		        clientCredentials: clientCredentials || DEFAULT_CLIENT_CREDENTIALS,
		        libraryInfo: { ...DEFAULT_LIBRARY_INFO, ...libraryInfo },
		        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS$1, ...telemetry },
		        serverTelemetryManager: serverTelemetryManager || null,
		        persistencePlugin: persistencePlugin || null,
		        serializableCache: serializableCache || null,
		    };
		}
		/**
		 * Construct authoptions from the client and platform passed values
		 * @param authOptions
		 */
		function buildAuthOptions(authOptions) {
		    return {
		        clientCapabilities: [],
		        azureCloudOptions: DEFAULT_AZURE_CLOUD_OPTIONS,
		        skipAuthorityMetadataCache: false,
		        instanceAware: false,
		        encodeExtraQueryParams: false,
		        ...authOptions,
		    };
		}
		/**
		 * Returns true if config has protocolMode set to ProtocolMode.OIDC, false otherwise
		 * @param ClientConfiguration
		 */
		function isOidcProtocolMode(config) {
		    return (config.authOptions.authority.options.protocolMode === ProtocolMode.OIDC);
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const CcsCredentialType = {
		    HOME_ACCOUNT_ID: "home_account_id",
		    UPN: "UPN",
		};

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const CLIENT_ID = "client_id";
		const REDIRECT_URI = "redirect_uri";
		const RESPONSE_TYPE = "response_type";
		const RESPONSE_MODE = "response_mode";
		const GRANT_TYPE = "grant_type";
		const CLAIMS = "claims";
		const SCOPE = "scope";
		const REFRESH_TOKEN = "refresh_token";
		const STATE = "state";
		const NONCE = "nonce";
		const PROMPT = "prompt";
		const CODE = "code";
		const CODE_CHALLENGE = "code_challenge";
		const CODE_CHALLENGE_METHOD = "code_challenge_method";
		const CODE_VERIFIER = "code_verifier";
		const CLIENT_REQUEST_ID = "client-request-id";
		const X_CLIENT_SKU = "x-client-SKU";
		const X_CLIENT_VER = "x-client-VER";
		const X_CLIENT_OS = "x-client-OS";
		const X_CLIENT_CPU = "x-client-CPU";
		const X_CLIENT_CURR_TELEM = "x-client-current-telemetry";
		const X_CLIENT_LAST_TELEM = "x-client-last-telemetry";
		const X_MS_LIB_CAPABILITY = "x-ms-lib-capability";
		const X_APP_NAME = "x-app-name";
		const X_APP_VER = "x-app-ver";
		const POST_LOGOUT_URI = "post_logout_redirect_uri";
		const ID_TOKEN_HINT = "id_token_hint";
		const DEVICE_CODE = "device_code";
		const CLIENT_SECRET = "client_secret";
		const CLIENT_ASSERTION = "client_assertion";
		const CLIENT_ASSERTION_TYPE = "client_assertion_type";
		const TOKEN_TYPE = "token_type";
		const REQ_CNF = "req_cnf";
		const OBO_ASSERTION = "assertion";
		const REQUESTED_TOKEN_USE = "requested_token_use";
		const ON_BEHALF_OF = "on_behalf_of";
		const RETURN_SPA_CODE = "return_spa_code";
		const LOGOUT_HINT = "logout_hint";
		const SID = "sid";
		const LOGIN_HINT = "login_hint";
		const DOMAIN_HINT = "domain_hint";
		const X_CLIENT_EXTRA_SKU = "x-client-xtra-sku";
		const BROKER_CLIENT_ID = "brk_client_id";
		const BROKER_REDIRECT_URI = "brk_redirect_uri";
		const INSTANCE_AWARE = "instance_aware";

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function instrumentBrokerParams(parameters, correlationId, performanceClient) {
		    if (!correlationId) {
		        return;
		    }
		    const clientId = parameters.get(CLIENT_ID);
		    if (clientId && parameters.has(BROKER_CLIENT_ID)) {
		        performanceClient?.addFields({
		            embeddedClientId: clientId,
		            embeddedRedirectUri: parameters.get(REDIRECT_URI),
		        }, correlationId);
		    }
		}
		/**
		 * Add the given response_type
		 * @param parameters
		 * @param responseType
		 */
		function addResponseType(parameters, responseType) {
		    parameters.set(RESPONSE_TYPE, responseType);
		}
		/**
		 * add response_mode. defaults to query.
		 * @param responseMode
		 */
		function addResponseMode(parameters, responseMode) {
		    parameters.set(RESPONSE_MODE, responseMode ? responseMode : ResponseMode.QUERY);
		}
		/**
		 * add scopes. set addOidcScopes to false to prevent default scopes in non-user scenarios
		 * @param scopeSet
		 * @param addOidcScopes
		 */
		function addScopes(parameters, scopes, addOidcScopes = true, defaultScopes = OIDC_DEFAULT_SCOPES) {
		    // Always add openid to the scopes when adding OIDC scopes
		    if (addOidcScopes &&
		        !defaultScopes.includes("openid") &&
		        !scopes.includes("openid")) {
		        defaultScopes.push("openid");
		    }
		    const requestScopes = addOidcScopes
		        ? [...(scopes || []), ...defaultScopes]
		        : scopes || [];
		    const scopeSet = new ScopeSet(requestScopes);
		    parameters.set(SCOPE, scopeSet.printScopes());
		}
		/**
		 * add clientId
		 * @param clientId
		 */
		function addClientId(parameters, clientId) {
		    parameters.set(CLIENT_ID, clientId);
		}
		/**
		 * add redirect_uri
		 * @param redirectUri
		 */
		function addRedirectUri(parameters, redirectUri) {
		    parameters.set(REDIRECT_URI, redirectUri);
		}
		/**
		 * add post logout redirectUri
		 * @param redirectUri
		 */
		function addPostLogoutRedirectUri(parameters, redirectUri) {
		    parameters.set(POST_LOGOUT_URI, redirectUri);
		}
		/**
		 * add id_token_hint to logout request
		 * @param idTokenHint
		 */
		function addIdTokenHint(parameters, idTokenHint) {
		    parameters.set(ID_TOKEN_HINT, idTokenHint);
		}
		/**
		 * add domain_hint
		 * @param domainHint
		 */
		function addDomainHint(parameters, domainHint) {
		    parameters.set(DOMAIN_HINT, domainHint);
		}
		/**
		 * add login_hint
		 * @param loginHint
		 */
		function addLoginHint(parameters, loginHint) {
		    parameters.set(LOGIN_HINT, loginHint);
		}
		/**
		 * Adds the CCS (Cache Credential Service) query parameter for login_hint
		 * @param loginHint
		 */
		function addCcsUpn(parameters, loginHint) {
		    parameters.set(HeaderNames.CCS_HEADER, `UPN:${loginHint}`);
		}
		/**
		 * Adds the CCS (Cache Credential Service) query parameter for account object
		 * @param loginHint
		 */
		function addCcsOid(parameters, clientInfo) {
		    parameters.set(HeaderNames.CCS_HEADER, `Oid:${clientInfo.uid}@${clientInfo.utid}`);
		}
		/**
		 * add sid
		 * @param sid
		 */
		function addSid(parameters, sid) {
		    parameters.set(SID, sid);
		}
		/**
		 * add claims
		 * @param claims
		 */
		function addClaims(parameters, claims, clientCapabilities) {
		    const mergedClaims = addClientCapabilitiesToClaims(claims, clientCapabilities);
		    try {
		        JSON.parse(mergedClaims);
		    }
		    catch (e) {
		        throw createClientConfigurationError(invalidClaims);
		    }
		    parameters.set(CLAIMS, mergedClaims);
		}
		/**
		 * add correlationId
		 * @param correlationId
		 */
		function addCorrelationId(parameters, correlationId) {
		    parameters.set(CLIENT_REQUEST_ID, correlationId);
		}
		/**
		 * add library info query params
		 * @param libraryInfo
		 */
		function addLibraryInfo(parameters, libraryInfo) {
		    // Telemetry Info
		    parameters.set(X_CLIENT_SKU, libraryInfo.sku);
		    parameters.set(X_CLIENT_VER, libraryInfo.version);
		    if (libraryInfo.os) {
		        parameters.set(X_CLIENT_OS, libraryInfo.os);
		    }
		    if (libraryInfo.cpu) {
		        parameters.set(X_CLIENT_CPU, libraryInfo.cpu);
		    }
		}
		/**
		 * Add client telemetry parameters
		 * @param appTelemetry
		 */
		function addApplicationTelemetry(parameters, appTelemetry) {
		    if (appTelemetry?.appName) {
		        parameters.set(X_APP_NAME, appTelemetry.appName);
		    }
		    if (appTelemetry?.appVersion) {
		        parameters.set(X_APP_VER, appTelemetry.appVersion);
		    }
		}
		/**
		 * add prompt
		 * @param prompt
		 */
		function addPrompt(parameters, prompt) {
		    parameters.set(PROMPT, prompt);
		}
		/**
		 * add state
		 * @param state
		 */
		function addState(parameters, state) {
		    if (state) {
		        parameters.set(STATE, state);
		    }
		}
		/**
		 * add nonce
		 * @param nonce
		 */
		function addNonce(parameters, nonce) {
		    parameters.set(NONCE, nonce);
		}
		/**
		 * add code_challenge and code_challenge_method
		 * - throw if either of them are not passed
		 * @param codeChallenge
		 * @param codeChallengeMethod
		 */
		function addCodeChallengeParams(parameters, codeChallenge, codeChallengeMethod) {
		    if (codeChallenge && codeChallengeMethod) {
		        parameters.set(CODE_CHALLENGE, codeChallenge);
		        parameters.set(CODE_CHALLENGE_METHOD, codeChallengeMethod);
		    }
		    else {
		        throw createClientConfigurationError(pkceParamsMissing);
		    }
		}
		/**
		 * add the `authorization_code` passed by the user to exchange for a token
		 * @param code
		 */
		function addAuthorizationCode(parameters, code) {
		    parameters.set(CODE, code);
		}
		/**
		 * add the `authorization_code` passed by the user to exchange for a token
		 * @param code
		 */
		function addDeviceCode(parameters, code) {
		    parameters.set(DEVICE_CODE, code);
		}
		/**
		 * add the `refreshToken` passed by the user
		 * @param refreshToken
		 */
		function addRefreshToken(parameters, refreshToken) {
		    parameters.set(REFRESH_TOKEN, refreshToken);
		}
		/**
		 * add the `code_verifier` passed by the user to exchange for a token
		 * @param codeVerifier
		 */
		function addCodeVerifier(parameters, codeVerifier) {
		    parameters.set(CODE_VERIFIER, codeVerifier);
		}
		/**
		 * add client_secret
		 * @param clientSecret
		 */
		function addClientSecret(parameters, clientSecret) {
		    parameters.set(CLIENT_SECRET, clientSecret);
		}
		/**
		 * add clientAssertion for confidential client flows
		 * @param clientAssertion
		 */
		function addClientAssertion(parameters, clientAssertion) {
		    if (clientAssertion) {
		        parameters.set(CLIENT_ASSERTION, clientAssertion);
		    }
		}
		/**
		 * add clientAssertionType for confidential client flows
		 * @param clientAssertionType
		 */
		function addClientAssertionType(parameters, clientAssertionType) {
		    if (clientAssertionType) {
		        parameters.set(CLIENT_ASSERTION_TYPE, clientAssertionType);
		    }
		}
		/**
		 * add OBO assertion for confidential client flows
		 * @param clientAssertion
		 */
		function addOboAssertion(parameters, oboAssertion) {
		    parameters.set(OBO_ASSERTION, oboAssertion);
		}
		/**
		 * add grant type
		 * @param grantType
		 */
		function addRequestTokenUse(parameters, tokenUse) {
		    parameters.set(REQUESTED_TOKEN_USE, tokenUse);
		}
		/**
		 * add grant type
		 * @param grantType
		 */
		function addGrantType(parameters, grantType) {
		    parameters.set(GRANT_TYPE, grantType);
		}
		/**
		 * add client info
		 *
		 */
		function addClientInfo(parameters) {
		    parameters.set(CLIENT_INFO, "1");
		}
		function addInstanceAware(parameters) {
		    if (!parameters.has(INSTANCE_AWARE)) {
		        parameters.set(INSTANCE_AWARE, "true");
		    }
		}
		/**
		 * add extraQueryParams
		 * @param eQParams
		 */
		function addExtraQueryParameters(parameters, eQParams) {
		    Object.entries(eQParams).forEach(([key, value]) => {
		        if (!parameters.has(key) && value) {
		            parameters.set(key, value);
		        }
		    });
		}
		function addClientCapabilitiesToClaims(claims, clientCapabilities) {
		    let mergedClaims;
		    // Parse provided claims into JSON object or initialize empty object
		    if (!claims) {
		        mergedClaims = {};
		    }
		    else {
		        try {
		            mergedClaims = JSON.parse(claims);
		        }
		        catch (e) {
		            throw createClientConfigurationError(invalidClaims);
		        }
		    }
		    if (clientCapabilities && clientCapabilities.length > 0) {
		        if (!mergedClaims.hasOwnProperty(ClaimsRequestKeys.ACCESS_TOKEN)) {
		            // Add access_token key to claims object
		            mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN] = {};
		        }
		        // Add xms_cc claim with provided clientCapabilities to access_token key
		        mergedClaims[ClaimsRequestKeys.ACCESS_TOKEN][ClaimsRequestKeys.XMS_CC] =
		            {
		                values: clientCapabilities,
		            };
		    }
		    return JSON.stringify(mergedClaims);
		}
		/**
		 * adds `username` for Password Grant flow
		 * @param username
		 */
		function addUsername(parameters, username) {
		    parameters.set(PasswordGrantConstants.username, username);
		}
		/**
		 * adds `password` for Password Grant flow
		 * @param password
		 */
		function addPassword(parameters, password) {
		    parameters.set(PasswordGrantConstants.password, password);
		}
		/**
		 * add pop_jwk to query params
		 * @param cnfString
		 */
		function addPopToken(parameters, cnfString) {
		    if (cnfString) {
		        parameters.set(TOKEN_TYPE, AuthenticationScheme.POP);
		        parameters.set(REQ_CNF, cnfString);
		    }
		}
		/**
		 * add SSH JWK and key ID to query params
		 */
		function addSshJwk(parameters, sshJwkString) {
		    if (sshJwkString) {
		        parameters.set(TOKEN_TYPE, AuthenticationScheme.SSH);
		        parameters.set(REQ_CNF, sshJwkString);
		    }
		}
		/**
		 * add server telemetry fields
		 * @param serverTelemetryManager
		 */
		function addServerTelemetry(parameters, serverTelemetryManager) {
		    parameters.set(X_CLIENT_CURR_TELEM, serverTelemetryManager.generateCurrentRequestHeaderValue());
		    parameters.set(X_CLIENT_LAST_TELEM, serverTelemetryManager.generateLastRequestHeaderValue());
		}
		/**
		 * Adds parameter that indicates to the server that throttling is supported
		 */
		function addThrottling(parameters) {
		    parameters.set(X_MS_LIB_CAPABILITY, ThrottlingConstants.X_MS_LIB_CAPABILITY_VALUE);
		}
		/**
		 * Adds logout_hint parameter for "silent" logout which prevent server account picker
		 */
		function addLogoutHint(parameters, logoutHint) {
		    parameters.set(LOGOUT_HINT, logoutHint);
		}
		function addBrokerParameters(parameters, brokerClientId, brokerRedirectUri) {
		    if (!parameters.has(BROKER_CLIENT_ID)) {
		        parameters.set(BROKER_CLIENT_ID, brokerClientId);
		    }
		    if (!parameters.has(BROKER_REDIRECT_URI)) {
		        parameters.set(BROKER_REDIRECT_URI, brokerRedirectUri);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function isOpenIdConfigResponse(response) {
		    return (response.hasOwnProperty("authorization_endpoint") &&
		        response.hasOwnProperty("token_endpoint") &&
		        response.hasOwnProperty("issuer") &&
		        response.hasOwnProperty("jwks_uri"));
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function isCloudInstanceDiscoveryResponse(response) {
		    return (response.hasOwnProperty("tenant_discovery_endpoint") &&
		        response.hasOwnProperty("metadata"));
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function isCloudInstanceDiscoveryErrorResponse(response) {
		    return (response.hasOwnProperty("error") &&
		        response.hasOwnProperty("error_description"));
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Wraps a function with a performance measurement.
		 * Usage: invoke(functionToCall, performanceClient, "EventName", "correlationId")(...argsToPassToFunction)
		 * @param callback
		 * @param eventName
		 * @param logger
		 * @param telemetryClient
		 * @param correlationId
		 * @returns
		 * @internal
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const invoke = (callback, eventName, logger, telemetryClient, correlationId) => {
		    return (...args) => {
		        logger.trace(`Executing function ${eventName}`);
		        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
		        if (correlationId) {
		            // Track number of times this API is called in a single request
		            const eventCount = eventName + "CallCount";
		            telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
		        }
		        try {
		            const result = callback(...args);
		            inProgressEvent?.end({
		                success: true,
		            });
		            logger.trace(`Returning result from ${eventName}`);
		            return result;
		        }
		        catch (e) {
		            logger.trace(`Error occurred in ${eventName}`);
		            try {
		                logger.trace(JSON.stringify(e));
		            }
		            catch (e) {
		                logger.trace("Unable to print error message.");
		            }
		            inProgressEvent?.end({
		                success: false,
		            }, e);
		            throw e;
		        }
		    };
		};
		/**
		 * Wraps an async function with a performance measurement.
		 * Usage: invokeAsync(functionToCall, performanceClient, "EventName", "correlationId")(...argsToPassToFunction)
		 * @param callback
		 * @param eventName
		 * @param logger
		 * @param telemetryClient
		 * @param correlationId
		 * @returns
		 * @internal
		 *
		 */
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		const invokeAsync = (callback, eventName, logger, telemetryClient, correlationId) => {
		    return (...args) => {
		        logger.trace(`Executing function ${eventName}`);
		        const inProgressEvent = telemetryClient?.startMeasurement(eventName, correlationId);
		        if (correlationId) {
		            // Track number of times this API is called in a single request
		            const eventCount = eventName + "CallCount";
		            telemetryClient?.incrementFields({ [eventCount]: 1 }, correlationId);
		        }
		        telemetryClient?.setPreQueueTime(eventName, correlationId);
		        return callback(...args)
		            .then((response) => {
		            logger.trace(`Returning result from ${eventName}`);
		            inProgressEvent?.end({
		                success: true,
		            });
		            return response;
		        })
		            .catch((e) => {
		            logger.trace(`Error occurred in ${eventName}`);
		            try {
		                logger.trace(JSON.stringify(e));
		            }
		            catch (e) {
		                logger.trace("Unable to print error message.");
		            }
		            inProgressEvent?.end({
		                success: false,
		            }, e);
		            throw e;
		        });
		    };
		};

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class RegionDiscovery {
		    constructor(networkInterface, logger, performanceClient, correlationId) {
		        this.networkInterface = networkInterface;
		        this.logger = logger;
		        this.performanceClient = performanceClient;
		        this.correlationId = correlationId;
		    }
		    /**
		     * Detect the region from the application's environment.
		     *
		     * @returns Promise<string | null>
		     */
		    async detectRegion(environmentRegion, regionDiscoveryMetadata) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryDetectRegion, this.correlationId);
		        // Initialize auto detected region with the region from the envrionment
		        let autodetectedRegionName = environmentRegion;
		        // Check if a region was detected from the environment, if not, attempt to get the region from IMDS
		        if (!autodetectedRegionName) {
		            const options = RegionDiscovery.IMDS_OPTIONS;
		            try {
		                const localIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(Constants$1.IMDS_VERSION, options);
		                if (localIMDSVersionResponse.status === HttpStatus.SUCCESS) {
		                    autodetectedRegionName = localIMDSVersionResponse.body;
		                    regionDiscoveryMetadata.region_source =
		                        RegionDiscoverySources.IMDS;
		                }
		                // If the response using the local IMDS version failed, try to fetch the current version of IMDS and retry.
		                if (localIMDSVersionResponse.status === HttpStatus.BAD_REQUEST) {
		                    const currentIMDSVersion = await invokeAsync(this.getCurrentVersion.bind(this), PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.logger, this.performanceClient, this.correlationId)(options);
		                    if (!currentIMDSVersion) {
		                        regionDiscoveryMetadata.region_source =
		                            RegionDiscoverySources.FAILED_AUTO_DETECTION;
		                        return null;
		                    }
		                    const currentIMDSVersionResponse = await invokeAsync(this.getRegionFromIMDS.bind(this), PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.logger, this.performanceClient, this.correlationId)(currentIMDSVersion, options);
		                    if (currentIMDSVersionResponse.status === HttpStatus.SUCCESS) {
		                        autodetectedRegionName =
		                            currentIMDSVersionResponse.body;
		                        regionDiscoveryMetadata.region_source =
		                            RegionDiscoverySources.IMDS;
		                    }
		                }
		            }
		            catch (e) {
		                regionDiscoveryMetadata.region_source =
		                    RegionDiscoverySources.FAILED_AUTO_DETECTION;
		                return null;
		            }
		        }
		        else {
		            regionDiscoveryMetadata.region_source =
		                RegionDiscoverySources.ENVIRONMENT_VARIABLE;
		        }
		        // If no region was auto detected from the environment or from the IMDS endpoint, mark the attempt as a FAILED_AUTO_DETECTION
		        if (!autodetectedRegionName) {
		            regionDiscoveryMetadata.region_source =
		                RegionDiscoverySources.FAILED_AUTO_DETECTION;
		        }
		        return autodetectedRegionName || null;
		    }
		    /**
		     * Make the call to the IMDS endpoint
		     *
		     * @param imdsEndpointUrl
		     * @returns Promise<NetworkResponse<string>>
		     */
		    async getRegionFromIMDS(version, options) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetRegionFromIMDS, this.correlationId);
		        return this.networkInterface.sendGetRequestAsync(`${Constants$1.IMDS_ENDPOINT}?api-version=${version}&format=text`, options, Constants$1.IMDS_TIMEOUT);
		    }
		    /**
		     * Get the most recent version of the IMDS endpoint available
		     *
		     * @returns Promise<string | null>
		     */
		    async getCurrentVersion(options) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RegionDiscoveryGetCurrentVersion, this.correlationId);
		        try {
		            const response = await this.networkInterface.sendGetRequestAsync(`${Constants$1.IMDS_ENDPOINT}?format=json`, options);
		            // When IMDS endpoint is called without the api version query param, bad request response comes back with latest version.
		            if (response.status === HttpStatus.BAD_REQUEST &&
		                response.body &&
		                response.body["newest-versions"] &&
		                response.body["newest-versions"].length > 0) {
		                return response.body["newest-versions"][0];
		            }
		            return null;
		        }
		        catch (e) {
		            return null;
		        }
		    }
		}
		// Options for the IMDS endpoint request
		RegionDiscovery.IMDS_OPTIONS = {
		    headers: {
		        Metadata: "true",
		    },
		};

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Utility functions for managing date and time operations.
		 */
		/**
		 * return the current time in Unix time (seconds).
		 */
		function nowSeconds() {
		    // Date.getTime() returns in milliseconds.
		    return Math.round(new Date().getTime() / 1000.0);
		}
		/**
		 * Convert seconds to JS Date object. Seconds can be in a number or string format or undefined (will still return a date).
		 * @param seconds
		 */
		function toDateFromSeconds(seconds) {
		    if (seconds) {
		        return new Date(Number(seconds) * 1000);
		    }
		    return new Date();
		}
		/**
		 * check if a token is expired based on given UTC time in seconds.
		 * @param expiresOn
		 */
		function isTokenExpired(expiresOn, offset) {
		    // check for access token expiry
		    const expirationSec = Number(expiresOn) || 0;
		    const offsetCurrentTimeSec = nowSeconds() + offset;
		    // If current time + offset is greater than token expiration time, then token is expired.
		    return offsetCurrentTimeSec > expirationSec;
		}
		/**
		 * If the current time is earlier than the time that a token was cached at, we must discard the token
		 * i.e. The system clock was turned back after acquiring the cached token
		 * @param cachedAt
		 * @param offset
		 */
		function wasClockTurnedBack(cachedAt) {
		    const cachedAtSec = Number(cachedAt);
		    return cachedAtSec > nowSeconds();
		}
		/**
		 * Waits for t number of milliseconds
		 * @param t number
		 * @param value T
		 */
		function delay(t, value) {
		    return new Promise((resolve) => setTimeout(() => resolve(value), t));
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Create IdTokenEntity
		 * @param homeAccountId
		 * @param authenticationResult
		 * @param clientId
		 * @param authority
		 */
		function createIdTokenEntity(homeAccountId, environment, idToken, clientId, tenantId) {
		    const idTokenEntity = {
		        credentialType: CredentialType.ID_TOKEN,
		        homeAccountId: homeAccountId,
		        environment: environment,
		        clientId: clientId,
		        secret: idToken,
		        realm: tenantId,
		        lastUpdatedAt: Date.now().toString(), // Set the last updated time to now
		    };
		    return idTokenEntity;
		}
		/**
		 * Create AccessTokenEntity
		 * @param homeAccountId
		 * @param environment
		 * @param accessToken
		 * @param clientId
		 * @param tenantId
		 * @param scopes
		 * @param expiresOn
		 * @param extExpiresOn
		 */
		function createAccessTokenEntity(homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, base64Decode, refreshOn, tokenType, userAssertionHash, keyId, requestedClaims, requestedClaimsHash) {
		    const atEntity = {
		        homeAccountId: homeAccountId,
		        credentialType: CredentialType.ACCESS_TOKEN,
		        secret: accessToken,
		        cachedAt: nowSeconds().toString(),
		        expiresOn: expiresOn.toString(),
		        extendedExpiresOn: extExpiresOn.toString(),
		        environment: environment,
		        clientId: clientId,
		        realm: tenantId,
		        target: scopes,
		        tokenType: tokenType || AuthenticationScheme.BEARER,
		        lastUpdatedAt: Date.now().toString(), // Set the last updated time to now
		    };
		    if (userAssertionHash) {
		        atEntity.userAssertionHash = userAssertionHash;
		    }
		    if (refreshOn) {
		        atEntity.refreshOn = refreshOn.toString();
		    }
		    if (requestedClaims) {
		        atEntity.requestedClaims = requestedClaims;
		        atEntity.requestedClaimsHash = requestedClaimsHash;
		    }
		    /*
		     * Create Access Token With Auth Scheme instead of regular access token
		     * Cast to lower to handle "bearer" from ADFS
		     */
		    if (atEntity.tokenType?.toLowerCase() !==
		        AuthenticationScheme.BEARER.toLowerCase()) {
		        atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;
		        switch (atEntity.tokenType) {
		            case AuthenticationScheme.POP:
		                // Make sure keyId is present and add it to credential
		                const tokenClaims = extractTokenClaims(accessToken, base64Decode);
		                if (!tokenClaims?.cnf?.kid) {
		                    throw createClientAuthError(tokenClaimsCnfRequiredForSignedJwt);
		                }
		                atEntity.keyId = tokenClaims.cnf.kid;
		                break;
		            case AuthenticationScheme.SSH:
		                atEntity.keyId = keyId;
		        }
		    }
		    return atEntity;
		}
		/**
		 * Create RefreshTokenEntity
		 * @param homeAccountId
		 * @param authenticationResult
		 * @param clientId
		 * @param authority
		 */
		function createRefreshTokenEntity(homeAccountId, environment, refreshToken, clientId, familyId, userAssertionHash, expiresOn) {
		    const rtEntity = {
		        credentialType: CredentialType.REFRESH_TOKEN,
		        homeAccountId: homeAccountId,
		        environment: environment,
		        clientId: clientId,
		        secret: refreshToken,
		        lastUpdatedAt: Date.now().toString(),
		    };
		    if (userAssertionHash) {
		        rtEntity.userAssertionHash = userAssertionHash;
		    }
		    if (familyId) {
		        rtEntity.familyId = familyId;
		    }
		    if (expiresOn) {
		        rtEntity.expiresOn = expiresOn.toString();
		    }
		    return rtEntity;
		}
		function isCredentialEntity(entity) {
		    return (entity.hasOwnProperty("homeAccountId") &&
		        entity.hasOwnProperty("environment") &&
		        entity.hasOwnProperty("credentialType") &&
		        entity.hasOwnProperty("clientId") &&
		        entity.hasOwnProperty("secret"));
		}
		/**
		 * Validates an entity: checks for all expected params
		 * @param entity
		 */
		function isAccessTokenEntity(entity) {
		    if (!entity) {
		        return false;
		    }
		    return (isCredentialEntity(entity) &&
		        entity.hasOwnProperty("realm") &&
		        entity.hasOwnProperty("target") &&
		        (entity["credentialType"] === CredentialType.ACCESS_TOKEN ||
		            entity["credentialType"] ===
		                CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME));
		}
		/**
		 * Validates an entity: checks for all expected params
		 * @param entity
		 */
		function isIdTokenEntity(entity) {
		    if (!entity) {
		        return false;
		    }
		    return (isCredentialEntity(entity) &&
		        entity.hasOwnProperty("realm") &&
		        entity["credentialType"] === CredentialType.ID_TOKEN);
		}
		/**
		 * Validates an entity: checks for all expected params
		 * @param entity
		 */
		function isRefreshTokenEntity(entity) {
		    if (!entity) {
		        return false;
		    }
		    return (isCredentialEntity(entity) &&
		        entity["credentialType"] === CredentialType.REFRESH_TOKEN);
		}
		/**
		 * validates if a given cache entry is "Telemetry", parses <key,value>
		 * @param key
		 * @param entity
		 */
		function isServerTelemetryEntity(key, entity) {
		    const validateKey = key.indexOf(SERVER_TELEM_CONSTANTS.CACHE_KEY) === 0;
		    let validateEntity = true;
		    if (entity) {
		        validateEntity =
		            entity.hasOwnProperty("failedRequests") &&
		                entity.hasOwnProperty("errors") &&
		                entity.hasOwnProperty("cacheHits");
		    }
		    return validateKey && validateEntity;
		}
		/**
		 * validates if a given cache entry is "Throttling", parses <key,value>
		 * @param key
		 * @param entity
		 */
		function isThrottlingEntity(key, entity) {
		    let validateKey = false;
		    if (key) {
		        validateKey = key.indexOf(ThrottlingConstants.THROTTLING_PREFIX) === 0;
		    }
		    let validateEntity = true;
		    if (entity) {
		        validateEntity = entity.hasOwnProperty("throttleTime");
		    }
		    return validateKey && validateEntity;
		}
		/**
		 * Generate AppMetadata Cache Key as per the schema: appmetadata-<environment>-<client_id>
		 */
		function generateAppMetadataKey({ environment, clientId, }) {
		    const appMetaDataKeyArray = [
		        APP_METADATA,
		        environment,
		        clientId,
		    ];
		    return appMetaDataKeyArray
		        .join(Separators.CACHE_KEY_SEPARATOR)
		        .toLowerCase();
		}
		/*
		 * Validates an entity: checks for all expected params
		 * @param entity
		 */
		function isAppMetadataEntity(key, entity) {
		    if (!entity) {
		        return false;
		    }
		    return (key.indexOf(APP_METADATA) === 0 &&
		        entity.hasOwnProperty("clientId") &&
		        entity.hasOwnProperty("environment"));
		}
		/**
		 * Validates an entity: checks for all expected params
		 * @param entity
		 */
		function isAuthorityMetadataEntity(key, entity) {
		    if (!entity) {
		        return false;
		    }
		    return (key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) === 0 &&
		        entity.hasOwnProperty("aliases") &&
		        entity.hasOwnProperty("preferred_cache") &&
		        entity.hasOwnProperty("preferred_network") &&
		        entity.hasOwnProperty("canonical_authority") &&
		        entity.hasOwnProperty("authorization_endpoint") &&
		        entity.hasOwnProperty("token_endpoint") &&
		        entity.hasOwnProperty("issuer") &&
		        entity.hasOwnProperty("aliasesFromNetwork") &&
		        entity.hasOwnProperty("endpointsFromNetwork") &&
		        entity.hasOwnProperty("expiresAt") &&
		        entity.hasOwnProperty("jwks_uri"));
		}
		/**
		 * Reset the exiresAt value
		 */
		function generateAuthorityMetadataExpiresAt() {
		    return (nowSeconds() +
		        AUTHORITY_METADATA_CONSTANTS.REFRESH_TIME_SECONDS);
		}
		function updateAuthorityEndpointMetadata(authorityMetadata, updatedValues, fromNetwork) {
		    authorityMetadata.authorization_endpoint =
		        updatedValues.authorization_endpoint;
		    authorityMetadata.token_endpoint = updatedValues.token_endpoint;
		    authorityMetadata.end_session_endpoint = updatedValues.end_session_endpoint;
		    authorityMetadata.issuer = updatedValues.issuer;
		    authorityMetadata.endpointsFromNetwork = fromNetwork;
		    authorityMetadata.jwks_uri = updatedValues.jwks_uri;
		}
		function updateCloudDiscoveryMetadata(authorityMetadata, updatedValues, fromNetwork) {
		    authorityMetadata.aliases = updatedValues.aliases;
		    authorityMetadata.preferred_cache = updatedValues.preferred_cache;
		    authorityMetadata.preferred_network = updatedValues.preferred_network;
		    authorityMetadata.aliasesFromNetwork = fromNetwork;
		}
		/**
		 * Returns whether or not the data needs to be refreshed
		 */
		function isAuthorityMetadataExpired(metadata) {
		    return metadata.expiresAt <= nowSeconds();
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * The authority class validates the authority URIs used by the user, and retrieves the OpenID Configuration Data from the
		 * endpoint. It will store the pertinent config data in this object for use during token calls.
		 * @internal
		 */
		class Authority {
		    constructor(authority, networkInterface, cacheManager, authorityOptions, logger, correlationId, performanceClient, managedIdentity) {
		        this.canonicalAuthority = authority;
		        this._canonicalAuthority.validateAsUri();
		        this.networkInterface = networkInterface;
		        this.cacheManager = cacheManager;
		        this.authorityOptions = authorityOptions;
		        this.regionDiscoveryMetadata = {
		            region_used: undefined,
		            region_source: undefined,
		            region_outcome: undefined,
		        };
		        this.logger = logger;
		        this.performanceClient = performanceClient;
		        this.correlationId = correlationId;
		        this.managedIdentity = managedIdentity || false;
		        this.regionDiscovery = new RegionDiscovery(networkInterface, this.logger, this.performanceClient, this.correlationId);
		    }
		    /**
		     * Get {@link AuthorityType}
		     * @param authorityUri {@link IUri}
		     * @private
		     */
		    getAuthorityType(authorityUri) {
		        // CIAM auth url pattern is being standardized as: <tenant>.ciamlogin.com
		        if (authorityUri.HostNameAndPort.endsWith(Constants$1.CIAM_AUTH_URL)) {
		            return AuthorityType.Ciam;
		        }
		        const pathSegments = authorityUri.PathSegments;
		        if (pathSegments.length) {
		            switch (pathSegments[0].toLowerCase()) {
		                case Constants$1.ADFS:
		                    return AuthorityType.Adfs;
		                case Constants$1.DSTS:
		                    return AuthorityType.Dsts;
		            }
		        }
		        return AuthorityType.Default;
		    }
		    // See above for AuthorityType
		    get authorityType() {
		        return this.getAuthorityType(this.canonicalAuthorityUrlComponents);
		    }
		    /**
		     * ProtocolMode enum representing the way endpoints are constructed.
		     */
		    get protocolMode() {
		        return this.authorityOptions.protocolMode;
		    }
		    /**
		     * Returns authorityOptions which can be used to reinstantiate a new authority instance
		     */
		    get options() {
		        return this.authorityOptions;
		    }
		    /**
		     * A URL that is the authority set by the developer
		     */
		    get canonicalAuthority() {
		        return this._canonicalAuthority.urlString;
		    }
		    /**
		     * Sets canonical authority.
		     */
		    set canonicalAuthority(url) {
		        this._canonicalAuthority = new UrlString(url);
		        this._canonicalAuthority.validateAsUri();
		        this._canonicalAuthorityUrlComponents = null;
		    }
		    /**
		     * Get authority components.
		     */
		    get canonicalAuthorityUrlComponents() {
		        if (!this._canonicalAuthorityUrlComponents) {
		            this._canonicalAuthorityUrlComponents =
		                this._canonicalAuthority.getUrlComponents();
		        }
		        return this._canonicalAuthorityUrlComponents;
		    }
		    /**
		     * Get hostname and port i.e. login.microsoftonline.com
		     */
		    get hostnameAndPort() {
		        return this.canonicalAuthorityUrlComponents.HostNameAndPort.toLowerCase();
		    }
		    /**
		     * Get tenant for authority.
		     */
		    get tenant() {
		        return this.canonicalAuthorityUrlComponents.PathSegments[0];
		    }
		    /**
		     * OAuth /authorize endpoint for requests
		     */
		    get authorizationEndpoint() {
		        if (this.discoveryComplete()) {
		            return this.replacePath(this.metadata.authorization_endpoint);
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * OAuth /token endpoint for requests
		     */
		    get tokenEndpoint() {
		        if (this.discoveryComplete()) {
		            return this.replacePath(this.metadata.token_endpoint);
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    get deviceCodeEndpoint() {
		        if (this.discoveryComplete()) {
		            return this.replacePath(this.metadata.token_endpoint.replace("/token", "/devicecode"));
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * OAuth logout endpoint for requests
		     */
		    get endSessionEndpoint() {
		        if (this.discoveryComplete()) {
		            // ROPC policies may not have end_session_endpoint set
		            if (!this.metadata.end_session_endpoint) {
		                throw createClientAuthError(endSessionEndpointNotSupported);
		            }
		            return this.replacePath(this.metadata.end_session_endpoint);
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * OAuth issuer for requests
		     */
		    get selfSignedJwtAudience() {
		        if (this.discoveryComplete()) {
		            return this.replacePath(this.metadata.issuer);
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * Jwks_uri for token signing keys
		     */
		    get jwksUri() {
		        if (this.discoveryComplete()) {
		            return this.replacePath(this.metadata.jwks_uri);
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * Returns a flag indicating that tenant name can be replaced in authority {@link IUri}
		     * @param authorityUri {@link IUri}
		     * @private
		     */
		    canReplaceTenant(authorityUri) {
		        return (authorityUri.PathSegments.length === 1 &&
		            !Authority.reservedTenantDomains.has(authorityUri.PathSegments[0]) &&
		            this.getAuthorityType(authorityUri) === AuthorityType.Default &&
		            this.protocolMode !== ProtocolMode.OIDC);
		    }
		    /**
		     * Replaces tenant in url path with current tenant. Defaults to common.
		     * @param urlString
		     */
		    replaceTenant(urlString) {
		        return urlString.replace(/{tenant}|{tenantid}/g, this.tenant);
		    }
		    /**
		     * Replaces path such as tenant or policy with the current tenant or policy.
		     * @param urlString
		     */
		    replacePath(urlString) {
		        let endpoint = urlString;
		        const cachedAuthorityUrl = new UrlString(this.metadata.canonical_authority);
		        const cachedAuthorityUrlComponents = cachedAuthorityUrl.getUrlComponents();
		        const cachedAuthorityParts = cachedAuthorityUrlComponents.PathSegments;
		        const currentAuthorityParts = this.canonicalAuthorityUrlComponents.PathSegments;
		        currentAuthorityParts.forEach((currentPart, index) => {
		            let cachedPart = cachedAuthorityParts[index];
		            if (index === 0 &&
		                this.canReplaceTenant(cachedAuthorityUrlComponents)) {
		                const tenantId = new UrlString(this.metadata.authorization_endpoint).getUrlComponents().PathSegments[0];
		                /**
		                 * Check if AAD canonical authority contains tenant domain name, for example "testdomain.onmicrosoft.com",
		                 * by comparing its first path segment to the corresponding authorization endpoint path segment, which is
		                 * always resolved with tenant id by OIDC.
		                 */
		                if (cachedPart !== tenantId) {
		                    this.logger.verbose(`Replacing tenant domain name ${cachedPart} with id ${tenantId}`);
		                    cachedPart = tenantId;
		                }
		            }
		            if (currentPart !== cachedPart) {
		                endpoint = endpoint.replace(`/${cachedPart}/`, `/${currentPart}/`);
		            }
		        });
		        return this.replaceTenant(endpoint);
		    }
		    /**
		     * The default open id configuration endpoint for any canonical authority.
		     */
		    get defaultOpenIdConfigurationEndpoint() {
		        const canonicalAuthorityHost = this.hostnameAndPort;
		        if (this.canonicalAuthority.endsWith("v2.0/") ||
		            this.authorityType === AuthorityType.Adfs ||
		            (this.protocolMode === ProtocolMode.OIDC &&
		                !this.isAliasOfKnownMicrosoftAuthority(canonicalAuthorityHost))) {
		            return `${this.canonicalAuthority}.well-known/openid-configuration`;
		        }
		        return `${this.canonicalAuthority}v2.0/.well-known/openid-configuration`;
		    }
		    /**
		     * Boolean that returns whether or not tenant discovery has been completed.
		     */
		    discoveryComplete() {
		        return !!this.metadata;
		    }
		    /**
		     * Perform endpoint discovery to discover aliases, preferred_cache, preferred_network
		     * and the /authorize, /token and logout endpoints.
		     */
		    async resolveEndpointsAsync() {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityResolveEndpointsAsync, this.correlationId);
		        const metadataEntity = this.getCurrentMetadataEntity();
		        const cloudDiscoverySource = await invokeAsync(this.updateCloudDiscoveryMetadata.bind(this), PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
		        this.canonicalAuthority = this.canonicalAuthority.replace(this.hostnameAndPort, metadataEntity.preferred_network);
		        const endpointSource = await invokeAsync(this.updateEndpointMetadata.bind(this), PerformanceEvents.AuthorityUpdateEndpointMetadata, this.logger, this.performanceClient, this.correlationId)(metadataEntity);
		        this.updateCachedMetadata(metadataEntity, cloudDiscoverySource, {
		            source: endpointSource,
		        });
		        this.performanceClient?.addFields({
		            cloudDiscoverySource: cloudDiscoverySource,
		            authorityEndpointSource: endpointSource,
		        }, this.correlationId);
		    }
		    /**
		     * Returns metadata entity from cache if it exists, otherwiser returns a new metadata entity built
		     * from the configured canonical authority
		     * @returns
		     */
		    getCurrentMetadataEntity() {
		        let metadataEntity = this.cacheManager.getAuthorityMetadataByAlias(this.hostnameAndPort);
		        if (!metadataEntity) {
		            metadataEntity = {
		                aliases: [],
		                preferred_cache: this.hostnameAndPort,
		                preferred_network: this.hostnameAndPort,
		                canonical_authority: this.canonicalAuthority,
		                authorization_endpoint: "",
		                token_endpoint: "",
		                end_session_endpoint: "",
		                issuer: "",
		                aliasesFromNetwork: false,
		                endpointsFromNetwork: false,
		                expiresAt: generateAuthorityMetadataExpiresAt(),
		                jwks_uri: "",
		            };
		        }
		        return metadataEntity;
		    }
		    /**
		     * Updates cached metadata based on metadata source and sets the instance's metadata
		     * property to the same value
		     * @param metadataEntity
		     * @param cloudDiscoverySource
		     * @param endpointMetadataResult
		     */
		    updateCachedMetadata(metadataEntity, cloudDiscoverySource, endpointMetadataResult) {
		        if (cloudDiscoverySource !== AuthorityMetadataSource.CACHE &&
		            endpointMetadataResult?.source !== AuthorityMetadataSource.CACHE) {
		            // Reset the expiration time unless both values came from a successful cache lookup
		            metadataEntity.expiresAt =
		                generateAuthorityMetadataExpiresAt();
		            metadataEntity.canonical_authority = this.canonicalAuthority;
		        }
		        const cacheKey = this.cacheManager.generateAuthorityMetadataCacheKey(metadataEntity.preferred_cache);
		        this.cacheManager.setAuthorityMetadata(cacheKey, metadataEntity);
		        this.metadata = metadataEntity;
		    }
		    /**
		     * Update AuthorityMetadataEntity with new endpoints and return where the information came from
		     * @param metadataEntity
		     */
		    async updateEndpointMetadata(metadataEntity) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateEndpointMetadata, this.correlationId);
		        const localMetadata = this.updateEndpointMetadataFromLocalSources(metadataEntity);
		        // Further update may be required for hardcoded metadata if regional metadata is preferred
		        if (localMetadata) {
		            if (localMetadata.source ===
		                AuthorityMetadataSource.HARDCODED_VALUES) {
		                // If the user prefers to use an azure region replace the global endpoints with regional information.
		                if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
		                    if (localMetadata.metadata) {
		                        const hardcodedMetadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(localMetadata.metadata);
		                        updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
		                        metadataEntity.canonical_authority =
		                            this.canonicalAuthority;
		                    }
		                }
		            }
		            return localMetadata.source;
		        }
		        // Get metadata from network if local sources aren't available
		        let metadata = await invokeAsync(this.getEndpointMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
		        if (metadata) {
		            // If the user prefers to use an azure region replace the global endpoints with regional information.
		            if (this.authorityOptions.azureRegionConfiguration?.azureRegion) {
		                metadata = await invokeAsync(this.updateMetadataWithRegionalInformation.bind(this), PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.logger, this.performanceClient, this.correlationId)(metadata);
		            }
		            updateAuthorityEndpointMetadata(metadataEntity, metadata, true);
		            return AuthorityMetadataSource.NETWORK;
		        }
		        else {
		            // Metadata could not be obtained from the config, cache, network or hardcoded values
		            throw createClientAuthError(openIdConfigError, this.defaultOpenIdConfigurationEndpoint);
		        }
		    }
		    /**
		     * Updates endpoint metadata from local sources and returns where the information was retrieved from and the metadata config
		     * response if the source is hardcoded metadata
		     * @param metadataEntity
		     * @returns
		     */
		    updateEndpointMetadataFromLocalSources(metadataEntity) {
		        this.logger.verbose("Attempting to get endpoint metadata from authority configuration");
		        const configMetadata = this.getEndpointMetadataFromConfig();
		        if (configMetadata) {
		            this.logger.verbose("Found endpoint metadata in authority configuration");
		            updateAuthorityEndpointMetadata(metadataEntity, configMetadata, false);
		            return {
		                source: AuthorityMetadataSource.CONFIG,
		            };
		        }
		        this.logger.verbose("Did not find endpoint metadata in the config... Attempting to get endpoint metadata from the hardcoded values.");
		        // skipAuthorityMetadataCache is used to bypass hardcoded authority metadata and force a network metadata cache lookup and network metadata request if no cached response is available.
		        if (this.authorityOptions.skipAuthorityMetadataCache) {
		            this.logger.verbose("Skipping hardcoded metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get endpoint metadata from the network metadata cache.");
		        }
		        else {
		            const hardcodedMetadata = this.getEndpointMetadataFromHardcodedValues();
		            if (hardcodedMetadata) {
		                updateAuthorityEndpointMetadata(metadataEntity, hardcodedMetadata, false);
		                return {
		                    source: AuthorityMetadataSource.HARDCODED_VALUES,
		                    metadata: hardcodedMetadata,
		                };
		            }
		            else {
		                this.logger.verbose("Did not find endpoint metadata in hardcoded values... Attempting to get endpoint metadata from the network metadata cache.");
		            }
		        }
		        // Check cached metadata entity expiration status
		        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
		        if (this.isAuthoritySameType(metadataEntity) &&
		            metadataEntity.endpointsFromNetwork &&
		            !metadataEntityExpired) {
		            // No need to update
		            this.logger.verbose("Found endpoint metadata in the cache.");
		            return { source: AuthorityMetadataSource.CACHE };
		        }
		        else if (metadataEntityExpired) {
		            this.logger.verbose("The metadata entity is expired.");
		        }
		        return null;
		    }
		    /**
		     * Compares the number of url components after the domain to determine if the cached
		     * authority metadata can be used for the requested authority. Protects against same domain different
		     * authority such as login.microsoftonline.com/tenant and login.microsoftonline.com/tfp/tenant/policy
		     * @param metadataEntity
		     */
		    isAuthoritySameType(metadataEntity) {
		        const cachedAuthorityUrl = new UrlString(metadataEntity.canonical_authority);
		        const cachedParts = cachedAuthorityUrl.getUrlComponents().PathSegments;
		        return (cachedParts.length ===
		            this.canonicalAuthorityUrlComponents.PathSegments.length);
		    }
		    /**
		     * Parse authorityMetadata config option
		     */
		    getEndpointMetadataFromConfig() {
		        if (this.authorityOptions.authorityMetadata) {
		            try {
		                return JSON.parse(this.authorityOptions.authorityMetadata);
		            }
		            catch (e) {
		                throw createClientConfigurationError(invalidAuthorityMetadata);
		            }
		        }
		        return null;
		    }
		    /**
		     * Gets OAuth endpoints from the given OpenID configuration endpoint.
		     *
		     * @param hasHardcodedMetadata boolean
		     */
		    async getEndpointMetadataFromNetwork() {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetEndpointMetadataFromNetwork, this.correlationId);
		        const options = {};
		        /*
		         * TODO: Add a timeout if the authority exists in our library's
		         * hardcoded list of metadata
		         */
		        const openIdConfigurationEndpoint = this.defaultOpenIdConfigurationEndpoint;
		        this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: attempting to retrieve OAuth endpoints from ${openIdConfigurationEndpoint}`);
		        try {
		            const response = await this.networkInterface.sendGetRequestAsync(openIdConfigurationEndpoint, options);
		            const isValidResponse = isOpenIdConfigResponse(response.body);
		            if (isValidResponse) {
		                return response.body;
		            }
		            else {
		                this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: could not parse response as OpenID configuration`);
		                return null;
		            }
		        }
		        catch (e) {
		            this.logger.verbose(`Authority.getEndpointMetadataFromNetwork: ${e}`);
		            return null;
		        }
		    }
		    /**
		     * Get OAuth endpoints for common authorities.
		     */
		    getEndpointMetadataFromHardcodedValues() {
		        if (this.hostnameAndPort in EndpointMetadata) {
		            return EndpointMetadata[this.hostnameAndPort];
		        }
		        return null;
		    }
		    /**
		     * Update the retrieved metadata with regional information.
		     * User selected Azure region will be used if configured.
		     */
		    async updateMetadataWithRegionalInformation(metadata) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateMetadataWithRegionalInformation, this.correlationId);
		        const userConfiguredAzureRegion = this.authorityOptions.azureRegionConfiguration?.azureRegion;
		        if (userConfiguredAzureRegion) {
		            if (userConfiguredAzureRegion !==
		                Constants$1.AZURE_REGION_AUTO_DISCOVER_FLAG) {
		                this.regionDiscoveryMetadata.region_outcome =
		                    RegionDiscoveryOutcomes.CONFIGURED_NO_AUTO_DETECTION;
		                this.regionDiscoveryMetadata.region_used =
		                    userConfiguredAzureRegion;
		                return Authority.replaceWithRegionalInformation(metadata, userConfiguredAzureRegion);
		            }
		            const autodetectedRegionName = await invokeAsync(this.regionDiscovery.detectRegion.bind(this.regionDiscovery), PerformanceEvents.RegionDiscoveryDetectRegion, this.logger, this.performanceClient, this.correlationId)(this.authorityOptions.azureRegionConfiguration
		                ?.environmentRegion, this.regionDiscoveryMetadata);
		            if (autodetectedRegionName) {
		                this.regionDiscoveryMetadata.region_outcome =
		                    RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_SUCCESSFUL;
		                this.regionDiscoveryMetadata.region_used =
		                    autodetectedRegionName;
		                return Authority.replaceWithRegionalInformation(metadata, autodetectedRegionName);
		            }
		            this.regionDiscoveryMetadata.region_outcome =
		                RegionDiscoveryOutcomes.AUTO_DETECTION_REQUESTED_FAILED;
		        }
		        return metadata;
		    }
		    /**
		     * Updates the AuthorityMetadataEntity with new aliases, preferred_network and preferred_cache
		     * and returns where the information was retrieved from
		     * @param metadataEntity
		     * @returns AuthorityMetadataSource
		     */
		    async updateCloudDiscoveryMetadata(metadataEntity) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityUpdateCloudDiscoveryMetadata, this.correlationId);
		        const localMetadataSource = this.updateCloudDiscoveryMetadataFromLocalSources(metadataEntity);
		        if (localMetadataSource) {
		            return localMetadataSource;
		        }
		        // Fallback to network as metadata source
		        const metadata = await invokeAsync(this.getCloudDiscoveryMetadataFromNetwork.bind(this), PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.logger, this.performanceClient, this.correlationId)();
		        if (metadata) {
		            updateCloudDiscoveryMetadata(metadataEntity, metadata, true);
		            return AuthorityMetadataSource.NETWORK;
		        }
		        // Metadata could not be obtained from the config, cache, network or hardcoded values
		        throw createClientConfigurationError(untrustedAuthority);
		    }
		    updateCloudDiscoveryMetadataFromLocalSources(metadataEntity) {
		        this.logger.verbose("Attempting to get cloud discovery metadata  from authority configuration");
		        this.logger.verbosePii(`Known Authorities: ${this.authorityOptions.knownAuthorities ||
		            Constants$1.NOT_APPLICABLE}`);
		        this.logger.verbosePii(`Authority Metadata: ${this.authorityOptions.authorityMetadata ||
		            Constants$1.NOT_APPLICABLE}`);
		        this.logger.verbosePii(`Canonical Authority: ${metadataEntity.canonical_authority || Constants$1.NOT_APPLICABLE}`);
		        const metadata = this.getCloudDiscoveryMetadataFromConfig();
		        if (metadata) {
		            this.logger.verbose("Found cloud discovery metadata in authority configuration");
		            updateCloudDiscoveryMetadata(metadataEntity, metadata, false);
		            return AuthorityMetadataSource.CONFIG;
		        }
		        // If the cached metadata came from config but that config was not passed to this instance, we must go to hardcoded values
		        this.logger.verbose("Did not find cloud discovery metadata in the config... Attempting to get cloud discovery metadata from the hardcoded values.");
		        if (this.options.skipAuthorityMetadataCache) {
		            this.logger.verbose("Skipping hardcoded cloud discovery metadata cache since skipAuthorityMetadataCache is set to true. Attempting to get cloud discovery metadata from the network metadata cache.");
		        }
		        else {
		            const hardcodedMetadata = getCloudDiscoveryMetadataFromHardcodedValues(this.hostnameAndPort);
		            if (hardcodedMetadata) {
		                this.logger.verbose("Found cloud discovery metadata from hardcoded values.");
		                updateCloudDiscoveryMetadata(metadataEntity, hardcodedMetadata, false);
		                return AuthorityMetadataSource.HARDCODED_VALUES;
		            }
		            this.logger.verbose("Did not find cloud discovery metadata in hardcoded values... Attempting to get cloud discovery metadata from the network metadata cache.");
		        }
		        const metadataEntityExpired = isAuthorityMetadataExpired(metadataEntity);
		        if (this.isAuthoritySameType(metadataEntity) &&
		            metadataEntity.aliasesFromNetwork &&
		            !metadataEntityExpired) {
		            this.logger.verbose("Found cloud discovery metadata in the cache.");
		            // No need to update
		            return AuthorityMetadataSource.CACHE;
		        }
		        else if (metadataEntityExpired) {
		            this.logger.verbose("The metadata entity is expired.");
		        }
		        return null;
		    }
		    /**
		     * Parse cloudDiscoveryMetadata config or check knownAuthorities
		     */
		    getCloudDiscoveryMetadataFromConfig() {
		        // CIAM does not support cloud discovery metadata
		        if (this.authorityType === AuthorityType.Ciam) {
		            this.logger.verbose("CIAM authorities do not support cloud discovery metadata, generate the aliases from authority host.");
		            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
		        }
		        // Check if network response was provided in config
		        if (this.authorityOptions.cloudDiscoveryMetadata) {
		            this.logger.verbose("The cloud discovery metadata has been provided as a network response, in the config.");
		            try {
		                this.logger.verbose("Attempting to parse the cloud discovery metadata.");
		                const parsedResponse = JSON.parse(this.authorityOptions.cloudDiscoveryMetadata);
		                const metadata = getCloudDiscoveryMetadataFromNetworkResponse(parsedResponse.metadata, this.hostnameAndPort);
		                this.logger.verbose("Parsed the cloud discovery metadata.");
		                if (metadata) {
		                    this.logger.verbose("There is returnable metadata attached to the parsed cloud discovery metadata.");
		                    return metadata;
		                }
		                else {
		                    this.logger.verbose("There is no metadata attached to the parsed cloud discovery metadata.");
		                }
		            }
		            catch (e) {
		                this.logger.verbose("Unable to parse the cloud discovery metadata. Throwing Invalid Cloud Discovery Metadata Error.");
		                throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
		            }
		        }
		        // If cloudDiscoveryMetadata is empty or does not contain the host, check knownAuthorities
		        if (this.isInKnownAuthorities()) {
		            this.logger.verbose("The host is included in knownAuthorities. Creating new cloud discovery metadata from the host.");
		            return Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
		        }
		        return null;
		    }
		    /**
		     * Called to get metadata from network if CloudDiscoveryMetadata was not populated by config
		     *
		     * @param hasHardcodedMetadata boolean
		     */
		    async getCloudDiscoveryMetadataFromNetwork() {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityGetCloudDiscoveryMetadataFromNetwork, this.correlationId);
		        const instanceDiscoveryEndpoint = `${Constants$1.AAD_INSTANCE_DISCOVERY_ENDPT}${this.canonicalAuthority}oauth2/v2.0/authorize`;
		        const options = {};
		        /*
		         * TODO: Add a timeout if the authority exists in our library's
		         * hardcoded list of metadata
		         */
		        let match = null;
		        try {
		            const response = await this.networkInterface.sendGetRequestAsync(instanceDiscoveryEndpoint, options);
		            let typedResponseBody;
		            let metadata;
		            if (isCloudInstanceDiscoveryResponse(response.body)) {
		                typedResponseBody =
		                    response.body;
		                metadata = typedResponseBody.metadata;
		                this.logger.verbosePii(`tenant_discovery_endpoint is: ${typedResponseBody.tenant_discovery_endpoint}`);
		            }
		            else if (isCloudInstanceDiscoveryErrorResponse(response.body)) {
		                this.logger.warning(`A CloudInstanceDiscoveryErrorResponse was returned. The cloud instance discovery network request's status code is: ${response.status}`);
		                typedResponseBody =
		                    response.body;
		                if (typedResponseBody.error === Constants$1.INVALID_INSTANCE) {
		                    this.logger.error("The CloudInstanceDiscoveryErrorResponse error is invalid_instance.");
		                    return null;
		                }
		                this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error is ${typedResponseBody.error}`);
		                this.logger.warning(`The CloudInstanceDiscoveryErrorResponse error description is ${typedResponseBody.error_description}`);
		                this.logger.warning("Setting the value of the CloudInstanceDiscoveryMetadata (returned from the network) to []");
		                metadata = [];
		            }
		            else {
		                this.logger.error("AAD did not return a CloudInstanceDiscoveryResponse or CloudInstanceDiscoveryErrorResponse");
		                return null;
		            }
		            this.logger.verbose("Attempting to find a match between the developer's authority and the CloudInstanceDiscoveryMetadata returned from the network request.");
		            match = getCloudDiscoveryMetadataFromNetworkResponse(metadata, this.hostnameAndPort);
		        }
		        catch (error) {
		            if (error instanceof AuthError) {
		                this.logger.error(`There was a network error while attempting to get the cloud discovery instance metadata.\nError: ${error.errorCode}\nError Description: ${error.errorMessage}`);
		            }
		            else {
		                const typedError = error;
		                this.logger.error(`A non-MSALJS error was thrown while attempting to get the cloud instance discovery metadata.\nError: ${typedError.name}\nError Description: ${typedError.message}`);
		            }
		            return null;
		        }
		        // Custom Domain scenario, host is trusted because Instance Discovery call succeeded
		        if (!match) {
		            this.logger.warning("The developer's authority was not found within the CloudInstanceDiscoveryMetadata returned from the network request.");
		            this.logger.verbose("Creating custom Authority for custom domain scenario.");
		            match = Authority.createCloudDiscoveryMetadataFromHost(this.hostnameAndPort);
		        }
		        return match;
		    }
		    /**
		     * Helper function to determine if this host is included in the knownAuthorities config option
		     */
		    isInKnownAuthorities() {
		        const matches = this.authorityOptions.knownAuthorities.filter((authority) => {
		            return (authority &&
		                UrlString.getDomainFromUrl(authority).toLowerCase() ===
		                    this.hostnameAndPort);
		        });
		        return matches.length > 0;
		    }
		    /**
		     * helper function to populate the authority based on azureCloudOptions
		     * @param authorityString
		     * @param azureCloudOptions
		     */
		    static generateAuthority(authorityString, azureCloudOptions) {
		        let authorityAzureCloudInstance;
		        if (azureCloudOptions &&
		            azureCloudOptions.azureCloudInstance !== AzureCloudInstance.None) {
		            const tenant = azureCloudOptions.tenant
		                ? azureCloudOptions.tenant
		                : Constants$1.DEFAULT_COMMON_TENANT;
		            authorityAzureCloudInstance = `${azureCloudOptions.azureCloudInstance}/${tenant}/`;
		        }
		        return authorityAzureCloudInstance
		            ? authorityAzureCloudInstance
		            : authorityString;
		    }
		    /**
		     * Creates cloud discovery metadata object from a given host
		     * @param host
		     */
		    static createCloudDiscoveryMetadataFromHost(host) {
		        return {
		            preferred_network: host,
		            preferred_cache: host,
		            aliases: [host],
		        };
		    }
		    /**
		     * helper function to generate environment from authority object
		     */
		    getPreferredCache() {
		        if (this.managedIdentity) {
		            return Constants$1.DEFAULT_AUTHORITY_HOST;
		        }
		        else if (this.discoveryComplete()) {
		            return this.metadata.preferred_cache;
		        }
		        else {
		            throw createClientAuthError(endpointResolutionError);
		        }
		    }
		    /**
		     * Returns whether or not the provided host is an alias of this authority instance
		     * @param host
		     */
		    isAlias(host) {
		        return this.metadata.aliases.indexOf(host) > -1;
		    }
		    /**
		     * Returns whether or not the provided host is an alias of a known Microsoft authority for purposes of endpoint discovery
		     * @param host
		     */
		    isAliasOfKnownMicrosoftAuthority(host) {
		        return InstanceDiscoveryMetadataAliases.has(host);
		    }
		    /**
		     * Checks whether the provided host is that of a public cloud authority
		     *
		     * @param authority string
		     * @returns bool
		     */
		    static isPublicCloudAuthority(host) {
		        return Constants$1.KNOWN_PUBLIC_CLOUDS.indexOf(host) >= 0;
		    }
		    /**
		     * Rebuild the authority string with the region
		     *
		     * @param host string
		     * @param region string
		     */
		    static buildRegionalAuthorityString(host, region, queryString) {
		        // Create and validate a Url string object with the initial authority string
		        const authorityUrlInstance = new UrlString(host);
		        authorityUrlInstance.validateAsUri();
		        const authorityUrlParts = authorityUrlInstance.getUrlComponents();
		        let hostNameAndPort = `${region}.${authorityUrlParts.HostNameAndPort}`;
		        if (this.isPublicCloudAuthority(authorityUrlParts.HostNameAndPort)) {
		            hostNameAndPort = `${region}.${Constants$1.REGIONAL_AUTH_PUBLIC_CLOUD_SUFFIX}`;
		        }
		        // Include the query string portion of the url
		        const url = UrlString.constructAuthorityUriFromObject({
		            ...authorityUrlInstance.getUrlComponents(),
		            HostNameAndPort: hostNameAndPort,
		        }).urlString;
		        // Add the query string if a query string was provided
		        if (queryString)
		            return `${url}?${queryString}`;
		        return url;
		    }
		    /**
		     * Replace the endpoints in the metadata object with their regional equivalents.
		     *
		     * @param metadata OpenIdConfigResponse
		     * @param azureRegion string
		     */
		    static replaceWithRegionalInformation(metadata, azureRegion) {
		        const regionalMetadata = { ...metadata };
		        regionalMetadata.authorization_endpoint =
		            Authority.buildRegionalAuthorityString(regionalMetadata.authorization_endpoint, azureRegion);
		        regionalMetadata.token_endpoint =
		            Authority.buildRegionalAuthorityString(regionalMetadata.token_endpoint, azureRegion);
		        if (regionalMetadata.end_session_endpoint) {
		            regionalMetadata.end_session_endpoint =
		                Authority.buildRegionalAuthorityString(regionalMetadata.end_session_endpoint, azureRegion);
		        }
		        return regionalMetadata;
		    }
		    /**
		     * Transform CIAM_AUTHORIY as per the below rules:
		     * If no path segments found and it is a CIAM authority (hostname ends with .ciamlogin.com), then transform it
		     *
		     * NOTE: The transformation path should go away once STS supports CIAM with the format: `tenantIdorDomain.ciamlogin.com`
		     * `ciamlogin.com` can also change in the future and we should accommodate the same
		     *
		     * @param authority
		     */
		    static transformCIAMAuthority(authority) {
		        let ciamAuthority = authority;
		        const authorityUrl = new UrlString(authority);
		        const authorityUrlComponents = authorityUrl.getUrlComponents();
		        // check if transformation is needed
		        if (authorityUrlComponents.PathSegments.length === 0 &&
		            authorityUrlComponents.HostNameAndPort.endsWith(Constants$1.CIAM_AUTH_URL)) {
		            const tenantIdOrDomain = authorityUrlComponents.HostNameAndPort.split(".")[0];
		            ciamAuthority = `${ciamAuthority}${tenantIdOrDomain}${Constants$1.AAD_TENANT_DOMAIN_SUFFIX}`;
		        }
		        return ciamAuthority;
		    }
		}
		// Reserved tenant domain names that will not be replaced with tenant id
		Authority.reservedTenantDomains = new Set([
		    "{tenant}",
		    "{tenantid}",
		    AADAuthorityConstants.COMMON,
		    AADAuthorityConstants.CONSUMERS,
		    AADAuthorityConstants.ORGANIZATIONS,
		]);
		/**
		 * Extract tenantId from authority
		 */
		function getTenantFromAuthorityString(authority) {
		    const authorityUrl = new UrlString(authority);
		    const authorityUrlComponents = authorityUrl.getUrlComponents();
		    /**
		     * For credential matching purposes, tenantId is the last path segment of the authority URL:
		     *  AAD Authority - domain/tenantId -> Credentials are cached with realm = tenantId
		     *  B2C Authority - domain/{tenantId}?/.../policy -> Credentials are cached with realm = policy
		     *  tenantId is downcased because B2C policies can have mixed case but tfp claim is downcased
		     *
		     * Note that we may not have any path segments in certain OIDC scenarios.
		     */
		    const tenantId = authorityUrlComponents.PathSegments.slice(-1)[0]?.toLowerCase();
		    switch (tenantId) {
		        case AADAuthorityConstants.COMMON:
		        case AADAuthorityConstants.ORGANIZATIONS:
		        case AADAuthorityConstants.CONSUMERS:
		            return undefined;
		        default:
		            return tenantId;
		    }
		}
		function formatAuthorityUri(authorityUri) {
		    return authorityUri.endsWith(Constants$1.FORWARD_SLASH)
		        ? authorityUri
		        : `${authorityUri}${Constants$1.FORWARD_SLASH}`;
		}
		function buildStaticAuthorityOptions(authOptions) {
		    const rawCloudDiscoveryMetadata = authOptions.cloudDiscoveryMetadata;
		    let cloudDiscoveryMetadata = undefined;
		    if (rawCloudDiscoveryMetadata) {
		        try {
		            cloudDiscoveryMetadata = JSON.parse(rawCloudDiscoveryMetadata);
		        }
		        catch (e) {
		            throw createClientConfigurationError(invalidCloudDiscoveryMetadata);
		        }
		    }
		    return {
		        canonicalAuthority: authOptions.authority
		            ? formatAuthorityUri(authOptions.authority)
		            : undefined,
		        knownAuthorities: authOptions.knownAuthorities,
		        cloudDiscoveryMetadata: cloudDiscoveryMetadata,
		    };
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Create an authority object of the correct type based on the url
		 * Performs basic authority validation - checks to see if the authority is of a valid type (i.e. aad, b2c, adfs)
		 *
		 * Also performs endpoint discovery.
		 *
		 * @param authorityUri
		 * @param networkClient
		 * @param protocolMode
		 * @internal
		 */
		async function createDiscoveredInstance(authorityUri, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient) {
		    performanceClient?.addQueueMeasurement(PerformanceEvents.AuthorityFactoryCreateDiscoveredInstance, correlationId);
		    const authorityUriFinal = Authority.transformCIAMAuthority(formatAuthorityUri(authorityUri));
		    // Initialize authority and perform discovery endpoint check.
		    const acquireTokenAuthority = new Authority(authorityUriFinal, networkClient, cacheManager, authorityOptions, logger, correlationId, performanceClient);
		    try {
		        await invokeAsync(acquireTokenAuthority.resolveEndpointsAsync.bind(acquireTokenAuthority), PerformanceEvents.AuthorityResolveEndpointsAsync, logger, performanceClient, correlationId)();
		        return acquireTokenAuthority;
		    }
		    catch (e) {
		        throw createClientAuthError(endpointResolutionError);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Error thrown when there is an error with the server code, for example, unavailability.
		 */
		class ServerError extends AuthError {
		    constructor(errorCode, errorMessage, subError, errorNo, status) {
		        super(errorCode, errorMessage, subError);
		        this.name = "ServerError";
		        this.errorNo = errorNo;
		        this.status = status;
		        Object.setPrototypeOf(this, ServerError.prototype);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function getRequestThumbprint(clientId, request, homeAccountId) {
		    return {
		        clientId: clientId,
		        authority: request.authority,
		        scopes: request.scopes,
		        homeAccountIdentifier: homeAccountId,
		        claims: request.claims,
		        authenticationScheme: request.authenticationScheme,
		        resourceRequestMethod: request.resourceRequestMethod,
		        resourceRequestUri: request.resourceRequestUri,
		        shrClaims: request.shrClaims,
		        sshKid: request.sshKid,
		        embeddedClientId: request.embeddedClientId || request.tokenBodyParameters?.clientId,
		    };
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/** @internal */
		class ThrottlingUtils {
		    /**
		     * Prepares a RequestThumbprint to be stored as a key.
		     * @param thumbprint
		     */
		    static generateThrottlingStorageKey(thumbprint) {
		        return `${ThrottlingConstants.THROTTLING_PREFIX}.${JSON.stringify(thumbprint)}`;
		    }
		    /**
		     * Performs necessary throttling checks before a network request.
		     * @param cacheManager
		     * @param thumbprint
		     */
		    static preProcess(cacheManager, thumbprint, correlationId) {
		        const key = ThrottlingUtils.generateThrottlingStorageKey(thumbprint);
		        const value = cacheManager.getThrottlingCache(key);
		        if (value) {
		            if (value.throttleTime < Date.now()) {
		                cacheManager.removeItem(key, correlationId);
		                return;
		            }
		            throw new ServerError(value.errorCodes?.join(" ") || Constants$1.EMPTY_STRING, value.errorMessage, value.subError);
		        }
		    }
		    /**
		     * Performs necessary throttling checks after a network request.
		     * @param cacheManager
		     * @param thumbprint
		     * @param response
		     */
		    static postProcess(cacheManager, thumbprint, response, correlationId) {
		        if (ThrottlingUtils.checkResponseStatus(response) ||
		            ThrottlingUtils.checkResponseForRetryAfter(response)) {
		            const thumbprintValue = {
		                throttleTime: ThrottlingUtils.calculateThrottleTime(parseInt(response.headers[HeaderNames.RETRY_AFTER])),
		                error: response.body.error,
		                errorCodes: response.body.error_codes,
		                errorMessage: response.body.error_description,
		                subError: response.body.suberror,
		            };
		            cacheManager.setThrottlingCache(ThrottlingUtils.generateThrottlingStorageKey(thumbprint), thumbprintValue, correlationId);
		        }
		    }
		    /**
		     * Checks a NetworkResponse object's status codes against 429 or 5xx
		     * @param response
		     */
		    static checkResponseStatus(response) {
		        return (response.status === 429 ||
		            (response.status >= 500 && response.status < 600));
		    }
		    /**
		     * Checks a NetworkResponse object's RetryAfter header
		     * @param response
		     */
		    static checkResponseForRetryAfter(response) {
		        if (response.headers) {
		            return (response.headers.hasOwnProperty(HeaderNames.RETRY_AFTER) &&
		                (response.status < 200 || response.status >= 300));
		        }
		        return false;
		    }
		    /**
		     * Calculates the Unix-time value for a throttle to expire given throttleTime in seconds.
		     * @param throttleTime
		     */
		    static calculateThrottleTime(throttleTime) {
		        const time = throttleTime <= 0 ? 0 : throttleTime;
		        const currentSeconds = Date.now() / 1000;
		        return Math.floor(Math.min(currentSeconds +
		            (time || ThrottlingConstants.DEFAULT_THROTTLE_TIME_SECONDS), currentSeconds +
		            ThrottlingConstants.DEFAULT_MAX_THROTTLE_TIME_SECONDS) * 1000);
		    }
		    static removeThrottle(cacheManager, clientId, request, homeAccountIdentifier) {
		        const thumbprint = getRequestThumbprint(clientId, request, homeAccountIdentifier);
		        const key = this.generateThrottlingStorageKey(thumbprint);
		        cacheManager.removeItem(key, request.correlationId);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Represents network related errors
		 */
		class NetworkError extends AuthError {
		    constructor(error, httpStatus, responseHeaders) {
		        super(error.errorCode, error.errorMessage, error.subError);
		        Object.setPrototypeOf(this, NetworkError.prototype);
		        this.name = "NetworkError";
		        this.error = error;
		        this.httpStatus = httpStatus;
		        this.responseHeaders = responseHeaders;
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Base application class which will construct requests to send to and handle responses from the Microsoft STS using the authorization code flow.
		 * @internal
		 */
		class BaseClient {
		    constructor(configuration, performanceClient) {
		        // Set the configuration
		        this.config = buildClientConfiguration(configuration);
		        // Initialize the logger
		        this.logger = new Logger(this.config.loggerOptions, name$1, version$1);
		        // Initialize crypto
		        this.cryptoUtils = this.config.cryptoInterface;
		        // Initialize storage interface
		        this.cacheManager = this.config.storageInterface;
		        // Set the network interface
		        this.networkClient = this.config.networkInterface;
		        // Set TelemetryManager
		        this.serverTelemetryManager = this.config.serverTelemetryManager;
		        // set Authority
		        this.authority = this.config.authOptions.authority;
		        // set performance telemetry client
		        this.performanceClient = performanceClient;
		    }
		    /**
		     * Creates default headers for requests to token endpoint
		     */
		    createTokenRequestHeaders(ccsCred) {
		        const headers = {};
		        headers[HeaderNames.CONTENT_TYPE] = Constants$1.URL_FORM_CONTENT_TYPE;
		        if (!this.config.systemOptions.preventCorsPreflight && ccsCred) {
		            switch (ccsCred.type) {
		                case CcsCredentialType.HOME_ACCOUNT_ID:
		                    try {
		                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
		                        headers[HeaderNames.CCS_HEADER] = `Oid:${clientInfo.uid}@${clientInfo.utid}`;
		                    }
		                    catch (e) {
		                        this.logger.verbose("Could not parse home account ID for CCS Header: " +
		                            e);
		                    }
		                    break;
		                case CcsCredentialType.UPN:
		                    headers[HeaderNames.CCS_HEADER] = `UPN: ${ccsCred.credential}`;
		                    break;
		            }
		        }
		        return headers;
		    }
		    /**
		     * Http post to token endpoint
		     * @param tokenEndpoint
		     * @param queryString
		     * @param headers
		     * @param thumbprint
		     */
		    async executePostToTokenEndpoint(tokenEndpoint, queryString, headers, thumbprint, correlationId, queuedEvent) {
		        if (queuedEvent) {
		            this.performanceClient?.addQueueMeasurement(queuedEvent, correlationId);
		        }
		        const response = await this.sendPostRequest(thumbprint, tokenEndpoint, { body: queryString, headers: headers }, correlationId);
		        if (this.config.serverTelemetryManager &&
		            response.status < 500 &&
		            response.status !== 429) {
		            // Telemetry data successfully logged by server, clear Telemetry cache
		            this.config.serverTelemetryManager.clearTelemetryCache();
		        }
		        return response;
		    }
		    /**
		     * Wraps sendPostRequestAsync with necessary preflight and postflight logic
		     * @param thumbprint - Request thumbprint for throttling
		     * @param tokenEndpoint - Endpoint to make the POST to
		     * @param options - Body and Headers to include on the POST request
		     * @param correlationId - CorrelationId for telemetry
		     */
		    async sendPostRequest(thumbprint, tokenEndpoint, options, correlationId) {
		        ThrottlingUtils.preProcess(this.cacheManager, thumbprint, correlationId);
		        let response;
		        try {
		            response = await invokeAsync((this.networkClient.sendPostRequestAsync.bind(this.networkClient)), PerformanceEvents.NetworkClientSendPostRequestAsync, this.logger, this.performanceClient, correlationId)(tokenEndpoint, options);
		            const responseHeaders = response.headers || {};
		            this.performanceClient?.addFields({
		                refreshTokenSize: response.body.refresh_token?.length || 0,
		                httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
		                requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] || "",
		            }, correlationId);
		        }
		        catch (e) {
		            if (e instanceof NetworkError) {
		                const responseHeaders = e.responseHeaders;
		                if (responseHeaders) {
		                    this.performanceClient?.addFields({
		                        httpVerToken: responseHeaders[HeaderNames.X_MS_HTTP_VERSION] || "",
		                        requestId: responseHeaders[HeaderNames.X_MS_REQUEST_ID] ||
		                            "",
		                        contentTypeHeader: responseHeaders[HeaderNames.CONTENT_TYPE] ||
		                            undefined,
		                        contentLengthHeader: responseHeaders[HeaderNames.CONTENT_LENGTH] ||
		                            undefined,
		                        httpStatus: e.httpStatus,
		                    }, correlationId);
		                }
		                throw e.error;
		            }
		            if (e instanceof AuthError) {
		                throw e;
		            }
		            else {
		                throw createClientAuthError(networkError);
		            }
		        }
		        ThrottlingUtils.postProcess(this.cacheManager, thumbprint, response, correlationId);
		        return response;
		    }
		    /**
		     * Updates the authority object of the client. Endpoint discovery must be completed.
		     * @param updatedAuthority
		     */
		    async updateAuthority(cloudInstanceHostname, correlationId) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.UpdateTokenEndpointAuthority, correlationId);
		        const cloudInstanceAuthorityUri = `https://${cloudInstanceHostname}/${this.authority.tenant}/`;
		        const cloudInstanceAuthority = await createDiscoveredInstance(cloudInstanceAuthorityUri, this.networkClient, this.cacheManager, this.authority.options, this.logger, correlationId, this.performanceClient);
		        this.authority = cloudInstanceAuthority;
		    }
		    /**
		     * Creates query string for the /token request
		     * @param request
		     */
		    createTokenQueryParameters(request) {
		        const parameters = new Map();
		        if (request.embeddedClientId) {
		            addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
		        }
		        if (request.tokenQueryParameters) {
		            addExtraQueryParameters(parameters, request.tokenQueryParameters);
		        }
		        addCorrelationId(parameters, request.correlationId);
		        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
		        return mapToQueryString(parameters);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		// Codes defined by MSAL
		const noTokensFound = "no_tokens_found";
		const nativeAccountUnavailable = "native_account_unavailable";
		const refreshTokenExpired = "refresh_token_expired";
		const uxNotAllowed = "ux_not_allowed";
		// Codes potentially returned by server
		const interactionRequired = "interaction_required";
		const consentRequired = "consent_required";
		const loginRequired = "login_required";
		const badToken = "bad_token";

		var InteractionRequiredAuthErrorCodes = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    badToken: badToken,
		    consentRequired: consentRequired,
		    interactionRequired: interactionRequired,
		    loginRequired: loginRequired,
		    nativeAccountUnavailable: nativeAccountUnavailable,
		    noTokensFound: noTokensFound,
		    refreshTokenExpired: refreshTokenExpired,
		    uxNotAllowed: uxNotAllowed
		});

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * InteractionRequiredServerErrorMessage contains string constants used by error codes and messages returned by the server indicating interaction is required
		 */
		const InteractionRequiredServerErrorMessage = [
		    interactionRequired,
		    consentRequired,
		    loginRequired,
		    badToken,
		    uxNotAllowed,
		];
		const InteractionRequiredAuthSubErrorMessage = [
		    "message_only",
		    "additional_action",
		    "basic_action",
		    "user_password_expired",
		    "consent_required",
		    "bad_token",
		];
		const InteractionRequiredAuthErrorMessages = {
		    [noTokensFound]: "No refresh token found in the cache. Please sign-in.",
		    [nativeAccountUnavailable]: "The requested account is not available in the native broker. It may have been deleted or logged out. Please sign-in again using an interactive API.",
		    [refreshTokenExpired]: "Refresh token has expired.",
		    [badToken]: "Identity provider returned bad_token due to an expired or invalid refresh token. Please invoke an interactive API to resolve.",
		    [uxNotAllowed]: "`canShowUI` flag in Edge was set to false. User interaction required on web page. Please invoke an interactive API to resolve.",
		};
		/**
		 * Interaction required errors defined by the SDK
		 * @deprecated Use InteractionRequiredAuthErrorCodes instead
		 */
		const InteractionRequiredAuthErrorMessage = {
		    noTokensFoundError: {
		        code: noTokensFound,
		        desc: InteractionRequiredAuthErrorMessages[noTokensFound],
		    },
		    native_account_unavailable: {
		        code: nativeAccountUnavailable,
		        desc: InteractionRequiredAuthErrorMessages[nativeAccountUnavailable],
		    },
		    bad_token: {
		        code: badToken,
		        desc: InteractionRequiredAuthErrorMessages[badToken],
		    },
		};
		/**
		 * Error thrown when user interaction is required.
		 */
		class InteractionRequiredAuthError extends AuthError {
		    constructor(errorCode, errorMessage, subError, timestamp, traceId, correlationId, claims, errorNo) {
		        super(errorCode, errorMessage, subError);
		        Object.setPrototypeOf(this, InteractionRequiredAuthError.prototype);
		        this.timestamp = timestamp || Constants$1.EMPTY_STRING;
		        this.traceId = traceId || Constants$1.EMPTY_STRING;
		        this.correlationId = correlationId || Constants$1.EMPTY_STRING;
		        this.claims = claims || Constants$1.EMPTY_STRING;
		        this.name = "InteractionRequiredAuthError";
		        this.errorNo = errorNo;
		    }
		}
		/**
		 * Helper function used to determine if an error thrown by the server requires interaction to resolve
		 * @param errorCode
		 * @param errorString
		 * @param subError
		 */
		function isInteractionRequiredError(errorCode, errorString, subError) {
		    const isInteractionRequiredErrorCode = !!errorCode &&
		        InteractionRequiredServerErrorMessage.indexOf(errorCode) > -1;
		    const isInteractionRequiredSubError = !!subError &&
		        InteractionRequiredAuthSubErrorMessage.indexOf(subError) > -1;
		    const isInteractionRequiredErrorDesc = !!errorString &&
		        InteractionRequiredServerErrorMessage.some((irErrorCode) => {
		            return errorString.indexOf(irErrorCode) > -1;
		        });
		    return (isInteractionRequiredErrorCode ||
		        isInteractionRequiredErrorDesc ||
		        isInteractionRequiredSubError);
		}
		/**
		 * Creates an InteractionRequiredAuthError
		 */
		function createInteractionRequiredAuthError(errorCode) {
		    return new InteractionRequiredAuthError(errorCode, InteractionRequiredAuthErrorMessages[errorCode]);
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Class which provides helpers for OAuth 2.0 protocol specific values
		 */
		class ProtocolUtils {
		    /**
		     * Appends user state with random guid, or returns random guid.
		     * @param userState
		     * @param randomGuid
		     */
		    static setRequestState(cryptoObj, userState, meta) {
		        const libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);
		        return userState
		            ? `${libraryState}${Constants$1.RESOURCE_DELIM}${userState}`
		            : libraryState;
		    }
		    /**
		     * Generates the state value used by the common library.
		     * @param randomGuid
		     * @param cryptoObj
		     */
		    static generateLibraryState(cryptoObj, meta) {
		        if (!cryptoObj) {
		            throw createClientAuthError(noCryptoObject);
		        }
		        // Create a state object containing a unique id and the timestamp of the request creation
		        const stateObj = {
		            id: cryptoObj.createNewGuid(),
		        };
		        if (meta) {
		            stateObj.meta = meta;
		        }
		        const stateString = JSON.stringify(stateObj);
		        return cryptoObj.base64Encode(stateString);
		    }
		    /**
		     * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.
		     * @param state
		     * @param cryptoObj
		     */
		    static parseRequestState(cryptoObj, state) {
		        if (!cryptoObj) {
		            throw createClientAuthError(noCryptoObject);
		        }
		        if (!state) {
		            throw createClientAuthError(invalidState);
		        }
		        try {
		            // Split the state between library state and user passed state and decode them separately
		            const splitState = state.split(Constants$1.RESOURCE_DELIM);
		            const libraryState = splitState[0];
		            const userState = splitState.length > 1
		                ? splitState.slice(1).join(Constants$1.RESOURCE_DELIM)
		                : Constants$1.EMPTY_STRING;
		            const libraryStateString = cryptoObj.base64Decode(libraryState);
		            const libraryStateObj = JSON.parse(libraryStateString);
		            return {
		                userRequestState: userState || Constants$1.EMPTY_STRING,
		                libraryState: libraryStateObj,
		            };
		        }
		        catch (e) {
		            throw createClientAuthError(invalidState);
		        }
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const KeyLocation = {
		    SW: "sw"};
		/** @internal */
		class PopTokenGenerator {
		    constructor(cryptoUtils, performanceClient) {
		        this.cryptoUtils = cryptoUtils;
		        this.performanceClient = performanceClient;
		    }
		    /**
		     * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters
		     * and returns an object containing the keyid, the full req_cnf string and the req_cnf string hash
		     * @param request
		     * @returns
		     */
		    async generateCnf(request, logger) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateCnf, request.correlationId);
		        const reqCnf = await invokeAsync(this.generateKid.bind(this), PerformanceEvents.PopTokenGenerateCnf, logger, this.performanceClient, request.correlationId)(request);
		        const reqCnfString = this.cryptoUtils.base64UrlEncode(JSON.stringify(reqCnf));
		        return {
		            kid: reqCnf.kid,
		            reqCnfString,
		        };
		    }
		    /**
		     * Generates key_id for a SHR token request
		     * @param request
		     * @returns
		     */
		    async generateKid(request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.PopTokenGenerateKid, request.correlationId);
		        const kidThumbprint = await this.cryptoUtils.getPublicKeyThumbprint(request);
		        return {
		            kid: kidThumbprint,
		            xms_ksl: KeyLocation.SW,
		        };
		    }
		    /**
		     * Signs the POP access_token with the local generated key-pair
		     * @param accessToken
		     * @param request
		     * @returns
		     */
		    async signPopToken(accessToken, keyId, request) {
		        return this.signPayload(accessToken, keyId, request);
		    }
		    /**
		     * Utility function to generate the signed JWT for an access_token
		     * @param payload
		     * @param kid
		     * @param request
		     * @param claims
		     * @returns
		     */
		    async signPayload(payload, keyId, request, claims) {
		        // Deconstruct request to extract SHR parameters
		        const { resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, shrOptions, } = request;
		        const resourceUrlString = resourceRequestUri
		            ? new UrlString(resourceRequestUri)
		            : undefined;
		        const resourceUrlComponents = resourceUrlString?.getUrlComponents();
		        return this.cryptoUtils.signJwt({
		            at: payload,
		            ts: nowSeconds(),
		            m: resourceRequestMethod?.toUpperCase(),
		            u: resourceUrlComponents?.HostNameAndPort,
		            nonce: shrNonce || this.cryptoUtils.createNewGuid(),
		            p: resourceUrlComponents?.AbsolutePath,
		            q: resourceUrlComponents?.QueryString
		                ? [[], resourceUrlComponents.QueryString]
		                : undefined,
		            client_claims: shrClaims || undefined,
		            ...claims,
		        }, keyId, shrOptions, request.correlationId);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * This class instance helps track the memory changes facilitating
		 * decisions to read from and write to the persistent cache
		 */ class TokenCacheContext {
		    constructor(tokenCache, hasChanged) {
		        this.cache = tokenCache;
		        this.hasChanged = hasChanged;
		    }
		    /**
		     * boolean which indicates the changes in cache
		     */
		    get cacheHasChanged() {
		        return this.hasChanged;
		    }
		    /**
		     * function to retrieve the token cache
		     */
		    get tokenCache() {
		        return this.cache;
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Class that handles response parsing.
		 * @internal
		 */
		class ResponseHandler {
		    constructor(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {
		        this.clientId = clientId;
		        this.cacheStorage = cacheStorage;
		        this.cryptoObj = cryptoObj;
		        this.logger = logger;
		        this.serializableCache = serializableCache;
		        this.persistencePlugin = persistencePlugin;
		        this.performanceClient = performanceClient;
		    }
		    /**
		     * Function which validates server authorization token response.
		     * @param serverResponse
		     * @param refreshAccessToken
		     */
		    validateTokenResponse(serverResponse, refreshAccessToken) {
		        // Check for error
		        if (serverResponse.error ||
		            serverResponse.error_description ||
		            serverResponse.suberror) {
		            const errString = `Error(s): ${serverResponse.error_codes || Constants$1.NOT_AVAILABLE} - Timestamp: ${serverResponse.timestamp || Constants$1.NOT_AVAILABLE} - Description: ${serverResponse.error_description || Constants$1.NOT_AVAILABLE} - Correlation ID: ${serverResponse.correlation_id || Constants$1.NOT_AVAILABLE} - Trace ID: ${serverResponse.trace_id || Constants$1.NOT_AVAILABLE}`;
		            const serverErrorNo = serverResponse.error_codes?.length
		                ? serverResponse.error_codes[0]
		                : undefined;
		            const serverError = new ServerError(serverResponse.error, errString, serverResponse.suberror, serverErrorNo, serverResponse.status);
		            // check if 500 error
		            if (refreshAccessToken &&
		                serverResponse.status &&
		                serverResponse.status >= HttpStatus.SERVER_ERROR_RANGE_START &&
		                serverResponse.status <= HttpStatus.SERVER_ERROR_RANGE_END) {
		                this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently unavailable and the access token is unable to be refreshed.\n${serverError}`);
		                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed
		                return;
		                // check if 400 error
		            }
		            else if (refreshAccessToken &&
		                serverResponse.status &&
		                serverResponse.status >= HttpStatus.CLIENT_ERROR_RANGE_START &&
		                serverResponse.status <= HttpStatus.CLIENT_ERROR_RANGE_END) {
		                this.logger.warning(`executeTokenRequest:validateTokenResponse - AAD is currently available but is unable to refresh the access token.\n${serverError}`);
		                // don't throw an exception, but alert the user via a log that the token was unable to be refreshed
		                return;
		            }
		            if (isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {
		                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants$1.EMPTY_STRING, serverResponse.trace_id || Constants$1.EMPTY_STRING, serverResponse.correlation_id || Constants$1.EMPTY_STRING, serverResponse.claims || Constants$1.EMPTY_STRING, serverErrorNo);
		            }
		            throw serverError;
		        }
		    }
		    /**
		     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.
		     * @param serverTokenResponse
		     * @param authority
		     */
		    async handleServerTokenResponse(serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);
		        // create an idToken object (not entity)
		        let idTokenClaims;
		        if (serverTokenResponse.id_token) {
		            idTokenClaims = extractTokenClaims(serverTokenResponse.id_token || Constants$1.EMPTY_STRING, this.cryptoObj.base64Decode);
		            // token nonce check (TODO: Add a warning if no nonce is given?)
		            if (authCodePayload && authCodePayload.nonce) {
		                if (idTokenClaims.nonce !== authCodePayload.nonce) {
		                    throw createClientAuthError(nonceMismatch);
		                }
		            }
		            // token max_age check
		            if (request.maxAge || request.maxAge === 0) {
		                const authTime = idTokenClaims.auth_time;
		                if (!authTime) {
		                    throw createClientAuthError(authTimeNotFound);
		                }
		                checkMaxAge(authTime, request.maxAge);
		            }
		        }
		        // generate homeAccountId
		        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants$1.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenClaims);
		        // save the response tokens
		        let requestStateObj;
		        if (!!authCodePayload && !!authCodePayload.state) {
		            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);
		        }
		        // Add keyId from request to serverTokenResponse if defined
		        serverTokenResponse.key_id =
		            serverTokenResponse.key_id || request.sshKid || undefined;
		        const cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload);
		        let cacheContext;
		        try {
		            if (this.persistencePlugin && this.serializableCache) {
		                this.logger.verbose("Persistence enabled, calling beforeCacheAccess");
		                cacheContext = new TokenCacheContext(this.serializableCache, true);
		                await this.persistencePlugin.beforeCacheAccess(cacheContext);
		            }
		            /*
		             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.
		             * If not present, we should return null, as it's the case that another application called removeAccount in between
		             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by
		             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.
		             */
		            if (handlingRefreshTokenResponse &&
		                !forceCacheRefreshTokenResponse &&
		                cacheRecord.account) {
		                const key = this.cacheStorage.generateAccountKey(AccountEntity.getAccountInfo(cacheRecord.account));
		                const account = this.cacheStorage.getAccount(key, request.correlationId);
		                if (!account) {
		                    this.logger.warning("Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache");
		                    return await ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, undefined, serverRequestId);
		                }
		            }
		            await this.cacheStorage.saveCacheRecord(cacheRecord, request.correlationId, isKmsi(idTokenClaims || {}), request.storeInCache);
		        }
		        finally {
		            if (this.persistencePlugin &&
		                this.serializableCache &&
		                cacheContext) {
		                this.logger.verbose("Persistence enabled, calling afterCacheAccess");
		                await this.persistencePlugin.afterCacheAccess(cacheContext);
		            }
		        }
		        return ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenClaims, requestStateObj, serverTokenResponse, serverRequestId);
		    }
		    /**
		     * Generates CacheRecord
		     * @param serverTokenResponse
		     * @param idTokenObj
		     * @param authority
		     */
		    generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenClaims, userAssertionHash, authCodePayload) {
		        const env = authority.getPreferredCache();
		        if (!env) {
		            throw createClientAuthError(invalidCacheEnvironment);
		        }
		        const claimsTenantId = getTenantIdFromIdTokenClaims(idTokenClaims);
		        // IdToken: non AAD scenarios can have empty realm
		        let cachedIdToken;
		        let cachedAccount;
		        if (serverTokenResponse.id_token && !!idTokenClaims) {
		            cachedIdToken = createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token, this.clientId, claimsTenantId || "");
		            cachedAccount = buildAccountToCache(this.cacheStorage, authority, this.homeAccountIdentifier, this.cryptoObj.base64Decode, request.correlationId, idTokenClaims, serverTokenResponse.client_info, env, claimsTenantId, authCodePayload, undefined, // nativeAccountId
		            this.logger);
		        }
		        // AccessToken
		        let cachedAccessToken = null;
		        if (serverTokenResponse.access_token) {
		            // If scopes not returned in server response, use request scopes
		            const responseScopes = serverTokenResponse.scope
		                ? ScopeSet.fromString(serverTokenResponse.scope)
		                : new ScopeSet(request.scopes || []);
		            /*
		             * Use timestamp calculated before request
		             * Server may return timestamps as strings, parse to numbers if so.
		             */
		            const expiresIn = (typeof serverTokenResponse.expires_in === "string"
		                ? parseInt(serverTokenResponse.expires_in, 10)
		                : serverTokenResponse.expires_in) || 0;
		            const extExpiresIn = (typeof serverTokenResponse.ext_expires_in === "string"
		                ? parseInt(serverTokenResponse.ext_expires_in, 10)
		                : serverTokenResponse.ext_expires_in) || 0;
		            const refreshIn = (typeof serverTokenResponse.refresh_in === "string"
		                ? parseInt(serverTokenResponse.refresh_in, 10)
		                : serverTokenResponse.refresh_in) || undefined;
		            const tokenExpirationSeconds = reqTimestamp + expiresIn;
		            const extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;
		            const refreshOnSeconds = refreshIn && refreshIn > 0
		                ? reqTimestamp + refreshIn
		                : undefined;
		            // non AAD scenarios can have empty realm
		            cachedAccessToken = createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token, this.clientId, claimsTenantId || authority.tenant || "", responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj.base64Decode, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);
		        }
		        // refreshToken
		        let cachedRefreshToken = null;
		        if (serverTokenResponse.refresh_token) {
		            let rtExpiresOn;
		            if (serverTokenResponse.refresh_token_expires_in) {
		                const rtExpiresIn = typeof serverTokenResponse.refresh_token_expires_in ===
		                    "string"
		                    ? parseInt(serverTokenResponse.refresh_token_expires_in, 10)
		                    : serverTokenResponse.refresh_token_expires_in;
		                rtExpiresOn = reqTimestamp + rtExpiresIn;
		            }
		            cachedRefreshToken = createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token, this.clientId, serverTokenResponse.foci, userAssertionHash, rtExpiresOn);
		        }
		        // appMetadata
		        let cachedAppMetadata = null;
		        if (serverTokenResponse.foci) {
		            cachedAppMetadata = {
		                clientId: this.clientId,
		                environment: env,
		                familyId: serverTokenResponse.foci,
		            };
		        }
		        return {
		            account: cachedAccount,
		            idToken: cachedIdToken,
		            accessToken: cachedAccessToken,
		            refreshToken: cachedRefreshToken,
		            appMetadata: cachedAppMetadata,
		        };
		    }
		    /**
		     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.
		     *
		     * Optionally takes a state string that is set as-is in the response.
		     *
		     * @param cacheRecord
		     * @param idTokenObj
		     * @param fromTokenCache
		     * @param stateString
		     */
		    static async generateAuthenticationResult(cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenClaims, requestState, serverTokenResponse, requestId) {
		        let accessToken = Constants$1.EMPTY_STRING;
		        let responseScopes = [];
		        let expiresOn = null;
		        let extExpiresOn;
		        let refreshOn;
		        let familyId = Constants$1.EMPTY_STRING;
		        if (cacheRecord.accessToken) {
		            /*
		             * if the request object has `popKid` property, `signPopToken` will be set to false and
		             * the token will be returned unsigned
		             */
		            if (cacheRecord.accessToken.tokenType ===
		                AuthenticationScheme.POP &&
		                !request.popKid) {
		                const popTokenGenerator = new PopTokenGenerator(cryptoObj);
		                const { secret, keyId } = cacheRecord.accessToken;
		                if (!keyId) {
		                    throw createClientAuthError(keyIdMissing);
		                }
		                accessToken = await popTokenGenerator.signPopToken(secret, keyId, request);
		            }
		            else {
		                accessToken = cacheRecord.accessToken.secret;
		            }
		            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();
		            // Access token expiresOn cached in seconds, converting to Date for AuthenticationResult
		            expiresOn = toDateFromSeconds(cacheRecord.accessToken.expiresOn);
		            extExpiresOn = toDateFromSeconds(cacheRecord.accessToken.extendedExpiresOn);
		            if (cacheRecord.accessToken.refreshOn) {
		                refreshOn = toDateFromSeconds(cacheRecord.accessToken.refreshOn);
		            }
		        }
		        if (cacheRecord.appMetadata) {
		            familyId =
		                cacheRecord.appMetadata.familyId === THE_FAMILY_ID
		                    ? THE_FAMILY_ID
		                    : "";
		        }
		        const uid = idTokenClaims?.oid || idTokenClaims?.sub || "";
		        const tid = idTokenClaims?.tid || "";
		        // for hybrid + native bridge enablement, send back the native account Id
		        if (serverTokenResponse?.spa_accountid && !!cacheRecord.account) {
		            cacheRecord.account.nativeAccountId =
		                serverTokenResponse?.spa_accountid;
		        }
		        const accountInfo = cacheRecord.account
		            ? updateAccountTenantProfileData(AccountEntity.getAccountInfo(cacheRecord.account), undefined, // tenantProfile optional
		            idTokenClaims, cacheRecord.idToken?.secret)
		            : null;
		        return {
		            authority: authority.canonicalAuthority,
		            uniqueId: uid,
		            tenantId: tid,
		            scopes: responseScopes,
		            account: accountInfo,
		            idToken: cacheRecord?.idToken?.secret || "",
		            idTokenClaims: idTokenClaims || {},
		            accessToken: accessToken,
		            fromCache: fromTokenCache,
		            expiresOn: expiresOn,
		            extExpiresOn: extExpiresOn,
		            refreshOn: refreshOn,
		            correlationId: request.correlationId,
		            requestId: requestId || Constants$1.EMPTY_STRING,
		            familyId: familyId,
		            tokenType: cacheRecord.accessToken?.tokenType || Constants$1.EMPTY_STRING,
		            state: requestState
		                ? requestState.userRequestState
		                : Constants$1.EMPTY_STRING,
		            cloudGraphHostName: cacheRecord.account?.cloudGraphHostName ||
		                Constants$1.EMPTY_STRING,
		            msGraphHost: cacheRecord.account?.msGraphHost || Constants$1.EMPTY_STRING,
		            code: serverTokenResponse?.spa_code,
		            fromNativeBroker: false,
		        };
		    }
		}
		function buildAccountToCache(cacheStorage, authority, homeAccountId, base64Decode, correlationId, idTokenClaims, clientInfo, environment, claimsTenantId, authCodePayload, nativeAccountId, logger) {
		    logger?.verbose("setCachedAccount called");
		    // Check if base account is already cached
		    const accountKeys = cacheStorage.getAccountKeys();
		    const baseAccountKey = accountKeys.find((accountKey) => {
		        return accountKey.startsWith(homeAccountId);
		    });
		    let cachedAccount = null;
		    if (baseAccountKey) {
		        cachedAccount = cacheStorage.getAccount(baseAccountKey, correlationId);
		    }
		    const baseAccount = cachedAccount ||
		        AccountEntity.createAccount({
		            homeAccountId,
		            idTokenClaims,
		            clientInfo,
		            environment,
		            cloudGraphHostName: authCodePayload?.cloud_graph_host_name,
		            msGraphHost: authCodePayload?.msgraph_host,
		            nativeAccountId: nativeAccountId,
		        }, authority, base64Decode);
		    const tenantProfiles = baseAccount.tenantProfiles || [];
		    const tenantId = claimsTenantId || baseAccount.realm;
		    if (tenantId &&
		        !tenantProfiles.find((tenantProfile) => {
		            return tenantProfile.tenantId === tenantId;
		        })) {
		        const newTenantProfile = buildTenantProfile(homeAccountId, baseAccount.localAccountId, tenantId, idTokenClaims);
		        tenantProfiles.push(newTenantProfile);
		    }
		    baseAccount.tenantProfiles = tenantProfiles;
		    return baseAccount;
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */
		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		async function getClientAssertion(clientAssertion, clientId, tokenEndpoint) {
		    if (typeof clientAssertion === "string") {
		        return clientAssertion;
		    }
		    else {
		        const config = {
		            clientId: clientId,
		            tokenEndpoint: tokenEndpoint,
		        };
		        return clientAssertion(config);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Oauth2.0 Authorization Code client
		 * @internal
		 */
		class AuthorizationCodeClient extends BaseClient {
		    constructor(configuration, performanceClient) {
		        super(configuration, performanceClient);
		        // Flag to indicate if client is for hybrid spa auth code redemption
		        this.includeRedirectUri = true;
		        this.oidcDefaultScopes =
		            this.config.authOptions.authority.options.OIDCOptions?.defaultScopes;
		    }
		    /**
		     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the
		     * authorization_code_grant
		     * @param request
		     */
		    async acquireToken(request, authCodePayload) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientAcquireToken, request.correlationId);
		        if (!request.code) {
		            throw createClientAuthError(requestCannotBeMade);
		        }
		        const reqTimestamp = nowSeconds();
		        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.AuthClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(this.authority, request);
		        // Retrieve requestId from response headers
		        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
		        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin, this.performanceClient);
		        // Validate response. This function throws a server error if an error is returned by the server.
		        responseHandler.validateTokenResponse(response.body);
		        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, authCodePayload, undefined, undefined, undefined, requestId);
		    }
		    /**
		     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.
		     * Default behaviour is to redirect the user to `window.location.href`.
		     * @param authorityUri
		     */
		    getLogoutUri(logoutRequest) {
		        // Throw error if logoutRequest is null/undefined
		        if (!logoutRequest) {
		            throw createClientConfigurationError(logoutRequestEmpty);
		        }
		        const queryString = this.createLogoutUrlQueryString(logoutRequest);
		        // Construct logout URI
		        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);
		    }
		    /**
		     * Executes POST request to token endpoint
		     * @param authority
		     * @param request
		     */
		    async executeTokenRequest(authority, request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientExecuteTokenRequest, request.correlationId);
		        const queryParametersString = this.createTokenQueryParameters(request);
		        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
		        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.AuthClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
		        let ccsCredential = undefined;
		        if (request.clientInfo) {
		            try {
		                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
		                ccsCredential = {
		                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
		                    type: CcsCredentialType.HOME_ACCOUNT_ID,
		                };
		            }
		            catch (e) {
		                this.logger.verbose("Could not parse client info for CCS Header: " + e);
		            }
		        }
		        const headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);
		        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
		        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.AuthorizationCodeClientExecutePostToTokenEndpoint);
		    }
		    /**
		     * Generates a map for all the params to be sent to the service
		     * @param request
		     */
		    async createTokenRequestBody(request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.AuthClientCreateTokenRequestBody, request.correlationId);
		        const parameters = new Map();
		        addClientId(parameters, request.embeddedClientId ||
		            request.tokenBodyParameters?.[CLIENT_ID] ||
		            this.config.authOptions.clientId);
		        /*
		         * For hybrid spa flow, there will be a code but no verifier
		         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI
		         */
		        if (!this.includeRedirectUri) {
		            // Just validate
		            if (!request.redirectUri) {
		                throw createClientConfigurationError(redirectUriEmpty);
		            }
		        }
		        else {
		            // Validate and include redirect uri
		            addRedirectUri(parameters, request.redirectUri);
		        }
		        // Add scope array, parameter builder will add default scopes and dedupe
		        addScopes(parameters, request.scopes, true, this.oidcDefaultScopes);
		        // add code: user set, not validated
		        addAuthorizationCode(parameters, request.code);
		        // Add library metadata
		        addLibraryInfo(parameters, this.config.libraryInfo);
		        addApplicationTelemetry(parameters, this.config.telemetry.application);
		        addThrottling(parameters);
		        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
		            addServerTelemetry(parameters, this.serverTelemetryManager);
		        }
		        // add code_verifier if passed
		        if (request.codeVerifier) {
		            addCodeVerifier(parameters, request.codeVerifier);
		        }
		        if (this.config.clientCredentials.clientSecret) {
		            addClientSecret(parameters, this.config.clientCredentials.clientSecret);
		        }
		        if (this.config.clientCredentials.clientAssertion) {
		            const clientAssertion = this.config.clientCredentials.clientAssertion;
		            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
		            addClientAssertionType(parameters, clientAssertion.assertionType);
		        }
		        addGrantType(parameters, GrantType.AUTHORIZATION_CODE_GRANT);
		        addClientInfo(parameters);
		        if (request.authenticationScheme === AuthenticationScheme.POP) {
		            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
		            let reqCnfData;
		            if (!request.popKid) {
		                const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
		                reqCnfData = generatedReqCnfData.reqCnfString;
		            }
		            else {
		                reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
		            }
		            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)
		            addPopToken(parameters, reqCnfData);
		        }
		        else if (request.authenticationScheme === AuthenticationScheme.SSH) {
		            if (request.sshJwk) {
		                addSshJwk(parameters, request.sshJwk);
		            }
		            else {
		                throw createClientConfigurationError(missingSshJwk);
		            }
		        }
		        if (!StringUtils.isEmptyObj(request.claims) ||
		            (this.config.authOptions.clientCapabilities &&
		                this.config.authOptions.clientCapabilities.length > 0)) {
		            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
		        }
		        let ccsCred = undefined;
		        if (request.clientInfo) {
		            try {
		                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils.base64Decode);
		                ccsCred = {
		                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,
		                    type: CcsCredentialType.HOME_ACCOUNT_ID,
		                };
		            }
		            catch (e) {
		                this.logger.verbose("Could not parse client info for CCS Header: " + e);
		            }
		        }
		        else {
		            ccsCred = request.ccsCredential;
		        }
		        // Adds these as parameters in the request instead of headers to prevent CORS preflight request
		        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {
		            switch (ccsCred.type) {
		                case CcsCredentialType.HOME_ACCOUNT_ID:
		                    try {
		                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);
		                        addCcsOid(parameters, clientInfo);
		                    }
		                    catch (e) {
		                        this.logger.verbose("Could not parse home account ID for CCS Header: " +
		                            e);
		                    }
		                    break;
		                case CcsCredentialType.UPN:
		                    addCcsUpn(parameters, ccsCred.credential);
		                    break;
		            }
		        }
		        if (request.embeddedClientId) {
		            addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
		        }
		        if (request.tokenBodyParameters) {
		            addExtraQueryParameters(parameters, request.tokenBodyParameters);
		        }
		        // Add hybrid spa parameters if not already provided
		        if (request.enableSpaAuthorizationCode &&
		            (!request.tokenBodyParameters ||
		                !request.tokenBodyParameters[RETURN_SPA_CODE])) {
		            addExtraQueryParameters(parameters, {
		                [RETURN_SPA_CODE]: "1",
		            });
		        }
		        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
		        return mapToQueryString(parameters);
		    }
		    /**
		     * This API validates the `EndSessionRequest` and creates a URL
		     * @param request
		     */
		    createLogoutUrlQueryString(request) {
		        const parameters = new Map();
		        if (request.postLogoutRedirectUri) {
		            addPostLogoutRedirectUri(parameters, request.postLogoutRedirectUri);
		        }
		        if (request.correlationId) {
		            addCorrelationId(parameters, request.correlationId);
		        }
		        if (request.idTokenHint) {
		            addIdTokenHint(parameters, request.idTokenHint);
		        }
		        if (request.state) {
		            addState(parameters, request.state);
		        }
		        if (request.logoutHint) {
		            addLogoutHint(parameters, request.logoutHint);
		        }
		        if (request.extraQueryParameters) {
		            addExtraQueryParameters(parameters, request.extraQueryParameters);
		        }
		        if (this.config.authOptions.instanceAware) {
		            addInstanceAware(parameters);
		        }
		        return mapToQueryString(parameters, this.config.authOptions.encodeExtraQueryParams, request.extraQueryParameters);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS = 300; // 5 Minutes
		/**
		 * OAuth2.0 refresh token client
		 * @internal
		 */
		class RefreshTokenClient extends BaseClient {
		    constructor(configuration, performanceClient) {
		        super(configuration, performanceClient);
		    }
		    async acquireToken(request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireToken, request.correlationId);
		        const reqTimestamp = nowSeconds();
		        const response = await invokeAsync(this.executeTokenRequest.bind(this), PerformanceEvents.RefreshTokenClientExecuteTokenRequest, this.logger, this.performanceClient, request.correlationId)(request, this.authority);
		        // Retrieve requestId from response headers
		        const requestId = response.headers?.[HeaderNames.X_MS_REQUEST_ID];
		        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
		        responseHandler.validateTokenResponse(response.body);
		        return invokeAsync(responseHandler.handleServerTokenResponse.bind(responseHandler), PerformanceEvents.HandleServerTokenResponse, this.logger, this.performanceClient, request.correlationId)(response.body, this.authority, reqTimestamp, request, undefined, undefined, true, request.forceCache, requestId);
		    }
		    /**
		     * Gets cached refresh token and attaches to request, then calls acquireToken API
		     * @param request
		     */
		    async acquireTokenByRefreshToken(request) {
		        // Cannot renew token if no request object is given.
		        if (!request) {
		            throw createClientConfigurationError(tokenRequestEmpty);
		        }
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenByRefreshToken, request.correlationId);
		        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases
		        if (!request.account) {
		            throw createClientAuthError(noAccountInSilentRequest);
		        }
		        // try checking if FOCI is enabled for the given application
		        const isFOCI = this.cacheManager.isAppMetadataFOCI(request.account.environment);
		        // if the app is part of the family, retrive a Family refresh token if present and make a refreshTokenRequest
		        if (isFOCI) {
		            try {
		                return await invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, true);
		            }
		            catch (e) {
		                const noFamilyRTInCache = e instanceof InteractionRequiredAuthError &&
		                    e.errorCode ===
		                        noTokensFound;
		                const clientMismatchErrorWithFamilyRT = e instanceof ServerError &&
		                    e.errorCode === Errors.INVALID_GRANT_ERROR &&
		                    e.subError === Errors.CLIENT_MISMATCH_ERROR;
		                // if family Refresh Token (FRT) cache acquisition fails or if client_mismatch error is seen with FRT, reattempt with application Refresh Token (ART)
		                if (noFamilyRTInCache || clientMismatchErrorWithFamilyRT) {
		                    return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
		                    // throw in all other cases
		                }
		                else {
		                    throw e;
		                }
		            }
		        }
		        // fall back to application refresh token acquisition
		        return invokeAsync(this.acquireTokenWithCachedRefreshToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, this.logger, this.performanceClient, request.correlationId)(request, false);
		    }
		    /**
		     * makes a network call to acquire tokens by exchanging RefreshToken available in userCache; throws if refresh token is not cached
		     * @param request
		     */
		    async acquireTokenWithCachedRefreshToken(request, foci) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientAcquireTokenWithCachedRefreshToken, request.correlationId);
		        // fetches family RT or application RT based on FOCI value
		        const refreshToken = invoke(this.cacheManager.getRefreshToken.bind(this.cacheManager), PerformanceEvents.CacheManagerGetRefreshToken, this.logger, this.performanceClient, request.correlationId)(request.account, foci, request.correlationId, undefined, this.performanceClient);
		        if (!refreshToken) {
		            throw createInteractionRequiredAuthError(noTokensFound);
		        }
		        if (refreshToken.expiresOn &&
		            isTokenExpired(refreshToken.expiresOn, request.refreshTokenExpirationOffsetSeconds ||
		                DEFAULT_REFRESH_TOKEN_EXPIRATION_OFFSET_SECONDS)) {
		            this.performanceClient?.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
		            throw createInteractionRequiredAuthError(refreshTokenExpired);
		        }
		        // attach cached RT size to the current measurement
		        const refreshTokenRequest = {
		            ...request,
		            refreshToken: refreshToken.secret,
		            authenticationScheme: request.authenticationScheme || AuthenticationScheme.BEARER,
		            ccsCredential: {
		                credential: request.account.homeAccountId,
		                type: CcsCredentialType.HOME_ACCOUNT_ID,
		            },
		        };
		        try {
		            return await invokeAsync(this.acquireToken.bind(this), PerformanceEvents.RefreshTokenClientAcquireToken, this.logger, this.performanceClient, request.correlationId)(refreshTokenRequest);
		        }
		        catch (e) {
		            if (e instanceof InteractionRequiredAuthError) {
		                this.performanceClient?.addFields({ rtExpiresOnMs: Number(refreshToken.expiresOn) }, request.correlationId);
		                if (e.subError === badToken) {
		                    // Remove bad refresh token from cache
		                    this.logger.verbose("acquireTokenWithRefreshToken: bad refresh token, removing from cache");
		                    const badRefreshTokenKey = this.cacheManager.generateCredentialKey(refreshToken);
		                    this.cacheManager.removeRefreshToken(badRefreshTokenKey, request.correlationId);
		                }
		            }
		            throw e;
		        }
		    }
		    /**
		     * Constructs the network message and makes a NW call to the underlying secure token service
		     * @param request
		     * @param authority
		     */
		    async executeTokenRequest(request, authority) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientExecuteTokenRequest, request.correlationId);
		        const queryParametersString = this.createTokenQueryParameters(request);
		        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
		        const requestBody = await invokeAsync(this.createTokenRequestBody.bind(this), PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, this.logger, this.performanceClient, request.correlationId)(request);
		        const headers = this.createTokenRequestHeaders(request.ccsCredential);
		        const thumbprint = getRequestThumbprint(this.config.authOptions.clientId, request);
		        return invokeAsync(this.executePostToTokenEndpoint.bind(this), PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint, this.logger, this.performanceClient, request.correlationId)(endpoint, requestBody, headers, thumbprint, request.correlationId, PerformanceEvents.RefreshTokenClientExecutePostToTokenEndpoint);
		    }
		    /**
		     * Helper function to create the token request body
		     * @param request
		     */
		    async createTokenRequestBody(request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.RefreshTokenClientCreateTokenRequestBody, request.correlationId);
		        const parameters = new Map();
		        addClientId(parameters, request.embeddedClientId ||
		            request.tokenBodyParameters?.[CLIENT_ID] ||
		            this.config.authOptions.clientId);
		        if (request.redirectUri) {
		            addRedirectUri(parameters, request.redirectUri);
		        }
		        addScopes(parameters, request.scopes, true, this.config.authOptions.authority.options.OIDCOptions?.defaultScopes);
		        addGrantType(parameters, GrantType.REFRESH_TOKEN_GRANT);
		        addClientInfo(parameters);
		        addLibraryInfo(parameters, this.config.libraryInfo);
		        addApplicationTelemetry(parameters, this.config.telemetry.application);
		        addThrottling(parameters);
		        if (this.serverTelemetryManager && !isOidcProtocolMode(this.config)) {
		            addServerTelemetry(parameters, this.serverTelemetryManager);
		        }
		        addRefreshToken(parameters, request.refreshToken);
		        if (this.config.clientCredentials.clientSecret) {
		            addClientSecret(parameters, this.config.clientCredentials.clientSecret);
		        }
		        if (this.config.clientCredentials.clientAssertion) {
		            const clientAssertion = this.config.clientCredentials.clientAssertion;
		            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
		            addClientAssertionType(parameters, clientAssertion.assertionType);
		        }
		        if (request.authenticationScheme === AuthenticationScheme.POP) {
		            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils, this.performanceClient);
		            let reqCnfData;
		            if (!request.popKid) {
		                const generatedReqCnfData = await invokeAsync(popTokenGenerator.generateCnf.bind(popTokenGenerator), PerformanceEvents.PopTokenGenerateCnf, this.logger, this.performanceClient, request.correlationId)(request, this.logger);
		                reqCnfData = generatedReqCnfData.reqCnfString;
		            }
		            else {
		                reqCnfData = this.cryptoUtils.encodeKid(request.popKid);
		            }
		            // SPA PoP requires full Base64Url encoded req_cnf string (unhashed)
		            addPopToken(parameters, reqCnfData);
		        }
		        else if (request.authenticationScheme === AuthenticationScheme.SSH) {
		            if (request.sshJwk) {
		                addSshJwk(parameters, request.sshJwk);
		            }
		            else {
		                throw createClientConfigurationError(missingSshJwk);
		            }
		        }
		        if (!StringUtils.isEmptyObj(request.claims) ||
		            (this.config.authOptions.clientCapabilities &&
		                this.config.authOptions.clientCapabilities.length > 0)) {
		            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
		        }
		        if (this.config.systemOptions.preventCorsPreflight &&
		            request.ccsCredential) {
		            switch (request.ccsCredential.type) {
		                case CcsCredentialType.HOME_ACCOUNT_ID:
		                    try {
		                        const clientInfo = buildClientInfoFromHomeAccountId(request.ccsCredential.credential);
		                        addCcsOid(parameters, clientInfo);
		                    }
		                    catch (e) {
		                        this.logger.verbose("Could not parse home account ID for CCS Header: " +
		                            e);
		                    }
		                    break;
		                case CcsCredentialType.UPN:
		                    addCcsUpn(parameters, request.ccsCredential.credential);
		                    break;
		            }
		        }
		        if (request.embeddedClientId) {
		            addBrokerParameters(parameters, this.config.authOptions.clientId, this.config.authOptions.redirectUri);
		        }
		        if (request.tokenBodyParameters) {
		            addExtraQueryParameters(parameters, request.tokenBodyParameters);
		        }
		        instrumentBrokerParams(parameters, request.correlationId, this.performanceClient);
		        return mapToQueryString(parameters);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/** @internal */
		class SilentFlowClient extends BaseClient {
		    constructor(configuration, performanceClient) {
		        super(configuration, performanceClient);
		    }
		    /**
		     * Retrieves token from cache or throws an error if it must be refreshed.
		     * @param request
		     */
		    async acquireCachedToken(request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientAcquireCachedToken, request.correlationId);
		        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
		        if (request.forceRefresh ||
		            (!this.config.cacheOptions.claimsBasedCachingEnabled &&
		                !StringUtils.isEmptyObj(request.claims))) {
		            // Must refresh due to present force_refresh flag.
		            this.setCacheOutcome(CacheOutcome.FORCE_REFRESH_OR_CLAIMS, request.correlationId);
		            throw createClientAuthError(tokenRefreshRequired);
		        }
		        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases
		        if (!request.account) {
		            throw createClientAuthError(noAccountInSilentRequest);
		        }
		        const requestTenantId = request.account.tenantId ||
		            getTenantFromAuthorityString(request.authority);
		        const tokenKeys = this.cacheManager.getTokenKeys();
		        const cachedAccessToken = this.cacheManager.getAccessToken(request.account, request, tokenKeys, requestTenantId);
		        if (!cachedAccessToken) {
		            // must refresh due to non-existent access_token
		            this.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN, request.correlationId);
		            throw createClientAuthError(tokenRefreshRequired);
		        }
		        else if (wasClockTurnedBack(cachedAccessToken.cachedAt) ||
		            isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
		            // must refresh due to the expires_in value
		            this.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED, request.correlationId);
		            throw createClientAuthError(tokenRefreshRequired);
		        }
		        else if (cachedAccessToken.refreshOn &&
		            isTokenExpired(cachedAccessToken.refreshOn, 0)) {
		            // must refresh (in the background) due to the refresh_in value
		            lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
		            // don't throw ClientAuthError.createRefreshRequiredError(), return cached token instead
		        }
		        const environment = request.authority || this.authority.getPreferredCache();
		        const cacheRecord = {
		            account: this.cacheManager.getAccount(this.cacheManager.generateAccountKey(request.account), request.correlationId),
		            accessToken: cachedAccessToken,
		            idToken: this.cacheManager.getIdToken(request.account, request.correlationId, tokenKeys, requestTenantId, this.performanceClient),
		            refreshToken: null,
		            appMetadata: this.cacheManager.readAppMetadataFromCache(environment),
		        };
		        this.setCacheOutcome(lastCacheOutcome, request.correlationId);
		        if (this.config.serverTelemetryManager) {
		            this.config.serverTelemetryManager.incrementCacheHits();
		        }
		        return [
		            await invokeAsync(this.generateResultFromCacheRecord.bind(this), PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, this.logger, this.performanceClient, request.correlationId)(cacheRecord, request),
		            lastCacheOutcome,
		        ];
		    }
		    setCacheOutcome(cacheOutcome, correlationId) {
		        this.serverTelemetryManager?.setCacheOutcome(cacheOutcome);
		        this.performanceClient?.addFields({
		            cacheOutcome: cacheOutcome,
		        }, correlationId);
		        if (cacheOutcome !== CacheOutcome.NOT_APPLICABLE) {
		            this.logger.info(`Token refresh is required due to cache outcome: ${cacheOutcome}`);
		        }
		    }
		    /**
		     * Helper function to build response object from the CacheRecord
		     * @param cacheRecord
		     */
		    async generateResultFromCacheRecord(cacheRecord, request) {
		        this.performanceClient?.addQueueMeasurement(PerformanceEvents.SilentFlowClientGenerateResultFromCacheRecord, request.correlationId);
		        let idTokenClaims;
		        if (cacheRecord.idToken) {
		            idTokenClaims = extractTokenClaims(cacheRecord.idToken.secret, this.config.cryptoInterface.base64Decode);
		        }
		        // token max_age check
		        if (request.maxAge || request.maxAge === 0) {
		            const authTime = idTokenClaims?.auth_time;
		            if (!authTime) {
		                throw createClientAuthError(authTimeNotFound);
		            }
		            checkMaxAge(authTime, request.maxAge);
		        }
		        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenClaims);
		    }
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Returns map of parameters that are applicable to all calls to /authorize whether using PKCE or EAR
		 * @param config
		 * @param request
		 * @param logger
		 * @param performanceClient
		 * @returns
		 */
		function getStandardAuthorizeRequestParameters(authOptions, request, logger, performanceClient) {
		    // generate the correlationId if not set by the user and add
		    const correlationId = request.correlationId;
		    const parameters = new Map();
		    addClientId(parameters, request.embeddedClientId ||
		        request.extraQueryParameters?.[CLIENT_ID] ||
		        authOptions.clientId);
		    const requestScopes = [
		        ...(request.scopes || []),
		        ...(request.extraScopesToConsent || []),
		    ];
		    addScopes(parameters, requestScopes, true, authOptions.authority.options.OIDCOptions?.defaultScopes);
		    addRedirectUri(parameters, request.redirectUri);
		    addCorrelationId(parameters, correlationId);
		    // add response_mode. If not passed in it defaults to query.
		    addResponseMode(parameters, request.responseMode);
		    // add client_info=1
		    addClientInfo(parameters);
		    if (request.prompt) {
		        addPrompt(parameters, request.prompt);
		    }
		    if (request.domainHint) {
		        addDomainHint(parameters, request.domainHint);
		    }
		    // Add sid or loginHint with preference for login_hint claim (in request) -> sid -> loginHint (upn/email) -> username of AccountInfo object
		    if (request.prompt !== PromptValue.SELECT_ACCOUNT) {
		        // AAD will throw if prompt=select_account is passed with an account hint
		        if (request.sid && request.prompt === PromptValue.NONE) {
		            // SessionID is only used in silent calls
		            logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from request");
		            addSid(parameters, request.sid);
		        }
		        else if (request.account) {
		            const accountSid = extractAccountSid(request.account);
		            let accountLoginHintClaim = extractLoginHint(request.account);
		            if (accountLoginHintClaim && request.domainHint) {
		                logger.warning(`AuthorizationCodeClient.createAuthCodeUrlQueryString: "domainHint" param is set, skipping opaque "login_hint" claim. Please consider not passing domainHint`);
		                accountLoginHintClaim = null;
		            }
		            // If login_hint claim is present, use it over sid/username
		            if (accountLoginHintClaim) {
		                logger.verbose("createAuthCodeUrlQueryString: login_hint claim present on account");
		                addLoginHint(parameters, accountLoginHintClaim);
		                try {
		                    const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
		                    addCcsOid(parameters, clientInfo);
		                }
		                catch (e) {
		                    logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
		                }
		            }
		            else if (accountSid && request.prompt === PromptValue.NONE) {
		                /*
		                 * If account and loginHint are provided, we will check account first for sid before adding loginHint
		                 * SessionId is only used in silent calls
		                 */
		                logger.verbose("createAuthCodeUrlQueryString: Prompt is none, adding sid from account");
		                addSid(parameters, accountSid);
		                try {
		                    const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
		                    addCcsOid(parameters, clientInfo);
		                }
		                catch (e) {
		                    logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
		                }
		            }
		            else if (request.loginHint) {
		                logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from request");
		                addLoginHint(parameters, request.loginHint);
		                addCcsUpn(parameters, request.loginHint);
		            }
		            else if (request.account.username) {
		                // Fallback to account username if provided
		                logger.verbose("createAuthCodeUrlQueryString: Adding login_hint from account");
		                addLoginHint(parameters, request.account.username);
		                try {
		                    const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);
		                    addCcsOid(parameters, clientInfo);
		                }
		                catch (e) {
		                    logger.verbose("createAuthCodeUrlQueryString: Could not parse home account ID for CCS Header");
		                }
		            }
		        }
		        else if (request.loginHint) {
		            logger.verbose("createAuthCodeUrlQueryString: No account, adding login_hint from request");
		            addLoginHint(parameters, request.loginHint);
		            addCcsUpn(parameters, request.loginHint);
		        }
		    }
		    else {
		        logger.verbose("createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints");
		    }
		    if (request.nonce) {
		        addNonce(parameters, request.nonce);
		    }
		    if (request.state) {
		        addState(parameters, request.state);
		    }
		    if (request.claims ||
		        (authOptions.clientCapabilities &&
		            authOptions.clientCapabilities.length > 0)) {
		        addClaims(parameters, request.claims, authOptions.clientCapabilities);
		    }
		    if (request.embeddedClientId) {
		        addBrokerParameters(parameters, authOptions.clientId, authOptions.redirectUri);
		    }
		    // If extraQueryParameters includes instance_aware its value will be added when extraQueryParameters are added
		    if (authOptions.instanceAware &&
		        (!request.extraQueryParameters ||
		            !Object.keys(request.extraQueryParameters).includes(INSTANCE_AWARE))) {
		        addInstanceAware(parameters);
		    }
		    return parameters;
		}
		/**
		 * Returns authorize endpoint with given request parameters in the query string
		 * @param authority
		 * @param requestParameters
		 * @returns
		 */
		function getAuthorizeUrl(authority, requestParameters, encodeParams, extraQueryParameters) {
		    const queryString = mapToQueryString(requestParameters, encodeParams, extraQueryParameters);
		    return UrlString.appendQueryString(authority.authorizationEndpoint, queryString);
		}
		/**
		 * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.
		 * @param account
		 */
		function extractAccountSid(account) {
		    return account.idTokenClaims?.sid || null;
		}
		function extractLoginHint(account) {
		    return account.loginHint || account.idTokenClaims?.login_hint || null;
		}

		/*! @azure/msal-common v15.13.3 2025-12-04 */

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const skuGroupSeparator = ",";
		const skuValueSeparator = "|";
		function makeExtraSkuString(params) {
		    const { skus, libraryName, libraryVersion, extensionName, extensionVersion, } = params;
		    const skuMap = new Map([
		        [0, [libraryName, libraryVersion]],
		        [2, [extensionName, extensionVersion]],
		    ]);
		    let skuArr = [];
		    if (skus?.length) {
		        skuArr = skus.split(skuGroupSeparator);
		        // Ignore invalid input sku param
		        if (skuArr.length < 4) {
		            return skus;
		        }
		    }
		    else {
		        skuArr = Array.from({ length: 4 }, () => skuValueSeparator);
		    }
		    skuMap.forEach((value, key) => {
		        if (value.length === 2 && value[0]?.length && value[1]?.length) {
		            setSku({
		                skuArr,
		                index: key,
		                skuName: value[0],
		                skuVersion: value[1],
		            });
		        }
		    });
		    return skuArr.join(skuGroupSeparator);
		}
		function setSku(params) {
		    const { skuArr, index, skuName, skuVersion } = params;
		    if (index >= skuArr.length) {
		        return;
		    }
		    skuArr[index] = [skuName, skuVersion].join(skuValueSeparator);
		}
		/** @internal */
		class ServerTelemetryManager {
		    constructor(telemetryRequest, cacheManager) {
		        this.cacheOutcome = CacheOutcome.NOT_APPLICABLE;
		        this.cacheManager = cacheManager;
		        this.apiId = telemetryRequest.apiId;
		        this.correlationId = telemetryRequest.correlationId;
		        this.wrapperSKU = telemetryRequest.wrapperSKU || Constants$1.EMPTY_STRING;
		        this.wrapperVer = telemetryRequest.wrapperVer || Constants$1.EMPTY_STRING;
		        this.telemetryCacheKey =
		            SERVER_TELEM_CONSTANTS.CACHE_KEY +
		                Separators.CACHE_KEY_SEPARATOR +
		                telemetryRequest.clientId;
		    }
		    /**
		     * API to add MSER Telemetry to request
		     */
		    generateCurrentRequestHeaderValue() {
		        const request = `${this.apiId}${SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR}${this.cacheOutcome}`;
		        const platformFieldsArr = [this.wrapperSKU, this.wrapperVer];
		        const nativeBrokerErrorCode = this.getNativeBrokerErrorCode();
		        if (nativeBrokerErrorCode?.length) {
		            platformFieldsArr.push(`broker_error=${nativeBrokerErrorCode}`);
		        }
		        const platformFields = platformFieldsArr.join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
		        const regionDiscoveryFields = this.getRegionDiscoveryFields();
		        const requestWithRegionDiscoveryFields = [
		            request,
		            regionDiscoveryFields,
		        ].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
		        return [
		            SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
		            requestWithRegionDiscoveryFields,
		            platformFields,
		        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
		    }
		    /**
		     * API to add MSER Telemetry for the last failed request
		     */
		    generateLastRequestHeaderValue() {
		        const lastRequests = this.getLastRequests();
		        const maxErrors = ServerTelemetryManager.maxErrorsToSend(lastRequests);
		        const failedRequests = lastRequests.failedRequests
		            .slice(0, 2 * maxErrors)
		            .join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
		        const errors = lastRequests.errors
		            .slice(0, maxErrors)
		            .join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
		        const errorCount = lastRequests.errors.length;
		        // Indicate whether this header contains all data or partial data
		        const overflow = maxErrors < errorCount
		            ? SERVER_TELEM_CONSTANTS.OVERFLOW_TRUE
		            : SERVER_TELEM_CONSTANTS.OVERFLOW_FALSE;
		        const platformFields = [errorCount, overflow].join(SERVER_TELEM_CONSTANTS.VALUE_SEPARATOR);
		        return [
		            SERVER_TELEM_CONSTANTS.SCHEMA_VERSION,
		            lastRequests.cacheHits,
		            failedRequests,
		            errors,
		            platformFields,
		        ].join(SERVER_TELEM_CONSTANTS.CATEGORY_SEPARATOR);
		    }
		    /**
		     * API to cache token failures for MSER data capture
		     * @param error
		     */
		    cacheFailedRequest(error) {
		        const lastRequests = this.getLastRequests();
		        if (lastRequests.errors.length >=
		            SERVER_TELEM_CONSTANTS.MAX_CACHED_ERRORS) {
		            // Remove a cached error to make room, first in first out
		            lastRequests.failedRequests.shift(); // apiId
		            lastRequests.failedRequests.shift(); // correlationId
		            lastRequests.errors.shift();
		        }
		        lastRequests.failedRequests.push(this.apiId, this.correlationId);
		        if (error instanceof Error && !!error && error.toString()) {
		            if (error instanceof AuthError) {
		                if (error.subError) {
		                    lastRequests.errors.push(error.subError);
		                }
		                else if (error.errorCode) {
		                    lastRequests.errors.push(error.errorCode);
		                }
		                else {
		                    lastRequests.errors.push(error.toString());
		                }
		            }
		            else {
		                lastRequests.errors.push(error.toString());
		            }
		        }
		        else {
		            lastRequests.errors.push(SERVER_TELEM_CONSTANTS.UNKNOWN_ERROR);
		        }
		        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
		        return;
		    }
		    /**
		     * Update server telemetry cache entry by incrementing cache hit counter
		     */
		    incrementCacheHits() {
		        const lastRequests = this.getLastRequests();
		        lastRequests.cacheHits += 1;
		        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
		        return lastRequests.cacheHits;
		    }
		    /**
		     * Get the server telemetry entity from cache or initialize a new one
		     */
		    getLastRequests() {
		        const initialValue = {
		            failedRequests: [],
		            errors: [],
		            cacheHits: 0,
		        };
		        const lastRequests = this.cacheManager.getServerTelemetry(this.telemetryCacheKey);
		        return lastRequests || initialValue;
		    }
		    /**
		     * Remove server telemetry cache entry
		     */
		    clearTelemetryCache() {
		        const lastRequests = this.getLastRequests();
		        const numErrorsFlushed = ServerTelemetryManager.maxErrorsToSend(lastRequests);
		        const errorCount = lastRequests.errors.length;
		        if (numErrorsFlushed === errorCount) {
		            // All errors were sent on last request, clear Telemetry cache
		            this.cacheManager.removeItem(this.telemetryCacheKey, this.correlationId);
		        }
		        else {
		            // Partial data was flushed to server, construct a new telemetry cache item with errors that were not flushed
		            const serverTelemEntity = {
		                failedRequests: lastRequests.failedRequests.slice(numErrorsFlushed * 2),
		                errors: lastRequests.errors.slice(numErrorsFlushed),
		                cacheHits: 0,
		            };
		            this.cacheManager.setServerTelemetry(this.telemetryCacheKey, serverTelemEntity, this.correlationId);
		        }
		    }
		    /**
		     * Returns the maximum number of errors that can be flushed to the server in the next network request
		     * @param serverTelemetryEntity
		     */
		    static maxErrorsToSend(serverTelemetryEntity) {
		        let i;
		        let maxErrors = 0;
		        let dataSize = 0;
		        const errorCount = serverTelemetryEntity.errors.length;
		        for (i = 0; i < errorCount; i++) {
		            // failedRequests parameter contains pairs of apiId and correlationId, multiply index by 2 to preserve pairs
		            const apiId = serverTelemetryEntity.failedRequests[2 * i] ||
		                Constants$1.EMPTY_STRING;
		            const correlationId = serverTelemetryEntity.failedRequests[2 * i + 1] ||
		                Constants$1.EMPTY_STRING;
		            const errorCode = serverTelemetryEntity.errors[i] || Constants$1.EMPTY_STRING;
		            // Count number of characters that would be added to header, each character is 1 byte. Add 3 at the end to account for separators
		            dataSize +=
		                apiId.toString().length +
		                    correlationId.toString().length +
		                    errorCode.length +
		                    3;
		            if (dataSize < SERVER_TELEM_CONSTANTS.MAX_LAST_HEADER_BYTES) {
		                // Adding this entry to the header would still keep header size below the limit
		                maxErrors += 1;
		            }
		            else {
		                break;
		            }
		        }
		        return maxErrors;
		    }
		    /**
		     * Get the region discovery fields
		     *
		     * @returns string
		     */
		    getRegionDiscoveryFields() {
		        const regionDiscoveryFields = [];
		        regionDiscoveryFields.push(this.regionUsed || Constants$1.EMPTY_STRING);
		        regionDiscoveryFields.push(this.regionSource || Constants$1.EMPTY_STRING);
		        regionDiscoveryFields.push(this.regionOutcome || Constants$1.EMPTY_STRING);
		        return regionDiscoveryFields.join(",");
		    }
		    /**
		     * Update the region discovery metadata
		     *
		     * @param regionDiscoveryMetadata
		     * @returns void
		     */
		    updateRegionDiscoveryMetadata(regionDiscoveryMetadata) {
		        this.regionUsed = regionDiscoveryMetadata.region_used;
		        this.regionSource = regionDiscoveryMetadata.region_source;
		        this.regionOutcome = regionDiscoveryMetadata.region_outcome;
		    }
		    /**
		     * Set cache outcome
		     */
		    setCacheOutcome(cacheOutcome) {
		        this.cacheOutcome = cacheOutcome;
		    }
		    setNativeBrokerErrorCode(errorCode) {
		        const lastRequests = this.getLastRequests();
		        lastRequests.nativeBrokerErrorCode = errorCode;
		        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
		    }
		    getNativeBrokerErrorCode() {
		        return this.getLastRequests().nativeBrokerErrorCode;
		    }
		    clearNativeBrokerErrorCode() {
		        const lastRequests = this.getLastRequests();
		        delete lastRequests.nativeBrokerErrorCode;
		        this.cacheManager.setServerTelemetry(this.telemetryCacheKey, lastRequests, this.correlationId);
		    }
		    static makeExtraSkuString(params) {
		        return makeExtraSkuString(params);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * This class deserializes cache entities read from the file into in-memory object types defined internally
		 * @internal
		 */
		class Deserializer {
		    /**
		     * Parse the JSON blob in memory and deserialize the content
		     * @param cachedJson - JSON blob cache
		     */
		    static deserializeJSONBlob(jsonFile) {
		        const deserializedCache = !jsonFile ? {} : JSON.parse(jsonFile);
		        return deserializedCache;
		    }
		    /**
		     * Deserializes accounts to AccountEntity objects
		     * @param accounts - accounts of type SerializedAccountEntity
		     */
		    static deserializeAccounts(accounts) {
		        const accountObjects = {};
		        if (accounts) {
		            Object.keys(accounts).map(function (key) {
		                const serializedAcc = accounts[key];
		                const mappedAcc = {
		                    homeAccountId: serializedAcc.home_account_id,
		                    environment: serializedAcc.environment,
		                    realm: serializedAcc.realm,
		                    localAccountId: serializedAcc.local_account_id,
		                    username: serializedAcc.username,
		                    authorityType: serializedAcc.authority_type,
		                    name: serializedAcc.name,
		                    clientInfo: serializedAcc.client_info,
		                    lastModificationTime: serializedAcc.last_modification_time,
		                    lastModificationApp: serializedAcc.last_modification_app,
		                    tenantProfiles: serializedAcc.tenantProfiles?.map((serializedTenantProfile) => {
		                        return JSON.parse(serializedTenantProfile);
		                    }),
		                    lastUpdatedAt: Date.now().toString(),
		                };
		                const account = new AccountEntity();
		                CacheManager.toObject(account, mappedAcc);
		                accountObjects[key] = account;
		            });
		        }
		        return accountObjects;
		    }
		    /**
		     * Deserializes id tokens to IdTokenEntity objects
		     * @param idTokens - credentials of type SerializedIdTokenEntity
		     */
		    static deserializeIdTokens(idTokens) {
		        const idObjects = {};
		        if (idTokens) {
		            Object.keys(idTokens).map(function (key) {
		                const serializedIdT = idTokens[key];
		                const idToken = {
		                    homeAccountId: serializedIdT.home_account_id,
		                    environment: serializedIdT.environment,
		                    credentialType: serializedIdT.credential_type,
		                    clientId: serializedIdT.client_id,
		                    secret: serializedIdT.secret,
		                    realm: serializedIdT.realm,
		                    lastUpdatedAt: Date.now().toString(),
		                };
		                idObjects[key] = idToken;
		            });
		        }
		        return idObjects;
		    }
		    /**
		     * Deserializes access tokens to AccessTokenEntity objects
		     * @param accessTokens - access tokens of type SerializedAccessTokenEntity
		     */
		    static deserializeAccessTokens(accessTokens) {
		        const atObjects = {};
		        if (accessTokens) {
		            Object.keys(accessTokens).map(function (key) {
		                const serializedAT = accessTokens[key];
		                const accessToken = {
		                    homeAccountId: serializedAT.home_account_id,
		                    environment: serializedAT.environment,
		                    credentialType: serializedAT.credential_type,
		                    clientId: serializedAT.client_id,
		                    secret: serializedAT.secret,
		                    realm: serializedAT.realm,
		                    target: serializedAT.target,
		                    cachedAt: serializedAT.cached_at,
		                    expiresOn: serializedAT.expires_on,
		                    extendedExpiresOn: serializedAT.extended_expires_on,
		                    refreshOn: serializedAT.refresh_on,
		                    keyId: serializedAT.key_id,
		                    tokenType: serializedAT.token_type,
		                    requestedClaims: serializedAT.requestedClaims,
		                    requestedClaimsHash: serializedAT.requestedClaimsHash,
		                    userAssertionHash: serializedAT.userAssertionHash,
		                    lastUpdatedAt: Date.now().toString(),
		                };
		                atObjects[key] = accessToken;
		            });
		        }
		        return atObjects;
		    }
		    /**
		     * Deserializes refresh tokens to RefreshTokenEntity objects
		     * @param refreshTokens - refresh tokens of type SerializedRefreshTokenEntity
		     */
		    static deserializeRefreshTokens(refreshTokens) {
		        const rtObjects = {};
		        if (refreshTokens) {
		            Object.keys(refreshTokens).map(function (key) {
		                const serializedRT = refreshTokens[key];
		                const refreshToken = {
		                    homeAccountId: serializedRT.home_account_id,
		                    environment: serializedRT.environment,
		                    credentialType: serializedRT.credential_type,
		                    clientId: serializedRT.client_id,
		                    secret: serializedRT.secret,
		                    familyId: serializedRT.family_id,
		                    target: serializedRT.target,
		                    realm: serializedRT.realm,
		                    lastUpdatedAt: Date.now().toString(),
		                };
		                rtObjects[key] = refreshToken;
		            });
		        }
		        return rtObjects;
		    }
		    /**
		     * Deserializes appMetadata to AppMetaData objects
		     * @param appMetadata - app metadata of type SerializedAppMetadataEntity
		     */
		    static deserializeAppMetadata(appMetadata) {
		        const appMetadataObjects = {};
		        if (appMetadata) {
		            Object.keys(appMetadata).map(function (key) {
		                const serializedAmdt = appMetadata[key];
		                appMetadataObjects[key] = {
		                    clientId: serializedAmdt.client_id,
		                    environment: serializedAmdt.environment,
		                    familyId: serializedAmdt.family_id,
		                };
		            });
		        }
		        return appMetadataObjects;
		    }
		    /**
		     * Deserialize an inMemory Cache
		     * @param jsonCache - JSON blob cache
		     */
		    static deserializeAllCache(jsonCache) {
		        return {
		            accounts: jsonCache.Account
		                ? this.deserializeAccounts(jsonCache.Account)
		                : {},
		            idTokens: jsonCache.IdToken
		                ? this.deserializeIdTokens(jsonCache.IdToken)
		                : {},
		            accessTokens: jsonCache.AccessToken
		                ? this.deserializeAccessTokens(jsonCache.AccessToken)
		                : {},
		            refreshTokens: jsonCache.RefreshToken
		                ? this.deserializeRefreshTokens(jsonCache.RefreshToken)
		                : {},
		            appMetadata: jsonCache.AppMetadata
		                ? this.deserializeAppMetadata(jsonCache.AppMetadata)
		                : {},
		        };
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Warning: This set of exports is purely intended to be used by other MSAL libraries, and should be considered potentially unstable. We strongly discourage using them directly, you do so at your own risk.
		 * Breaking changes to these APIs will be shipped under a minor version, instead of a major version.
		 */

		var internals = /*#__PURE__*/Object.freeze({
		    __proto__: null,
		    Deserializer: Deserializer,
		    Serializer: Serializer
		});

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		// MSI Constants. Docs for MSI are available here https://docs.microsoft.com/azure/app-service/overview-managed-identity
		const DEFAULT_MANAGED_IDENTITY_ID = "system_assigned_managed_identity";
		const MANAGED_IDENTITY_DEFAULT_TENANT = "managed_identity";
		const DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY = `https://login.microsoftonline.com/${MANAGED_IDENTITY_DEFAULT_TENANT}/`;
		/**
		 * Managed Identity Headers - used in network requests
		 */
		const ManagedIdentityHeaders = {
		    AUTHORIZATION_HEADER_NAME: "Authorization",
		    METADATA_HEADER_NAME: "Metadata",
		    APP_SERVICE_SECRET_HEADER_NAME: "X-IDENTITY-HEADER",
		    ML_AND_SF_SECRET_HEADER_NAME: "secret",
		};
		/**
		 * Managed Identity Query Parameters - used in network requests
		 */
		const ManagedIdentityQueryParameters = {
		    API_VERSION: "api-version",
		    RESOURCE: "resource",
		    SHA256_TOKEN_TO_REFRESH: "token_sha256_to_refresh",
		    XMS_CC: "xms_cc",
		};
		/**
		 * Managed Identity Environment Variable Names
		 */
		const ManagedIdentityEnvironmentVariableNames = {
		    AZURE_POD_IDENTITY_AUTHORITY_HOST: "AZURE_POD_IDENTITY_AUTHORITY_HOST",
		    DEFAULT_IDENTITY_CLIENT_ID: "DEFAULT_IDENTITY_CLIENT_ID",
		    IDENTITY_ENDPOINT: "IDENTITY_ENDPOINT",
		    IDENTITY_HEADER: "IDENTITY_HEADER",
		    IDENTITY_SERVER_THUMBPRINT: "IDENTITY_SERVER_THUMBPRINT",
		    IMDS_ENDPOINT: "IMDS_ENDPOINT",
		    MSI_ENDPOINT: "MSI_ENDPOINT",
		    MSI_SECRET: "MSI_SECRET",
		};
		/**
		 * Managed Identity Source Names
		 * @public
		 */
		const ManagedIdentitySourceNames = {
		    APP_SERVICE: "AppService",
		    AZURE_ARC: "AzureArc",
		    CLOUD_SHELL: "CloudShell",
		    DEFAULT_TO_IMDS: "DefaultToImds",
		    IMDS: "Imds",
		    MACHINE_LEARNING: "MachineLearning",
		    SERVICE_FABRIC: "ServiceFabric",
		};
		/**
		 * Managed Identity Ids
		 */
		const ManagedIdentityIdType = {
		    SYSTEM_ASSIGNED: "system-assigned",
		    USER_ASSIGNED_CLIENT_ID: "user-assigned-client-id",
		    USER_ASSIGNED_RESOURCE_ID: "user-assigned-resource-id",
		    USER_ASSIGNED_OBJECT_ID: "user-assigned-object-id",
		};
		/**
		 * http methods
		 */
		const HttpMethod = {
		    GET: "get",
		    POST: "post",
		};
		const ProxyStatus = {
		    SUCCESS_RANGE_START: HttpStatus.SUCCESS_RANGE_START,
		    SUCCESS_RANGE_END: HttpStatus.SUCCESS_RANGE_END,
		    SERVER_ERROR: HttpStatus.SERVER_ERROR,
		};
		/**
		 * Constants used for region discovery
		 */
		const REGION_ENVIRONMENT_VARIABLE = "REGION_NAME";
		const MSAL_FORCE_REGION = "MSAL_FORCE_REGION";
		/**
		 * Constant used for PKCE
		 */
		const RANDOM_OCTET_SIZE = 32;
		/**
		 * Constants used in PKCE
		 */
		const Hash = {
		    SHA256: "sha256",
		};
		/**
		 * Constants for encoding schemes
		 */
		const CharSet = {
		    CV_CHARSET: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",
		};
		/**
		 * Cache Constants
		 */
		const CACHE = {
		    KEY_SEPARATOR: "-",
		};
		/**
		 * Constants
		 */
		const Constants = {
		    MSAL_SKU: "msal.js.node",
		    JWT_BEARER_ASSERTION_TYPE: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
		    AUTHORIZATION_PENDING: "authorization_pending",
		    HTTP_PROTOCOL: "http://",
		    LOCALHOST: "localhost",
		};
		/**
		 * API Codes for Telemetry purposes.
		 * Before adding a new code you must claim it in the MSAL Telemetry tracker as these number spaces are shared across all MSALs
		 * 0-99 Silent Flow
		 * 600-699 Device Code Flow
		 * 800-899 Auth Code Flow
		 */
		const ApiId = {
		    acquireTokenSilent: 62,
		    acquireTokenByUsernamePassword: 371,
		    acquireTokenByDeviceCode: 671,
		    acquireTokenByClientCredential: 771,
		    acquireTokenByCode: 871,
		    acquireTokenByRefreshToken: 872,
		};
		/**
		 * JWT  constants
		 */
		const JwtConstants = {
		    RSA_256: "RS256",
		    PSS_256: "PS256",
		    X5T_256: "x5t#S256",
		    X5T: "x5t",
		    X5C: "x5c",
		    AUDIENCE: "aud",
		    EXPIRATION_TIME: "exp",
		    ISSUER: "iss",
		    SUBJECT: "sub",
		    NOT_BEFORE: "nbf",
		    JWT_ID: "jti",
		};
		const LOOPBACK_SERVER_CONSTANTS = {
		    INTERVAL_MS: 100,
		    TIMEOUT_MS: 5000,
		};
		const AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES = 4096; // 4 KB

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class NetworkUtils {
		    static getNetworkResponse(headers, body, statusCode) {
		        return {
		            headers: headers,
		            body: body,
		            status: statusCode,
		        };
		    }
		    /*
		     * Utility function that converts a URL object into an ordinary options object as expected by the
		     * http.request and https.request APIs.
		     * https://github.com/nodejs/node/blob/main/lib/internal/url.js#L1090
		     */
		    static urlToHttpOptions(url) {
		        const options = {
		            protocol: url.protocol,
		            hostname: url.hostname && url.hostname.startsWith("[")
		                ? url.hostname.slice(1, -1)
		                : url.hostname,
		            hash: url.hash,
		            search: url.search,
		            pathname: url.pathname,
		            path: `${url.pathname || ""}${url.search || ""}`,
		            href: url.href,
		        };
		        if (url.port !== "") {
		            options.port = Number(url.port);
		        }
		        if (url.username || url.password) {
		            options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;
		        }
		        return options;
		    }
		}

		/* eslint-disable header/header */
		const name = "@azure/msal-node";
		const version = "3.8.4";

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * This class implements the API for network requests.
		 */
		class HttpClient {
		    constructor(proxyUrl, customAgentOptions, loggerOptions) {
		        this.networkRequestViaProxy = (httpMethod, destinationUrlString, options, timeout) => {
		            const destinationUrl = new URL(destinationUrlString);
		            const proxyUrl = new URL(this.proxyUrl);
		            // "method: connect" must be used to establish a connection to the proxy
		            const headers = options?.headers || {};
		            const tunnelRequestOptions = {
		                host: proxyUrl.hostname,
		                port: proxyUrl.port,
		                method: "CONNECT",
		                path: destinationUrl.hostname,
		                headers: headers,
		            };
		            if (this.customAgentOptions &&
		                Object.keys(this.customAgentOptions).length) {
		                tunnelRequestOptions.agent = new http.Agent(this.customAgentOptions);
		            }
		            // compose a request string for the socket
		            let postRequestStringContent = "";
		            if (httpMethod === HttpMethod.POST) {
		                const body = options?.body || "";
		                postRequestStringContent =
		                    "Content-Type: application/x-www-form-urlencoded\r\n" +
		                        `Content-Length: ${body.length}\r\n` +
		                        `\r\n${body}`;
		            }
		            else {
		                // optional timeout is only for get requests (regionDiscovery, for example)
		                if (timeout) {
		                    tunnelRequestOptions.timeout = timeout;
		                }
		            }
		            const outgoingRequestString = `${httpMethod.toUpperCase()} ${destinationUrl.href} HTTP/1.1\r\n` +
		                `Host: ${destinationUrl.host}\r\n` +
		                "Connection: close\r\n" +
		                postRequestStringContent +
		                "\r\n";
		            return new Promise((resolve, reject) => {
		                const request = http.request(tunnelRequestOptions);
		                if (timeout) {
		                    request.on("timeout", () => {
		                        this.logUrlWithPiiAwareness(`Request timeout after ${timeout}ms for URL`, destinationUrlString);
		                        request.destroy();
		                        reject(new Error(`Request time out after ${timeout}ms`));
		                    });
		                }
		                request.end();
		                // establish connection to the proxy
		                request.on("connect", (response, socket) => {
		                    const proxyStatusCode = response?.statusCode || ProxyStatus.SERVER_ERROR;
		                    if (proxyStatusCode < ProxyStatus.SUCCESS_RANGE_START ||
		                        proxyStatusCode > ProxyStatus.SUCCESS_RANGE_END) {
		                        request.destroy();
		                        socket.destroy();
		                        reject(new Error(`Error connecting to proxy. Http status code: ${response.statusCode}. Http status message: ${response?.statusMessage || "Unknown"}`));
		                    }
		                    // make a request over an HTTP tunnel
		                    socket.write(outgoingRequestString);
		                    const data = [];
		                    socket.on("data", (chunk) => {
		                        data.push(chunk);
		                    });
		                    socket.on("end", () => {
		                        // combine all received buffer streams into one buffer, and then into a string
		                        const dataString = Buffer.concat([...data]).toString();
		                        // separate each line into it's own entry in an arry
		                        const dataStringArray = dataString.split("\r\n");
		                        // the first entry will contain the statusCode and statusMessage
		                        const httpStatusCode = parseInt(dataStringArray[0].split(" ")[1]);
		                        // remove "HTTP/1.1" and the status code to get the status message
		                        const statusMessage = dataStringArray[0]
		                            .split(" ")
		                            .slice(2)
		                            .join(" ");
		                        // the last entry will contain the body
		                        const body = dataStringArray[dataStringArray.length - 1];
		                        // everything in between the first and last entries are the headers
		                        const headersArray = dataStringArray.slice(1, dataStringArray.length - 2);
		                        // build an object out of all the headers
		                        const entries = new Map();
		                        headersArray.forEach((header) => {
		                            /**
		                             * the header might look like "Content-Length: 1531", but that is just a string
		                             * it needs to be converted to a key/value pair
		                             * split the string at the first instance of ":"
		                             * there may be more than one ":" if the value of the header is supposed to be a JSON object
		                             */
		                            const headerKeyValue = header.split(new RegExp(/:\s(.*)/s));
		                            const headerKey = headerKeyValue[0];
		                            let headerValue = headerKeyValue[1];
		                            // check if the value of the header is supposed to be a JSON object
		                            try {
		                                const object = JSON.parse(headerValue);
		                                // if it is, then convert it from a string to a JSON object
		                                if (object && typeof object === "object") {
		                                    headerValue = object;
		                                }
		                            }
		                            catch (e) {
		                                // otherwise, leave it as a string
		                            }
		                            entries.set(headerKey, headerValue);
		                        });
		                        const headers = Object.fromEntries(entries);
		                        const parsedHeaders = headers;
		                        const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, this.parseBody(httpStatusCode, statusMessage, parsedHeaders, body), httpStatusCode);
		                        if (this.shouldDestroyRequest(httpStatusCode, networkResponse)) {
		                            request.destroy();
		                        }
		                        resolve(networkResponse);
		                    });
		                    socket.on("error", (chunk) => {
		                        request.destroy();
		                        socket.destroy();
		                        reject(new Error(chunk.toString()));
		                    });
		                });
		                request.on("error", (chunk) => {
		                    this.logger.error(`HttpClient - Proxy request error: ${chunk.toString()}`, "");
		                    this.logUrlWithPiiAwareness("Destination URL", destinationUrlString);
		                    this.logUrlWithPiiAwareness("Proxy URL", this.proxyUrl);
		                    this.logger.error(`HttpClient - Method: ${httpMethod}`, "");
		                    this.logger.errorPii(`HttpClient - Headers: ${JSON.stringify(headers)}`, "");
		                    request.destroy();
		                    reject(new Error(chunk.toString()));
		                });
		            });
		        };
		        this.networkRequestViaHttps = (httpMethod, urlString, options, timeout) => {
		            const isPostRequest = httpMethod === HttpMethod.POST;
		            const body = options?.body || "";
		            const url = new URL(urlString);
		            const headers = options?.headers || {};
		            const customOptions = {
		                method: httpMethod,
		                headers: headers,
		                ...NetworkUtils.urlToHttpOptions(url),
		            };
		            if (this.customAgentOptions &&
		                Object.keys(this.customAgentOptions).length) {
		                customOptions.agent = new https.Agent(this.customAgentOptions);
		            }
		            if (isPostRequest) {
		                // needed for post request to work
		                customOptions.headers = {
		                    ...customOptions.headers,
		                    "Content-Length": body.length,
		                };
		            }
		            else {
		                // optional timeout is only for get requests (regionDiscovery, for example)
		                if (timeout) {
		                    customOptions.timeout = timeout;
		                }
		            }
		            return new Promise((resolve, reject) => {
		                let request;
		                // managed identity sources use http instead of https
		                if (customOptions.protocol === "http:") {
		                    request = http.request(customOptions);
		                }
		                else {
		                    request = https.request(customOptions);
		                }
		                if (isPostRequest) {
		                    request.write(body);
		                }
		                if (timeout) {
		                    request.on("timeout", () => {
		                        this.logUrlWithPiiAwareness(`HTTPS request timeout after ${timeout}ms for URL`, urlString);
		                        request.destroy();
		                        reject(new Error(`Request time out after ${timeout}ms`));
		                    });
		                }
		                request.end();
		                request.on("response", (response) => {
		                    const headers = response.headers;
		                    const statusCode = response.statusCode;
		                    const statusMessage = response.statusMessage;
		                    const data = [];
		                    response.on("data", (chunk) => {
		                        data.push(chunk);
		                    });
		                    response.on("end", () => {
		                        // combine all received buffer streams into one buffer, and then into a string
		                        const body = Buffer.concat([...data]).toString();
		                        const parsedHeaders = headers;
		                        const networkResponse = NetworkUtils.getNetworkResponse(parsedHeaders, this.parseBody(statusCode, statusMessage, parsedHeaders, body), statusCode);
		                        if (this.shouldDestroyRequest(statusCode, networkResponse)) {
		                            request.destroy();
		                        }
		                        resolve(networkResponse);
		                    });
		                });
		                request.on("error", (chunk) => {
		                    this.logger.error(`HttpClient - HTTPS request error: ${chunk.toString()}`, "");
		                    this.logUrlWithPiiAwareness("URL", urlString);
		                    this.logger.error(`HttpClient - Method: ${httpMethod}`, "");
		                    this.logger.errorPii(`HttpClient - Headers: ${JSON.stringify(headers)}`, "");
		                    request.destroy();
		                    reject(new Error(chunk.toString()));
		                });
		            });
		        };
		        /**
		         * Check if extra parsing is needed on the repsonse from the server
		         * @param statusCode {number} the status code of the response from the server
		         * @param statusMessage {string | undefined} the status message of the response from the server
		         * @param headers {Record<string, string>} the headers of the response from the server
		         * @param body {string} the body from the response of the server
		         * @returns {Object} JSON parsed body or error object
		         */
		        this.parseBody = (statusCode, statusMessage, headers, body) => {
		            /*
		             * Informational responses (100  199)
		             * Successful responses (200  299)
		             * Redirection messages (300  399)
		             * Client error responses (400  499)
		             * Server error responses (500  599)
		             */
		            let parsedBody;
		            try {
		                parsedBody = JSON.parse(body);
		            }
		            catch (error) {
		                let errorType;
		                let errorDescriptionHelper;
		                if (statusCode >= HttpStatus.CLIENT_ERROR_RANGE_START &&
		                    statusCode <= HttpStatus.CLIENT_ERROR_RANGE_END) {
		                    errorType = "client_error";
		                    errorDescriptionHelper = "A client";
		                }
		                else if (statusCode >= HttpStatus.SERVER_ERROR_RANGE_START &&
		                    statusCode <= HttpStatus.SERVER_ERROR_RANGE_END) {
		                    errorType = "server_error";
		                    errorDescriptionHelper = "A server";
		                }
		                else {
		                    errorType = "unknown_error";
		                    errorDescriptionHelper = "An unknown";
		                }
		                parsedBody = {
		                    error: errorType,
		                    error_description: `${errorDescriptionHelper} error occured.\nHttp status code: ${statusCode}\nHttp status message: ${statusMessage || "Unknown"}\nHeaders: ${JSON.stringify(headers)}`,
		                };
		            }
		            return parsedBody;
		        };
		        /**
		         * Helper function to log a formatted message containing URLs, with PII-aware sanitization
		         * @param label {string} the label for the log message
		         * @param urlString {string} the URL to log
		         */
		        this.logUrlWithPiiAwareness = (label, urlString) => {
		            if (this.isPiiEnabled) {
		                this.logger.errorPii(`HttpClient - ${label}: ${urlString}`, "");
		            }
		            else {
		                let urlHelper;
		                try {
		                    const url = new URL(urlString);
		                    urlHelper = `${url.protocol}//${url.host}${url.pathname}`;
		                }
		                catch {
		                    urlHelper = urlString.split("?")[0] || "unknown";
		                }
		                this.logger.error(`HttpClient - ${label}: ${urlHelper} [Enable PII logging to see additional details]`, "");
		            }
		        };
		        /**
		         * Helper function to determine if a request should be destroyed based on status code and response body.
		         * Checks if the response is an error and not part of the device code flow (authorization_pending).
		         * @param statusCode {number} the status code of the response
		         * @param networkResponse {NetworkResponse<T>} the network response object
		         * @returns {boolean} true if the request should be destroyed, false otherwise
		         */
		        this.shouldDestroyRequest = (statusCode, networkResponse) => {
		            return ((statusCode < HttpStatus.SUCCESS_RANGE_START ||
		                statusCode > HttpStatus.SUCCESS_RANGE_END) &&
		                // do not destroy the request for the device code flow
		                !(networkResponse.body &&
		                    typeof networkResponse.body === "object" &&
		                    "error" in networkResponse.body &&
		                    networkResponse.body.error ===
		                        Constants.AUTHORIZATION_PENDING));
		        };
		        this.proxyUrl = proxyUrl || "";
		        this.customAgentOptions = customAgentOptions || {};
		        this.logger = new Logger(loggerOptions || {}, name, version);
		        this.isPiiEnabled = this.logger.isPiiLoggingEnabled();
		    }
		    /**
		     * Http Get request
		     * @param url
		     * @param options
		     */
		    async sendGetRequestAsync(url, options, timeout) {
		        if (this.proxyUrl) {
		            return this.networkRequestViaProxy(HttpMethod.GET, url, options, timeout);
		        }
		        else {
		            return this.networkRequestViaHttps(HttpMethod.GET, url, options, timeout);
		        }
		    }
		    /**
		     * Http Post request
		     * @param url
		     * @param options
		     */
		    async sendPostRequestAsync(url, options) {
		        if (this.proxyUrl) {
		            return this.networkRequestViaProxy(HttpMethod.POST, url, options);
		        }
		        else {
		            return this.networkRequestViaHttps(HttpMethod.POST, url, options);
		        }
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const invalidFileExtension = "invalid_file_extension";
		const invalidFilePath = "invalid_file_path";
		const invalidManagedIdentityIdType = "invalid_managed_identity_id_type";
		const invalidSecret = "invalid_secret";
		const missingId = "missing_client_id";
		const networkUnavailable = "network_unavailable";
		const platformNotSupported = "platform_not_supported";
		const unableToCreateAzureArc = "unable_to_create_azure_arc";
		const unableToCreateCloudShell = "unable_to_create_cloud_shell";
		const unableToCreateSource = "unable_to_create_source";
		const unableToReadSecretFile = "unable_to_read_secret_file";
		const userAssignedNotAvailableAtRuntime = "user_assigned_not_available_at_runtime";
		const wwwAuthenticateHeaderMissing = "www_authenticate_header_missing";
		const wwwAuthenticateHeaderUnsupportedFormat = "www_authenticate_header_unsupported_format";
		const MsiEnvironmentVariableUrlMalformedErrorCodes = {
		    [ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST]: "azure_pod_identity_authority_host_url_malformed",
		    [ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT]: "identity_endpoint_url_malformed",
		    [ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT]: "imds_endpoint_url_malformed",
		    [ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT]: "msi_endpoint_url_malformed",
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * ManagedIdentityErrorMessage class containing string constants used by error codes and messages.
		 */
		const ManagedIdentityErrorMessages = {
		    [invalidFileExtension]: "The file path in the WWW-Authenticate header does not contain a .key file.",
		    [invalidFilePath]: "The file path in the WWW-Authenticate header is not in a valid Windows or Linux Format.",
		    [invalidManagedIdentityIdType]: "More than one ManagedIdentityIdType was provided.",
		    [invalidSecret]: "The secret in the file on the file path in the WWW-Authenticate header is greater than 4096 bytes.",
		    [platformNotSupported]: "The platform is not supported by Azure Arc. Azure Arc only supports Windows and Linux.",
		    [missingId]: "A ManagedIdentityId id was not provided.",
		    [MsiEnvironmentVariableUrlMalformedErrorCodes
		        .AZURE_POD_IDENTITY_AUTHORITY_HOST]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST}' environment variable is malformed.`,
		    [MsiEnvironmentVariableUrlMalformedErrorCodes
		        .IDENTITY_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variable is malformed.`,
		    [MsiEnvironmentVariableUrlMalformedErrorCodes
		        .IMDS_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' environment variable is malformed.`,
		    [MsiEnvironmentVariableUrlMalformedErrorCodes
		        .MSI_ENDPOINT]: `The Managed Identity's '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}' environment variable is malformed.`,
		    [networkUnavailable]: "Authentication unavailable. The request to the managed identity endpoint timed out.",
		    [unableToCreateAzureArc]: "Azure Arc Managed Identities can only be system assigned.",
		    [unableToCreateCloudShell]: "Cloud Shell Managed Identities can only be system assigned.",
		    [unableToCreateSource]: "Unable to create a Managed Identity source based on environment variables.",
		    [unableToReadSecretFile]: "Unable to read the secret file.",
		    [userAssignedNotAvailableAtRuntime]: "Service Fabric user assigned managed identity ClientId or ResourceId is not configurable at runtime.",
		    [wwwAuthenticateHeaderMissing]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is missing.",
		    [wwwAuthenticateHeaderUnsupportedFormat]: "A 401 response was received form the Azure Arc Managed Identity, but the www-authenticate header is in an unsupported format.",
		};
		class ManagedIdentityError extends AuthError {
		    constructor(errorCode) {
		        super(errorCode, ManagedIdentityErrorMessages[errorCode]);
		        this.name = "ManagedIdentityError";
		        Object.setPrototypeOf(this, ManagedIdentityError.prototype);
		    }
		}
		function createManagedIdentityError(errorCode) {
		    return new ManagedIdentityError(errorCode);
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class ManagedIdentityId {
		    get id() {
		        return this._id;
		    }
		    set id(value) {
		        this._id = value;
		    }
		    get idType() {
		        return this._idType;
		    }
		    set idType(value) {
		        this._idType = value;
		    }
		    constructor(managedIdentityIdParams) {
		        const userAssignedClientId = managedIdentityIdParams?.userAssignedClientId;
		        const userAssignedResourceId = managedIdentityIdParams?.userAssignedResourceId;
		        const userAssignedObjectId = managedIdentityIdParams?.userAssignedObjectId;
		        if (userAssignedClientId) {
		            if (userAssignedResourceId || userAssignedObjectId) {
		                throw createManagedIdentityError(invalidManagedIdentityIdType);
		            }
		            this.id = userAssignedClientId;
		            this.idType = ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID;
		        }
		        else if (userAssignedResourceId) {
		            if (userAssignedClientId || userAssignedObjectId) {
		                throw createManagedIdentityError(invalidManagedIdentityIdType);
		            }
		            this.id = userAssignedResourceId;
		            this.idType = ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID;
		        }
		        else if (userAssignedObjectId) {
		            if (userAssignedClientId || userAssignedResourceId) {
		                throw createManagedIdentityError(invalidManagedIdentityIdType);
		            }
		            this.id = userAssignedObjectId;
		            this.idType = ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID;
		        }
		        else {
		            this.id = DEFAULT_MANAGED_IDENTITY_ID;
		            this.idType = ManagedIdentityIdType.SYSTEM_ASSIGNED;
		        }
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * NodeAuthErrorMessage class containing string constants used by error codes and messages.
		 */
		const NodeAuthErrorMessage = {
		    invalidLoopbackAddressType: {
		        code: "invalid_loopback_server_address_type",
		        desc: "Loopback server address is not type string. This is unexpected.",
		    },
		    unableToLoadRedirectUri: {
		        code: "unable_to_load_redirectUrl",
		        desc: "Loopback server callback was invoked without a url. This is unexpected.",
		    },
		    noAuthCodeInResponse: {
		        code: "no_auth_code_in_response",
		        desc: "No auth code found in the server response. Please check your network trace to determine what happened.",
		    },
		    noLoopbackServerExists: {
		        code: "no_loopback_server_exists",
		        desc: "No loopback server exists yet.",
		    },
		    loopbackServerAlreadyExists: {
		        code: "loopback_server_already_exists",
		        desc: "Loopback server already exists. Cannot create another.",
		    },
		    loopbackServerTimeout: {
		        code: "loopback_server_timeout",
		        desc: "Timed out waiting for auth code listener to be registered.",
		    },
		    stateNotFoundError: {
		        code: "state_not_found",
		        desc: "State not found. Please verify that the request originated from msal.",
		    },
		    thumbprintMissing: {
		        code: "thumbprint_missing_from_client_certificate",
		        desc: "Client certificate does not contain a SHA-1 or SHA-256 thumbprint.",
		    },
		    redirectUriNotSupported: {
		        code: "redirect_uri_not_supported",
		        desc: "RedirectUri is not supported in this scenario. Please remove redirectUri from the request.",
		    },
		};
		class NodeAuthError extends AuthError {
		    constructor(errorCode, errorMessage) {
		        super(errorCode, errorMessage);
		        this.name = "NodeAuthError";
		    }
		    /**
		     * Creates an error thrown if loopback server address is of type string.
		     */
		    static createInvalidLoopbackAddressTypeError() {
		        return new NodeAuthError(NodeAuthErrorMessage.invalidLoopbackAddressType.code, `${NodeAuthErrorMessage.invalidLoopbackAddressType.desc}`);
		    }
		    /**
		     * Creates an error thrown if the loopback server is unable to get a url.
		     */
		    static createUnableToLoadRedirectUrlError() {
		        return new NodeAuthError(NodeAuthErrorMessage.unableToLoadRedirectUri.code, `${NodeAuthErrorMessage.unableToLoadRedirectUri.desc}`);
		    }
		    /**
		     * Creates an error thrown if the server response does not contain an auth code.
		     */
		    static createNoAuthCodeInResponseError() {
		        return new NodeAuthError(NodeAuthErrorMessage.noAuthCodeInResponse.code, `${NodeAuthErrorMessage.noAuthCodeInResponse.desc}`);
		    }
		    /**
		     * Creates an error thrown if the loopback server has not been spun up yet.
		     */
		    static createNoLoopbackServerExistsError() {
		        return new NodeAuthError(NodeAuthErrorMessage.noLoopbackServerExists.code, `${NodeAuthErrorMessage.noLoopbackServerExists.desc}`);
		    }
		    /**
		     * Creates an error thrown if a loopback server already exists when attempting to create another one.
		     */
		    static createLoopbackServerAlreadyExistsError() {
		        return new NodeAuthError(NodeAuthErrorMessage.loopbackServerAlreadyExists.code, `${NodeAuthErrorMessage.loopbackServerAlreadyExists.desc}`);
		    }
		    /**
		     * Creates an error thrown if the loopback server times out registering the auth code listener.
		     */
		    static createLoopbackServerTimeoutError() {
		        return new NodeAuthError(NodeAuthErrorMessage.loopbackServerTimeout.code, `${NodeAuthErrorMessage.loopbackServerTimeout.desc}`);
		    }
		    /**
		     * Creates an error thrown when the state is not present.
		     */
		    static createStateNotFoundError() {
		        return new NodeAuthError(NodeAuthErrorMessage.stateNotFoundError.code, NodeAuthErrorMessage.stateNotFoundError.desc);
		    }
		    /**
		     * Creates an error thrown when client certificate was provided, but neither the SHA-1 or SHA-256 thumbprints were provided
		     */
		    static createThumbprintMissingError() {
		        return new NodeAuthError(NodeAuthErrorMessage.thumbprintMissing.code, NodeAuthErrorMessage.thumbprintMissing.desc);
		    }
		    /**
		     * Creates an error thrown when redirectUri is provided in an unsupported scenario
		     */
		    static createRedirectUriNotSupportedError() {
		        return new NodeAuthError(NodeAuthErrorMessage.redirectUriNotSupported.code, NodeAuthErrorMessage.redirectUriNotSupported.desc);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const DEFAULT_AUTH_OPTIONS = {
		    clientId: Constants$1.EMPTY_STRING,
		    authority: Constants$1.DEFAULT_AUTHORITY,
		    clientSecret: Constants$1.EMPTY_STRING,
		    clientAssertion: Constants$1.EMPTY_STRING,
		    clientCertificate: {
		        thumbprint: Constants$1.EMPTY_STRING,
		        thumbprintSha256: Constants$1.EMPTY_STRING,
		        privateKey: Constants$1.EMPTY_STRING,
		        x5c: Constants$1.EMPTY_STRING,
		    },
		    knownAuthorities: [],
		    cloudDiscoveryMetadata: Constants$1.EMPTY_STRING,
		    authorityMetadata: Constants$1.EMPTY_STRING,
		    clientCapabilities: [],
		    protocolMode: ProtocolMode.AAD,
		    azureCloudOptions: {
		        azureCloudInstance: AzureCloudInstance.None,
		        tenant: Constants$1.EMPTY_STRING,
		    },
		    skipAuthorityMetadataCache: false,
		    encodeExtraQueryParams: false,
		};
		const DEFAULT_CACHE_OPTIONS = {
		    claimsBasedCachingEnabled: false,
		};
		const DEFAULT_LOGGER_OPTIONS = {
		    loggerCallback: () => {
		        // allow users to not set logger call back
		    },
		    piiLoggingEnabled: false,
		    logLevel: exports$1.LogLevel.Info,
		};
		const DEFAULT_SYSTEM_OPTIONS = {
		    loggerOptions: DEFAULT_LOGGER_OPTIONS,
		    networkClient: new HttpClient(),
		    proxyUrl: Constants$1.EMPTY_STRING,
		    customAgentOptions: {},
		    disableInternalRetries: false,
		};
		const DEFAULT_TELEMETRY_OPTIONS = {
		    application: {
		        appName: Constants$1.EMPTY_STRING,
		        appVersion: Constants$1.EMPTY_STRING,
		    },
		};
		/**
		 * Sets the default options when not explicitly configured from app developer
		 *
		 * @param auth - Authentication options
		 * @param cache - Cache options
		 * @param system - System options
		 * @param telemetry - Telemetry options
		 *
		 * @returns Configuration
		 * @internal
		 */
		function buildAppConfiguration({ auth, broker, cache, system, telemetry, }) {
		    const systemOptions = {
		        ...DEFAULT_SYSTEM_OPTIONS,
		        networkClient: new HttpClient(system?.proxyUrl, system?.customAgentOptions),
		        loggerOptions: system?.loggerOptions || DEFAULT_LOGGER_OPTIONS,
		        disableInternalRetries: system?.disableInternalRetries || false,
		    };
		    // if client certificate was provided, ensure that at least one of the SHA-1 or SHA-256 thumbprints were provided
		    if (!!auth.clientCertificate &&
		        !!!auth.clientCertificate.thumbprint &&
		        !!!auth.clientCertificate.thumbprintSha256) {
		        throw NodeAuthError.createStateNotFoundError();
		    }
		    return {
		        auth: { ...DEFAULT_AUTH_OPTIONS, ...auth },
		        broker: { ...broker },
		        cache: { ...DEFAULT_CACHE_OPTIONS, ...cache },
		        system: { ...systemOptions, ...system },
		        telemetry: { ...DEFAULT_TELEMETRY_OPTIONS, ...telemetry },
		    };
		}
		function buildManagedIdentityConfiguration({ clientCapabilities, managedIdentityIdParams, system, }) {
		    const managedIdentityId = new ManagedIdentityId(managedIdentityIdParams);
		    const loggerOptions = system?.loggerOptions || DEFAULT_LOGGER_OPTIONS;
		    let networkClient;
		    // use developer provided network client if passed in
		    if (system?.networkClient) {
		        networkClient = system.networkClient;
		        // otherwise, create a new one
		    }
		    else {
		        networkClient = new HttpClient(system?.proxyUrl, system?.customAgentOptions);
		    }
		    return {
		        clientCapabilities: clientCapabilities || [],
		        managedIdentityId: managedIdentityId,
		        system: {
		            loggerOptions,
		            networkClient,
		        },
		        disableInternalRetries: system?.disableInternalRetries || false,
		    };
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class GuidGenerator {
		    /**
		     *
		     * RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or pseudo-random numbers.
		     * uuidv4 generates guids from cryprtographically-string random
		     */
		    generateGuid() {
		        return uuid.v4();
		    }
		    /**
		     * verifies if a string is  GUID
		     * @param guid
		     */
		    isGuid(guid) {
		        const regexGuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
		        return regexGuid.test(guid);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class EncodingUtils {
		    /**
		     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
		     * 'base64': Base64 encoding.
		     *
		     * @param str text
		     */
		    static base64Encode(str, encoding) {
		        return Buffer.from(str, encoding).toString(EncodingTypes.BASE64);
		    }
		    /**
		     * encode a URL
		     * @param str
		     */
		    static base64EncodeUrl(str, encoding) {
		        return EncodingUtils.base64Encode(str, encoding)
		            .replace(/=/g, Constants$1.EMPTY_STRING)
		            .replace(/\+/g, "-")
		            .replace(/\//g, "_");
		    }
		    /**
		     * 'utf8': Multibyte encoded Unicode characters. Many web pages and other document formats use UTF-8.
		     * 'base64': Base64 encoding.
		     *
		     * @param base64Str Base64 encoded text
		     */
		    static base64Decode(base64Str) {
		        return Buffer.from(base64Str, EncodingTypes.BASE64).toString("utf8");
		    }
		    /**
		     * @param base64Str Base64 encoded Url
		     */
		    static base64DecodeUrl(base64Str) {
		        let str = base64Str.replace(/-/g, "+").replace(/_/g, "/");
		        while (str.length % 4) {
		            str += "=";
		        }
		        return EncodingUtils.base64Decode(str);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class HashUtils {
		    /**
		     * generate 'SHA256' hash
		     * @param buffer
		     */
		    sha256(buffer) {
		        return crypto.createHash(Hash.SHA256).update(buffer).digest();
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * https://tools.ietf.org/html/rfc7636#page-8
		 */
		class PkceGenerator {
		    constructor() {
		        this.hashUtils = new HashUtils();
		    }
		    /**
		     * generates the codeVerfier and the challenge from the codeVerfier
		     * reference: https://tools.ietf.org/html/rfc7636#section-4.1 and https://tools.ietf.org/html/rfc7636#section-4.2
		     */
		    async generatePkceCodes() {
		        const verifier = this.generateCodeVerifier();
		        const challenge = this.generateCodeChallengeFromVerifier(verifier);
		        return { verifier, challenge };
		    }
		    /**
		     * generates the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.1
		     */
		    generateCodeVerifier() {
		        const charArr = [];
		        const maxNumber = 256 - (256 % CharSet.CV_CHARSET.length);
		        while (charArr.length <= RANDOM_OCTET_SIZE) {
		            const byte = crypto.randomBytes(1)[0];
		            if (byte >= maxNumber) {
		                /*
		                 * Ignore this number to maintain randomness.
		                 * Including it would result in an unequal distribution of characters after doing the modulo
		                 */
		                continue;
		            }
		            const index = byte % CharSet.CV_CHARSET.length;
		            charArr.push(CharSet.CV_CHARSET[index]);
		        }
		        const verifier = charArr.join(Constants$1.EMPTY_STRING);
		        return EncodingUtils.base64EncodeUrl(verifier);
		    }
		    /**
		     * generate the challenge from the codeVerfier; reference: https://tools.ietf.org/html/rfc7636#section-4.2
		     * @param codeVerifier
		     */
		    generateCodeChallengeFromVerifier(codeVerifier) {
		        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(codeVerifier).toString(EncodingTypes.BASE64), EncodingTypes.BASE64);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * This class implements MSAL node's crypto interface, which allows it to perform base64 encoding and decoding, generating cryptographically random GUIDs and
		 * implementing Proof Key for Code Exchange specs for the OAuth Authorization Code Flow using PKCE (rfc here: https://tools.ietf.org/html/rfc7636).
		 * @public
		 */
		class CryptoProvider {
		    constructor() {
		        // Browser crypto needs to be validated first before any other classes can be set.
		        this.pkceGenerator = new PkceGenerator();
		        this.guidGenerator = new GuidGenerator();
		        this.hashUtils = new HashUtils();
		    }
		    /**
		     * base64 URL safe encoded string
		     */
		    base64UrlEncode() {
		        throw new Error("Method not implemented.");
		    }
		    /**
		     * Stringifies and base64Url encodes input public key
		     * @param inputKid - public key id
		     * @returns Base64Url encoded public key
		     */
		    encodeKid() {
		        throw new Error("Method not implemented.");
		    }
		    /**
		     * Creates a new random GUID - used to populate state and nonce.
		     * @returns string (GUID)
		     */
		    createNewGuid() {
		        return this.guidGenerator.generateGuid();
		    }
		    /**
		     * Encodes input string to base64.
		     * @param input - string to be encoded
		     */
		    base64Encode(input) {
		        return EncodingUtils.base64Encode(input);
		    }
		    /**
		     * Decodes input string from base64.
		     * @param input - string to be decoded
		     */
		    base64Decode(input) {
		        return EncodingUtils.base64Decode(input);
		    }
		    /**
		     * Generates PKCE codes used in Authorization Code Flow.
		     */
		    generatePkceCodes() {
		        return this.pkceGenerator.generatePkceCodes();
		    }
		    /**
		     * Generates a keypair, stores it and returns a thumbprint - not yet implemented for node
		     */
		    getPublicKeyThumbprint() {
		        throw new Error("Method not implemented.");
		    }
		    /**
		     * Removes cryptographic keypair from key store matching the keyId passed in
		     * @param kid - public key id
		     */
		    removeTokenBindingKey() {
		        throw new Error("Method not implemented.");
		    }
		    /**
		     * Removes all cryptographic keys from Keystore
		     */
		    clearKeystore() {
		        throw new Error("Method not implemented.");
		    }
		    /**
		     * Signs the given object as a jwt payload with private key retrieved by given kid - currently not implemented for node
		     */
		    signJwt() {
		        throw new Error("Method not implemented.");
		    }
		    /**
		     * Returns the SHA-256 hash of an input string
		     */
		    async hashString(plainText) {
		        return EncodingUtils.base64EncodeUrl(this.hashUtils.sha256(plainText).toString(EncodingTypes.BASE64), EncodingTypes.BASE64);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		function generateCredentialKey(credential) {
		    const familyId = (credential.credentialType === CredentialType.REFRESH_TOKEN &&
		        credential.familyId) ||
		        credential.clientId;
		    const scheme = credential.tokenType &&
		        credential.tokenType.toLowerCase() !==
		            AuthenticationScheme.BEARER.toLowerCase()
		        ? credential.tokenType.toLowerCase()
		        : "";
		    const credentialKey = [
		        credential.homeAccountId,
		        credential.environment,
		        credential.credentialType,
		        familyId,
		        credential.realm || "",
		        credential.target || "",
		        credential.requestedClaimsHash || "",
		        scheme,
		    ];
		    return credentialKey.join(CACHE.KEY_SEPARATOR).toLowerCase();
		}
		function generateAccountKey(account) {
		    const homeTenantId = account.homeAccountId.split(".")[1];
		    const accountKey = [
		        account.homeAccountId,
		        account.environment,
		        homeTenantId || account.tenantId || "",
		    ];
		    return accountKey.join(CACHE.KEY_SEPARATOR).toLowerCase();
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * This class implements Storage for node, reading cache from user specified storage location or an  extension library
		 * @public
		 */
		class NodeStorage extends CacheManager {
		    constructor(logger, clientId, cryptoImpl, staticAuthorityOptions) {
		        super(clientId, cryptoImpl, logger, new msalCommon.StubPerformanceClient(), staticAuthorityOptions);
		        this.cache = {};
		        this.changeEmitters = [];
		        this.logger = logger;
		    }
		    /**
		     * Queue up callbacks
		     * @param func - a callback function for cache change indication
		     */
		    registerChangeEmitter(func) {
		        this.changeEmitters.push(func);
		    }
		    /**
		     * Invoke the callback when cache changes
		     */
		    emitChange() {
		        this.changeEmitters.forEach((func) => func.call(null));
		    }
		    /**
		     * Converts cacheKVStore to InMemoryCache
		     * @param cache - key value store
		     */
		    cacheToInMemoryCache(cache) {
		        const inMemoryCache = {
		            accounts: {},
		            idTokens: {},
		            accessTokens: {},
		            refreshTokens: {},
		            appMetadata: {},
		        };
		        for (const key in cache) {
		            const value = cache[key];
		            if (typeof value !== "object") {
		                continue;
		            }
		            if (value instanceof AccountEntity) {
		                inMemoryCache.accounts[key] = value;
		            }
		            else if (isIdTokenEntity(value)) {
		                inMemoryCache.idTokens[key] = value;
		            }
		            else if (isAccessTokenEntity(value)) {
		                inMemoryCache.accessTokens[key] = value;
		            }
		            else if (isRefreshTokenEntity(value)) {
		                inMemoryCache.refreshTokens[key] = value;
		            }
		            else if (isAppMetadataEntity(key, value)) {
		                inMemoryCache.appMetadata[key] = value;
		            }
		            else {
		                continue;
		            }
		        }
		        return inMemoryCache;
		    }
		    /**
		     * converts inMemoryCache to CacheKVStore
		     * @param inMemoryCache - kvstore map for inmemory
		     */
		    inMemoryCacheToCache(inMemoryCache) {
		        // convert in memory cache to a flat Key-Value map
		        let cache = this.getCache();
		        cache = {
		            ...cache,
		            ...inMemoryCache.accounts,
		            ...inMemoryCache.idTokens,
		            ...inMemoryCache.accessTokens,
		            ...inMemoryCache.refreshTokens,
		            ...inMemoryCache.appMetadata,
		        };
		        // convert in memory cache to a flat Key-Value map
		        return cache;
		    }
		    /**
		     * gets the current in memory cache for the client
		     */
		    getInMemoryCache() {
		        this.logger.trace("Getting in-memory cache");
		        // convert the cache key value store to inMemoryCache
		        const inMemoryCache = this.cacheToInMemoryCache(this.getCache());
		        return inMemoryCache;
		    }
		    /**
		     * sets the current in memory cache for the client
		     * @param inMemoryCache - key value map in memory
		     */
		    setInMemoryCache(inMemoryCache) {
		        this.logger.trace("Setting in-memory cache");
		        // convert and append the inMemoryCache to cacheKVStore
		        const cache = this.inMemoryCacheToCache(inMemoryCache);
		        this.setCache(cache);
		        this.emitChange();
		    }
		    /**
		     * get the current cache key-value store
		     */
		    getCache() {
		        this.logger.trace("Getting cache key-value store");
		        return this.cache;
		    }
		    /**
		     * sets the current cache (key value store)
		     * @param cacheMap - key value map
		     */
		    setCache(cache) {
		        this.logger.trace("Setting cache key value store");
		        this.cache = cache;
		        // mark change in cache
		        this.emitChange();
		    }
		    /**
		     * Gets cache item with given key.
		     * @param key - lookup key for the cache entry
		     */
		    getItem(key) {
		        this.logger.tracePii(`Item key: ${key}`);
		        // read cache
		        const cache = this.getCache();
		        return cache[key];
		    }
		    /**
		     * Gets cache item with given key-value
		     * @param key - lookup key for the cache entry
		     * @param value - value of the cache entry
		     */
		    setItem(key, value) {
		        this.logger.tracePii(`Item key: ${key}`);
		        // read cache
		        const cache = this.getCache();
		        cache[key] = value;
		        // write to cache
		        this.setCache(cache);
		    }
		    generateCredentialKey(credential) {
		        return generateCredentialKey(credential);
		    }
		    generateAccountKey(account) {
		        return generateAccountKey(account);
		    }
		    getAccountKeys() {
		        const inMemoryCache = this.getInMemoryCache();
		        const accountKeys = Object.keys(inMemoryCache.accounts);
		        return accountKeys;
		    }
		    getTokenKeys() {
		        const inMemoryCache = this.getInMemoryCache();
		        const tokenKeys = {
		            idToken: Object.keys(inMemoryCache.idTokens),
		            accessToken: Object.keys(inMemoryCache.accessTokens),
		            refreshToken: Object.keys(inMemoryCache.refreshTokens),
		        };
		        return tokenKeys;
		    }
		    /**
		     * Reads account from cache, builds it into an account entity and returns it.
		     * @param accountKey - lookup key to fetch cache type AccountEntity
		     * @returns
		     */
		    getAccount(accountKey) {
		        const cachedAccount = this.getItem(accountKey);
		        return cachedAccount
		            ? Object.assign(new AccountEntity(), this.getItem(accountKey))
		            : null;
		    }
		    /**
		     * set account entity
		     * @param account - cache value to be set of type AccountEntity
		     */
		    async setAccount(account) {
		        const accountKey = this.generateAccountKey(AccountEntity.getAccountInfo(account));
		        this.setItem(accountKey, account);
		    }
		    /**
		     * fetch the idToken credential
		     * @param idTokenKey - lookup key to fetch cache type IdTokenEntity
		     */
		    getIdTokenCredential(idTokenKey) {
		        const idToken = this.getItem(idTokenKey);
		        if (isIdTokenEntity(idToken)) {
		            return idToken;
		        }
		        return null;
		    }
		    /**
		     * set idToken credential
		     * @param idToken - cache value to be set of type IdTokenEntity
		     */
		    async setIdTokenCredential(idToken) {
		        const idTokenKey = this.generateCredentialKey(idToken);
		        this.setItem(idTokenKey, idToken);
		    }
		    /**
		     * fetch the accessToken credential
		     * @param accessTokenKey - lookup key to fetch cache type AccessTokenEntity
		     */
		    getAccessTokenCredential(accessTokenKey) {
		        const accessToken = this.getItem(accessTokenKey);
		        if (isAccessTokenEntity(accessToken)) {
		            return accessToken;
		        }
		        return null;
		    }
		    /**
		     * set accessToken credential
		     * @param accessToken -  cache value to be set of type AccessTokenEntity
		     */
		    async setAccessTokenCredential(accessToken) {
		        const accessTokenKey = this.generateCredentialKey(accessToken);
		        this.setItem(accessTokenKey, accessToken);
		    }
		    /**
		     * fetch the refreshToken credential
		     * @param refreshTokenKey - lookup key to fetch cache type RefreshTokenEntity
		     */
		    getRefreshTokenCredential(refreshTokenKey) {
		        const refreshToken = this.getItem(refreshTokenKey);
		        if (isRefreshTokenEntity(refreshToken)) {
		            return refreshToken;
		        }
		        return null;
		    }
		    /**
		     * set refreshToken credential
		     * @param refreshToken - cache value to be set of type RefreshTokenEntity
		     */
		    async setRefreshTokenCredential(refreshToken) {
		        const refreshTokenKey = this.generateCredentialKey(refreshToken);
		        this.setItem(refreshTokenKey, refreshToken);
		    }
		    /**
		     * fetch appMetadata entity from the platform cache
		     * @param appMetadataKey - lookup key to fetch cache type AppMetadataEntity
		     */
		    getAppMetadata(appMetadataKey) {
		        const appMetadata = this.getItem(appMetadataKey);
		        if (isAppMetadataEntity(appMetadataKey, appMetadata)) {
		            return appMetadata;
		        }
		        return null;
		    }
		    /**
		     * set appMetadata entity to the platform cache
		     * @param appMetadata - cache value to be set of type AppMetadataEntity
		     */
		    setAppMetadata(appMetadata) {
		        const appMetadataKey = generateAppMetadataKey(appMetadata);
		        this.setItem(appMetadataKey, appMetadata);
		    }
		    /**
		     * fetch server telemetry entity from the platform cache
		     * @param serverTelemetrykey - lookup key to fetch cache type ServerTelemetryEntity
		     */
		    getServerTelemetry(serverTelemetrykey) {
		        const serverTelemetryEntity = this.getItem(serverTelemetrykey);
		        if (serverTelemetryEntity &&
		            isServerTelemetryEntity(serverTelemetrykey, serverTelemetryEntity)) {
		            return serverTelemetryEntity;
		        }
		        return null;
		    }
		    /**
		     * set server telemetry entity to the platform cache
		     * @param serverTelemetryKey - lookup key to fetch cache type ServerTelemetryEntity
		     * @param serverTelemetry - cache value to be set of type ServerTelemetryEntity
		     */
		    setServerTelemetry(serverTelemetryKey, serverTelemetry) {
		        this.setItem(serverTelemetryKey, serverTelemetry);
		    }
		    /**
		     * fetch authority metadata entity from the platform cache
		     * @param key - lookup key to fetch cache type AuthorityMetadataEntity
		     */
		    getAuthorityMetadata(key) {
		        const authorityMetadataEntity = this.getItem(key);
		        if (authorityMetadataEntity &&
		            isAuthorityMetadataEntity(key, authorityMetadataEntity)) {
		            return authorityMetadataEntity;
		        }
		        return null;
		    }
		    /**
		     * Get all authority metadata keys
		     */
		    getAuthorityMetadataKeys() {
		        return this.getKeys().filter((key) => {
		            return this.isAuthorityMetadata(key);
		        });
		    }
		    /**
		     * set authority metadata entity to the platform cache
		     * @param key - lookup key to fetch cache type AuthorityMetadataEntity
		     * @param metadata - cache value to be set of type AuthorityMetadataEntity
		     */
		    setAuthorityMetadata(key, metadata) {
		        this.setItem(key, metadata);
		    }
		    /**
		     * fetch throttling entity from the platform cache
		     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
		     */
		    getThrottlingCache(throttlingCacheKey) {
		        const throttlingCache = this.getItem(throttlingCacheKey);
		        if (throttlingCache &&
		            isThrottlingEntity(throttlingCacheKey, throttlingCache)) {
		            return throttlingCache;
		        }
		        return null;
		    }
		    /**
		     * set throttling entity to the platform cache
		     * @param throttlingCacheKey - lookup key to fetch cache type ThrottlingEntity
		     * @param throttlingCache - cache value to be set of type ThrottlingEntity
		     */
		    setThrottlingCache(throttlingCacheKey, throttlingCache) {
		        this.setItem(throttlingCacheKey, throttlingCache);
		    }
		    /**
		     * Removes the cache item from memory with the given key.
		     * @param key - lookup key to remove a cache entity
		     * @param inMemory - key value map of the cache
		     */
		    removeItem(key) {
		        this.logger.tracePii(`Item key: ${key}`);
		        // read inMemoryCache
		        let result = false;
		        const cache = this.getCache();
		        if (!!cache[key]) {
		            delete cache[key];
		            result = true;
		        }
		        // write to the cache after removal
		        if (result) {
		            this.setCache(cache);
		            this.emitChange();
		        }
		        return result;
		    }
		    /**
		     * Remove account entity from the platform cache if it's outdated
		     * @param accountKey - lookup key to fetch cache type AccountEntity
		     */
		    removeOutdatedAccount(accountKey) {
		        this.removeItem(accountKey);
		    }
		    /**
		     * Checks whether key is in cache.
		     * @param key - look up key for a cache entity
		     */
		    containsKey(key) {
		        return this.getKeys().includes(key);
		    }
		    /**
		     * Gets all keys in window.
		     */
		    getKeys() {
		        this.logger.trace("Retrieving all cache keys");
		        // read cache
		        const cache = this.getCache();
		        return [...Object.keys(cache)];
		    }
		    /**
		     * Clears all cache entries created by MSAL (except tokens).
		     */
		    clear() {
		        this.logger.trace("Clearing cache entries created by MSAL");
		        // read inMemoryCache
		        const cacheKeys = this.getKeys();
		        // delete each element
		        cacheKeys.forEach((key) => {
		            this.removeItem(key);
		        });
		        this.emitChange();
		    }
		    /**
		     * Initialize in memory cache from an exisiting cache vault
		     * @param cache - blob formatted cache (JSON)
		     */
		    static generateInMemoryCache(cache) {
		        return Deserializer.deserializeAllCache(Deserializer.deserializeJSONBlob(cache));
		    }
		    /**
		     * retrieves the final JSON
		     * @param inMemoryCache - itemised cache read from the JSON
		     */
		    static generateJsonCache(inMemoryCache) {
		        return Serializer.serializeAllCache(inMemoryCache);
		    }
		    /**
		     * Updates a credential's cache key if the current cache key is outdated
		     */
		    updateCredentialCacheKey(currentCacheKey, credential) {
		        const updatedCacheKey = this.generateCredentialKey(credential);
		        if (currentCacheKey !== updatedCacheKey) {
		            const cacheItem = this.getItem(currentCacheKey);
		            if (cacheItem) {
		                this.removeItem(currentCacheKey);
		                this.setItem(updatedCacheKey, cacheItem);
		                this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);
		                return updatedCacheKey;
		            }
		            else {
		                this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);
		            }
		        }
		        return currentCacheKey;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const defaultSerializedCache = {
		    Account: {},
		    IdToken: {},
		    AccessToken: {},
		    RefreshToken: {},
		    AppMetadata: {},
		};
		/**
		 * In-memory token cache manager
		 * @public
		 */
		class TokenCache {
		    constructor(storage, logger, cachePlugin) {
		        this.cacheHasChanged = false;
		        this.storage = storage;
		        this.storage.registerChangeEmitter(this.handleChangeEvent.bind(this));
		        if (cachePlugin) {
		            this.persistence = cachePlugin;
		        }
		        this.logger = logger;
		    }
		    /**
		     * Set to true if cache state has changed since last time serialize or writeToPersistence was called
		     */
		    hasChanged() {
		        return this.cacheHasChanged;
		    }
		    /**
		     * Serializes in memory cache to JSON
		     */
		    serialize() {
		        this.logger.trace("Serializing in-memory cache");
		        let finalState = Serializer.serializeAllCache(this.storage.getInMemoryCache());
		        // if cacheSnapshot not null or empty, merge
		        if (this.cacheSnapshot) {
		            this.logger.trace("Reading cache snapshot from disk");
		            finalState = this.mergeState(JSON.parse(this.cacheSnapshot), finalState);
		        }
		        else {
		            this.logger.trace("No cache snapshot to merge");
		        }
		        this.cacheHasChanged = false;
		        return JSON.stringify(finalState);
		    }
		    /**
		     * Deserializes JSON to in-memory cache. JSON should be in MSAL cache schema format
		     * @param cache - blob formatted cache
		     */
		    deserialize(cache) {
		        this.logger.trace("Deserializing JSON to in-memory cache");
		        this.cacheSnapshot = cache;
		        if (this.cacheSnapshot) {
		            this.logger.trace("Reading cache snapshot from disk");
		            const deserializedCache = Deserializer.deserializeAllCache(this.overlayDefaults(JSON.parse(this.cacheSnapshot)));
		            this.storage.setInMemoryCache(deserializedCache);
		        }
		        else {
		            this.logger.trace("No cache snapshot to deserialize");
		        }
		    }
		    /**
		     * Fetches the cache key-value map
		     */
		    getKVStore() {
		        return this.storage.getCache();
		    }
		    /**
		     * Gets cache snapshot in CacheKVStore format
		     */
		    getCacheSnapshot() {
		        const deserializedPersistentStorage = NodeStorage.generateInMemoryCache(this.cacheSnapshot);
		        return this.storage.inMemoryCacheToCache(deserializedPersistentStorage);
		    }
		    /**
		     * API that retrieves all accounts currently in cache to the user
		     */
		    async getAllAccounts(correlationId = new CryptoProvider().createNewGuid()) {
		        this.logger.trace("getAllAccounts called");
		        let cacheContext;
		        try {
		            if (this.persistence) {
		                cacheContext = new TokenCacheContext(this, false);
		                await this.persistence.beforeCacheAccess(cacheContext);
		            }
		            return this.storage.getAllAccounts({}, correlationId);
		        }
		        finally {
		            if (this.persistence && cacheContext) {
		                await this.persistence.afterCacheAccess(cacheContext);
		            }
		        }
		    }
		    /**
		     * Returns the signed in account matching homeAccountId.
		     * (the account object is created at the time of successful login)
		     * or null when no matching account is found
		     * @param homeAccountId - unique identifier for an account (uid.utid)
		     */
		    async getAccountByHomeId(homeAccountId) {
		        const allAccounts = await this.getAllAccounts();
		        if (homeAccountId && allAccounts && allAccounts.length) {
		            return (allAccounts.filter((accountObj) => accountObj.homeAccountId === homeAccountId)[0] || null);
		        }
		        else {
		            return null;
		        }
		    }
		    /**
		     * Returns the signed in account matching localAccountId.
		     * (the account object is created at the time of successful login)
		     * or null when no matching account is found
		     * @param localAccountId - unique identifier of an account (sub/obj when homeAccountId cannot be populated)
		     */
		    async getAccountByLocalId(localAccountId) {
		        const allAccounts = await this.getAllAccounts();
		        if (localAccountId && allAccounts && allAccounts.length) {
		            return (allAccounts.filter((accountObj) => accountObj.localAccountId === localAccountId)[0] || null);
		        }
		        else {
		            return null;
		        }
		    }
		    /**
		     * API to remove a specific account and the relevant data from cache
		     * @param account - AccountInfo passed by the user
		     */
		    async removeAccount(account, correlationId) {
		        this.logger.trace("removeAccount called");
		        let cacheContext;
		        try {
		            if (this.persistence) {
		                cacheContext = new TokenCacheContext(this, true);
		                await this.persistence.beforeCacheAccess(cacheContext);
		            }
		            this.storage.removeAccount(account, correlationId || new GuidGenerator().generateGuid());
		        }
		        finally {
		            if (this.persistence && cacheContext) {
		                await this.persistence.afterCacheAccess(cacheContext);
		            }
		        }
		    }
		    /**
		     * Overwrites in-memory cache with persistent cache
		     */
		    async overwriteCache() {
		        if (!this.persistence) {
		            this.logger.info("No persistence layer specified, cache cannot be overwritten");
		            return;
		        }
		        this.logger.info("Overwriting in-memory cache with persistent cache");
		        this.storage.clear();
		        const cacheContext = new TokenCacheContext(this, false);
		        await this.persistence.beforeCacheAccess(cacheContext);
		        const cacheSnapshot = this.getCacheSnapshot();
		        this.storage.setCache(cacheSnapshot);
		        await this.persistence.afterCacheAccess(cacheContext);
		    }
		    /**
		     * Called when the cache has changed state.
		     */
		    handleChangeEvent() {
		        this.cacheHasChanged = true;
		    }
		    /**
		     * Merge in memory cache with the cache snapshot.
		     * @param oldState - cache before changes
		     * @param currentState - current cache state in the library
		     */
		    mergeState(oldState, currentState) {
		        this.logger.trace("Merging in-memory cache with cache snapshot");
		        const stateAfterRemoval = this.mergeRemovals(oldState, currentState);
		        return this.mergeUpdates(stateAfterRemoval, currentState);
		    }
		    /**
		     * Deep update of oldState based on newState values
		     * @param oldState - cache before changes
		     * @param newState - updated cache
		     */
		    mergeUpdates(oldState, newState) {
		        Object.keys(newState).forEach((newKey) => {
		            const newValue = newState[newKey];
		            // if oldState does not contain value but newValue does, add it
		            if (!oldState.hasOwnProperty(newKey)) {
		                if (newValue !== null) {
		                    oldState[newKey] = newValue;
		                }
		            }
		            else {
		                // both oldState and newState contain the key, do deep update
		                const newValueNotNull = newValue !== null;
		                const newValueIsObject = typeof newValue === "object";
		                const newValueIsNotArray = !Array.isArray(newValue);
		                const oldStateNotUndefinedOrNull = typeof oldState[newKey] !== "undefined" &&
		                    oldState[newKey] !== null;
		                if (newValueNotNull &&
		                    newValueIsObject &&
		                    newValueIsNotArray &&
		                    oldStateNotUndefinedOrNull) {
		                    this.mergeUpdates(oldState[newKey], newValue);
		                }
		                else {
		                    oldState[newKey] = newValue;
		                }
		            }
		        });
		        return oldState;
		    }
		    /**
		     * Removes entities in oldState that the were removed from newState. If there are any unknown values in root of
		     * oldState that are not recognized, they are left untouched.
		     * @param oldState - cache before changes
		     * @param newState - updated cache
		     */
		    mergeRemovals(oldState, newState) {
		        this.logger.trace("Remove updated entries in cache");
		        const accounts = oldState.Account
		            ? this.mergeRemovalsDict(oldState.Account, newState.Account)
		            : oldState.Account;
		        const accessTokens = oldState.AccessToken
		            ? this.mergeRemovalsDict(oldState.AccessToken, newState.AccessToken)
		            : oldState.AccessToken;
		        const refreshTokens = oldState.RefreshToken
		            ? this.mergeRemovalsDict(oldState.RefreshToken, newState.RefreshToken)
		            : oldState.RefreshToken;
		        const idTokens = oldState.IdToken
		            ? this.mergeRemovalsDict(oldState.IdToken, newState.IdToken)
		            : oldState.IdToken;
		        const appMetadata = oldState.AppMetadata
		            ? this.mergeRemovalsDict(oldState.AppMetadata, newState.AppMetadata)
		            : oldState.AppMetadata;
		        return {
		            ...oldState,
		            Account: accounts,
		            AccessToken: accessTokens,
		            RefreshToken: refreshTokens,
		            IdToken: idTokens,
		            AppMetadata: appMetadata,
		        };
		    }
		    /**
		     * Helper to merge new cache with the old one
		     * @param oldState - cache before changes
		     * @param newState - updated cache
		     */
		    mergeRemovalsDict(oldState, newState) {
		        const finalState = { ...oldState };
		        Object.keys(oldState).forEach((oldKey) => {
		            if (!newState || !newState.hasOwnProperty(oldKey)) {
		                delete finalState[oldKey];
		            }
		        });
		        return finalState;
		    }
		    /**
		     * Helper to overlay as a part of cache merge
		     * @param passedInCache - cache read from the blob
		     */
		    overlayDefaults(passedInCache) {
		        this.logger.trace("Overlaying input cache with the default cache");
		        return {
		            Account: {
		                ...defaultSerializedCache.Account,
		                ...passedInCache.Account,
		            },
		            IdToken: {
		                ...defaultSerializedCache.IdToken,
		                ...passedInCache.IdToken,
		            },
		            AccessToken: {
		                ...defaultSerializedCache.AccessToken,
		                ...passedInCache.AccessToken,
		            },
		            RefreshToken: {
		                ...defaultSerializedCache.RefreshToken,
		                ...passedInCache.RefreshToken,
		            },
		            AppMetadata: {
		                ...defaultSerializedCache.AppMetadata,
		                ...passedInCache.AppMetadata,
		            },
		        };
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Client assertion of type jwt-bearer used in confidential client flows
		 * @public
		 */
		class ClientAssertion {
		    /**
		     * Initialize the ClientAssertion class from the clientAssertion passed by the user
		     * @param assertion - refer https://tools.ietf.org/html/rfc7521
		     */
		    static fromAssertion(assertion) {
		        const clientAssertion = new ClientAssertion();
		        clientAssertion.jwt = assertion;
		        return clientAssertion;
		    }
		    /**
		     * @deprecated Use fromCertificateWithSha256Thumbprint instead, with a SHA-256 thumprint
		     * Initialize the ClientAssertion class from the certificate passed by the user
		     * @param thumbprint - identifier of a certificate
		     * @param privateKey - secret key
		     * @param publicCertificate - electronic document provided to prove the ownership of the public key
		     */
		    static fromCertificate(thumbprint, privateKey, publicCertificate) {
		        const clientAssertion = new ClientAssertion();
		        clientAssertion.privateKey = privateKey;
		        clientAssertion.thumbprint = thumbprint;
		        clientAssertion.useSha256 = false;
		        if (publicCertificate) {
		            clientAssertion.publicCertificate =
		                this.parseCertificate(publicCertificate);
		        }
		        return clientAssertion;
		    }
		    /**
		     * Initialize the ClientAssertion class from the certificate passed by the user
		     * @param thumbprint - identifier of a certificate
		     * @param privateKey - secret key
		     * @param publicCertificate - electronic document provided to prove the ownership of the public key
		     */
		    static fromCertificateWithSha256Thumbprint(thumbprint, privateKey, publicCertificate) {
		        const clientAssertion = new ClientAssertion();
		        clientAssertion.privateKey = privateKey;
		        clientAssertion.thumbprint = thumbprint;
		        clientAssertion.useSha256 = true;
		        if (publicCertificate) {
		            clientAssertion.publicCertificate =
		                this.parseCertificate(publicCertificate);
		        }
		        return clientAssertion;
		    }
		    /**
		     * Update JWT for certificate based clientAssertion, if passed by the user, uses it as is
		     * @param cryptoProvider - library's crypto helper
		     * @param issuer - iss claim
		     * @param jwtAudience - aud claim
		     */
		    getJwt(cryptoProvider, issuer, jwtAudience) {
		        // if assertion was created from certificate, check if jwt is expired and create new one.
		        if (this.privateKey && this.thumbprint) {
		            if (this.jwt &&
		                !this.isExpired() &&
		                issuer === this.issuer &&
		                jwtAudience === this.jwtAudience) {
		                return this.jwt;
		            }
		            return this.createJwt(cryptoProvider, issuer, jwtAudience);
		        }
		        /*
		         * if assertion was created by caller, then we just append it. It is up to the caller to
		         * ensure that it contains necessary claims and that it is not expired.
		         */
		        if (this.jwt) {
		            return this.jwt;
		        }
		        throw createClientAuthError(invalidAssertion);
		    }
		    /**
		     * JWT format and required claims specified: https://tools.ietf.org/html/rfc7523#section-3
		     */
		    createJwt(cryptoProvider, issuer, jwtAudience) {
		        this.issuer = issuer;
		        this.jwtAudience = jwtAudience;
		        const issuedAt = nowSeconds();
		        this.expirationTime = issuedAt + 600;
		        const algorithm = this.useSha256
		            ? JwtConstants.PSS_256
		            : JwtConstants.RSA_256;
		        const header = {
		            alg: algorithm,
		        };
		        const thumbprintHeader = this.useSha256
		            ? JwtConstants.X5T_256
		            : JwtConstants.X5T;
		        Object.assign(header, {
		            [thumbprintHeader]: EncodingUtils.base64EncodeUrl(this.thumbprint, EncodingTypes.HEX),
		        });
		        if (this.publicCertificate) {
		            Object.assign(header, {
		                [JwtConstants.X5C]: this.publicCertificate,
		            });
		        }
		        const payload = {
		            [JwtConstants.AUDIENCE]: this.jwtAudience,
		            [JwtConstants.EXPIRATION_TIME]: this.expirationTime,
		            [JwtConstants.ISSUER]: this.issuer,
		            [JwtConstants.SUBJECT]: this.issuer,
		            [JwtConstants.NOT_BEFORE]: issuedAt,
		            [JwtConstants.JWT_ID]: cryptoProvider.createNewGuid(),
		        };
		        this.jwt = jwt.sign(payload, this.privateKey, { header });
		        return this.jwt;
		    }
		    /**
		     * Utility API to check expiration
		     */
		    isExpired() {
		        return this.expirationTime < nowSeconds();
		    }
		    /**
		     * Extracts the raw certs from a given certificate string and returns them in an array.
		     * @param publicCertificate - electronic document provided to prove the ownership of the public key
		     */
		    static parseCertificate(publicCertificate) {
		        /**
		         * This is regex to identify the certs in a given certificate string.
		         * We want to look for the contents between the BEGIN and END certificate strings, without the associated newlines.
		         * The information in parens "(.+?)" is the capture group to represent the cert we want isolated.
		         * "." means any string character, "+" means match 1 or more times, and "?" means the shortest match.
		         * The "g" at the end of the regex means search the string globally, and the "s" enables the "." to match newlines.
		         */
		        const regexToFindCerts = /-----BEGIN CERTIFICATE-----\r*\n(.+?)\r*\n-----END CERTIFICATE-----/gs;
		        const certs = [];
		        let matches;
		        while ((matches = regexToFindCerts.exec(publicCertificate)) !== null) {
		            // matches[1] represents the first parens capture group in the regex.
		            certs.push(matches[1].replace(/\r*\n/g, Constants$1.EMPTY_STRING));
		        }
		        return certs;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Oauth2.0 Password grant client
		 * Note: We are only supporting public clients for password grant and for purely testing purposes
		 * @public
		 * @deprecated - Use a more secure flow instead
		 */
		class UsernamePasswordClient extends BaseClient {
		    constructor(configuration) {
		        super(configuration);
		    }
		    /**
		     * API to acquire a token by passing the username and password to the service in exchage of credentials
		     * password_grant
		     * @param request - CommonUsernamePasswordRequest
		     */
		    async acquireToken(request) {
		        this.logger.info("in acquireToken call in username-password client");
		        const reqTimestamp = nowSeconds();
		        const response = await this.executeTokenRequest(this.authority, request);
		        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
		        // Validate response. This function throws a server error if an error is returned by the server.
		        responseHandler.validateTokenResponse(response.body);
		        const tokenResponse = responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request);
		        return tokenResponse;
		    }
		    /**
		     * Executes POST request to token endpoint
		     * @param authority - authority object
		     * @param request - CommonUsernamePasswordRequest provided by the developer
		     */
		    async executeTokenRequest(authority, request) {
		        const queryParametersString = this.createTokenQueryParameters(request);
		        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
		        const requestBody = await this.createTokenRequestBody(request);
		        const headers = this.createTokenRequestHeaders({
		            credential: request.username,
		            type: CcsCredentialType.UPN,
		        });
		        const thumbprint = {
		            clientId: this.config.authOptions.clientId,
		            authority: authority.canonicalAuthority,
		            scopes: request.scopes,
		            claims: request.claims,
		            authenticationScheme: request.authenticationScheme,
		            resourceRequestMethod: request.resourceRequestMethod,
		            resourceRequestUri: request.resourceRequestUri,
		            shrClaims: request.shrClaims,
		            sshKid: request.sshKid,
		        };
		        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
		    }
		    /**
		     * Generates a map for all the params to be sent to the service
		     * @param request - CommonUsernamePasswordRequest provided by the developer
		     */
		    async createTokenRequestBody(request) {
		        const parameters = new Map();
		        addClientId(parameters, this.config.authOptions.clientId);
		        addUsername(parameters, request.username);
		        addPassword(parameters, request.password);
		        addScopes(parameters, request.scopes);
		        addResponseType(parameters, OAuthResponseType.IDTOKEN_TOKEN);
		        addGrantType(parameters, GrantType.RESOURCE_OWNER_PASSWORD_GRANT);
		        addClientInfo(parameters);
		        addLibraryInfo(parameters, this.config.libraryInfo);
		        addApplicationTelemetry(parameters, this.config.telemetry.application);
		        addThrottling(parameters);
		        if (this.serverTelemetryManager) {
		            addServerTelemetry(parameters, this.serverTelemetryManager);
		        }
		        const correlationId = request.correlationId ||
		            this.config.cryptoInterface.createNewGuid();
		        addCorrelationId(parameters, correlationId);
		        if (this.config.clientCredentials.clientSecret) {
		            addClientSecret(parameters, this.config.clientCredentials.clientSecret);
		        }
		        const clientAssertion = this.config.clientCredentials.clientAssertion;
		        if (clientAssertion) {
		            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
		            addClientAssertionType(parameters, clientAssertion.assertionType);
		        }
		        if (!StringUtils.isEmptyObj(request.claims) ||
		            (this.config.authOptions.clientCapabilities &&
		                this.config.authOptions.clientCapabilities.length > 0)) {
		            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
		        }
		        if (this.config.systemOptions.preventCorsPreflight &&
		            request.username) {
		            addCcsUpn(parameters, request.username);
		        }
		        return mapToQueryString(parameters);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Constructs the full /authorize URL with request parameters
		 * @param config
		 * @param authority
		 * @param request
		 * @param logger
		 * @returns
		 */
		function getAuthCodeRequestUrl(config, authority, request, logger) {
		    const parameters = getStandardAuthorizeRequestParameters({
		        ...config.auth,
		        authority: authority,
		        redirectUri: request.redirectUri || "",
		    }, request, logger);
		    addLibraryInfo(parameters, {
		        sku: Constants.MSAL_SKU,
		        version: version,
		        cpu: process.arch || "",
		        os: process.platform || "",
		    });
		    if (config.auth.protocolMode !== ProtocolMode.OIDC) {
		        addApplicationTelemetry(parameters, config.telemetry.application);
		    }
		    addResponseType(parameters, OAuthResponseType.CODE);
		    if (request.codeChallenge && request.codeChallengeMethod) {
		        addCodeChallengeParams(parameters, request.codeChallenge, request.codeChallengeMethod);
		    }
		    addExtraQueryParameters(parameters, request.extraQueryParameters || {});
		    return getAuthorizeUrl(authority, parameters, config.auth.encodeExtraQueryParams, request.extraQueryParameters);
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Base abstract class for all ClientApplications - public and confidential
		 * @public
		 */
		class ClientApplication {
		    /**
		     * Constructor for the ClientApplication
		     */
		    constructor(configuration) {
		        this.config = buildAppConfiguration(configuration);
		        this.cryptoProvider = new CryptoProvider();
		        this.logger = new Logger(this.config.system.loggerOptions, name, version);
		        this.storage = new NodeStorage(this.logger, this.config.auth.clientId, this.cryptoProvider, buildStaticAuthorityOptions(this.config.auth));
		        this.tokenCache = new TokenCache(this.storage, this.logger, this.config.cache.cachePlugin);
		    }
		    /**
		     * Creates the URL of the authorization request, letting the user input credentials and consent to the
		     * application. The URL targets the /authorize endpoint of the authority configured in the
		     * application object.
		     *
		     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI
		     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via
		     * `acquireTokenByCode(AuthorizationCodeRequest)`.
		     */
		    async getAuthCodeUrl(request) {
		        this.logger.info("getAuthCodeUrl called", request.correlationId);
		        const validRequest = {
		            ...request,
		            ...(await this.initializeBaseRequest(request)),
		            responseMode: request.responseMode || ResponseMode.QUERY,
		            authenticationScheme: AuthenticationScheme.BEARER,
		            state: request.state || "",
		            nonce: request.nonce || "",
		        };
		        const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);
		        return getAuthCodeRequestUrl(this.config, discoveredAuthority, validRequest, this.logger);
		    }
		    /**
		     * Acquires a token by exchanging the Authorization Code received from the first step of OAuth2.0
		     * Authorization Code flow.
		     *
		     * `getAuthCodeUrl(AuthorizationCodeUrlRequest)` can be used to create the URL for the first step of OAuth2.0
		     * Authorization Code flow. Ensure that values for redirectUri and scopes in AuthorizationCodeUrlRequest and
		     * AuthorizationCodeRequest are the same.
		     */
		    async acquireTokenByCode(request, authCodePayLoad) {
		        this.logger.info("acquireTokenByCode called");
		        if (request.state && authCodePayLoad) {
		            this.logger.info("acquireTokenByCode - validating state");
		            this.validateState(request.state, authCodePayLoad.state || "");
		            // eslint-disable-next-line no-param-reassign
		            authCodePayLoad = { ...authCodePayLoad, state: "" };
		        }
		        const validRequest = {
		            ...request,
		            ...(await this.initializeBaseRequest(request)),
		            authenticationScheme: AuthenticationScheme.BEARER,
		        };
		        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByCode, validRequest.correlationId);
		        try {
		            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);
		            const authClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri, serverTelemetryManager);
		            const authorizationCodeClient = new AuthorizationCodeClient(authClientConfig);
		            this.logger.verbose("Auth code client created", validRequest.correlationId);
		            return await authorizationCodeClient.acquireToken(validRequest, authCodePayLoad);
		        }
		        catch (e) {
		            if (e instanceof AuthError) {
		                e.setCorrelationId(validRequest.correlationId);
		            }
		            serverTelemetryManager.cacheFailedRequest(e);
		            throw e;
		        }
		    }
		    /**
		     * Acquires a token by exchanging the refresh token provided for a new set of tokens.
		     *
		     * This API is provided only for scenarios where you would like to migrate from ADAL to MSAL. Otherwise, it is
		     * recommended that you use `acquireTokenSilent()` for silent scenarios. When using `acquireTokenSilent()`, MSAL will
		     * handle the caching and refreshing of tokens automatically.
		     */
		    async acquireTokenByRefreshToken(request) {
		        this.logger.info("acquireTokenByRefreshToken called", request.correlationId);
		        const validRequest = {
		            ...request,
		            ...(await this.initializeBaseRequest(request)),
		            authenticationScheme: AuthenticationScheme.BEARER,
		        };
		        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByRefreshToken, validRequest.correlationId);
		        try {
		            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);
		            const refreshTokenClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri || "", serverTelemetryManager);
		            const refreshTokenClient = new RefreshTokenClient(refreshTokenClientConfig);
		            this.logger.verbose("Refresh token client created", validRequest.correlationId);
		            return await refreshTokenClient.acquireToken(validRequest);
		        }
		        catch (e) {
		            if (e instanceof AuthError) {
		                e.setCorrelationId(validRequest.correlationId);
		            }
		            serverTelemetryManager.cacheFailedRequest(e);
		            throw e;
		        }
		    }
		    /**
		     * Acquires a token silently when a user specifies the account the token is requested for.
		     *
		     * This API expects the user to provide an account object and looks into the cache to retrieve the token if present.
		     * There is also an optional "forceRefresh" boolean the user can send to bypass the cache for access_token and id_token.
		     * In case the refresh_token is expired or not found, an error is thrown
		     * and the guidance is for the user to call any interactive token acquisition API (eg: `acquireTokenByCode()`).
		     */
		    async acquireTokenSilent(request) {
		        const validRequest = {
		            ...request,
		            ...(await this.initializeBaseRequest(request)),
		            forceRefresh: request.forceRefresh || false,
		        };
		        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent, validRequest.correlationId, validRequest.forceRefresh);
		        try {
		            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);
		            const clientConfiguration = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, validRequest.redirectUri || "", serverTelemetryManager);
		            const silentFlowClient = new SilentFlowClient(clientConfiguration);
		            this.logger.verbose("Silent flow client created", validRequest.correlationId);
		            try {
		                // always overwrite the in-memory cache with the persistence cache (if it exists) before a cache lookup
		                await this.tokenCache.overwriteCache();
		                return await this.acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration);
		            }
		            catch (error) {
		                if (error instanceof ClientAuthError &&
		                    error.errorCode ===
		                        tokenRefreshRequired) {
		                    const refreshTokenClient = new RefreshTokenClient(clientConfiguration);
		                    return refreshTokenClient.acquireTokenByRefreshToken(validRequest);
		                }
		                throw error;
		            }
		        }
		        catch (error) {
		            if (error instanceof AuthError) {
		                error.setCorrelationId(validRequest.correlationId);
		            }
		            serverTelemetryManager.cacheFailedRequest(error);
		            throw error;
		        }
		    }
		    async acquireCachedTokenSilent(validRequest, silentFlowClient, clientConfiguration) {
		        const [authResponse, cacheOutcome] = await silentFlowClient.acquireCachedToken({
		            ...validRequest,
		            scopes: validRequest.scopes?.length
		                ? validRequest.scopes
		                : [...OIDC_DEFAULT_SCOPES],
		        });
		        if (cacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
		            this.logger.info("ClientApplication:acquireCachedTokenSilent - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
		            // refresh the access token in the background
		            const refreshTokenClient = new RefreshTokenClient(clientConfiguration);
		            try {
		                await refreshTokenClient.acquireTokenByRefreshToken(validRequest);
		            }
		            catch {
		                // do nothing, this is running in the background and no action is to be taken upon success or failure
		            }
		        }
		        // return the cached token
		        return authResponse;
		    }
		    /**
		     * Acquires tokens with password grant by exchanging client applications username and password for credentials
		     *
		     * The latest OAuth 2.0 Security Best Current Practice disallows the password grant entirely.
		     * More details on this recommendation at https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4
		     * Microsoft's documentation and recommendations are at:
		     * https://docs.microsoft.com/en-us/azure/active-directory/develop/msal-authentication-flows#usernamepassword
		     *
		     * @param request - UsenamePasswordRequest
		     * @deprecated - Use a more secure flow instead
		     */
		    async acquireTokenByUsernamePassword(request) {
		        this.logger.info("acquireTokenByUsernamePassword called", request.correlationId);
		        const validRequest = {
		            ...request,
		            ...(await this.initializeBaseRequest(request)),
		        };
		        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByUsernamePassword, validRequest.correlationId);
		        try {
		            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);
		            const usernamePasswordClientConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);
		            const usernamePasswordClient = new UsernamePasswordClient(usernamePasswordClientConfig);
		            this.logger.verbose("Username password client created", validRequest.correlationId);
		            return await usernamePasswordClient.acquireToken(validRequest);
		        }
		        catch (e) {
		            if (e instanceof AuthError) {
		                e.setCorrelationId(validRequest.correlationId);
		            }
		            serverTelemetryManager.cacheFailedRequest(e);
		            throw e;
		        }
		    }
		    /**
		     * Gets the token cache for the application.
		     */
		    getTokenCache() {
		        this.logger.info("getTokenCache called");
		        return this.tokenCache;
		    }
		    /**
		     * Validates OIDC state by comparing the user cached state with the state received from the server.
		     *
		     * This API is provided for scenarios where you would use OAuth2.0 state parameter to mitigate against
		     * CSRF attacks.
		     * For more information about state, visit https://datatracker.ietf.org/doc/html/rfc6819#section-3.6.
		     * @param state - Unique GUID generated by the user that is cached by the user and sent to the server during the first leg of the flow
		     * @param cachedState - This string is sent back by the server with the authorization code
		     */
		    validateState(state, cachedState) {
		        if (!state) {
		            throw NodeAuthError.createStateNotFoundError();
		        }
		        if (state !== cachedState) {
		            throw createClientAuthError(stateMismatch);
		        }
		    }
		    /**
		     * Returns the logger instance
		     */
		    getLogger() {
		        return this.logger;
		    }
		    /**
		     * Replaces the default logger set in configurations with new Logger with new configurations
		     * @param logger - Logger instance
		     */
		    setLogger(logger) {
		        this.logger = logger;
		    }
		    /**
		     * Builds the common configuration to be passed to the common component based on the platform configurarion
		     * @param authority - user passed authority in configuration
		     * @param serverTelemetryManager - initializes servertelemetry if passed
		     */
		    async buildOauthClientConfiguration(discoveredAuthority, requestCorrelationId, redirectUri, serverTelemetryManager) {
		        this.logger.verbose("buildOauthClientConfiguration called", requestCorrelationId);
		        this.logger.info(`Building oauth client configuration with the following authority: ${discoveredAuthority.tokenEndpoint}.`, requestCorrelationId);
		        serverTelemetryManager?.updateRegionDiscoveryMetadata(discoveredAuthority.regionDiscoveryMetadata);
		        const clientConfiguration = {
		            authOptions: {
		                clientId: this.config.auth.clientId,
		                authority: discoveredAuthority,
		                clientCapabilities: this.config.auth.clientCapabilities,
		                redirectUri,
		            },
		            loggerOptions: {
		                logLevel: this.config.system.loggerOptions.logLevel,
		                loggerCallback: this.config.system.loggerOptions.loggerCallback,
		                piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,
		                correlationId: requestCorrelationId,
		            },
		            cacheOptions: {
		                claimsBasedCachingEnabled: this.config.cache.claimsBasedCachingEnabled,
		            },
		            cryptoInterface: this.cryptoProvider,
		            networkInterface: this.config.system.networkClient,
		            storageInterface: this.storage,
		            serverTelemetryManager: serverTelemetryManager,
		            clientCredentials: {
		                clientSecret: this.clientSecret,
		                clientAssertion: await this.getClientAssertion(discoveredAuthority),
		            },
		            libraryInfo: {
		                sku: Constants.MSAL_SKU,
		                version: version,
		                cpu: process.arch || Constants$1.EMPTY_STRING,
		                os: process.platform || Constants$1.EMPTY_STRING,
		            },
		            telemetry: this.config.telemetry,
		            persistencePlugin: this.config.cache.cachePlugin,
		            serializableCache: this.tokenCache,
		        };
		        return clientConfiguration;
		    }
		    async getClientAssertion(authority) {
		        if (this.developerProvidedClientAssertion) {
		            this.clientAssertion = ClientAssertion.fromAssertion(await getClientAssertion(this.developerProvidedClientAssertion, this.config.auth.clientId, authority.tokenEndpoint));
		        }
		        return (this.clientAssertion && {
		            assertion: this.clientAssertion.getJwt(this.cryptoProvider, this.config.auth.clientId, authority.tokenEndpoint),
		            assertionType: Constants.JWT_BEARER_ASSERTION_TYPE,
		        });
		    }
		    /**
		     * Generates a request with the default scopes & generates a correlationId.
		     * @param authRequest - BaseAuthRequest for initialization
		     */
		    async initializeBaseRequest(authRequest) {
		        this.logger.verbose("initializeRequestScopes called", authRequest.correlationId);
		        // Default authenticationScheme to Bearer, log that POP isn't supported yet
		        if (authRequest.authenticationScheme &&
		            authRequest.authenticationScheme === AuthenticationScheme.POP) {
		            this.logger.verbose("Authentication Scheme 'pop' is not supported yet, setting Authentication Scheme to 'Bearer' for request", authRequest.correlationId);
		        }
		        authRequest.authenticationScheme = AuthenticationScheme.BEARER;
		        // Set requested claims hash if claims-based caching is enabled and claims were requested
		        if (this.config.cache.claimsBasedCachingEnabled &&
		            authRequest.claims &&
		            // Checks for empty stringified object "{}" which doesn't qualify as requested claims
		            !StringUtils.isEmptyObj(authRequest.claims)) {
		            authRequest.requestedClaimsHash =
		                await this.cryptoProvider.hashString(authRequest.claims);
		        }
		        return {
		            ...authRequest,
		            scopes: [
		                ...((authRequest && authRequest.scopes) || []),
		                ...OIDC_DEFAULT_SCOPES,
		            ],
		            correlationId: (authRequest && authRequest.correlationId) ||
		                this.cryptoProvider.createNewGuid(),
		            authority: authRequest.authority || this.config.auth.authority,
		        };
		    }
		    /**
		     * Initializes the server telemetry payload
		     * @param apiId - Id for a specific request
		     * @param correlationId - GUID
		     * @param forceRefresh - boolean to indicate network call
		     */
		    initializeServerTelemetryManager(apiId, correlationId, forceRefresh) {
		        const telemetryPayload = {
		            clientId: this.config.auth.clientId,
		            correlationId: correlationId,
		            apiId: apiId,
		            forceRefresh: forceRefresh || false,
		        };
		        return new ServerTelemetryManager(telemetryPayload, this.storage);
		    }
		    /**
		     * Create authority instance. If authority not passed in request, default to authority set on the application
		     * object. If no authority set in application object, then default to common authority.
		     * @param authorityString - authority from user configuration
		     */
		    async createAuthority(authorityString, requestCorrelationId, azureRegionConfiguration, azureCloudOptions) {
		        this.logger.verbose("createAuthority called", requestCorrelationId);
		        // build authority string based on auth params - azureCloudInstance is prioritized if provided
		        const authorityUrl = Authority.generateAuthority(authorityString, azureCloudOptions || this.config.auth.azureCloudOptions);
		        const authorityOptions = {
		            protocolMode: this.config.auth.protocolMode,
		            knownAuthorities: this.config.auth.knownAuthorities,
		            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,
		            authorityMetadata: this.config.auth.authorityMetadata,
		            azureRegionConfiguration,
		            skipAuthorityMetadataCache: this.config.auth.skipAuthorityMetadataCache,
		        };
		        return createDiscoveredInstance(authorityUrl, this.config.system.networkClient, this.storage, authorityOptions, this.logger, requestCorrelationId);
		    }
		    /**
		     * Clear the cache
		     */
		    clearCache() {
		        this.storage.clear();
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class LoopbackClient {
		    /**
		     * Spins up a loopback server which returns the server response when the localhost redirectUri is hit
		     * @param successTemplate
		     * @param errorTemplate
		     * @returns
		     */
		    async listenForAuthCode(successTemplate, errorTemplate) {
		        if (this.server) {
		            throw NodeAuthError.createLoopbackServerAlreadyExistsError();
		        }
		        return new Promise((resolve, reject) => {
		            this.server = http.createServer((req, res) => {
		                const url = req.url;
		                if (!url) {
		                    res.end(errorTemplate ||
		                        "Error occurred loading redirectUrl");
		                    reject(NodeAuthError.createUnableToLoadRedirectUrlError());
		                    return;
		                }
		                else if (url === Constants$1.FORWARD_SLASH) {
		                    res.end(successTemplate ||
		                        "Auth code was successfully acquired. You can close this window now.");
		                    return;
		                }
		                const redirectUri = this.getRedirectUri();
		                const parsedUrl = new URL(url, redirectUri);
		                const authCodeResponse = getDeserializedResponse(parsedUrl.search) ||
		                    {};
		                if (authCodeResponse.code) {
		                    res.writeHead(HttpStatus.REDIRECT, {
		                        location: redirectUri,
		                    }); // Prevent auth code from being saved in the browser history
		                    res.end();
		                }
		                if (authCodeResponse.error) {
		                    res.end(errorTemplate ||
		                        `Error occurred: ${authCodeResponse.error}`);
		                }
		                resolve(authCodeResponse);
		            });
		            this.server.listen(0, "127.0.0.1"); // Listen on any available port
		        });
		    }
		    /**
		     * Get the port that the loopback server is running on
		     * @returns
		     */
		    getRedirectUri() {
		        if (!this.server || !this.server.listening) {
		            throw NodeAuthError.createNoLoopbackServerExistsError();
		        }
		        const address = this.server.address();
		        if (!address || typeof address === "string" || !address.port) {
		            this.closeServer();
		            throw NodeAuthError.createInvalidLoopbackAddressTypeError();
		        }
		        const port = address && address.port;
		        return `${Constants.HTTP_PROTOCOL}${Constants.LOCALHOST}:${port}`;
		    }
		    /**
		     * Close the loopback server
		     */
		    closeServer() {
		        if (this.server) {
		            // Only stops accepting new connections, server will close once open/idle connections are closed.
		            this.server.close();
		            if (typeof this.server.closeAllConnections === "function") {
		                /*
		                 * Close open/idle connections. This API is available in Node versions 18.2 and higher
		                 */
		                this.server.closeAllConnections();
		            }
		            this.server.unref();
		            this.server = undefined;
		        }
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * OAuth2.0 Device code client
		 * @public
		 */
		class DeviceCodeClient extends BaseClient {
		    constructor(configuration) {
		        super(configuration);
		    }
		    /**
		     * Gets device code from device code endpoint, calls back to with device code response, and
		     * polls token endpoint to exchange device code for tokens
		     * @param request - developer provided CommonDeviceCodeRequest
		     */
		    async acquireToken(request) {
		        const deviceCodeResponse = await this.getDeviceCode(request);
		        request.deviceCodeCallback(deviceCodeResponse);
		        const reqTimestamp = nowSeconds();
		        const response = await this.acquireTokenWithDeviceCode(request, deviceCodeResponse);
		        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
		        // Validate response. This function throws a server error if an error is returned by the server.
		        responseHandler.validateTokenResponse(response);
		        return responseHandler.handleServerTokenResponse(response, this.authority, reqTimestamp, request);
		    }
		    /**
		     * Creates device code request and executes http GET
		     * @param request - developer provided CommonDeviceCodeRequest
		     */
		    async getDeviceCode(request) {
		        const queryParametersString = this.createExtraQueryParameters(request);
		        const endpoint = UrlString.appendQueryString(this.authority.deviceCodeEndpoint, queryParametersString);
		        const queryString = this.createQueryString(request);
		        const headers = this.createTokenRequestHeaders();
		        const thumbprint = {
		            clientId: this.config.authOptions.clientId,
		            authority: request.authority,
		            scopes: request.scopes,
		            claims: request.claims,
		            authenticationScheme: request.authenticationScheme,
		            resourceRequestMethod: request.resourceRequestMethod,
		            resourceRequestUri: request.resourceRequestUri,
		            shrClaims: request.shrClaims,
		            sshKid: request.sshKid,
		        };
		        return this.executePostRequestToDeviceCodeEndpoint(endpoint, queryString, headers, thumbprint, request.correlationId);
		    }
		    /**
		     * Creates query string for the device code request
		     * @param request - developer provided CommonDeviceCodeRequest
		     */
		    createExtraQueryParameters(request) {
		        const parameters = new Map();
		        if (request.extraQueryParameters) {
		            addExtraQueryParameters(parameters, request.extraQueryParameters);
		        }
		        return mapToQueryString(parameters);
		    }
		    /**
		     * Executes POST request to device code endpoint
		     * @param deviceCodeEndpoint - token endpoint
		     * @param queryString - string to be used in the body of the request
		     * @param headers - headers for the request
		     * @param thumbprint - unique request thumbprint
		     * @param correlationId - correlation id to be used in the request
		     */
		    async executePostRequestToDeviceCodeEndpoint(deviceCodeEndpoint, queryString, headers, thumbprint, correlationId) {
		        const { body: { user_code: userCode, device_code: deviceCode, verification_uri: verificationUri, expires_in: expiresIn, interval, message, }, } = await this.sendPostRequest(thumbprint, deviceCodeEndpoint, {
		            body: queryString,
		            headers: headers,
		        }, correlationId);
		        return {
		            userCode,
		            deviceCode,
		            verificationUri,
		            expiresIn,
		            interval,
		            message,
		        };
		    }
		    /**
		     * Create device code endpoint query parameters and returns string
		     * @param request - developer provided CommonDeviceCodeRequest
		     */
		    createQueryString(request) {
		        const parameters = new Map();
		        addScopes(parameters, request.scopes);
		        addClientId(parameters, this.config.authOptions.clientId);
		        if (request.extraQueryParameters) {
		            addExtraQueryParameters(parameters, request.extraQueryParameters);
		        }
		        if (request.claims ||
		            (this.config.authOptions.clientCapabilities &&
		                this.config.authOptions.clientCapabilities.length > 0)) {
		            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
		        }
		        return mapToQueryString(parameters);
		    }
		    /**
		     * Breaks the polling with specific conditions
		     * @param deviceCodeExpirationTime - expiration time for the device code request
		     * @param userSpecifiedTimeout - developer provided timeout, to be compared against deviceCodeExpirationTime
		     * @param userSpecifiedCancelFlag - boolean indicating the developer would like to cancel the request
		     */
		    continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, userSpecifiedCancelFlag) {
		        if (userSpecifiedCancelFlag) {
		            this.logger.error("Token request cancelled by setting DeviceCodeRequest.cancel = true");
		            throw createClientAuthError(deviceCodePollingCancelled);
		        }
		        else if (userSpecifiedTimeout &&
		            userSpecifiedTimeout < deviceCodeExpirationTime &&
		            nowSeconds() > userSpecifiedTimeout) {
		            this.logger.error(`User defined timeout for device code polling reached. The timeout was set for ${userSpecifiedTimeout}`);
		            throw createClientAuthError(userTimeoutReached);
		        }
		        else if (nowSeconds() > deviceCodeExpirationTime) {
		            if (userSpecifiedTimeout) {
		                this.logger.verbose(`User specified timeout ignored as the device code has expired before the timeout elapsed. The user specified timeout was set for ${userSpecifiedTimeout}`);
		            }
		            this.logger.error(`Device code expired. Expiration time of device code was ${deviceCodeExpirationTime}`);
		            throw createClientAuthError(deviceCodeExpired);
		        }
		        return true;
		    }
		    /**
		     * Creates token request with device code response and polls token endpoint at interval set by the device code response
		     * @param request - developer provided CommonDeviceCodeRequest
		     * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint
		     */
		    async acquireTokenWithDeviceCode(request, deviceCodeResponse) {
		        const queryParametersString = this.createTokenQueryParameters(request);
		        const endpoint = UrlString.appendQueryString(this.authority.tokenEndpoint, queryParametersString);
		        const requestBody = this.createTokenRequestBody(request, deviceCodeResponse);
		        const headers = this.createTokenRequestHeaders();
		        const userSpecifiedTimeout = request.timeout
		            ? nowSeconds() + request.timeout
		            : undefined;
		        const deviceCodeExpirationTime = nowSeconds() + deviceCodeResponse.expiresIn;
		        const pollingIntervalMilli = deviceCodeResponse.interval * 1000;
		        /*
		         * Poll token endpoint while (device code is not expired AND operation has not been cancelled by
		         * setting CancellationToken.cancel = true). POST request is sent at interval set by pollingIntervalMilli
		         */
		        while (this.continuePolling(deviceCodeExpirationTime, userSpecifiedTimeout, request.cancel)) {
		            const thumbprint = {
		                clientId: this.config.authOptions.clientId,
		                authority: request.authority,
		                scopes: request.scopes,
		                claims: request.claims,
		                authenticationScheme: request.authenticationScheme,
		                resourceRequestMethod: request.resourceRequestMethod,
		                resourceRequestUri: request.resourceRequestUri,
		                shrClaims: request.shrClaims,
		                sshKid: request.sshKid,
		            };
		            const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
		            if (response.body && response.body.error) {
		                // user authorization is pending. Sleep for polling interval and try again
		                if (response.body.error === Constants$1.AUTHORIZATION_PENDING) {
		                    this.logger.info("Authorization pending. Continue polling.");
		                    await delay(pollingIntervalMilli);
		                }
		                else {
		                    // for any other error, throw
		                    this.logger.info("Unexpected error in polling from the server");
		                    throw createAuthError(postRequestFailed, response.body.error);
		                }
		            }
		            else {
		                this.logger.verbose("Authorization completed successfully. Polling stopped.");
		                return response.body;
		            }
		        }
		        /*
		         * The above code should've thrown by this point, but to satisfy TypeScript,
		         * and in the rare case the conditionals in continuePolling() may not catch everything...
		         */
		        this.logger.error("Polling stopped for unknown reasons.");
		        throw createClientAuthError(deviceCodeUnknownError);
		    }
		    /**
		     * Creates query parameters and converts to string.
		     * @param request - developer provided CommonDeviceCodeRequest
		     * @param deviceCodeResponse - DeviceCodeResponse returned by the security token service device code endpoint
		     */
		    createTokenRequestBody(request, deviceCodeResponse) {
		        const parameters = new Map();
		        addScopes(parameters, request.scopes);
		        addClientId(parameters, this.config.authOptions.clientId);
		        addGrantType(parameters, GrantType.DEVICE_CODE_GRANT);
		        addDeviceCode(parameters, deviceCodeResponse.deviceCode);
		        const correlationId = request.correlationId ||
		            this.config.cryptoInterface.createNewGuid();
		        addCorrelationId(parameters, correlationId);
		        addClientInfo(parameters);
		        addLibraryInfo(parameters, this.config.libraryInfo);
		        addApplicationTelemetry(parameters, this.config.telemetry.application);
		        addThrottling(parameters);
		        if (this.serverTelemetryManager) {
		            addServerTelemetry(parameters, this.serverTelemetryManager);
		        }
		        if (!StringUtils.isEmptyObj(request.claims) ||
		            (this.config.authOptions.clientCapabilities &&
		                this.config.authOptions.clientCapabilities.length > 0)) {
		            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
		        }
		        return mapToQueryString(parameters);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * This class is to be used to acquire tokens for public client applications (desktop, mobile). Public client applications
		 * are not trusted to safely store application secrets, and therefore can only request tokens in the name of an user.
		 * @public
		 */
		class PublicClientApplication extends ClientApplication {
		    /**
		     * Important attributes in the Configuration object for auth are:
		     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal.
		     * - authority: the authority URL for your application.
		     *
		     * AAD authorities are of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
		     * - If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
		     * - If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
		     * - If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
		     * - To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
		     *
		     * Azure B2C authorities are of the form https://\{instance\}/\{tenant\}/\{policy\}. Each policy is considered
		     * its own authority. You will have to set the all of the knownAuthorities at the time of the client application
		     * construction.
		     *
		     * ADFS authorities are of the form https://\{instance\}/adfs.
		     */
		    constructor(configuration) {
		        super(configuration);
		        if (this.config.broker.nativeBrokerPlugin) {
		            if (this.config.broker.nativeBrokerPlugin.isBrokerAvailable) {
		                this.nativeBrokerPlugin = this.config.broker.nativeBrokerPlugin;
		                this.nativeBrokerPlugin.setLogger(this.config.system.loggerOptions);
		            }
		            else {
		                this.logger.warning("NativeBroker implementation was provided but the broker is unavailable.");
		            }
		        }
		        this.skus = ServerTelemetryManager.makeExtraSkuString({
		            libraryName: Constants.MSAL_SKU,
		            libraryVersion: version,
		        });
		    }
		    /**
		     * Acquires a token from the authority using OAuth2.0 device code flow.
		     * This flow is designed for devices that do not have access to a browser or have input constraints.
		     * The authorization server issues a DeviceCode object with a verification code, an end-user code,
		     * and the end-user verification URI. The DeviceCode object is provided through a callback, and the end-user should be
		     * instructed to use another device to navigate to the verification URI to input credentials.
		     * Since the client cannot receive incoming requests, it polls the authorization server repeatedly
		     * until the end-user completes input of credentials.
		     */
		    async acquireTokenByDeviceCode(request) {
		        this.logger.info("acquireTokenByDeviceCode called", request.correlationId);
		        const validRequest = Object.assign(request, await this.initializeBaseRequest(request));
		        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByDeviceCode, validRequest.correlationId);
		        try {
		            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);
		            const deviceCodeConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);
		            const deviceCodeClient = new DeviceCodeClient(deviceCodeConfig);
		            this.logger.verbose("Device code client created", validRequest.correlationId);
		            return await deviceCodeClient.acquireToken(validRequest);
		        }
		        catch (e) {
		            if (e instanceof AuthError) {
		                e.setCorrelationId(validRequest.correlationId);
		            }
		            serverTelemetryManager.cacheFailedRequest(e);
		            throw e;
		        }
		    }
		    /**
		     * Acquires a token interactively via the browser by requesting an authorization code then exchanging it for a token.
		     */
		    async acquireTokenInteractive(request) {
		        const correlationId = request.correlationId || this.cryptoProvider.createNewGuid();
		        this.logger.trace("acquireTokenInteractive called", correlationId);
		        const { openBrowser, successTemplate, errorTemplate, windowHandle, loopbackClient: customLoopbackClient, ...remainingProperties } = request;
		        if (this.nativeBrokerPlugin) {
		            const brokerRequest = {
		                ...remainingProperties,
		                clientId: this.config.auth.clientId,
		                scopes: request.scopes || OIDC_DEFAULT_SCOPES,
		                redirectUri: request.redirectUri || "",
		                authority: request.authority || this.config.auth.authority,
		                correlationId: correlationId,
		                extraParameters: {
		                    ...remainingProperties.extraQueryParameters,
		                    ...remainingProperties.tokenQueryParameters,
		                    [X_CLIENT_EXTRA_SKU]: this.skus,
		                },
		                accountId: remainingProperties.account?.nativeAccountId,
		            };
		            return this.nativeBrokerPlugin.acquireTokenInteractive(brokerRequest, windowHandle);
		        }
		        if (request.redirectUri) {
		            // If its not a broker fallback scenario, we throw a error
		            if (!this.config.broker.nativeBrokerPlugin) {
		                throw NodeAuthError.createRedirectUriNotSupportedError();
		            }
		            // If a redirect URI is provided for a broker flow but MSAL runtime startup failed, we fall back to the browser flow and will ignore the redirect URI provided for the broker flow
		            request.redirectUri = "";
		        }
		        const { verifier, challenge } = await this.cryptoProvider.generatePkceCodes();
		        const loopbackClient = customLoopbackClient || new LoopbackClient();
		        let authCodeResponse = {};
		        let authCodeListenerError = null;
		        try {
		            const authCodeListener = loopbackClient
		                .listenForAuthCode(successTemplate, errorTemplate)
		                .then((response) => {
		                authCodeResponse = response;
		            })
		                .catch((e) => {
		                // Store the promise instead of throwing so we can control when its thrown
		                authCodeListenerError = e;
		            });
		            // Wait for server to be listening
		            const redirectUri = await this.waitForRedirectUri(loopbackClient);
		            const validRequest = {
		                ...remainingProperties,
		                correlationId: correlationId,
		                scopes: request.scopes || OIDC_DEFAULT_SCOPES,
		                redirectUri: redirectUri,
		                responseMode: ResponseMode.QUERY,
		                codeChallenge: challenge,
		                codeChallengeMethod: CodeChallengeMethodValues.S256,
		            };
		            const authCodeUrl = await this.getAuthCodeUrl(validRequest);
		            await openBrowser(authCodeUrl);
		            await authCodeListener;
		            if (authCodeListenerError) {
		                throw authCodeListenerError;
		            }
		            if (authCodeResponse.error) {
		                throw new ServerError(authCodeResponse.error, authCodeResponse.error_description, authCodeResponse.suberror);
		            }
		            else if (!authCodeResponse.code) {
		                throw NodeAuthError.createNoAuthCodeInResponseError();
		            }
		            const clientInfo = authCodeResponse.client_info;
		            const tokenRequest = {
		                code: authCodeResponse.code,
		                codeVerifier: verifier,
		                clientInfo: clientInfo || Constants$1.EMPTY_STRING,
		                ...validRequest,
		            };
		            return await this.acquireTokenByCode(tokenRequest); // Await this so the server doesn't close prematurely
		        }
		        finally {
		            loopbackClient.closeServer();
		        }
		    }
		    /**
		     * Returns a token retrieved either from the cache or by exchanging the refresh token for a fresh access token. If brokering is enabled the token request will be serviced by the broker.
		     * @param request - developer provided SilentFlowRequest
		     * @returns
		     */
		    async acquireTokenSilent(request) {
		        const correlationId = request.correlationId || this.cryptoProvider.createNewGuid();
		        this.logger.trace("acquireTokenSilent called", correlationId);
		        if (this.nativeBrokerPlugin) {
		            const brokerRequest = {
		                ...request,
		                clientId: this.config.auth.clientId,
		                scopes: request.scopes || OIDC_DEFAULT_SCOPES,
		                redirectUri: request.redirectUri || "",
		                authority: request.authority || this.config.auth.authority,
		                correlationId: correlationId,
		                extraParameters: {
		                    ...request.tokenQueryParameters,
		                    [X_CLIENT_EXTRA_SKU]: this.skus,
		                },
		                accountId: request.account.nativeAccountId,
		                forceRefresh: request.forceRefresh || false,
		            };
		            return this.nativeBrokerPlugin.acquireTokenSilent(brokerRequest);
		        }
		        if (request.redirectUri) {
		            // If its not a broker fallback scenario, we throw a error
		            if (!this.config.broker.nativeBrokerPlugin) {
		                throw NodeAuthError.createRedirectUriNotSupportedError();
		            }
		            request.redirectUri = "";
		        }
		        return super.acquireTokenSilent(request);
		    }
		    /**
		     * Removes cache artifacts associated with the given account
		     * @param request - developer provided SignOutRequest
		     * @returns
		     */
		    async signOut(request) {
		        if (this.nativeBrokerPlugin && request.account.nativeAccountId) {
		            const signoutRequest = {
		                clientId: this.config.auth.clientId,
		                accountId: request.account.nativeAccountId,
		                correlationId: request.correlationId ||
		                    this.cryptoProvider.createNewGuid(),
		            };
		            await this.nativeBrokerPlugin.signOut(signoutRequest);
		        }
		        await this.getTokenCache().removeAccount(request.account, request.correlationId);
		    }
		    /**
		     * Returns all cached accounts for this application. If brokering is enabled this request will be serviced by the broker.
		     * @returns
		     */
		    async getAllAccounts() {
		        if (this.nativeBrokerPlugin) {
		            const correlationId = this.cryptoProvider.createNewGuid();
		            return this.nativeBrokerPlugin.getAllAccounts(this.config.auth.clientId, correlationId);
		        }
		        return this.getTokenCache().getAllAccounts();
		    }
		    /**
		     * Attempts to retrieve the redirectUri from the loopback server. If the loopback server does not start listening for requests within the timeout this will throw.
		     * @param loopbackClient - developer provided custom loopback server implementation
		     * @returns
		     */
		    async waitForRedirectUri(loopbackClient) {
		        return new Promise((resolve, reject) => {
		            let ticks = 0;
		            const id = setInterval(() => {
		                if (LOOPBACK_SERVER_CONSTANTS.TIMEOUT_MS /
		                    LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS <
		                    ticks) {
		                    clearInterval(id);
		                    reject(NodeAuthError.createLoopbackServerTimeoutError());
		                    return;
		                }
		                try {
		                    const r = loopbackClient.getRedirectUri();
		                    clearInterval(id);
		                    resolve(r);
		                    return;
		                }
		                catch (e) {
		                    if (e instanceof AuthError &&
		                        e.errorCode ===
		                            NodeAuthErrorMessage.noLoopbackServerExists.code) {
		                        // Loopback server is not listening yet
		                        ticks++;
		                        return;
		                    }
		                    clearInterval(id);
		                    reject(e);
		                    return;
		                }
		            }, LOOPBACK_SERVER_CONSTANTS.INTERVAL_MS);
		        });
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * OAuth2.0 client credential grant
		 * @public
		 */
		class ClientCredentialClient extends BaseClient {
		    constructor(configuration, appTokenProvider) {
		        super(configuration);
		        this.appTokenProvider = appTokenProvider;
		    }
		    /**
		     * Public API to acquire a token with ClientCredential Flow for Confidential clients
		     * @param request - CommonClientCredentialRequest provided by the developer
		     */
		    async acquireToken(request) {
		        if (request.skipCache || request.claims) {
		            return this.executeTokenRequest(request, this.authority);
		        }
		        const [cachedAuthenticationResult, lastCacheOutcome] = await this.getCachedAuthenticationResult(request, this.config, this.cryptoUtils, this.authority, this.cacheManager, this.serverTelemetryManager);
		        if (cachedAuthenticationResult) {
		            // if the token is not expired but must be refreshed; get a new one in the background
		            if (lastCacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
		                this.logger.info("ClientCredentialClient:getCachedAuthenticationResult - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
		                // refresh the access token in the background
		                const refreshAccessToken = true;
		                await this.executeTokenRequest(request, this.authority, refreshAccessToken);
		            }
		            // return the cached token
		            return cachedAuthenticationResult;
		        }
		        else {
		            return this.executeTokenRequest(request, this.authority);
		        }
		    }
		    /**
		     * looks up cache if the tokens are cached already
		     */
		    async getCachedAuthenticationResult(request, config, cryptoUtils, authority, cacheManager, serverTelemetryManager) {
		        const clientConfiguration = config;
		        const managedIdentityConfiguration = config;
		        let lastCacheOutcome = CacheOutcome.NOT_APPLICABLE;
		        // read the user-supplied cache into memory, if applicable
		        let cacheContext;
		        if (clientConfiguration.serializableCache &&
		            clientConfiguration.persistencePlugin) {
		            cacheContext = new TokenCacheContext(clientConfiguration.serializableCache, false);
		            await clientConfiguration.persistencePlugin.beforeCacheAccess(cacheContext);
		        }
		        const cachedAccessToken = this.readAccessTokenFromCache(authority, managedIdentityConfiguration.managedIdentityId?.id ||
		            clientConfiguration.authOptions.clientId, new ScopeSet(request.scopes || []), cacheManager, request.correlationId);
		        if (clientConfiguration.serializableCache &&
		            clientConfiguration.persistencePlugin &&
		            cacheContext) {
		            await clientConfiguration.persistencePlugin.afterCacheAccess(cacheContext);
		        }
		        // must refresh due to non-existent access_token
		        if (!cachedAccessToken) {
		            serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
		            return [null, CacheOutcome.NO_CACHED_ACCESS_TOKEN];
		        }
		        // must refresh due to the expires_in value
		        if (isTokenExpired(cachedAccessToken.expiresOn, clientConfiguration.systemOptions?.tokenRenewalOffsetSeconds ||
		            DEFAULT_TOKEN_RENEWAL_OFFSET_SEC)) {
		            serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
		            return [null, CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED];
		        }
		        // must refresh (in the background) due to the refresh_in value
		        if (cachedAccessToken.refreshOn &&
		            isTokenExpired(cachedAccessToken.refreshOn.toString(), 0)) {
		            lastCacheOutcome = CacheOutcome.PROACTIVELY_REFRESHED;
		            serverTelemetryManager?.setCacheOutcome(CacheOutcome.PROACTIVELY_REFRESHED);
		        }
		        return [
		            await ResponseHandler.generateAuthenticationResult(cryptoUtils, authority, {
		                account: null,
		                idToken: null,
		                accessToken: cachedAccessToken,
		                refreshToken: null,
		                appMetadata: null,
		            }, true, request),
		            lastCacheOutcome,
		        ];
		    }
		    /**
		     * Reads access token from the cache
		     */
		    readAccessTokenFromCache(authority, id, scopeSet, cacheManager, correlationId) {
		        const accessTokenFilter = {
		            homeAccountId: Constants$1.EMPTY_STRING,
		            environment: authority.canonicalAuthorityUrlComponents.HostNameAndPort,
		            credentialType: CredentialType.ACCESS_TOKEN,
		            clientId: id,
		            realm: authority.tenant,
		            target: ScopeSet.createSearchScopes(scopeSet.asArray()),
		        };
		        const accessTokens = cacheManager.getAccessTokensByFilter(accessTokenFilter, correlationId);
		        if (accessTokens.length < 1) {
		            return null;
		        }
		        else if (accessTokens.length > 1) {
		            throw createClientAuthError(multipleMatchingTokens);
		        }
		        return accessTokens[0];
		    }
		    /**
		     * Makes a network call to request the token from the service
		     * @param request - CommonClientCredentialRequest provided by the developer
		     * @param authority - authority object
		     */
		    async executeTokenRequest(request, authority, refreshAccessToken) {
		        let serverTokenResponse;
		        let reqTimestamp;
		        if (this.appTokenProvider) {
		            this.logger.info("Using appTokenProvider extensibility.");
		            const appTokenPropviderParameters = {
		                correlationId: request.correlationId,
		                tenantId: this.config.authOptions.authority.tenant,
		                scopes: request.scopes,
		                claims: request.claims,
		            };
		            reqTimestamp = nowSeconds();
		            const appTokenProviderResult = await this.appTokenProvider(appTokenPropviderParameters);
		            serverTokenResponse = {
		                access_token: appTokenProviderResult.accessToken,
		                expires_in: appTokenProviderResult.expiresInSeconds,
		                refresh_in: appTokenProviderResult.refreshInSeconds,
		                token_type: AuthenticationScheme.BEARER,
		            };
		        }
		        else {
		            const queryParametersString = this.createTokenQueryParameters(request);
		            const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
		            const requestBody = await this.createTokenRequestBody(request);
		            const headers = this.createTokenRequestHeaders();
		            const thumbprint = {
		                clientId: this.config.authOptions.clientId,
		                authority: request.authority,
		                scopes: request.scopes,
		                claims: request.claims,
		                authenticationScheme: request.authenticationScheme,
		                resourceRequestMethod: request.resourceRequestMethod,
		                resourceRequestUri: request.resourceRequestUri,
		                shrClaims: request.shrClaims,
		                sshKid: request.sshKid,
		            };
		            this.logger.info("Sending token request to endpoint: " + authority.tokenEndpoint);
		            reqTimestamp = nowSeconds();
		            const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
		            serverTokenResponse = response.body;
		            serverTokenResponse.status = response.status;
		        }
		        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
		        responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);
		        const tokenResponse = await responseHandler.handleServerTokenResponse(serverTokenResponse, this.authority, reqTimestamp, request);
		        return tokenResponse;
		    }
		    /**
		     * generate the request to the server in the acceptable format
		     * @param request - CommonClientCredentialRequest provided by the developer
		     */
		    async createTokenRequestBody(request) {
		        const parameters = new Map();
		        addClientId(parameters, this.config.authOptions.clientId);
		        addScopes(parameters, request.scopes, false);
		        addGrantType(parameters, GrantType.CLIENT_CREDENTIALS_GRANT);
		        addLibraryInfo(parameters, this.config.libraryInfo);
		        addApplicationTelemetry(parameters, this.config.telemetry.application);
		        addThrottling(parameters);
		        if (this.serverTelemetryManager) {
		            addServerTelemetry(parameters, this.serverTelemetryManager);
		        }
		        const correlationId = request.correlationId ||
		            this.config.cryptoInterface.createNewGuid();
		        addCorrelationId(parameters, correlationId);
		        if (this.config.clientCredentials.clientSecret) {
		            addClientSecret(parameters, this.config.clientCredentials.clientSecret);
		        }
		        // Use clientAssertion from request, fallback to client assertion in base configuration
		        const clientAssertion = request.clientAssertion ||
		            this.config.clientCredentials.clientAssertion;
		        if (clientAssertion) {
		            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
		            addClientAssertionType(parameters, clientAssertion.assertionType);
		        }
		        if (!StringUtils.isEmptyObj(request.claims) ||
		            (this.config.authOptions.clientCapabilities &&
		                this.config.authOptions.clientCapabilities.length > 0)) {
		            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
		        }
		        return mapToQueryString(parameters);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * On-Behalf-Of client
		 * @public
		 */
		class OnBehalfOfClient extends BaseClient {
		    constructor(configuration) {
		        super(configuration);
		    }
		    /**
		     * Public API to acquire tokens with on behalf of flow
		     * @param request - developer provided CommonOnBehalfOfRequest
		     */
		    async acquireToken(request) {
		        this.scopeSet = new ScopeSet(request.scopes || []);
		        // generate the user_assertion_hash for OBOAssertion
		        this.userAssertionHash = await this.cryptoUtils.hashString(request.oboAssertion);
		        if (request.skipCache || request.claims) {
		            return this.executeTokenRequest(request, this.authority, this.userAssertionHash);
		        }
		        try {
		            return await this.getCachedAuthenticationResult(request);
		        }
		        catch (e) {
		            // Any failure falls back to interactive request, once we implement distributed cache, we plan to handle `createRefreshRequiredError` to refresh using the RT
		            return await this.executeTokenRequest(request, this.authority, this.userAssertionHash);
		        }
		    }
		    /**
		     * look up cache for tokens
		     * Find idtoken in the cache
		     * Find accessToken based on user assertion and account info in the cache
		     * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires
		     * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session
		     * @param request - developer provided CommonOnBehalfOfRequest
		     */
		    async getCachedAuthenticationResult(request) {
		        // look in the cache for the access_token which matches the incoming_assertion
		        const cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request);
		        if (!cachedAccessToken) {
		            // Must refresh due to non-existent access_token.
		            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);
		            this.logger.info("SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.");
		            throw createClientAuthError(tokenRefreshRequired);
		        }
		        else if (isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {
		            // Access token expired, will need to renewed
		            this.serverTelemetryManager?.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);
		            this.logger.info(`OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within ${this.config.systemOptions.tokenRenewalOffsetSeconds} seconds.`);
		            throw createClientAuthError(tokenRefreshRequired);
		        }
		        // fetch the idToken from cache
		        const cachedIdToken = this.readIdTokenFromCacheForOBO(cachedAccessToken.homeAccountId, request.correlationId);
		        let idTokenClaims;
		        let cachedAccount = null;
		        if (cachedIdToken) {
		            idTokenClaims = extractTokenClaims(cachedIdToken.secret, EncodingUtils.base64Decode);
		            const localAccountId = idTokenClaims.oid || idTokenClaims.sub;
		            const accountInfo = {
		                homeAccountId: cachedIdToken.homeAccountId,
		                environment: cachedIdToken.environment,
		                tenantId: cachedIdToken.realm,
		                username: Constants$1.EMPTY_STRING,
		                localAccountId: localAccountId || Constants$1.EMPTY_STRING,
		            };
		            cachedAccount = this.cacheManager.getAccount(this.cacheManager.generateAccountKey(accountInfo), request.correlationId);
		        }
		        // increment telemetry cache hit counter
		        if (this.config.serverTelemetryManager) {
		            this.config.serverTelemetryManager.incrementCacheHits();
		        }
		        return ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {
		            account: cachedAccount,
		            accessToken: cachedAccessToken,
		            idToken: cachedIdToken,
		            refreshToken: null,
		            appMetadata: null,
		        }, true, request, idTokenClaims);
		    }
		    /**
		     * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager
		     * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service
		     * @param atHomeAccountId - account id
		     */
		    readIdTokenFromCacheForOBO(atHomeAccountId, correlationId) {
		        const idTokenFilter = {
		            homeAccountId: atHomeAccountId,
		            environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,
		            credentialType: CredentialType.ID_TOKEN,
		            clientId: this.config.authOptions.clientId,
		            realm: this.authority.tenant,
		        };
		        const idTokenMap = this.cacheManager.getIdTokensByFilter(idTokenFilter, correlationId);
		        // When acquiring a token on behalf of an application, there might not be an id token in the cache
		        if (Object.values(idTokenMap).length < 1) {
		            return null;
		        }
		        return Object.values(idTokenMap)[0];
		    }
		    /**
		     * Fetches the cached access token based on incoming assertion
		     * @param clientId - client id
		     * @param request - developer provided CommonOnBehalfOfRequest
		     */
		    readAccessTokenFromCacheForOBO(clientId, request) {
		        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;
		        /*
		         * Distinguish between Bearer and PoP/SSH token cache types
		         * Cast to lowercase to handle "bearer" from ADFS
		         */
		        const credentialType = authScheme.toLowerCase() !==
		                AuthenticationScheme.BEARER.toLowerCase()
		            ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME
		            : CredentialType.ACCESS_TOKEN;
		        const accessTokenFilter = {
		            credentialType: credentialType,
		            clientId,
		            target: ScopeSet.createSearchScopes(this.scopeSet.asArray()),
		            tokenType: authScheme,
		            keyId: request.sshKid,
		            requestedClaimsHash: request.requestedClaimsHash,
		            userAssertionHash: this.userAssertionHash,
		        };
		        const accessTokens = this.cacheManager.getAccessTokensByFilter(accessTokenFilter, request.correlationId);
		        const numAccessTokens = accessTokens.length;
		        if (numAccessTokens < 1) {
		            return null;
		        }
		        else if (numAccessTokens > 1) {
		            throw createClientAuthError(multipleMatchingTokens);
		        }
		        return accessTokens[0];
		    }
		    /**
		     * Make a network call to the server requesting credentials
		     * @param request - developer provided CommonOnBehalfOfRequest
		     * @param authority - authority object
		     */
		    async executeTokenRequest(request, authority, userAssertionHash) {
		        const queryParametersString = this.createTokenQueryParameters(request);
		        const endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);
		        const requestBody = await this.createTokenRequestBody(request);
		        const headers = this.createTokenRequestHeaders();
		        const thumbprint = {
		            clientId: this.config.authOptions.clientId,
		            authority: request.authority,
		            scopes: request.scopes,
		            claims: request.claims,
		            authenticationScheme: request.authenticationScheme,
		            resourceRequestMethod: request.resourceRequestMethod,
		            resourceRequestUri: request.resourceRequestUri,
		            shrClaims: request.shrClaims,
		            sshKid: request.sshKid,
		        };
		        const reqTimestamp = nowSeconds();
		        const response = await this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint, request.correlationId);
		        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);
		        responseHandler.validateTokenResponse(response.body);
		        const tokenResponse = await responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, userAssertionHash);
		        return tokenResponse;
		    }
		    /**
		     * generate a server request in accepable format
		     * @param request - developer provided CommonOnBehalfOfRequest
		     */
		    async createTokenRequestBody(request) {
		        const parameters = new Map();
		        addClientId(parameters, this.config.authOptions.clientId);
		        addScopes(parameters, request.scopes);
		        addGrantType(parameters, GrantType.JWT_BEARER);
		        addClientInfo(parameters);
		        addLibraryInfo(parameters, this.config.libraryInfo);
		        addApplicationTelemetry(parameters, this.config.telemetry.application);
		        addThrottling(parameters);
		        if (this.serverTelemetryManager) {
		            addServerTelemetry(parameters, this.serverTelemetryManager);
		        }
		        const correlationId = request.correlationId ||
		            this.config.cryptoInterface.createNewGuid();
		        addCorrelationId(parameters, correlationId);
		        addRequestTokenUse(parameters, ON_BEHALF_OF);
		        addOboAssertion(parameters, request.oboAssertion);
		        if (this.config.clientCredentials.clientSecret) {
		            addClientSecret(parameters, this.config.clientCredentials.clientSecret);
		        }
		        const clientAssertion = this.config.clientCredentials.clientAssertion;
		        if (clientAssertion) {
		            addClientAssertion(parameters, await getClientAssertion(clientAssertion.assertion, this.config.authOptions.clientId, request.resourceRequestUri));
		            addClientAssertionType(parameters, clientAssertion.assertionType);
		        }
		        if (request.claims ||
		            (this.config.authOptions.clientCapabilities &&
		                this.config.authOptions.clientCapabilities.length > 0)) {
		            addClaims(parameters, request.claims, this.config.authOptions.clientCapabilities);
		        }
		        return mapToQueryString(parameters);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		// AADAuthorityConstants
		/**
		 *  This class is to be used to acquire tokens for confidential client applications (webApp, webAPI). Confidential client applications
		 *  will configure application secrets, client certificates/assertions as applicable
		 * @public
		 */
		class ConfidentialClientApplication extends ClientApplication {
		    /**
		     * Constructor for the ConfidentialClientApplication
		     *
		     * Required attributes in the Configuration object are:
		     * - clientID: the application ID of your application. You can obtain one by registering your application with our application registration portal
		     * - authority: the authority URL for your application.
		     * - client credential: Must set either client secret, certificate, or assertion for confidential clients. You can obtain a client secret from the application registration portal.
		     *
		     * In Azure AD, authority is a URL indicating of the form https://login.microsoftonline.com/\{Enter_the_Tenant_Info_Here\}.
		     * If your application supports Accounts in one organizational directory, replace "Enter_the_Tenant_Info_Here" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).
		     * If your application supports Accounts in any organizational directory, replace "Enter_the_Tenant_Info_Here" value with organizations.
		     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace "Enter_the_Tenant_Info_Here" value with common.
		     * To restrict support to Personal Microsoft accounts only, replace "Enter_the_Tenant_Info_Here" value with consumers.
		     *
		     * In Azure B2C, authority is of the form https://\{instance\}/tfp/\{tenant\}/\{policyName\}/
		     * Full B2C functionality will be available in this library in future versions.
		     *
		     * @param Configuration - configuration object for the MSAL ConfidentialClientApplication instance
		     */
		    constructor(configuration) {
		        super(configuration);
		        const clientSecretNotEmpty = !!this.config.auth.clientSecret;
		        const clientAssertionNotEmpty = !!this.config.auth.clientAssertion;
		        const certificateNotEmpty = (!!this.config.auth.clientCertificate?.thumbprint ||
		            !!this.config.auth.clientCertificate?.thumbprintSha256) &&
		            !!this.config.auth.clientCertificate?.privateKey;
		        /*
		         * If app developer configures this callback, they don't need a credential
		         * i.e. AzureSDK can get token from Managed Identity without a cert / secret
		         */
		        if (this.appTokenProvider) {
		            return;
		        }
		        // Check that at most one credential is set on the application
		        if ((clientSecretNotEmpty && clientAssertionNotEmpty) ||
		            (clientAssertionNotEmpty && certificateNotEmpty) ||
		            (clientSecretNotEmpty && certificateNotEmpty)) {
		            throw createClientAuthError(invalidClientCredential);
		        }
		        if (this.config.auth.clientSecret) {
		            this.clientSecret = this.config.auth.clientSecret;
		            return;
		        }
		        if (this.config.auth.clientAssertion) {
		            this.developerProvidedClientAssertion =
		                this.config.auth.clientAssertion;
		            return;
		        }
		        if (!certificateNotEmpty) {
		            throw createClientAuthError(invalidClientCredential);
		        }
		        else {
		            this.clientAssertion = !!this.config.auth.clientCertificate
		                .thumbprintSha256
		                ? ClientAssertion.fromCertificateWithSha256Thumbprint(this.config.auth.clientCertificate.thumbprintSha256, this.config.auth.clientCertificate.privateKey, this.config.auth.clientCertificate.x5c)
		                : ClientAssertion.fromCertificate(
		                // guaranteed to be a string, due to prior error checking in this function
		                this.config.auth.clientCertificate.thumbprint, this.config.auth.clientCertificate.privateKey, this.config.auth.clientCertificate.x5c);
		        }
		        this.appTokenProvider = undefined;
		    }
		    /**
		     * This extensibility point only works for the client_credential flow, i.e. acquireTokenByClientCredential and
		     * is meant for Azure SDK to enhance Managed Identity support.
		     *
		     * @param IAppTokenProvider  - Extensibility interface, which allows the app developer to return a token from a custom source.
		     */
		    SetAppTokenProvider(provider) {
		        this.appTokenProvider = provider;
		    }
		    /**
		     * Acquires tokens from the authority for the application (not for an end user).
		     */
		    async acquireTokenByClientCredential(request) {
		        this.logger.info("acquireTokenByClientCredential called", request.correlationId);
		        // If there is a client assertion present in the request, it overrides the one present in the client configuration
		        let clientAssertion;
		        if (request.clientAssertion) {
		            clientAssertion = {
		                assertion: await getClientAssertion(request.clientAssertion, this.config.auth.clientId
		                // tokenEndpoint will be undefined. resourceRequestUri is omitted in ClientCredentialRequest
		                ),
		                assertionType: Constants.JWT_BEARER_ASSERTION_TYPE,
		            };
		        }
		        const baseRequest = await this.initializeBaseRequest(request);
		        // valid base request should not contain oidc scopes in this grant type
		        const validBaseRequest = {
		            ...baseRequest,
		            scopes: baseRequest.scopes.filter((scope) => !OIDC_DEFAULT_SCOPES.includes(scope)),
		        };
		        const validRequest = {
		            ...request,
		            ...validBaseRequest,
		            clientAssertion,
		        };
		        /*
		         * valid request should not have "common" or "organizations" in lieu of the tenant_id in the authority in the auth configuration
		         * example authority: "https://login.microsoftonline.com/TenantId",
		         */
		        const authority = new UrlString(validRequest.authority);
		        const tenantId = authority.getUrlComponents().PathSegments[0];
		        if (Object.values(AADAuthorityConstants).includes(tenantId)) {
		            throw createClientAuthError(missingTenantIdError);
		        }
		        /*
		         * if this env variable is set, and the developer provided region isn't defined and isn't "DisableMsalForceRegion",
		         * MSAL shall opt-in to ESTS-R with the value of this variable
		         */
		        const ENV_MSAL_FORCE_REGION = process.env[MSAL_FORCE_REGION];
		        let region;
		        if (validRequest.azureRegion !== "DisableMsalForceRegion") {
		            if (!validRequest.azureRegion && ENV_MSAL_FORCE_REGION) {
		                region = ENV_MSAL_FORCE_REGION;
		            }
		            else {
		                region = validRequest.azureRegion;
		            }
		        }
		        const azureRegionConfiguration = {
		            azureRegion: region,
		            environmentRegion: process.env[REGION_ENVIRONMENT_VARIABLE],
		        };
		        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenByClientCredential, validRequest.correlationId, validRequest.skipCache);
		        try {
		            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, azureRegionConfiguration, request.azureCloudOptions);
		            const clientCredentialConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", serverTelemetryManager);
		            const clientCredentialClient = new ClientCredentialClient(clientCredentialConfig, this.appTokenProvider);
		            this.logger.verbose("Client credential client created", validRequest.correlationId);
		            return await clientCredentialClient.acquireToken(validRequest);
		        }
		        catch (e) {
		            if (e instanceof AuthError) {
		                e.setCorrelationId(validRequest.correlationId);
		            }
		            serverTelemetryManager.cacheFailedRequest(e);
		            throw e;
		        }
		    }
		    /**
		     * Acquires tokens from the authority for the application.
		     *
		     * Used in scenarios where the current app is a middle-tier service which was called with a token
		     * representing an end user. The current app can use the token (oboAssertion) to request another
		     * token to access downstream web API, on behalf of that user.
		     *
		     * The current middle-tier app has no user interaction to obtain consent.
		     * See how to gain consent upfront for your middle-tier app from this article.
		     * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-on-behalf-of-flow#gaining-consent-for-the-middle-tier-application
		     */
		    async acquireTokenOnBehalfOf(request) {
		        this.logger.info("acquireTokenOnBehalfOf called", request.correlationId);
		        const validRequest = {
		            ...request,
		            ...(await this.initializeBaseRequest(request)),
		        };
		        try {
		            const discoveredAuthority = await this.createAuthority(validRequest.authority, validRequest.correlationId, undefined, request.azureCloudOptions);
		            const onBehalfOfConfig = await this.buildOauthClientConfiguration(discoveredAuthority, validRequest.correlationId, "", undefined);
		            const oboClient = new OnBehalfOfClient(onBehalfOfConfig);
		            this.logger.verbose("On behalf of client created", validRequest.correlationId);
		            return await oboClient.acquireToken(validRequest);
		        }
		        catch (e) {
		            if (e instanceof AuthError) {
		                e.setCorrelationId(validRequest.correlationId);
		            }
		            throw e;
		        }
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * @internal
		 * Checks if a given date string is in ISO 8601 format.
		 *
		 * @param dateString - The date string to be checked.
		 * @returns boolean - Returns true if the date string is in ISO 8601 format, otherwise false.
		 */
		function isIso8601(dateString) {
		    if (typeof dateString !== "string") {
		        return false;
		    }
		    const date = new Date(dateString);
		    return !isNaN(date.getTime()) && date.toISOString() === dateString;
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class HttpClientWithRetries {
		    constructor(httpClientNoRetries, retryPolicy, logger) {
		        this.httpClientNoRetries = httpClientNoRetries;
		        this.retryPolicy = retryPolicy;
		        this.logger = logger;
		    }
		    async sendNetworkRequestAsyncHelper(httpMethod, url, options) {
		        if (httpMethod === HttpMethod.GET) {
		            return this.httpClientNoRetries.sendGetRequestAsync(url, options);
		        }
		        else {
		            return this.httpClientNoRetries.sendPostRequestAsync(url, options);
		        }
		    }
		    async sendNetworkRequestAsync(httpMethod, url, options) {
		        // the underlying network module (custom or HttpClient) will make the call
		        let response = await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);
		        if ("isNewRequest" in this.retryPolicy) {
		            this.retryPolicy.isNewRequest = true;
		        }
		        let currentRetry = 0;
		        while (await this.retryPolicy.pauseForRetry(response.status, currentRetry, this.logger, response.headers[HeaderNames.RETRY_AFTER])) {
		            response = await this.sendNetworkRequestAsyncHelper(httpMethod, url, options);
		            currentRetry++;
		        }
		        return response;
		    }
		    async sendGetRequestAsync(url, options) {
		        return this.sendNetworkRequestAsync(HttpMethod.GET, url, options);
		    }
		    async sendPostRequestAsync(url, options) {
		        return this.sendNetworkRequestAsync(HttpMethod.POST, url, options);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Managed Identity User Assigned Id Query Parameter Names
		 */
		const ManagedIdentityUserAssignedIdQueryParameterNames = {
		    MANAGED_IDENTITY_CLIENT_ID_2017: "clientid",
		    MANAGED_IDENTITY_CLIENT_ID: "client_id",
		    MANAGED_IDENTITY_OBJECT_ID: "object_id",
		    MANAGED_IDENTITY_RESOURCE_ID_IMDS: "msi_res_id",
		    MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS: "mi_res_id",
		};
		/**
		 * Base class for all Managed Identity sources. Provides common functionality for
		 * authenticating with Azure Managed Identity endpoints across different Azure services
		 * including IMDS, App Service, Azure Arc, Service Fabric, Cloud Shell, and Machine Learning.
		 *
		 * This abstract class handles token acquisition, response processing, and network communication
		 * while allowing concrete implementations to define source-specific request creation logic.
		 */
		class BaseManagedIdentitySource {
		    /**
		     * Creates an instance of BaseManagedIdentitySource.
		     *
		     * @param logger - Logger instance for diagnostic information
		     * @param nodeStorage - Storage interface for caching tokens
		     * @param networkClient - Network client for making HTTP requests
		     * @param cryptoProvider - Cryptographic provider for token operations
		     * @param disableInternalRetries - Whether to disable automatic retry logic
		     */
		    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
		        this.logger = logger;
		        this.nodeStorage = nodeStorage;
		        this.networkClient = networkClient;
		        this.cryptoProvider = cryptoProvider;
		        this.disableInternalRetries = disableInternalRetries;
		    }
		    /**
		     * Processes the network response and converts it to a standardized server token response.
		     * This async version allows for source-specific response processing logic while maintaining
		     * backward compatibility with the synchronous version.
		     *
		     * @param response - The network response containing the managed identity token
		     * @param _networkClient - Network client used for the request (unused in base implementation)
		     * @param _networkRequest - The original network request parameters (unused in base implementation)
		     * @param _networkRequestOptions - The network request options (unused in base implementation)
		     *
		     * @returns Promise resolving to a standardized server authorization token response
		     */
		    async getServerTokenResponseAsync(response, 
		    // eslint-disable-next-line @typescript-eslint/no-unused-vars
		    _networkClient, 
		    // eslint-disable-next-line @typescript-eslint/no-unused-vars
		    _networkRequest, 
		    // eslint-disable-next-line @typescript-eslint/no-unused-vars
		    _networkRequestOptions) {
		        return this.getServerTokenResponse(response);
		    }
		    /**
		     * Converts a managed identity token response to a standardized server authorization token response.
		     * Handles time format conversion, expiration calculation, and error mapping to ensure
		     * compatibility with the MSAL response handling pipeline.
		     *
		     * @param response - The network response containing the managed identity token
		     *
		     * @returns Standardized server authorization token response with normalized fields
		     */
		    getServerTokenResponse(response) {
		        let refreshIn, expiresIn;
		        if (response.body.expires_on) {
		            // if the expires_on field in the response body is a string and in ISO 8601 format, convert it to a Unix timestamp (seconds since epoch)
		            if (isIso8601(response.body.expires_on)) {
		                response.body.expires_on =
		                    new Date(response.body.expires_on).getTime() / 1000;
		            }
		            expiresIn = response.body.expires_on - nowSeconds();
		            // compute refresh_in as 1/2 of expires_in, but only if expires_in > 2h
		            if (expiresIn > 2 * 3600) {
		                refreshIn = expiresIn / 2;
		            }
		        }
		        const serverTokenResponse = {
		            status: response.status,
		            // success
		            access_token: response.body.access_token,
		            expires_in: expiresIn,
		            scope: response.body.resource,
		            token_type: response.body.token_type,
		            refresh_in: refreshIn,
		            // error
		            correlation_id: response.body.correlation_id || response.body.correlationId,
		            error: typeof response.body.error === "string"
		                ? response.body.error
		                : response.body.error?.code,
		            error_description: response.body.message ||
		                (typeof response.body.error === "string"
		                    ? response.body.error_description
		                    : response.body.error?.message),
		            error_codes: response.body.error_codes,
		            timestamp: response.body.timestamp,
		            trace_id: response.body.trace_id,
		        };
		        return serverTokenResponse;
		    }
		    /**
		     * Acquires an access token using the managed identity endpoint for the specified resource.
		     * This is the primary method for token acquisition, handling the complete flow from
		     * request creation through response processing and token caching.
		     *
		     * @param managedIdentityRequest - The managed identity request containing resource and optional parameters
		     * @param managedIdentityId - The managed identity configuration (system or user-assigned)
		     * @param fakeAuthority - Authority instance used for token caching (managed identity uses a placeholder authority)
		     * @param refreshAccessToken - Whether this is a token refresh operation
		     *
		     * @returns Promise resolving to an authentication result containing the access token and metadata
		     *
		     * @throws {AuthError} When network requests fail or token validation fails
		     * @throws {ClientAuthError} When network errors occur during the request
		     */
		    async acquireTokenWithManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {
		        const networkRequest = this.createRequest(managedIdentityRequest.resource, managedIdentityId);
		        if (managedIdentityRequest.revokedTokenSha256Hash) {
		            this.logger.info(`[Managed Identity] The following claims are present in the request: ${managedIdentityRequest.claims}`);
		            networkRequest.queryParameters[ManagedIdentityQueryParameters.SHA256_TOKEN_TO_REFRESH] = managedIdentityRequest.revokedTokenSha256Hash;
		        }
		        if (managedIdentityRequest.clientCapabilities?.length) {
		            const clientCapabilities = managedIdentityRequest.clientCapabilities.toString();
		            this.logger.info(`[Managed Identity] The following client capabilities are present in the request: ${clientCapabilities}`);
		            networkRequest.queryParameters[ManagedIdentityQueryParameters.XMS_CC] = clientCapabilities;
		        }
		        const headers = networkRequest.headers;
		        headers[HeaderNames.CONTENT_TYPE] = Constants$1.URL_FORM_CONTENT_TYPE;
		        const networkRequestOptions = { headers };
		        if (Object.keys(networkRequest.bodyParameters).length) {
		            networkRequestOptions.body =
		                networkRequest.computeParametersBodyString();
		        }
		        /**
		         * Initializes the network client helper based on the retry policy configuration.
		         * If internal retries are disabled, it uses the provided network client directly.
		         * Otherwise, it wraps the network client with an HTTP client that supports retries.
		         */
		        const networkClientHelper = this.disableInternalRetries
		            ? this.networkClient
		            : new HttpClientWithRetries(this.networkClient, networkRequest.retryPolicy, this.logger);
		        const reqTimestamp = nowSeconds();
		        let response;
		        try {
		            // Sources that send POST requests: Cloud Shell
		            if (networkRequest.httpMethod === HttpMethod.POST) {
		                response =
		                    await networkClientHelper.sendPostRequestAsync(networkRequest.computeUri(), networkRequestOptions);
		                // Sources that send GET requests: App Service, Azure Arc, IMDS, Service Fabric
		            }
		            else {
		                response =
		                    await networkClientHelper.sendGetRequestAsync(networkRequest.computeUri(), networkRequestOptions);
		            }
		        }
		        catch (error) {
		            if (error instanceof AuthError) {
		                throw error;
		            }
		            else {
		                throw createClientAuthError(networkError);
		            }
		        }
		        const responseHandler = new ResponseHandler(managedIdentityId.id, this.nodeStorage, this.cryptoProvider, this.logger, null, null);
		        const serverTokenResponse = await this.getServerTokenResponseAsync(response, networkClientHelper, networkRequest, networkRequestOptions);
		        responseHandler.validateTokenResponse(serverTokenResponse, refreshAccessToken);
		        // caches the token
		        return responseHandler.handleServerTokenResponse(serverTokenResponse, fakeAuthority, reqTimestamp, managedIdentityRequest);
		    }
		    /**
		     * Determines the appropriate query parameter name for user-assigned managed identity
		     * based on the identity type, API version, and endpoint characteristics.
		     * Different Azure services and API versions use different parameter names for the same identity types.
		     *
		     * @param managedIdentityIdType - The type of user-assigned managed identity (client ID, object ID, or resource ID)
		     * @param isImds - Whether the request is being made to the IMDS (Instance Metadata Service) endpoint
		     * @param usesApi2017 - Whether the endpoint uses the 2017-09-01 API version (affects client ID parameter name)
		     *
		     * @returns The correct query parameter name for the specified identity type and endpoint
		     *
		     * @throws {ManagedIdentityError} When an invalid managed identity ID type is provided
		     */
		    getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityIdType, isImds, usesApi2017) {
		        switch (managedIdentityIdType) {
		            case ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID:
		                this.logger.info(`[Managed Identity] [API version ${usesApi2017 ? "2017+" : "2019+"}] Adding user assigned client id to the request.`);
		                // The Machine Learning source uses the 2017-09-01 API version, which uses "clientid" instead of "client_id"
		                return usesApi2017
		                    ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID_2017
		                    : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID;
		            case ManagedIdentityIdType.USER_ASSIGNED_RESOURCE_ID:
		                this.logger.info("[Managed Identity] Adding user assigned resource id to the request.");
		                return isImds
		                    ? ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_IMDS
		                    : ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_RESOURCE_ID_NON_IMDS;
		            case ManagedIdentityIdType.USER_ASSIGNED_OBJECT_ID:
		                this.logger.info("[Managed Identity] Adding user assigned object id to the request.");
		                return ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_OBJECT_ID;
		            default:
		                throw createManagedIdentityError(invalidManagedIdentityIdType);
		        }
		    }
		}
		/**
		 * Validates and normalizes an environment variable containing a URL string.
		 * This static utility method ensures that environment variables used for managed identity
		 * endpoints contain properly formatted URLs and provides informative error messages when validation fails.
		 *
		 * @param envVariableStringName - The name of the environment variable being validated (for error reporting)
		 * @param envVariable - The environment variable value containing the URL string
		 * @param sourceName - The name of the managed identity source (for error reporting)
		 * @param logger - Logger instance for diagnostic information
		 *
		 * @returns The validated and normalized URL string
		 *
		 * @throws {ManagedIdentityError} When the environment variable contains a malformed URL
		 */
		BaseManagedIdentitySource.getValidatedEnvVariableUrlString = (envVariableStringName, envVariable, sourceName, logger) => {
		    try {
		        return new UrlString(envVariable).urlString;
		    }
		    catch (error) {
		        logger.info(`[Managed Identity] ${sourceName} managed identity is unavailable because the '${envVariableStringName}' environment variable is malformed.`);
		        throw createManagedIdentityError(MsiEnvironmentVariableUrlMalformedErrorCodes[envVariableStringName]);
		    }
		};

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class LinearRetryStrategy {
		    /**
		     * Calculates the number of milliseconds to sleep based on the `retry-after` HTTP header.
		     *
		     * @param retryHeader - The value of the `retry-after` HTTP header. This can be either a number of seconds
		     *                      or an HTTP date string.
		     * @returns The number of milliseconds to sleep before retrying the request. If the `retry-after` header is not
		     *          present or cannot be parsed, returns 0.
		     */
		    calculateDelay(retryHeader, minimumDelay) {
		        if (!retryHeader) {
		            return minimumDelay;
		        }
		        // retry-after header is in seconds
		        let millisToSleep = Math.round(parseFloat(retryHeader) * 1000);
		        /*
		         * retry-after header is in HTTP Date format
		         * <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
		         */
		        if (isNaN(millisToSleep)) {
		            // .valueOf() is needed to subtract dates in TypeScript
		            millisToSleep =
		                new Date(retryHeader).valueOf() - new Date().valueOf();
		        }
		        return Math.max(minimumDelay, millisToSleep);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const DEFAULT_MANAGED_IDENTITY_MAX_RETRIES = 3; // referenced in unit test
		const DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS = 1000;
		const DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON = [
		    msalCommon.HttpStatus.NOT_FOUND,
		    msalCommon.HttpStatus.REQUEST_TIMEOUT,
		    msalCommon.HttpStatus.TOO_MANY_REQUESTS,
		    msalCommon.HttpStatus.SERVER_ERROR,
		    msalCommon.HttpStatus.SERVICE_UNAVAILABLE,
		    msalCommon.HttpStatus.GATEWAY_TIMEOUT,
		];
		class DefaultManagedIdentityRetryPolicy {
		    constructor() {
		        this.linearRetryStrategy = new LinearRetryStrategy();
		    }
		    /*
		     * this is defined here as a static variable despite being defined as a constant outside of the
		     * class because it needs to be overridden in the unit tests so that the unit tests run faster
		     */
		    static get DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS() {
		        return DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS;
		    }
		    async pauseForRetry(httpStatusCode, currentRetry, logger, retryAfterHeader) {
		        if (DEFAULT_MANAGED_IDENTITY_HTTP_STATUS_CODES_TO_RETRY_ON.includes(httpStatusCode) &&
		            currentRetry < DEFAULT_MANAGED_IDENTITY_MAX_RETRIES) {
		            const retryAfterDelay = this.linearRetryStrategy.calculateDelay(retryAfterHeader, DefaultManagedIdentityRetryPolicy.DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS);
		            logger.verbose(`Retrying request in ${retryAfterDelay}ms (retry attempt: ${currentRetry + 1})`);
		            // pause execution for the calculated delay
		            await new Promise((resolve) => {
		                // retryAfterHeader value of 0 evaluates to false, and DEFAULT_MANAGED_IDENTITY_RETRY_DELAY_MS will be used
		                return setTimeout(resolve, retryAfterDelay);
		            });
		            return true;
		        }
		        // if the status code is not retriable or max retries have been reached, do not retry
		        return false;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class ManagedIdentityRequestParameters {
		    constructor(httpMethod, endpoint, retryPolicy) {
		        this.httpMethod = httpMethod;
		        this._baseEndpoint = endpoint;
		        this.headers = {};
		        this.bodyParameters = {};
		        this.queryParameters = {};
		        this.retryPolicy =
		            retryPolicy || new DefaultManagedIdentityRetryPolicy();
		    }
		    computeUri() {
		        const parameters = new Map();
		        if (this.queryParameters) {
		            addExtraQueryParameters(parameters, this.queryParameters);
		        }
		        const queryParametersString = mapToQueryString(parameters);
		        return UrlString.appendQueryString(this._baseEndpoint, queryParametersString);
		    }
		    computeParametersBodyString() {
		        const parameters = new Map();
		        if (this.bodyParameters) {
		            addExtraQueryParameters(parameters, this.bodyParameters);
		        }
		        return mapToQueryString(parameters);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		// MSI Constants. Docs for MSI are available here https://docs.microsoft.com/azure/app-service/overview-managed-identity
		const APP_SERVICE_MSI_API_VERSION = "2019-08-01";
		/**
		 * Azure App Service Managed Identity Source implementation.
		 *
		 * This class provides managed identity authentication for applications running in Azure App Service.
		 * It uses the local metadata service endpoint available within App Service environments to obtain
		 * access tokens without requiring explicit credentials.
		 *
		 * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/AppServiceManagedIdentitySource.cs
		 */
		class AppService extends BaseManagedIdentitySource {
		    /**
		     * Creates a new instance of the AppService managed identity source.
		     *
		     * @param logger - Logger instance for diagnostic output
		     * @param nodeStorage - Node.js storage implementation for caching
		     * @param networkClient - Network client for making HTTP requests
		     * @param cryptoProvider - Cryptographic operations provider
		     * @param disableInternalRetries - Whether to disable internal retry logic
		     * @param identityEndpoint - The App Service identity endpoint URL
		     * @param identityHeader - The secret header value required for authentication
		     */
		    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader) {
		        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
		        this.identityEndpoint = identityEndpoint;
		        this.identityHeader = identityHeader;
		    }
		    /**
		     * Retrieves the required environment variables for App Service managed identity.
		     *
		     * App Service managed identity requires two environment variables:
		     * - IDENTITY_ENDPOINT: The URL of the local metadata service
		     * - IDENTITY_HEADER: A secret header value for authentication
		     *
		     * @returns An array containing [identityEndpoint, identityHeader] values from environment variables.
		     *          Either value may be undefined if the environment variable is not set.
		     */
		    static getEnvironmentVariables() {
		        const identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];
		        const identityHeader = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER];
		        return [identityEndpoint, identityHeader];
		    }
		    /**
		     * Attempts to create an AppService managed identity source if the environment supports it.
		     *
		     * This method checks for the presence of required environment variables and validates
		     * the identity endpoint URL. If the environment is not suitable for App Service managed
		     * identity (missing environment variables or invalid endpoint), it returns null.
		     *
		     * @param logger - Logger instance for diagnostic output
		     * @param nodeStorage - Node.js storage implementation for caching
		     * @param networkClient - Network client for making HTTP requests
		     * @param cryptoProvider - Cryptographic operations provider
		     * @param disableInternalRetries - Whether to disable internal retry logic
		     *
		     * @returns A new AppService instance if the environment is suitable, null otherwise
		     */
		    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
		        const [identityEndpoint, identityHeader] = AppService.getEnvironmentVariables();
		        // if either of the identity endpoint or identity header variables are undefined, this MSI provider is unavailable.
		        if (!identityEndpoint || !identityHeader) {
		            logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.APP_SERVICE} managed identity is unavailable because one or both of the '${ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER}' and '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' environment variables are not defined.`);
		            return null;
		        }
		        const validatedIdentityEndpoint = AppService.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, ManagedIdentitySourceNames.APP_SERVICE, logger);
		        logger.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.APP_SERVICE} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.APP_SERVICE} managed identity.`);
		        return new AppService(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader);
		    }
		    /**
		     * Creates a managed identity token request for the App Service environment.
		     *
		     * This method constructs an HTTP GET request to the App Service identity endpoint
		     * with the required headers, query parameters, and managed identity configuration.
		     * The request includes the secret header for authentication and appropriate API version.
		     *
		     * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
		     * @param managedIdentityId - The managed identity configuration specifying whether to use system-assigned or user-assigned identity
		     *
		     * @returns A configured ManagedIdentityRequestParameters object ready for network execution
		     */
		    createRequest(resource, managedIdentityId) {
		        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);
		        request.headers[ManagedIdentityHeaders.APP_SERVICE_SECRET_HEADER_NAME] =
		            this.identityHeader;
		        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =
		            APP_SERVICE_MSI_API_VERSION;
		        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =
		            resource;
		        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
		            request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType)] = managedIdentityId.id;
		        }
		        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity
		        return request;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const ARC_API_VERSION = "2019-11-01";
		const DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT = "http://127.0.0.1:40342/metadata/identity/oauth2/token";
		const HIMDS_EXECUTABLE_HELPER_STRING = "N/A: himds executable exists";
		const SUPPORTED_AZURE_ARC_PLATFORMS = {
		    win32: `${process.env["ProgramData"]}\\AzureConnectedMachineAgent\\Tokens\\`,
		    linux: "/var/opt/azcmagent/tokens/",
		};
		const AZURE_ARC_FILE_DETECTION = {
		    win32: `${process.env["ProgramFiles"]}\\AzureConnectedMachineAgent\\himds.exe`,
		    linux: "/opt/azcmagent/bin/himds",
		};
		/**
		 * Azure Arc managed identity source implementation for acquiring tokens from Azure Arc-enabled servers.
		 *
		 * This class provides managed identity authentication for applications running on Azure Arc-enabled servers
		 * by communicating with the local Hybrid Instance Metadata Service (HIMDS). It supports both environment
		 * variable-based configuration and automatic detection through the HIMDS executable.
		 *
		 * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/AzureArcManagedIdentitySource.cs
		 */
		class AzureArc extends BaseManagedIdentitySource {
		    /**
		     * Creates a new instance of the AzureArc managed identity source.
		     *
		     * @param logger - Logger instance for capturing telemetry and diagnostic information
		     * @param nodeStorage - Storage implementation for caching tokens and metadata
		     * @param networkClient - Network client for making HTTP requests to the identity endpoint
		     * @param cryptoProvider - Cryptographic operations provider for token validation and encryption
		     * @param disableInternalRetries - Flag to disable automatic retry logic for failed requests
		     * @param identityEndpoint - The Azure Arc identity endpoint URL for token requests
		     */
		    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint) {
		        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
		        this.identityEndpoint = identityEndpoint;
		    }
		    /**
		     * Retrieves and validates Azure Arc environment variables for managed identity configuration.
		     *
		     * This method checks for IDENTITY_ENDPOINT and IMDS_ENDPOINT environment variables.
		     * If either is missing, it attempts to detect the Azure Arc environment by checking for
		     * the HIMDS executable at platform-specific paths. On successful detection, it returns
		     * the default identity endpoint and a helper string indicating file-based detection.
		     *
		     * @returns An array containing [identityEndpoint, imdsEndpoint] where both values are
		     *          strings if Azure Arc is available, or undefined if not available.
		     */
		    static getEnvironmentVariables() {
		        let identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];
		        let imdsEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT];
		        // if either of the identity or imds endpoints are undefined, check if the himds executable exists
		        if (!identityEndpoint || !imdsEndpoint) {
		            // get the expected Windows or Linux file path of the himds executable
		            const fileDetectionPath = AZURE_ARC_FILE_DETECTION[process.platform];
		            try {
		                /*
		                 * check if the himds executable exists and its permissions allow it to be read
		                 * returns undefined if true, throws an error otherwise
		                 */
		                fs.accessSync(fileDetectionPath, fs.constants.F_OK | fs.constants.R_OK);
		                identityEndpoint = DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT;
		                imdsEndpoint = HIMDS_EXECUTABLE_HELPER_STRING;
		            }
		            catch (err) {
		                /*
		                 * do nothing
		                 * accessSync returns undefined on success, and throws an error on failure
		                 */
		            }
		        }
		        return [identityEndpoint, imdsEndpoint];
		    }
		    /**
		     * Attempts to create an AzureArc managed identity source instance.
		     *
		     * Validates the Azure Arc environment by checking environment variables
		     * and performing file-based detection. It ensures that only system-assigned managed identities
		     * are supported for Azure Arc scenarios. The method performs comprehensive validation of
		     * endpoint URLs and logs detailed information about the detection process.
		     *
		     * @param logger - Logger instance for capturing creation and validation steps
		     * @param nodeStorage - Storage implementation for the managed identity source
		     * @param networkClient - Network client for HTTP communication
		     * @param cryptoProvider - Cryptographic operations provider
		     * @param disableInternalRetries - Whether to disable automatic retry mechanisms
		     * @param managedIdentityId - The managed identity configuration, must be system-assigned
		     *
		     * @returns AzureArc instance if the environment supports Azure Arc managed identity, null otherwise
		     *
		     * @throws {ManagedIdentityError} When a user-assigned managed identity is specified (not supported for Azure Arc)
		     */
		    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {
		        const [identityEndpoint, imdsEndpoint] = AzureArc.getEnvironmentVariables();
		        // if either of the identity or imds endpoints are undefined (even after himds file detection)
		        if (!identityEndpoint || !imdsEndpoint) {
		            logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is unavailable through environment variables because one or both of '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' and '${ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT}' are not defined. ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is also unavailable through file detection.`);
		            return null;
		        }
		        // check if the imds endpoint is set to the default for file detection
		        if (imdsEndpoint === HIMDS_EXECUTABLE_HELPER_STRING) {
		            logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.AZURE_ARC} managed identity is available through file detection. Defaulting to known ${ManagedIdentitySourceNames.AZURE_ARC} endpoint: ${DEFAULT_AZURE_ARC_IDENTITY_ENDPOINT}. Creating ${ManagedIdentitySourceNames.AZURE_ARC} managed identity.`);
		        }
		        else {
		            // otherwise, both the identity and imds endpoints are defined without file detection; validate them
		            const validatedIdentityEndpoint = AzureArc.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, ManagedIdentitySourceNames.AZURE_ARC, logger);
		            // remove trailing slash
		            validatedIdentityEndpoint.endsWith("/")
		                ? validatedIdentityEndpoint.slice(0, -1)
		                : validatedIdentityEndpoint;
		            AzureArc.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IMDS_ENDPOINT, imdsEndpoint, ManagedIdentitySourceNames.AZURE_ARC, logger);
		            logger.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.AZURE_ARC} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.AZURE_ARC} managed identity.`);
		        }
		        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
		            throw createManagedIdentityError(unableToCreateAzureArc);
		        }
		        return new AzureArc(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint);
		    }
		    /**
		     * Creates a properly formatted HTTP request for acquiring tokens from the Azure Arc identity endpoint.
		     *
		     * This method constructs a GET request to the Azure Arc HIMDS endpoint with the required metadata header
		     * and query parameters. The endpoint URL is normalized to use 127.0.0.1 instead of localhost for
		     * consistency. Additional body parameters are calculated by the base class during token acquisition.
		     *
		     * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
		     *
		     * @returns A configured ManagedIdentityRequestParameters object ready for network execution
		     */
		    createRequest(resource) {
		        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint.replace("localhost", "127.0.0.1"));
		        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";
		        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =
		            ARC_API_VERSION;
		        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =
		            resource;
		        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity
		        return request;
		    }
		    /**
		     * Processes the server response and handles Azure Arc-specific authentication challenges.
		     *
		     * This method implements the Azure Arc authentication flow which may require reading a secret file
		     * for authorization. When the initial request returns HTTP 401 Unauthorized, it extracts the file
		     * path from the WWW-Authenticate header, validates the file location and size, reads the secret,
		     * and retries the request with Basic authentication. The method includes comprehensive security
		     * validations to prevent path traversal and ensure file integrity.
		     *
		     * @param originalResponse - The initial HTTP response from the identity endpoint
		     * @param networkClient - Network client for making the retry request if needed
		     * @param networkRequest - The original request parameters (modified with auth header for retry)
		     * @param networkRequestOptions - Additional options for network requests
		     *
		     * @returns A promise that resolves to the server token response with access token and metadata
		     *
		     * @throws {ManagedIdentityError} When:
		     *   - WWW-Authenticate header is missing or has unsupported format
		     *   - Platform is not supported (not Windows or Linux)
		     *   - Secret file has invalid extension (not .key)
		     *   - Secret file path doesn't match expected platform path
		     *   - Secret file cannot be read or is too large (>4096 bytes)
		     * @throws {ClientAuthError} When network errors occur during retry request
		     */
		    async getServerTokenResponseAsync(originalResponse, networkClient, networkRequest, networkRequestOptions) {
		        let retryResponse;
		        if (originalResponse.status === HttpStatus.UNAUTHORIZED) {
		            const wwwAuthHeader = originalResponse.headers["www-authenticate"];
		            if (!wwwAuthHeader) {
		                throw createManagedIdentityError(wwwAuthenticateHeaderMissing);
		            }
		            if (!wwwAuthHeader.includes("Basic realm=")) {
		                throw createManagedIdentityError(wwwAuthenticateHeaderUnsupportedFormat);
		            }
		            const secretFilePath = wwwAuthHeader.split("Basic realm=")[1];
		            // throw an error if the managed identity application is not being run on Windows or Linux
		            if (!SUPPORTED_AZURE_ARC_PLATFORMS.hasOwnProperty(process.platform)) {
		                throw createManagedIdentityError(platformNotSupported);
		            }
		            // get the expected Windows or Linux file path
		            const expectedSecretFilePath = SUPPORTED_AZURE_ARC_PLATFORMS[process.platform];
		            // throw an error if the file in the file path is not a .key file
		            const fileName = path.basename(secretFilePath);
		            if (!fileName.endsWith(".key")) {
		                throw createManagedIdentityError(invalidFileExtension);
		            }
		            /*
		             * throw an error if the file path from the www-authenticate header does not match the
		             * expected file path for the platform (Windows or Linux) the managed identity application
		             * is running on
		             */
		            if (expectedSecretFilePath + fileName !== secretFilePath) {
		                throw createManagedIdentityError(invalidFilePath);
		            }
		            let secretFileSize;
		            // attempt to get the secret file's size, in bytes
		            try {
		                secretFileSize = await fs.statSync(secretFilePath).size;
		            }
		            catch (e) {
		                throw createManagedIdentityError(unableToReadSecretFile);
		            }
		            // throw an error if the secret file's size is greater than 4096 bytes
		            if (secretFileSize > AZURE_ARC_SECRET_FILE_MAX_SIZE_BYTES) {
		                throw createManagedIdentityError(invalidSecret);
		            }
		            // attempt to read the contents of the secret file
		            let secret;
		            try {
		                secret = fs.readFileSync(secretFilePath, EncodingTypes.UTF8);
		            }
		            catch (e) {
		                throw createManagedIdentityError(unableToReadSecretFile);
		            }
		            const authHeaderValue = `Basic ${secret}`;
		            this.logger.info(`[Managed Identity] Adding authorization header to the request.`);
		            networkRequest.headers[ManagedIdentityHeaders.AUTHORIZATION_HEADER_NAME] = authHeaderValue;
		            try {
		                retryResponse =
		                    await networkClient.sendGetRequestAsync(networkRequest.computeUri(), networkRequestOptions);
		            }
		            catch (error) {
		                if (error instanceof AuthError) {
		                    throw error;
		                }
		                else {
		                    throw createClientAuthError(networkError);
		                }
		            }
		        }
		        return this.getServerTokenResponse(retryResponse || originalResponse);
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Azure Cloud Shell managed identity source implementation.
		 *
		 * This class handles authentication for applications running in Azure Cloud Shell environment.
		 * Cloud Shell provides a browser-accessible shell for managing Azure resources and includes
		 * a pre-configured managed identity for authentication.
		 *
		 * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/CloudShellManagedIdentitySource.cs
		 */
		class CloudShell extends BaseManagedIdentitySource {
		    /**
		     * Creates a new CloudShell managed identity source instance.
		     *
		     * @param logger - Logger instance for diagnostic logging
		     * @param nodeStorage - Node.js storage implementation for caching
		     * @param networkClient - HTTP client for making requests to the managed identity endpoint
		     * @param cryptoProvider - Cryptographic operations provider
		     * @param disableInternalRetries - Whether to disable automatic retry logic for failed requests
		     * @param msiEndpoint - The MSI endpoint URL obtained from environment variables
		     */
		    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint) {
		        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
		        this.msiEndpoint = msiEndpoint;
		    }
		    /**
		     * Retrieves the required environment variables for Cloud Shell managed identity.
		     *
		     * Cloud Shell requires the MSI_ENDPOINT environment variable to be set, which
		     * contains the URL of the managed identity service endpoint.
		     *
		     * @returns An array containing the MSI_ENDPOINT environment variable value (or undefined if not set)
		     */
		    static getEnvironmentVariables() {
		        const msiEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT];
		        return [msiEndpoint];
		    }
		    /**
		     * Attempts to create a CloudShell managed identity source instance.
		     *
		     * This method validates that the required environment variables are present and
		     * creates a CloudShell instance if the environment is properly configured.
		     * Cloud Shell only supports system-assigned managed identities.
		     *
		     * @param logger - Logger instance for diagnostic logging
		     * @param nodeStorage - Node.js storage implementation for caching
		     * @param networkClient - HTTP client for making requests
		     * @param cryptoProvider - Cryptographic operations provider
		     * @param disableInternalRetries - Whether to disable automatic retry logic
		     * @param managedIdentityId - The managed identity configuration (must be system-assigned)
		     *
		     * @returns A CloudShell instance if the environment is valid, null otherwise
		     *
		     * @throws {ManagedIdentityError} When a user-assigned managed identity is requested,
		     *         as Cloud Shell only supports system-assigned identities
		     */
		    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {
		        const [msiEndpoint] = CloudShell.getEnvironmentVariables();
		        // if the msi endpoint environment variable is undefined, this MSI provider is unavailable.
		        if (!msiEndpoint) {
		            logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity is unavailable because the '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT} environment variable is not defined.`);
		            return null;
		        }
		        const validatedMsiEndpoint = CloudShell.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT, msiEndpoint, ManagedIdentitySourceNames.CLOUD_SHELL, logger);
		        logger.info(`[Managed Identity] Environment variable validation passed for ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity. Endpoint URI: ${validatedMsiEndpoint}. Creating ${ManagedIdentitySourceNames.CLOUD_SHELL} managed identity.`);
		        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
		            throw createManagedIdentityError(unableToCreateCloudShell);
		        }
		        return new CloudShell(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint);
		    }
		    /**
		     * Creates an HTTP request to acquire an access token from the Cloud Shell managed identity endpoint.
		     *
		     * This method constructs a POST request to the MSI endpoint with the required headers and
		     * body parameters for Cloud Shell authentication. The request includes the target resource
		     * for which the access token is being requested.
		     *
		     * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
		     *
		     * @returns A configured ManagedIdentityRequestParameters object ready for network execution
		     */
		    createRequest(resource) {
		        const request = new ManagedIdentityRequestParameters(HttpMethod.POST, this.msiEndpoint);
		        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";
		        request.bodyParameters[ManagedIdentityQueryParameters.RESOURCE] =
		            resource;
		        return request;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		class ExponentialRetryStrategy {
		    constructor(minExponentialBackoff, maxExponentialBackoff, exponentialDeltaBackoff) {
		        this.minExponentialBackoff = minExponentialBackoff;
		        this.maxExponentialBackoff = maxExponentialBackoff;
		        this.exponentialDeltaBackoff = exponentialDeltaBackoff;
		    }
		    /**
		     * Calculates the exponential delay based on the current retry attempt.
		     *
		     * @param {number} currentRetry - The current retry attempt number.
		     * @returns {number} - The calculated exponential delay in milliseconds.
		     *
		     * The delay is calculated using the formula:
		     * - If `currentRetry` is 0, it returns the minimum backoff time.
		     * - Otherwise, it calculates the delay as the minimum of:
		     *   - `(2^(currentRetry - 1)) * deltaBackoff`
		     *   - `maxBackoff`
		     *
		     * This ensures that the delay increases exponentially with each retry attempt,
		     * but does not exceed the maximum backoff time.
		     */
		    calculateDelay(currentRetry) {
		        // Attempt 1
		        if (currentRetry === 0) {
		            return this.minExponentialBackoff;
		        }
		        // Attempt 2+
		        const exponentialDelay = Math.min(Math.pow(2, currentRetry - 1) * this.exponentialDeltaBackoff, this.maxExponentialBackoff);
		        return exponentialDelay;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY = [
		    msalCommon.HttpStatus.NOT_FOUND,
		    msalCommon.HttpStatus.REQUEST_TIMEOUT,
		    msalCommon.HttpStatus.GONE,
		    msalCommon.HttpStatus.TOO_MANY_REQUESTS,
		];
		const EXPONENTIAL_STRATEGY_NUM_RETRIES = 3;
		const LINEAR_STRATEGY_NUM_RETRIES = 7;
		const MIN_EXPONENTIAL_BACKOFF_MS = 1000;
		const MAX_EXPONENTIAL_BACKOFF_MS = 4000;
		const EXPONENTIAL_DELTA_BACKOFF_MS = 2000;
		const HTTP_STATUS_GONE_RETRY_AFTER_MS = 10 * 1000; // 10 seconds
		class ImdsRetryPolicy {
		    constructor() {
		        this.exponentialRetryStrategy = new ExponentialRetryStrategy(ImdsRetryPolicy.MIN_EXPONENTIAL_BACKOFF_MS, ImdsRetryPolicy.MAX_EXPONENTIAL_BACKOFF_MS, ImdsRetryPolicy.EXPONENTIAL_DELTA_BACKOFF_MS);
		    }
		    /*
		     * these are defined here as static variables despite being defined as constants outside of the
		     * class because they need to be overridden in the unit tests so that the unit tests run faster
		     */
		    static get MIN_EXPONENTIAL_BACKOFF_MS() {
		        return MIN_EXPONENTIAL_BACKOFF_MS;
		    }
		    static get MAX_EXPONENTIAL_BACKOFF_MS() {
		        return MAX_EXPONENTIAL_BACKOFF_MS;
		    }
		    static get EXPONENTIAL_DELTA_BACKOFF_MS() {
		        return EXPONENTIAL_DELTA_BACKOFF_MS;
		    }
		    static get HTTP_STATUS_GONE_RETRY_AFTER_MS() {
		        return HTTP_STATUS_GONE_RETRY_AFTER_MS;
		    }
		    set isNewRequest(value) {
		        this._isNewRequest = value;
		    }
		    /**
		     * Pauses execution for a calculated delay before retrying a request.
		     *
		     * @param httpStatusCode - The HTTP status code of the response.
		     * @param currentRetry - The current retry attempt number.
		     * @param retryAfterHeader - The value of the "retry-after" header from the response.
		     * @returns A promise that resolves to a boolean indicating whether a retry should be attempted.
		     */
		    async pauseForRetry(httpStatusCode, currentRetry, logger) {
		        if (this._isNewRequest) {
		            this._isNewRequest = false;
		            // calculate the maxRetries based on the status code, once per request
		            this.maxRetries =
		                httpStatusCode === msalCommon.HttpStatus.GONE
		                    ? LINEAR_STRATEGY_NUM_RETRIES
		                    : EXPONENTIAL_STRATEGY_NUM_RETRIES;
		        }
		        /**
		         * (status code is one of the retriable 400 status code
		         * or
		         * status code is >= 500 and <= 599)
		         * and
		         * current count of retries is less than the max number of retries
		         */
		        if ((HTTP_STATUS_400_CODES_FOR_EXPONENTIAL_STRATEGY.includes(httpStatusCode) ||
		            (httpStatusCode >= msalCommon.HttpStatus.SERVER_ERROR_RANGE_START &&
		                httpStatusCode <= msalCommon.HttpStatus.SERVER_ERROR_RANGE_END &&
		                currentRetry < this.maxRetries)) &&
		            currentRetry < this.maxRetries) {
		            const retryAfterDelay = httpStatusCode === msalCommon.HttpStatus.GONE
		                ? ImdsRetryPolicy.HTTP_STATUS_GONE_RETRY_AFTER_MS
		                : this.exponentialRetryStrategy.calculateDelay(currentRetry);
		            logger.verbose(`Retrying request in ${retryAfterDelay}ms (retry attempt: ${currentRetry + 1})`);
		            // pause execution for the calculated delay
		            await new Promise((resolve) => {
		                return setTimeout(resolve, retryAfterDelay);
		            });
		            return true;
		        }
		        // if the status code is not retriable or max retries have been reached, do not retry
		        return false;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		// Documentation for IMDS is available at https://docs.microsoft.com/azure/active-directory/managed-identities-azure-resources/how-to-use-vm-token#get-a-token-using-http
		const IMDS_TOKEN_PATH = "/metadata/identity/oauth2/token";
		const DEFAULT_IMDS_ENDPOINT = `http://169.254.169.254${IMDS_TOKEN_PATH}`;
		const IMDS_API_VERSION = "2018-02-01";
		/**
		 * Managed Identity source implementation for Azure Instance Metadata Service (IMDS).
		 *
		 * IMDS is available on Azure Virtual Machines and Virtual Machine Scale Sets and provides
		 * a REST endpoint to obtain OAuth tokens for managed identities. This implementation
		 * handles both system-assigned and user-assigned managed identities.
		 *
		 * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ImdsManagedIdentitySource.cs
		 */
		class Imds extends BaseManagedIdentitySource {
		    /**
		     * Constructs an Imds instance with the specified configuration.
		     *
		     * @param logger - Logger instance for recording debug information and errors
		     * @param nodeStorage - NodeStorage instance used for token caching operations
		     * @param networkClient - Network client implementation for making HTTP requests to IMDS
		     * @param cryptoProvider - CryptoProvider for generating correlation IDs and other cryptographic operations
		     * @param disableInternalRetries - When true, disables the built-in retry logic for IMDS requests
		     * @param identityEndpoint - The complete IMDS endpoint URL including the token path
		     */
		    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint) {
		        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
		        this.identityEndpoint = identityEndpoint;
		    }
		    /**
		     * Creates an Imds instance with the appropriate endpoint configuration.
		     *
		     * This method checks for the presence of the AZURE_POD_IDENTITY_AUTHORITY_HOST environment
		     * variable, which is used in Azure Kubernetes Service (AKS) environments with Azure AD
		     * Pod Identity. If found, it uses that endpoint; otherwise, it falls back to the standard
		     * IMDS endpoint (169.254.169.254).
		     *
		     * @param logger - Logger instance for recording endpoint discovery and validation
		     * @param nodeStorage - NodeStorage instance for token caching
		     * @param networkClient - Network client for HTTP requests
		     * @param cryptoProvider - CryptoProvider for cryptographic operations
		     * @param disableInternalRetries - Whether to disable built-in retry logic
		     *
		     * @returns A configured Imds instance ready to make token requests
		     */
		    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
		        let validatedIdentityEndpoint;
		        if (process.env[ManagedIdentityEnvironmentVariableNames
		            .AZURE_POD_IDENTITY_AUTHORITY_HOST]) {
		            logger.info(`[Managed Identity] Environment variable ${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST} for ${ManagedIdentitySourceNames.IMDS} returned endpoint: ${process.env[ManagedIdentityEnvironmentVariableNames
		                .AZURE_POD_IDENTITY_AUTHORITY_HOST]}`);
		            validatedIdentityEndpoint = Imds.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST, `${process.env[ManagedIdentityEnvironmentVariableNames
		                .AZURE_POD_IDENTITY_AUTHORITY_HOST]}${IMDS_TOKEN_PATH}`, ManagedIdentitySourceNames.IMDS, logger);
		        }
		        else {
		            logger.info(`[Managed Identity] Unable to find ${ManagedIdentityEnvironmentVariableNames.AZURE_POD_IDENTITY_AUTHORITY_HOST} environment variable for ${ManagedIdentitySourceNames.IMDS}, using the default endpoint.`);
		            validatedIdentityEndpoint = DEFAULT_IMDS_ENDPOINT;
		        }
		        return new Imds(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, validatedIdentityEndpoint);
		    }
		    /**
		     * Creates a properly configured HTTP request for acquiring an access token from IMDS.
		     *
		     * This method builds a complete request object with all necessary headers, query parameters,
		     * and retry policies required by the Azure Instance Metadata Service.
		     *
		     * Key request components:
		     * - HTTP GET method to the IMDS token endpoint
		     * - Metadata header set to "true" (required by IMDS)
		     * - API version parameter (currently "2018-02-01")
		     * - Resource parameter specifying the target audience
		     * - Identity-specific parameters for user-assigned managed identities
		     * - IMDS-specific retry policy
		     *
		     * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
		     * @param managedIdentityId - The managed identity configuration specifying whether to use system-assigned or user-assigned identity
		     *
		     * @returns A configured ManagedIdentityRequestParameters object ready for network execution
		     */
		    createRequest(resource, managedIdentityId) {
		        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);
		        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";
		        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =
		            IMDS_API_VERSION;
		        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =
		            resource;
		        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
		            request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType, true // indicates source is IMDS
		            )] = managedIdentityId.id;
		        }
		        // The bodyParameters are calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity.
		        request.retryPolicy = new ImdsRetryPolicy();
		        return request;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const SERVICE_FABRIC_MSI_API_VERSION = "2019-07-01-preview";
		/**
		 * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ServiceFabricManagedIdentitySource.cs
		 */
		class ServiceFabric extends BaseManagedIdentitySource {
		    /**
		     * Constructs a new ServiceFabric managed identity source for acquiring tokens from Azure Service Fabric clusters.
		     *
		     * Service Fabric managed identity allows applications running in Service Fabric clusters to authenticate
		     * without storing credentials in code. This source handles token acquisition using the Service Fabric
		     * Managed Identity Token Service (MITS).
		     *
		     * @param logger - Logger instance for logging authentication events and debugging information
		     * @param nodeStorage - NodeStorage instance for caching tokens and other authentication artifacts
		     * @param networkClient - Network client for making HTTP requests to the Service Fabric identity endpoint
		     * @param cryptoProvider - Crypto provider for cryptographic operations like token validation
		     * @param disableInternalRetries - Whether to disable internal retry logic for failed requests
		     * @param identityEndpoint - The Service Fabric managed identity endpoint URL
		     * @param identityHeader - The Service Fabric managed identity secret header value
		     */
		    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader) {
		        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
		        this.identityEndpoint = identityEndpoint;
		        this.identityHeader = identityHeader;
		    }
		    /**
		     * Retrieves the environment variables required for Service Fabric managed identity authentication.
		     *
		     * Service Fabric managed identity requires three specific environment variables to be set by the
		     * Service Fabric runtime:
		     * - IDENTITY_ENDPOINT: The endpoint URL for the Managed Identity Token Service (MITS)
		     * - IDENTITY_HEADER: A secret value used for authentication with the MITS
		     * - IDENTITY_SERVER_THUMBPRINT: The thumbprint of the MITS server certificate for secure communication
		     *
		     * @returns An array containing the identity endpoint, identity header, and identity server thumbprint values.
		     *          Elements will be undefined if the corresponding environment variables are not set.
		     */
		    static getEnvironmentVariables() {
		        const identityEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT];
		        const identityHeader = process.env[ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER];
		        const identityServerThumbprint = process.env[ManagedIdentityEnvironmentVariableNames
		            .IDENTITY_SERVER_THUMBPRINT];
		        return [identityEndpoint, identityHeader, identityServerThumbprint];
		    }
		    /**
		     * Attempts to create a ServiceFabric managed identity source if the runtime environment supports it.
		     *
		     * Checks for the presence of all required Service Fabric environment variables
		     * and validates the endpoint URL format. It will only create a ServiceFabric instance if the application
		     * is running in a properly configured Service Fabric cluster with managed identity enabled.
		     *
		     * Note: User-assigned managed identities must be configured at the cluster level, not at runtime.
		     * This method will log a warning if a user-assigned identity is requested.
		     *
		     * @param logger - Logger instance for logging creation events and validation results
		     * @param nodeStorage - NodeStorage instance for caching tokens and authentication artifacts
		     * @param networkClient - Network client for making HTTP requests to the identity endpoint
		     * @param cryptoProvider - Crypto provider for cryptographic operations
		     * @param disableInternalRetries - Whether to disable internal retry logic for failed requests
		     * @param managedIdentityId - Managed identity identifier specifying system-assigned or user-assigned identity
		     *
		     * @returns A ServiceFabric instance if all environment variables are valid and present, otherwise null
		     */
		    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {
		        const [identityEndpoint, identityHeader, identityServerThumbprint] = ServiceFabric.getEnvironmentVariables();
		        if (!identityEndpoint || !identityHeader || !identityServerThumbprint) {
		            logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity is unavailable because one or all of the '${ManagedIdentityEnvironmentVariableNames.IDENTITY_HEADER}', '${ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT}' or '${ManagedIdentityEnvironmentVariableNames.IDENTITY_SERVER_THUMBPRINT}' environment variables are not defined.`);
		            return null;
		        }
		        const validatedIdentityEndpoint = ServiceFabric.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.IDENTITY_ENDPOINT, identityEndpoint, ManagedIdentitySourceNames.SERVICE_FABRIC, logger);
		        logger.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity. Endpoint URI: ${validatedIdentityEndpoint}. Creating ${ManagedIdentitySourceNames.SERVICE_FABRIC} managed identity.`);
		        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
		            logger.warning(`[Managed Identity] ${ManagedIdentitySourceNames.SERVICE_FABRIC} user assigned managed identity is configured in the cluster, not during runtime. See also: https://learn.microsoft.com/en-us/azure/service-fabric/configure-existing-cluster-enable-managed-identity-token-service.`);
		        }
		        return new ServiceFabric(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, identityEndpoint, identityHeader);
		    }
		    /**
		     * Creates HTTP request parameters for acquiring an access token from the Service Fabric Managed Identity Token Service (MITS).
		     *
		     * This method constructs a properly formatted HTTP GET request that includes:
		     * - The secret header for authentication with MITS
		     * - API version parameter for the Service Fabric MSI endpoint
		     * - Resource parameter specifying the target Azure service
		     * - Optional identity parameters for user-assigned managed identities
		     *
		     * The request follows the Service Fabric managed identity protocol and uses the 2019-07-01-preview API version.
		     * For user-assigned identities, the appropriate query parameter (client_id, object_id, or resource_id) is added
		     * based on the identity type.
		     *
		     * @param resource - The Azure resource URI for which the access token is requested (e.g., "https://vault.azure.net/")
		     * @param managedIdentityId - The managed identity configuration specifying system-assigned or user-assigned identity details
		     *
		     * @returns A configured ManagedIdentityRequestParameters object ready for network execution
		     */
		    createRequest(resource, managedIdentityId) {
		        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.identityEndpoint);
		        request.headers[ManagedIdentityHeaders.ML_AND_SF_SECRET_HEADER_NAME] =
		            this.identityHeader;
		        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =
		            SERVICE_FABRIC_MSI_API_VERSION;
		        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =
		            resource;
		        if (managedIdentityId.idType !== ManagedIdentityIdType.SYSTEM_ASSIGNED) {
		            request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType)] = managedIdentityId.id;
		        }
		        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity
		        return request;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const MACHINE_LEARNING_MSI_API_VERSION = "2017-09-01";
		const MANAGED_IDENTITY_MACHINE_LEARNING_UNSUPPORTED_ID_TYPE_ERROR = `Only client id is supported for user-assigned managed identity in ${ManagedIdentitySourceNames.MACHINE_LEARNING}.`; // referenced in unit test
		/**
		 * Machine Learning Managed Identity Source implementation for Azure Machine Learning environments.
		 *
		 * This class handles managed identity authentication specifically for Azure Machine Learning services.
		 * It supports both system-assigned and user-assigned managed identities, using the MSI_ENDPOINT
		 * and MSI_SECRET environment variables that are automatically provided in Azure ML environments.
		 */
		class MachineLearning extends BaseManagedIdentitySource {
		    /**
		     * Creates a new MachineLearning managed identity source instance.
		     *
		     * @param logger - Logger instance for diagnostic information
		     * @param nodeStorage - Node storage implementation for caching
		     * @param networkClient - Network client for making HTTP requests
		     * @param cryptoProvider - Cryptographic operations provider
		     * @param disableInternalRetries - Whether to disable automatic request retries
		     * @param msiEndpoint - The MSI endpoint URL from environment variables
		     * @param secret - The MSI secret from environment variables
		     */
		    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint, secret) {
		        super(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
		        this.msiEndpoint = msiEndpoint;
		        this.secret = secret;
		    }
		    /**
		     * Retrieves the required environment variables for Azure Machine Learning managed identity.
		     *
		     * This method checks for the presence of MSI_ENDPOINT and MSI_SECRET environment variables
		     * that are automatically set by the Azure Machine Learning platform when managed identity
		     * is enabled for the compute instance or cluster.
		     *
		     * @returns An array containing [msiEndpoint, secret] where either value may be undefined
		     *          if the corresponding environment variable is not set
		     */
		    static getEnvironmentVariables() {
		        const msiEndpoint = process.env[ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT];
		        const secret = process.env[ManagedIdentityEnvironmentVariableNames.MSI_SECRET];
		        return [msiEndpoint, secret];
		    }
		    /**
		     * Attempts to create a MachineLearning managed identity source.
		     *
		     * This method validates the Azure Machine Learning environment by checking for the required
		     * MSI_ENDPOINT and MSI_SECRET environment variables. If both are present and valid,
		     * it creates and returns a MachineLearning instance. If either is missing or invalid,
		     * it returns null, indicating that this managed identity source is not available
		     * in the current environment.
		     *
		     * @param logger - Logger instance for diagnostic information
		     * @param nodeStorage - Node storage implementation for caching
		     * @param networkClient - Network client for making HTTP requests
		     * @param cryptoProvider - Cryptographic operations provider
		     * @param disableInternalRetries - Whether to disable automatic request retries
		     *
		     * @returns A new MachineLearning instance if the environment is valid, null otherwise
		     */
		    static tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
		        const [msiEndpoint, secret] = MachineLearning.getEnvironmentVariables();
		        // if either of the MSI endpoint or MSI secret variables are undefined, this MSI provider is unavailable.
		        if (!msiEndpoint || !secret) {
		            logger.info(`[Managed Identity] ${ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity is unavailable because one or both of the '${ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT}' and '${ManagedIdentityEnvironmentVariableNames.MSI_SECRET}' environment variables are not defined.`);
		            return null;
		        }
		        const validatedMsiEndpoint = MachineLearning.getValidatedEnvVariableUrlString(ManagedIdentityEnvironmentVariableNames.MSI_ENDPOINT, msiEndpoint, ManagedIdentitySourceNames.MACHINE_LEARNING, logger);
		        logger.info(`[Managed Identity] Environment variables validation passed for ${ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity. Endpoint URI: ${validatedMsiEndpoint}. Creating ${ManagedIdentitySourceNames.MACHINE_LEARNING} managed identity.`);
		        return new MachineLearning(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, msiEndpoint, secret);
		    }
		    /**
		     * Creates a managed identity token request for Azure Machine Learning environments.
		     *
		     * This method constructs the HTTP request parameters needed to acquire an access token
		     * from the Azure Machine Learning managed identity endpoint. It handles both system-assigned
		     * and user-assigned managed identities with specific logic for each type:
		     *
		     * - System-assigned: Uses the DEFAULT_IDENTITY_CLIENT_ID environment variable
		     * - User-assigned: Only supports client ID-based identification (not object ID or resource ID)
		     *
		     * The request uses the 2017-09-01 API version and includes the required secret header
		     * for authentication with the MSI endpoint.
		     *
		     * @param resource - The target resource/scope for which to request an access token (e.g., "https://graph.microsoft.com/.default")
		     * @param managedIdentityId - The managed identity configuration specifying whether to use system-assigned or user-assigned identity
		     *
		     * @returns A configured ManagedIdentityRequestParameters object ready for network execution
		     *
		     * @throws Error if an unsupported managed identity ID type is specified (only client ID is supported for user-assigned)
		     */
		    createRequest(resource, managedIdentityId) {
		        const request = new ManagedIdentityRequestParameters(HttpMethod.GET, this.msiEndpoint);
		        request.headers[ManagedIdentityHeaders.METADATA_HEADER_NAME] = "true";
		        request.headers[ManagedIdentityHeaders.ML_AND_SF_SECRET_HEADER_NAME] =
		            this.secret;
		        request.queryParameters[ManagedIdentityQueryParameters.API_VERSION] =
		            MACHINE_LEARNING_MSI_API_VERSION;
		        request.queryParameters[ManagedIdentityQueryParameters.RESOURCE] =
		            resource;
		        if (managedIdentityId.idType === ManagedIdentityIdType.SYSTEM_ASSIGNED) {
		            request.queryParameters[ManagedIdentityUserAssignedIdQueryParameterNames.MANAGED_IDENTITY_CLIENT_ID_2017] = process.env[ManagedIdentityEnvironmentVariableNames
		                .DEFAULT_IDENTITY_CLIENT_ID]; // this environment variable is always set in an Azure Machine Learning source
		        }
		        else if (managedIdentityId.idType ===
		            ManagedIdentityIdType.USER_ASSIGNED_CLIENT_ID) {
		            request.queryParameters[this.getManagedIdentityUserAssignedIdQueryParameterKey(managedIdentityId.idType, false, // isIMDS
		            true // uses2017API
		            )] = managedIdentityId.id;
		        }
		        else {
		            throw new Error(MANAGED_IDENTITY_MACHINE_LEARNING_UNSUPPORTED_ID_TYPE_ERROR);
		        }
		        // bodyParameters calculated in BaseManagedIdentity.acquireTokenWithManagedIdentity
		        return request;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/*
		 * Class to initialize a managed identity and identify the service.
		 * Original source of code: https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/ManagedIdentityClient.cs
		 */
		class ManagedIdentityClient {
		    constructor(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) {
		        this.logger = logger;
		        this.nodeStorage = nodeStorage;
		        this.networkClient = networkClient;
		        this.cryptoProvider = cryptoProvider;
		        this.disableInternalRetries = disableInternalRetries;
		    }
		    async sendManagedIdentityTokenRequest(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {
		        if (!ManagedIdentityClient.identitySource) {
		            ManagedIdentityClient.identitySource =
		                this.selectManagedIdentitySource(this.logger, this.nodeStorage, this.networkClient, this.cryptoProvider, this.disableInternalRetries, managedIdentityId);
		        }
		        return ManagedIdentityClient.identitySource.acquireTokenWithManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken);
		    }
		    allEnvironmentVariablesAreDefined(environmentVariables) {
		        return Object.values(environmentVariables).every((environmentVariable) => {
		            return environmentVariable !== undefined;
		        });
		    }
		    /**
		     * Determine the Managed Identity Source based on available environment variables. This API is consumed by ManagedIdentityApplication's getManagedIdentitySource.
		     * @returns ManagedIdentitySourceNames - The Managed Identity source's name
		     */
		    getManagedIdentitySource() {
		        ManagedIdentityClient.sourceName =
		            this.allEnvironmentVariablesAreDefined(ServiceFabric.getEnvironmentVariables())
		                ? ManagedIdentitySourceNames.SERVICE_FABRIC
		                : this.allEnvironmentVariablesAreDefined(AppService.getEnvironmentVariables())
		                    ? ManagedIdentitySourceNames.APP_SERVICE
		                    : this.allEnvironmentVariablesAreDefined(MachineLearning.getEnvironmentVariables())
		                        ? ManagedIdentitySourceNames.MACHINE_LEARNING
		                        : this.allEnvironmentVariablesAreDefined(CloudShell.getEnvironmentVariables())
		                            ? ManagedIdentitySourceNames.CLOUD_SHELL
		                            : this.allEnvironmentVariablesAreDefined(AzureArc.getEnvironmentVariables())
		                                ? ManagedIdentitySourceNames.AZURE_ARC
		                                : ManagedIdentitySourceNames.DEFAULT_TO_IMDS;
		        return ManagedIdentityClient.sourceName;
		    }
		    /**
		     * Tries to create a managed identity source for all sources
		     * @returns the managed identity Source
		     */
		    selectManagedIdentitySource(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) {
		        const source = ServiceFabric.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) ||
		            AppService.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) ||
		            MachineLearning.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries) ||
		            CloudShell.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) ||
		            AzureArc.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries, managedIdentityId) ||
		            Imds.tryCreate(logger, nodeStorage, networkClient, cryptoProvider, disableInternalRetries);
		        if (!source) {
		            throw createManagedIdentityError(unableToCreateSource);
		        }
		        return source;
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		const SOURCES_THAT_SUPPORT_TOKEN_REVOCATION = [ManagedIdentitySourceNames.SERVICE_FABRIC];
		/**
		 * Class to initialize a managed identity and identify the service
		 * @public
		 */
		class ManagedIdentityApplication {
		    constructor(configuration) {
		        // undefined config means the managed identity is system-assigned
		        this.config = buildManagedIdentityConfiguration(configuration || {});
		        this.logger = new Logger(this.config.system.loggerOptions, name, version);
		        const fakeStatusAuthorityOptions = {
		            canonicalAuthority: Constants$1.DEFAULT_AUTHORITY,
		        };
		        if (!ManagedIdentityApplication.nodeStorage) {
		            ManagedIdentityApplication.nodeStorage = new NodeStorage(this.logger, this.config.managedIdentityId.id, DEFAULT_CRYPTO_IMPLEMENTATION, fakeStatusAuthorityOptions);
		        }
		        this.networkClient = this.config.system.networkClient;
		        this.cryptoProvider = new CryptoProvider();
		        const fakeAuthorityOptions = {
		            protocolMode: ProtocolMode.AAD,
		            knownAuthorities: [DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY],
		            cloudDiscoveryMetadata: "",
		            authorityMetadata: "",
		        };
		        this.fakeAuthority = new Authority(DEFAULT_AUTHORITY_FOR_MANAGED_IDENTITY, this.networkClient, ManagedIdentityApplication.nodeStorage, fakeAuthorityOptions, this.logger, this.cryptoProvider.createNewGuid(), // correlationID
		        undefined, true);
		        this.fakeClientCredentialClient = new ClientCredentialClient({
		            authOptions: {
		                clientId: this.config.managedIdentityId.id,
		                authority: this.fakeAuthority,
		            },
		        });
		        this.managedIdentityClient = new ManagedIdentityClient(this.logger, ManagedIdentityApplication.nodeStorage, this.networkClient, this.cryptoProvider, this.config.disableInternalRetries);
		        this.hashUtils = new HashUtils();
		    }
		    /**
		     * Acquire an access token from the cache or the managed identity
		     * @param managedIdentityRequest - the ManagedIdentityRequestParams object passed in by the developer
		     * @returns the access token
		     */
		    async acquireToken(managedIdentityRequestParams) {
		        if (!managedIdentityRequestParams.resource) {
		            throw createClientConfigurationError(urlEmptyError);
		        }
		        const managedIdentityRequest = {
		            forceRefresh: managedIdentityRequestParams.forceRefresh,
		            resource: managedIdentityRequestParams.resource.replace("/.default", ""),
		            scopes: [
		                managedIdentityRequestParams.resource.replace("/.default", ""),
		            ],
		            authority: this.fakeAuthority.canonicalAuthority,
		            correlationId: this.cryptoProvider.createNewGuid(),
		            claims: managedIdentityRequestParams.claims,
		            clientCapabilities: this.config.clientCapabilities,
		        };
		        if (managedIdentityRequest.forceRefresh) {
		            return this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);
		        }
		        const [cachedAuthenticationResult, lastCacheOutcome] = await this.fakeClientCredentialClient.getCachedAuthenticationResult(managedIdentityRequest, this.config, this.cryptoProvider, this.fakeAuthority, ManagedIdentityApplication.nodeStorage);
		        /*
		         * Check if claims are present in the managed identity request.
		         * If so, the cached token will not be used.
		         */
		        if (managedIdentityRequest.claims) {
		            const sourceName = this.managedIdentityClient.getManagedIdentitySource();
		            /*
		             * Check if there is a cached token and if the Managed Identity source supports token revocation.
		             * If so, hash the cached access token and add it to the request.
		             */
		            if (cachedAuthenticationResult &&
		                SOURCES_THAT_SUPPORT_TOKEN_REVOCATION.includes(sourceName)) {
		                const revokedTokenSha256Hash = this.hashUtils
		                    .sha256(cachedAuthenticationResult.accessToken)
		                    .toString(EncodingTypes.HEX);
		                managedIdentityRequest.revokedTokenSha256Hash =
		                    revokedTokenSha256Hash;
		            }
		            return this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);
		        }
		        if (cachedAuthenticationResult) {
		            // if the token is not expired but must be refreshed; get a new one in the background
		            if (lastCacheOutcome === CacheOutcome.PROACTIVELY_REFRESHED) {
		                this.logger.info("ClientCredentialClient:getCachedAuthenticationResult - Cached access token's refreshOn property has been exceeded'. It's not expired, but must be refreshed.");
		                // force refresh; will run in the background
		                const refreshAccessToken = true;
		                await this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority, refreshAccessToken);
		            }
		            return cachedAuthenticationResult;
		        }
		        else {
		            return this.acquireTokenFromManagedIdentity(managedIdentityRequest, this.config.managedIdentityId, this.fakeAuthority);
		        }
		    }
		    /**
		     * Acquires a token from a managed identity endpoint.
		     *
		     * @param managedIdentityRequest - The request object containing parameters for the managed identity token request.
		     * @param managedIdentityId - The identifier for the managed identity (e.g., client ID or resource ID).
		     * @param fakeAuthority - A placeholder authority used for the token request.
		     * @param refreshAccessToken - Optional flag indicating whether to force a refresh of the access token.
		     * @returns A promise that resolves to an AuthenticationResult containing the acquired token and related information.
		     */
		    async acquireTokenFromManagedIdentity(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken) {
		        // make a network call to the managed identity
		        return this.managedIdentityClient.sendManagedIdentityTokenRequest(managedIdentityRequest, managedIdentityId, fakeAuthority, refreshAccessToken);
		    }
		    /**
		     * Determine the Managed Identity Source based on available environment variables. This API is consumed by Azure Identity SDK.
		     * @returns ManagedIdentitySourceNames - The Managed Identity source's name
		     */
		    getManagedIdentitySource() {
		        return (ManagedIdentityClient.sourceName ||
		            this.managedIdentityClient.getManagedIdentitySource());
		    }
		}

		/*
		 * Copyright (c) Microsoft Corporation. All rights reserved.
		 * Licensed under the MIT License.
		 */
		/**
		 * Cache plugin that serializes data to the cache and deserializes data from the cache
		 * @public
		 */
		class DistributedCachePlugin {
		    constructor(client, partitionManager) {
		        this.client = client;
		        this.partitionManager = partitionManager;
		    }
		    /**
		     * Deserializes the cache before accessing it
		     * @param cacheContext - TokenCacheContext
		     */
		    async beforeCacheAccess(cacheContext) {
		        const partitionKey = await this.partitionManager.getKey();
		        const cacheData = await this.client.get(partitionKey);
		        cacheContext.tokenCache.deserialize(cacheData);
		    }
		    /**
		     * Serializes the cache after accessing it
		     * @param cacheContext - TokenCacheContext
		     */
		    async afterCacheAccess(cacheContext) {
		        if (cacheContext.cacheHasChanged) {
		            const kvStore = cacheContext.tokenCache.getKVStore();
		            const accountEntities = Object.values(kvStore).filter((value) => AccountEntity.isAccountEntity(value));
		            let partitionKey;
		            if (accountEntities.length > 0) {
		                const accountEntity = accountEntities[0];
		                partitionKey = await this.partitionManager.extractKey(accountEntity);
		            }
		            else {
		                partitionKey = await this.partitionManager.getKey();
		            }
		            await this.client.set(partitionKey, cacheContext.tokenCache.serialize());
		        }
		    }
		}

		exports$1.AuthError = AuthError;
		exports$1.AuthErrorCodes = AuthErrorCodes;
		exports$1.AuthErrorMessage = AuthErrorMessage;
		exports$1.AzureCloudInstance = AzureCloudInstance;
		exports$1.ClientApplication = ClientApplication;
		exports$1.ClientAssertion = ClientAssertion;
		exports$1.ClientAuthError = ClientAuthError;
		exports$1.ClientAuthErrorCodes = ClientAuthErrorCodes;
		exports$1.ClientAuthErrorMessage = ClientAuthErrorMessage;
		exports$1.ClientConfigurationError = ClientConfigurationError;
		exports$1.ClientConfigurationErrorCodes = ClientConfigurationErrorCodes;
		exports$1.ClientConfigurationErrorMessage = ClientConfigurationErrorMessage;
		exports$1.ClientCredentialClient = ClientCredentialClient;
		exports$1.ConfidentialClientApplication = ConfidentialClientApplication;
		exports$1.CryptoProvider = CryptoProvider;
		exports$1.DeviceCodeClient = DeviceCodeClient;
		exports$1.DistributedCachePlugin = DistributedCachePlugin;
		exports$1.InteractionRequiredAuthError = InteractionRequiredAuthError;
		exports$1.InteractionRequiredAuthErrorCodes = InteractionRequiredAuthErrorCodes;
		exports$1.InteractionRequiredAuthErrorMessage = InteractionRequiredAuthErrorMessage;
		exports$1.Logger = Logger;
		exports$1.ManagedIdentityApplication = ManagedIdentityApplication;
		exports$1.ManagedIdentitySourceNames = ManagedIdentitySourceNames;
		exports$1.OnBehalfOfClient = OnBehalfOfClient;
		exports$1.PromptValue = PromptValue;
		exports$1.ProtocolMode = ProtocolMode;
		exports$1.PublicClientApplication = PublicClientApplication;
		exports$1.ResponseMode = ResponseMode;
		exports$1.ServerError = ServerError;
		exports$1.TokenCache = TokenCache;
		exports$1.TokenCacheContext = TokenCacheContext;
		exports$1.UsernamePasswordClient = UsernamePasswordClient;
		exports$1.internals = internals;
		exports$1.version = version;
		
	} (msalNode));
	return msalNode;
}

var utils$3 = {};

var commonjs$5 = {};

var internal$2 = {};

var delay$1 = {};

var random = {};

var hasRequiredRandom;

function requireRandom () {
	if (hasRequiredRandom) return random;
	hasRequiredRandom = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(random, "__esModule", { value: true });
	random.getRandomIntegerInclusive = getRandomIntegerInclusive;
	/**
	 * Returns a random integer value between a lower and upper bound,
	 * inclusive of both bounds.
	 * Note that this uses Math.random and isn't secure. If you need to use
	 * this for any kind of security purpose, find a better source of random.
	 * @param min - The smallest integer value allowed.
	 * @param max - The largest integer value allowed.
	 */
	function getRandomIntegerInclusive(min, max) {
	    // Make sure inputs are integers.
	    min = Math.ceil(min);
	    max = Math.floor(max);
	    // Pick a random offset from zero to the size of the range.
	    // Since Math.random() can never return 1, we have to make the range one larger
	    // in order to be inclusive of the maximum value after we take the floor.
	    const offset = Math.floor(Math.random() * (max - min + 1));
	    return offset + min;
	}
	
	return random;
}

var hasRequiredDelay$1;

function requireDelay$1 () {
	if (hasRequiredDelay$1) return delay$1;
	hasRequiredDelay$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(delay$1, "__esModule", { value: true });
	delay$1.calculateRetryDelay = calculateRetryDelay;
	const random_js_1 = requireRandom();
	/**
	 * Calculates the delay interval for retry attempts using exponential delay with jitter.
	 * @param retryAttempt - The current retry attempt number.
	 * @param config - The exponential retry configuration.
	 * @returns An object containing the calculated retry delay.
	 */
	function calculateRetryDelay(retryAttempt, config) {
	    // Exponentially increase the delay each time
	    const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
	    // Don't let the delay exceed the maximum
	    const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
	    // Allow the final value to have some "jitter" (within 50% of the delay size) so
	    // that retries across multiple clients don't occur simultaneously.
	    const retryAfterInMs = clampedDelay / 2 + (0, random_js_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
	    return { retryAfterInMs };
	}
	
	return delay$1;
}

var object = {};

var hasRequiredObject;

function requireObject () {
	if (hasRequiredObject) return object;
	hasRequiredObject = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(object, "__esModule", { value: true });
	object.isObject = isObject;
	/**
	 * Helper to determine when an input is a generic JS object.
	 * @returns true when input is an object type that is not null, Array, RegExp, or Date.
	 */
	function isObject(input) {
	    return (typeof input === "object" &&
	        input !== null &&
	        !Array.isArray(input) &&
	        !(input instanceof RegExp) &&
	        !(input instanceof Date));
	}
	
	return object;
}

var error$1 = {};

var hasRequiredError$1;

function requireError$1 () {
	if (hasRequiredError$1) return error$1;
	hasRequiredError$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(error$1, "__esModule", { value: true });
	error$1.isError = isError;
	const object_js_1 = requireObject();
	/**
	 * Typeguard for an error object shape (has name and message)
	 * @param e - Something caught by a catch clause.
	 */
	function isError(e) {
	    if ((0, object_js_1.isObject)(e)) {
	        const hasName = typeof e.name === "string";
	        const hasMessage = typeof e.message === "string";
	        return hasName && hasMessage;
	    }
	    return false;
	}
	
	return error$1;
}

var sha256 = {};

const require$7 = createRequire(import.meta.url);
function __require$6() { return require$7("node:crypto"); }

var hasRequiredSha256;

function requireSha256 () {
	if (hasRequiredSha256) return sha256;
	hasRequiredSha256 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(sha256, "__esModule", { value: true });
	sha256.computeSha256Hmac = computeSha256Hmac;
	sha256.computeSha256Hash = computeSha256Hash;
	const node_crypto_1 = __require$6();
	/**
	 * Generates a SHA-256 HMAC signature.
	 * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
	 * @param stringToSign - The data to be signed.
	 * @param encoding - The textual encoding to use for the returned HMAC digest.
	 */
	async function computeSha256Hmac(key, stringToSign, encoding) {
	    const decodedKey = Buffer.from(key, "base64");
	    return (0, node_crypto_1.createHmac)("sha256", decodedKey).update(stringToSign).digest(encoding);
	}
	/**
	 * Generates a SHA-256 hash.
	 * @param content - The data to be included in the hash.
	 * @param encoding - The textual encoding to use for the returned hash.
	 */
	async function computeSha256Hash(content, encoding) {
	    return (0, node_crypto_1.createHash)("sha256").update(content).digest(encoding);
	}
	
	return sha256;
}

var uuidUtils = {};

var hasRequiredUuidUtils;

function requireUuidUtils () {
	if (hasRequiredUuidUtils) return uuidUtils;
	hasRequiredUuidUtils = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(uuidUtils, "__esModule", { value: true });
	uuidUtils.randomUUID = randomUUID;
	/**
	 * Generated Universally Unique Identifier
	 *
	 * @returns RFC4122 v4 UUID.
	 */
	function randomUUID() {
	    return crypto.randomUUID();
	}
	
	return uuidUtils;
}

var checkEnvironment = {};

var hasRequiredCheckEnvironment;

function requireCheckEnvironment () {
	if (hasRequiredCheckEnvironment) return checkEnvironment;
	hasRequiredCheckEnvironment = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.isReactNative = exports$1.isNodeRuntime = exports$1.isNodeLike = exports$1.isBun = exports$1.isDeno = exports$1.isWebWorker = exports$1.isBrowser = void 0;
		/**
		 * A constant that indicates whether the environment the code is running is a Web Browser.
		 */
		// eslint-disable-next-line @azure/azure-sdk/ts-no-window
		exports$1.isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
		/**
		 * A constant that indicates whether the environment the code is running is a Web Worker.
		 */
		exports$1.isWebWorker = typeof self === "object" &&
		    typeof self?.importScripts === "function" &&
		    (self.constructor?.name === "DedicatedWorkerGlobalScope" ||
		        self.constructor?.name === "ServiceWorkerGlobalScope" ||
		        self.constructor?.name === "SharedWorkerGlobalScope");
		/**
		 * A constant that indicates whether the environment the code is running is Deno.
		 */
		exports$1.isDeno = typeof Deno !== "undefined" &&
		    typeof Deno.version !== "undefined" &&
		    typeof Deno.version.deno !== "undefined";
		/**
		 * A constant that indicates whether the environment the code is running is Bun.sh.
		 */
		exports$1.isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
		/**
		 * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
		 */
		exports$1.isNodeLike = typeof globalThis.process !== "undefined" &&
		    Boolean(globalThis.process.version) &&
		    Boolean(globalThis.process.versions?.node);
		/**
		 * A constant that indicates whether the environment the code is running is Node.JS.
		 */
		exports$1.isNodeRuntime = exports$1.isNodeLike && !exports$1.isBun && !exports$1.isDeno;
		/**
		 * A constant that indicates whether the environment the code is running is in React-Native.
		 */
		// https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
		exports$1.isReactNative = typeof navigator !== "undefined" && navigator?.product === "ReactNative";
		
	} (checkEnvironment));
	return checkEnvironment;
}

var bytesEncoding = {};

var hasRequiredBytesEncoding;

function requireBytesEncoding () {
	if (hasRequiredBytesEncoding) return bytesEncoding;
	hasRequiredBytesEncoding = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(bytesEncoding, "__esModule", { value: true });
	bytesEncoding.uint8ArrayToString = uint8ArrayToString;
	bytesEncoding.stringToUint8Array = stringToUint8Array;
	/**
	 * The helper that transforms bytes with specific character encoding into string
	 * @param bytes - the uint8array bytes
	 * @param format - the format we use to encode the byte
	 * @returns a string of the encoded string
	 */
	function uint8ArrayToString(bytes, format) {
	    return Buffer.from(bytes).toString(format);
	}
	/**
	 * The helper that transforms string to specific character encoded bytes array.
	 * @param value - the string to be converted
	 * @param format - the format we use to decode the value
	 * @returns a uint8array
	 */
	function stringToUint8Array(value, format) {
	    return Buffer.from(value, format);
	}
	
	return bytesEncoding;
}

var sanitizer = {};

var hasRequiredSanitizer;

function requireSanitizer () {
	if (hasRequiredSanitizer) return sanitizer;
	hasRequiredSanitizer = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(sanitizer, "__esModule", { value: true });
	sanitizer.Sanitizer = void 0;
	const object_js_1 = requireObject();
	const RedactedString = "REDACTED";
	// Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts
	const defaultAllowedHeaderNames = [
	    "x-ms-client-request-id",
	    "x-ms-return-client-request-id",
	    "x-ms-useragent",
	    "x-ms-correlation-request-id",
	    "x-ms-request-id",
	    "client-request-id",
	    "ms-cv",
	    "return-client-request-id",
	    "traceparent",
	    "Access-Control-Allow-Credentials",
	    "Access-Control-Allow-Headers",
	    "Access-Control-Allow-Methods",
	    "Access-Control-Allow-Origin",
	    "Access-Control-Expose-Headers",
	    "Access-Control-Max-Age",
	    "Access-Control-Request-Headers",
	    "Access-Control-Request-Method",
	    "Origin",
	    "Accept",
	    "Accept-Encoding",
	    "Cache-Control",
	    "Connection",
	    "Content-Length",
	    "Content-Type",
	    "Date",
	    "ETag",
	    "Expires",
	    "If-Match",
	    "If-Modified-Since",
	    "If-None-Match",
	    "If-Unmodified-Since",
	    "Last-Modified",
	    "Pragma",
	    "Request-Id",
	    "Retry-After",
	    "Server",
	    "Transfer-Encoding",
	    "User-Agent",
	    "WWW-Authenticate",
	];
	const defaultAllowedQueryParameters = ["api-version"];
	/**
	 * A utility class to sanitize objects for logging.
	 */
	class Sanitizer {
	    allowedHeaderNames;
	    allowedQueryParameters;
	    constructor({ additionalAllowedHeaderNames: allowedHeaderNames = [], additionalAllowedQueryParameters: allowedQueryParameters = [], } = {}) {
	        allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);
	        allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);
	        this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));
	        this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));
	    }
	    /**
	     * Sanitizes an object for logging.
	     * @param obj - The object to sanitize
	     * @returns - The sanitized object as a string
	     */
	    sanitize(obj) {
	        const seen = new Set();
	        return JSON.stringify(obj, (key, value) => {
	            // Ensure Errors include their interesting non-enumerable members
	            if (value instanceof Error) {
	                return {
	                    ...value,
	                    name: value.name,
	                    message: value.message,
	                };
	            }
	            if (key === "headers") {
	                return this.sanitizeHeaders(value);
	            }
	            else if (key === "url") {
	                return this.sanitizeUrl(value);
	            }
	            else if (key === "query") {
	                return this.sanitizeQuery(value);
	            }
	            else if (key === "body") {
	                // Don't log the request body
	                return undefined;
	            }
	            else if (key === "response") {
	                // Don't log response again
	                return undefined;
	            }
	            else if (key === "operationSpec") {
	                // When using sendOperationRequest, the request carries a massive
	                // field with the autorest spec. No need to log it.
	                return undefined;
	            }
	            else if (Array.isArray(value) || (0, object_js_1.isObject)(value)) {
	                if (seen.has(value)) {
	                    return "[Circular]";
	                }
	                seen.add(value);
	            }
	            return value;
	        }, 2);
	    }
	    /**
	     * Sanitizes a URL for logging.
	     * @param value - The URL to sanitize
	     * @returns - The sanitized URL as a string
	     */
	    sanitizeUrl(value) {
	        if (typeof value !== "string" || value === null || value === "") {
	            return value;
	        }
	        const url = new URL(value);
	        if (!url.search) {
	            return value;
	        }
	        for (const [key] of url.searchParams) {
	            if (!this.allowedQueryParameters.has(key.toLowerCase())) {
	                url.searchParams.set(key, RedactedString);
	            }
	        }
	        return url.toString();
	    }
	    sanitizeHeaders(obj) {
	        const sanitized = {};
	        for (const key of Object.keys(obj)) {
	            if (this.allowedHeaderNames.has(key.toLowerCase())) {
	                sanitized[key] = obj[key];
	            }
	            else {
	                sanitized[key] = RedactedString;
	            }
	        }
	        return sanitized;
	    }
	    sanitizeQuery(value) {
	        if (typeof value !== "object" || value === null) {
	            return value;
	        }
	        const sanitized = {};
	        for (const k of Object.keys(value)) {
	            if (this.allowedQueryParameters.has(k.toLowerCase())) {
	                sanitized[k] = value[k];
	            }
	            else {
	                sanitized[k] = RedactedString;
	            }
	        }
	        return sanitized;
	    }
	}
	sanitizer.Sanitizer = Sanitizer;
	
	return sanitizer;
}

var hasRequiredInternal$2;

function requireInternal$2 () {
	if (hasRequiredInternal$2) return internal$2;
	hasRequiredInternal$2 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.Sanitizer = exports$1.uint8ArrayToString = exports$1.stringToUint8Array = exports$1.isWebWorker = exports$1.isReactNative = exports$1.isDeno = exports$1.isNodeRuntime = exports$1.isNodeLike = exports$1.isBun = exports$1.isBrowser = exports$1.randomUUID = exports$1.computeSha256Hmac = exports$1.computeSha256Hash = exports$1.isError = exports$1.isObject = exports$1.getRandomIntegerInclusive = exports$1.calculateRetryDelay = void 0;
		var delay_js_1 = requireDelay$1();
		Object.defineProperty(exports$1, "calculateRetryDelay", { enumerable: true, get: function () { return delay_js_1.calculateRetryDelay; } });
		var random_js_1 = requireRandom();
		Object.defineProperty(exports$1, "getRandomIntegerInclusive", { enumerable: true, get: function () { return random_js_1.getRandomIntegerInclusive; } });
		var object_js_1 = requireObject();
		Object.defineProperty(exports$1, "isObject", { enumerable: true, get: function () { return object_js_1.isObject; } });
		var error_js_1 = requireError$1();
		Object.defineProperty(exports$1, "isError", { enumerable: true, get: function () { return error_js_1.isError; } });
		var sha256_js_1 = requireSha256();
		Object.defineProperty(exports$1, "computeSha256Hash", { enumerable: true, get: function () { return sha256_js_1.computeSha256Hash; } });
		Object.defineProperty(exports$1, "computeSha256Hmac", { enumerable: true, get: function () { return sha256_js_1.computeSha256Hmac; } });
		var uuidUtils_js_1 = requireUuidUtils();
		Object.defineProperty(exports$1, "randomUUID", { enumerable: true, get: function () { return uuidUtils_js_1.randomUUID; } });
		var checkEnvironment_js_1 = requireCheckEnvironment();
		Object.defineProperty(exports$1, "isBrowser", { enumerable: true, get: function () { return checkEnvironment_js_1.isBrowser; } });
		Object.defineProperty(exports$1, "isBun", { enumerable: true, get: function () { return checkEnvironment_js_1.isBun; } });
		Object.defineProperty(exports$1, "isNodeLike", { enumerable: true, get: function () { return checkEnvironment_js_1.isNodeLike; } });
		Object.defineProperty(exports$1, "isNodeRuntime", { enumerable: true, get: function () { return checkEnvironment_js_1.isNodeRuntime; } });
		Object.defineProperty(exports$1, "isDeno", { enumerable: true, get: function () { return checkEnvironment_js_1.isDeno; } });
		Object.defineProperty(exports$1, "isReactNative", { enumerable: true, get: function () { return checkEnvironment_js_1.isReactNative; } });
		Object.defineProperty(exports$1, "isWebWorker", { enumerable: true, get: function () { return checkEnvironment_js_1.isWebWorker; } });
		var bytesEncoding_js_1 = requireBytesEncoding();
		Object.defineProperty(exports$1, "stringToUint8Array", { enumerable: true, get: function () { return bytesEncoding_js_1.stringToUint8Array; } });
		Object.defineProperty(exports$1, "uint8ArrayToString", { enumerable: true, get: function () { return bytesEncoding_js_1.uint8ArrayToString; } });
		var sanitizer_js_1 = requireSanitizer();
		Object.defineProperty(exports$1, "Sanitizer", { enumerable: true, get: function () { return sanitizer_js_1.Sanitizer; } });
		
	} (internal$2));
	return internal$2;
}

var aborterUtils = {};

var hasRequiredAborterUtils;

function requireAborterUtils () {
	if (hasRequiredAborterUtils) return aborterUtils;
	hasRequiredAborterUtils = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(aborterUtils, "__esModule", { value: true });
	aborterUtils.cancelablePromiseRace = cancelablePromiseRace;
	/**
	 * promise.race() wrapper that aborts rest of promises as soon as the first promise settles.
	 */
	async function cancelablePromiseRace(abortablePromiseBuilders, options) {
	    const aborter = new AbortController();
	    function abortHandler() {
	        aborter.abort();
	    }
	    options?.abortSignal?.addEventListener("abort", abortHandler);
	    try {
	        return await Promise.race(abortablePromiseBuilders.map((p) => p({ abortSignal: aborter.signal })));
	    }
	    finally {
	        aborter.abort();
	        options?.abortSignal?.removeEventListener("abort", abortHandler);
	    }
	}
	
	return aborterUtils;
}

var createAbortablePromise = {};

var commonjs$4 = {};

var AbortError$1 = {};

var hasRequiredAbortError$2;

function requireAbortError$2 () {
	if (hasRequiredAbortError$2) return AbortError$1;
	hasRequiredAbortError$2 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT license.
	Object.defineProperty(AbortError$1, "__esModule", { value: true });
	AbortError$1.AbortError = void 0;
	/**
	 * This error is thrown when an asynchronous operation has been aborted.
	 * Check for this error by testing the `name` that the name property of the
	 * error matches `"AbortError"`.
	 *
	 * @example
	 * ```ts
	 * const controller = new AbortController();
	 * controller.abort();
	 * try {
	 *   doAsyncWork(controller.signal)
	 * } catch (e) {
	 *   if (e.name === 'AbortError') {
	 *     // handle abort error here.
	 *   }
	 * }
	 * ```
	 */
	class AbortError extends Error {
	    constructor(message) {
	        super(message);
	        this.name = "AbortError";
	    }
	}
	AbortError$1.AbortError = AbortError;
	
	return AbortError$1;
}

var hasRequiredCommonjs$6;

function requireCommonjs$6 () {
	if (hasRequiredCommonjs$6) return commonjs$4;
	hasRequiredCommonjs$6 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT license.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.AbortError = void 0;
		var AbortError_js_1 = requireAbortError$2();
		Object.defineProperty(exports$1, "AbortError", { enumerable: true, get: function () { return AbortError_js_1.AbortError; } });
		
	} (commonjs$4));
	return commonjs$4;
}

var hasRequiredCreateAbortablePromise;

function requireCreateAbortablePromise () {
	if (hasRequiredCreateAbortablePromise) return createAbortablePromise;
	hasRequiredCreateAbortablePromise = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(createAbortablePromise, "__esModule", { value: true });
	createAbortablePromise.createAbortablePromise = createAbortablePromise$1;
	const abort_controller_1 = /*@__PURE__*/ requireCommonjs$6();
	/**
	 * Creates an abortable promise.
	 * @param buildPromise - A function that takes the resolve and reject functions as parameters.
	 * @param options - The options for the abortable promise.
	 * @returns A promise that can be aborted.
	 */
	function createAbortablePromise$1(buildPromise, options) {
	    const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options ?? {};
	    return new Promise((resolve, reject) => {
	        function rejectOnAbort() {
	            reject(new abort_controller_1.AbortError(abortErrorMsg ?? "The operation was aborted."));
	        }
	        function removeListeners() {
	            abortSignal?.removeEventListener("abort", onAbort);
	        }
	        function onAbort() {
	            cleanupBeforeAbort?.();
	            removeListeners();
	            rejectOnAbort();
	        }
	        if (abortSignal?.aborted) {
	            return rejectOnAbort();
	        }
	        try {
	            buildPromise((x) => {
	                removeListeners();
	                resolve(x);
	            }, (x) => {
	                removeListeners();
	                reject(x);
	            });
	        }
	        catch (err) {
	            reject(err);
	        }
	        abortSignal?.addEventListener("abort", onAbort);
	    });
	}
	
	return createAbortablePromise;
}

var delay = {};

var hasRequiredDelay;

function requireDelay () {
	if (hasRequiredDelay) return delay;
	hasRequiredDelay = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(delay, "__esModule", { value: true });
	delay.delay = delay$1;
	delay.calculateRetryDelay = calculateRetryDelay;
	const createAbortablePromise_js_1 = requireCreateAbortablePromise();
	const util_1 = /*@__PURE__*/ requireInternal$2();
	const StandardAbortMessage = "The delay was aborted.";
	/**
	 * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.
	 * @param timeInMs - The number of milliseconds to be delayed.
	 * @param options - The options for delay - currently abort options
	 * @returns Promise that is resolved after timeInMs
	 */
	function delay$1(timeInMs, options) {
	    let token;
	    const { abortSignal, abortErrorMsg } = options ?? {};
	    return (0, createAbortablePromise_js_1.createAbortablePromise)((resolve) => {
	        token = setTimeout(resolve, timeInMs);
	    }, {
	        cleanupBeforeAbort: () => clearTimeout(token),
	        abortSignal,
	        abortErrorMsg: abortErrorMsg ?? StandardAbortMessage,
	    });
	}
	/**
	 * Calculates the delay interval for retry attempts using exponential delay with jitter.
	 * @param retryAttempt - The current retry attempt number.
	 * @param config - The exponential retry configuration.
	 * @returns An object containing the calculated retry delay.
	 */
	function calculateRetryDelay(retryAttempt, config) {
	    // Exponentially increase the delay each time
	    const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
	    // Don't let the delay exceed the maximum
	    const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
	    // Allow the final value to have some "jitter" (within 50% of the delay size) so
	    // that retries across multiple clients don't occur simultaneously.
	    const retryAfterInMs = clampedDelay / 2 + (0, util_1.getRandomIntegerInclusive)(0, clampedDelay / 2);
	    return { retryAfterInMs };
	}
	
	return delay;
}

var error = {};

var hasRequiredError;

function requireError () {
	if (hasRequiredError) return error;
	hasRequiredError = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(error, "__esModule", { value: true });
	error.getErrorMessage = getErrorMessage;
	const util_1 = /*@__PURE__*/ requireInternal$2();
	/**
	 * Given what is thought to be an error object, return the message if possible.
	 * If the message is missing, returns a stringified version of the input.
	 * @param e - Something thrown from a try block
	 * @returns The error message or a string of the input
	 */
	function getErrorMessage(e) {
	    if ((0, util_1.isError)(e)) {
	        return e.message;
	    }
	    else {
	        let stringified;
	        try {
	            if (typeof e === "object" && e) {
	                stringified = JSON.stringify(e);
	            }
	            else {
	                stringified = String(e);
	            }
	        }
	        catch (err) {
	            stringified = "[unable to stringify input]";
	        }
	        return `Unknown error ${stringified}`;
	    }
	}
	
	return error;
}

var typeGuards$1 = {};

var hasRequiredTypeGuards$1;

function requireTypeGuards$1 () {
	if (hasRequiredTypeGuards$1) return typeGuards$1;
	hasRequiredTypeGuards$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(typeGuards$1, "__esModule", { value: true });
	typeGuards$1.isDefined = isDefined;
	typeGuards$1.isObjectWithProperties = isObjectWithProperties;
	typeGuards$1.objectHasProperty = objectHasProperty;
	/**
	 * Helper TypeGuard that checks if something is defined or not.
	 * @param thing - Anything
	 */
	function isDefined(thing) {
	    return typeof thing !== "undefined" && thing !== null;
	}
	/**
	 * Helper TypeGuard that checks if the input is an object with the specified properties.
	 * @param thing - Anything.
	 * @param properties - The name of the properties that should appear in the object.
	 */
	function isObjectWithProperties(thing, properties) {
	    if (!isDefined(thing) || typeof thing !== "object") {
	        return false;
	    }
	    for (const property of properties) {
	        if (!objectHasProperty(thing, property)) {
	            return false;
	        }
	    }
	    return true;
	}
	/**
	 * Helper TypeGuard that checks if the input is an object with the specified property.
	 * @param thing - Any object.
	 * @param property - The name of the property that should appear in the object.
	 */
	function objectHasProperty(thing, property) {
	    return (isDefined(thing) && typeof thing === "object" && property in thing);
	}
	
	return typeGuards$1;
}

var hasRequiredCommonjs$5;

function requireCommonjs$5 () {
	if (hasRequiredCommonjs$5) return commonjs$5;
	hasRequiredCommonjs$5 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.isWebWorker = exports$1.isReactNative = exports$1.isNodeRuntime = exports$1.isNodeLike = exports$1.isNode = exports$1.isDeno = exports$1.isBun = exports$1.isBrowser = exports$1.objectHasProperty = exports$1.isObjectWithProperties = exports$1.isDefined = exports$1.getErrorMessage = exports$1.delay = exports$1.createAbortablePromise = exports$1.cancelablePromiseRace = void 0;
		exports$1.calculateRetryDelay = calculateRetryDelay;
		exports$1.computeSha256Hash = computeSha256Hash;
		exports$1.computeSha256Hmac = computeSha256Hmac;
		exports$1.getRandomIntegerInclusive = getRandomIntegerInclusive;
		exports$1.isError = isError;
		exports$1.isObject = isObject;
		exports$1.randomUUID = randomUUID;
		exports$1.uint8ArrayToString = uint8ArrayToString;
		exports$1.stringToUint8Array = stringToUint8Array;
		const tslib_1 = require$$0$3;
		const tspRuntime = tslib_1.__importStar(/*@__PURE__*/ requireInternal$2());
		var aborterUtils_js_1 = requireAborterUtils();
		Object.defineProperty(exports$1, "cancelablePromiseRace", { enumerable: true, get: function () { return aborterUtils_js_1.cancelablePromiseRace; } });
		var createAbortablePromise_js_1 = requireCreateAbortablePromise();
		Object.defineProperty(exports$1, "createAbortablePromise", { enumerable: true, get: function () { return createAbortablePromise_js_1.createAbortablePromise; } });
		var delay_js_1 = requireDelay();
		Object.defineProperty(exports$1, "delay", { enumerable: true, get: function () { return delay_js_1.delay; } });
		var error_js_1 = requireError();
		Object.defineProperty(exports$1, "getErrorMessage", { enumerable: true, get: function () { return error_js_1.getErrorMessage; } });
		var typeGuards_js_1 = requireTypeGuards$1();
		Object.defineProperty(exports$1, "isDefined", { enumerable: true, get: function () { return typeGuards_js_1.isDefined; } });
		Object.defineProperty(exports$1, "isObjectWithProperties", { enumerable: true, get: function () { return typeGuards_js_1.isObjectWithProperties; } });
		Object.defineProperty(exports$1, "objectHasProperty", { enumerable: true, get: function () { return typeGuards_js_1.objectHasProperty; } });
		/**
		 * Calculates the delay interval for retry attempts using exponential delay with jitter.
		 *
		 * @param retryAttempt - The current retry attempt number.
		 *
		 * @param config - The exponential retry configuration.
		 *
		 * @returns An object containing the calculated retry delay.
		 */
		function calculateRetryDelay(retryAttempt, config) {
		    return tspRuntime.calculateRetryDelay(retryAttempt, config);
		}
		/**
		 * Generates a SHA-256 hash.
		 *
		 * @param content - The data to be included in the hash.
		 *
		 * @param encoding - The textual encoding to use for the returned hash.
		 */
		function computeSha256Hash(content, encoding) {
		    return tspRuntime.computeSha256Hash(content, encoding);
		}
		/**
		 * Generates a SHA-256 HMAC signature.
		 *
		 * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
		 *
		 * @param stringToSign - The data to be signed.
		 *
		 * @param encoding - The textual encoding to use for the returned HMAC digest.
		 */
		function computeSha256Hmac(key, stringToSign, encoding) {
		    return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);
		}
		/**
		 * Returns a random integer value between a lower and upper bound, inclusive of both bounds. Note that this uses Math.random and isn't secure. If you need to use this for any kind of security purpose, find a better source of random.
		 *
		 * @param min - The smallest integer value allowed.
		 *
		 * @param max - The largest integer value allowed.
		 */
		function getRandomIntegerInclusive(min, max) {
		    return tspRuntime.getRandomIntegerInclusive(min, max);
		}
		/**
		 * Typeguard for an error object shape (has name and message)
		 *
		 * @param e - Something caught by a catch clause.
		 */
		function isError(e) {
		    return tspRuntime.isError(e);
		}
		/**
		 * Helper to determine when an input is a generic JS object.
		 *
		 * @returns true when input is an object type that is not null, Array, RegExp, or Date.
		 */
		function isObject(input) {
		    return tspRuntime.isObject(input);
		}
		/**
		 * Generated Universally Unique Identifier
		 *
		 * @returns RFC4122 v4 UUID.
		 */
		function randomUUID() {
		    return tspRuntime.randomUUID();
		}
		/**
		 * A constant that indicates whether the environment the code is running is a Web Browser.
		 */
		exports$1.isBrowser = tspRuntime.isBrowser;
		/**
		 * A constant that indicates whether the environment the code is running is Bun.sh.
		 */
		exports$1.isBun = tspRuntime.isBun;
		/**
		 * A constant that indicates whether the environment the code is running is Deno.
		 */
		exports$1.isDeno = tspRuntime.isDeno;
		/**
		 * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
		 *
		 * @deprecated
		 *
		 * Use `isNodeLike` instead.
		 */
		exports$1.isNode = tspRuntime.isNodeLike;
		/**
		 * A constant that indicates whether the environment the code is running is a Node.js compatible environment.
		 */
		exports$1.isNodeLike = tspRuntime.isNodeLike;
		/**
		 * A constant that indicates whether the environment the code is running is Node.JS.
		 */
		exports$1.isNodeRuntime = tspRuntime.isNodeRuntime;
		/**
		 * A constant that indicates whether the environment the code is running is in React-Native.
		 */
		exports$1.isReactNative = tspRuntime.isReactNative;
		/**
		 * A constant that indicates whether the environment the code is running is a Web Worker.
		 */
		exports$1.isWebWorker = tspRuntime.isWebWorker;
		/**
		 * The helper that transforms bytes with specific character encoding into string
		 * @param bytes - the uint8array bytes
		 * @param format - the format we use to encode the byte
		 * @returns a string of the encoded string
		 */
		function uint8ArrayToString(bytes, format) {
		    return tspRuntime.uint8ArrayToString(bytes, format);
		}
		/**
		 * The helper that transforms string to specific character encoded bytes array.
		 * @param value - the string to be converted
		 * @param format - the format we use to decode the value
		 * @returns a uint8array
		 */
		function stringToUint8Array(value, format) {
		    return tspRuntime.stringToUint8Array(value, format);
		}
		
	} (commonjs$5));
	return commonjs$5;
}

var msal = {};

var hasRequiredMsal;

function requireMsal () {
	if (hasRequiredMsal) return msal;
	hasRequiredMsal = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(msal, "__esModule", { value: true });
	msal.msalCommon = void 0;
	const tslib_1 = require$$0$3;
	const msalCommon = tslib_1.__importStar(requireMsalNode());
	msal.msalCommon = msalCommon;
	
	return msal;
}

var hasRequiredUtils$3;

function requireUtils$3 () {
	if (hasRequiredUtils$3) return utils$3;
	hasRequiredUtils$3 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(utils$3, "__esModule", { value: true });
	utils$3.defaultLoggerCallback = void 0;
	utils$3.ensureValidMsalToken = ensureValidMsalToken;
	utils$3.getAuthorityHost = getAuthorityHost;
	utils$3.getAuthority = getAuthority;
	utils$3.getKnownAuthorities = getKnownAuthorities;
	utils$3.getMSALLogLevel = getMSALLogLevel;
	utils$3.randomUUID = randomUUID;
	utils$3.handleMsalError = handleMsalError;
	utils$3.publicToMsal = publicToMsal;
	utils$3.msalToPublic = msalToPublic;
	utils$3.serializeAuthenticationRecord = serializeAuthenticationRecord;
	utils$3.deserializeAuthenticationRecord = deserializeAuthenticationRecord;
	const errors_js_1 = requireErrors$2();
	const logging_js_1 = requireLogging();
	const constants_js_1 = requireConstants$3();
	const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
	const abort_controller_1 = /*@__PURE__*/ requireCommonjs$6();
	const msal_js_1 = requireMsal();
	const logger = (0, logging_js_1.credentialLogger)("IdentityUtils");
	/**
	 * Latest AuthenticationRecord version
	 */
	const LatestAuthenticationRecordVersion = "1.0";
	/**
	 * Ensures the validity of the MSAL token
	 * @internal
	 */
	function ensureValidMsalToken(scopes, msalToken, getTokenOptions) {
	    const error = (message) => {
	        logger.getToken.info(message);
	        return new errors_js_1.AuthenticationRequiredError({
	            scopes: Array.isArray(scopes) ? scopes : [scopes],
	            getTokenOptions,
	            message,
	        });
	    };
	    if (!msalToken) {
	        throw error("No response");
	    }
	    if (!msalToken.expiresOn) {
	        throw error(`Response had no "expiresOn" property.`);
	    }
	    if (!msalToken.accessToken) {
	        throw error(`Response had no "accessToken" property.`);
	    }
	}
	/**
	 * Returns the authority host from either the options bag or the AZURE_AUTHORITY_HOST environment variable.
	 *
	 * Defaults to {@link DefaultAuthorityHost}.
	 * @internal
	 */
	function getAuthorityHost(options) {
	    let authorityHost = options?.authorityHost;
	    if (!authorityHost && core_util_1.isNodeLike) {
	        authorityHost = process.env.AZURE_AUTHORITY_HOST;
	    }
	    return authorityHost ?? constants_js_1.DefaultAuthorityHost;
	}
	/**
	 * Generates a valid authority by combining a host with a tenantId.
	 * @internal
	 */
	function getAuthority(tenantId, host) {
	    if (!host) {
	        host = constants_js_1.DefaultAuthorityHost;
	    }
	    if (new RegExp(`${tenantId}/?$`).test(host)) {
	        return host;
	    }
	    if (host.endsWith("/")) {
	        return host + tenantId;
	    }
	    else {
	        return `${host}/${tenantId}`;
	    }
	}
	/**
	 * Generates the known authorities.
	 * If the Tenant Id is `adfs`, the authority can't be validated since the format won't match the expected one.
	 * For that reason, we have to force MSAL to disable validating the authority
	 * by sending it within the known authorities in the MSAL configuration.
	 * @internal
	 */
	function getKnownAuthorities(tenantId, authorityHost, disableInstanceDiscovery) {
	    if ((tenantId === "adfs" && authorityHost) || disableInstanceDiscovery) {
	        return [authorityHost];
	    }
	    return [];
	}
	/**
	 * Generates a logger that can be passed to the MSAL clients.
	 * @param credLogger - The logger of the credential.
	 * @internal
	 */
	const defaultLoggerCallback = (credLogger, platform = core_util_1.isNode ? "Node" : "Browser") => (level, message, containsPii) => {
	    if (containsPii) {
	        return;
	    }
	    switch (level) {
	        case msal_js_1.msalCommon.LogLevel.Error:
	            credLogger.info(`MSAL ${platform} V2 error: ${message}`);
	            return;
	        case msal_js_1.msalCommon.LogLevel.Info:
	            credLogger.info(`MSAL ${platform} V2 info message: ${message}`);
	            return;
	        case msal_js_1.msalCommon.LogLevel.Verbose:
	            credLogger.info(`MSAL ${platform} V2 verbose message: ${message}`);
	            return;
	        case msal_js_1.msalCommon.LogLevel.Warning:
	            credLogger.info(`MSAL ${platform} V2 warning: ${message}`);
	            return;
	    }
	};
	utils$3.defaultLoggerCallback = defaultLoggerCallback;
	/**
	 * @internal
	 */
	function getMSALLogLevel(logLevel) {
	    switch (logLevel) {
	        case "error":
	            return msal_js_1.msalCommon.LogLevel.Error;
	        case "info":
	            return msal_js_1.msalCommon.LogLevel.Info;
	        case "verbose":
	            return msal_js_1.msalCommon.LogLevel.Verbose;
	        case "warning":
	            return msal_js_1.msalCommon.LogLevel.Warning;
	        default:
	            // default msal logging level should be Info
	            return msal_js_1.msalCommon.LogLevel.Info;
	    }
	}
	/**
	 * Wraps core-util's randomUUID in order to allow for mocking in tests.
	 * This prepares the library for the upcoming core-util update to ESM.
	 *
	 * @internal
	 * @returns A string containing a random UUID
	 */
	function randomUUID() {
	    return (0, core_util_1.randomUUID)();
	}
	/**
	 * Handles MSAL errors.
	 */
	function handleMsalError(scopes, error, getTokenOptions) {
	    if (error.name === "AuthError" ||
	        error.name === "ClientAuthError" ||
	        error.name === "BrowserAuthError") {
	        const msalError = error;
	        switch (msalError.errorCode) {
	            case "endpoints_resolution_error":
	                logger.info((0, logging_js_1.formatError)(scopes, error.message));
	                return new errors_js_1.CredentialUnavailableError(error.message);
	            case "device_code_polling_cancelled":
	                return new abort_controller_1.AbortError("The authentication has been aborted by the caller.");
	            case "consent_required":
	            case "interaction_required":
	            case "login_required":
	                logger.info((0, logging_js_1.formatError)(scopes, `Authentication returned errorCode ${msalError.errorCode}`));
	                break;
	            default:
	                logger.info((0, logging_js_1.formatError)(scopes, `Failed to acquire token: ${error.message}`));
	                break;
	        }
	    }
	    if (error.name === "ClientConfigurationError" ||
	        error.name === "BrowserConfigurationAuthError" ||
	        error.name === "AbortError" ||
	        error.name === "AuthenticationError") {
	        return error;
	    }
	    if (error.name === "NativeAuthError") {
	        logger.info((0, logging_js_1.formatError)(scopes, `Error from the native broker: ${error.message} with status code: ${error.statusCode}`));
	        return error;
	    }
	    return new errors_js_1.AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });
	}
	// transformations
	function publicToMsal(account) {
	    return {
	        localAccountId: account.homeAccountId,
	        environment: account.authority,
	        username: account.username,
	        homeAccountId: account.homeAccountId,
	        tenantId: account.tenantId,
	    };
	}
	function msalToPublic(clientId, account) {
	    const record = {
	        authority: account.environment ?? constants_js_1.DefaultAuthority,
	        homeAccountId: account.homeAccountId,
	        tenantId: account.tenantId || constants_js_1.DefaultTenantId,
	        username: account.username,
	        clientId,
	        version: LatestAuthenticationRecordVersion,
	    };
	    return record;
	}
	/**
	 * Serializes an `AuthenticationRecord` into a string.
	 *
	 * The output of a serialized authentication record will contain the following properties:
	 *
	 * - "authority"
	 * - "homeAccountId"
	 * - "clientId"
	 * - "tenantId"
	 * - "username"
	 * - "version"
	 *
	 * To later convert this string to a serialized `AuthenticationRecord`, please use the exported function `deserializeAuthenticationRecord()`.
	 */
	function serializeAuthenticationRecord(record) {
	    return JSON.stringify(record);
	}
	/**
	 * Deserializes a previously serialized authentication record from a string into an object.
	 *
	 * The input string must contain the following properties:
	 *
	 * - "authority"
	 * - "homeAccountId"
	 * - "clientId"
	 * - "tenantId"
	 * - "username"
	 * - "version"
	 *
	 * If the version we receive is unsupported, an error will be thrown.
	 *
	 * At the moment, the only available version is: "1.0", which is always set when the authentication record is serialized.
	 *
	 * @param serializedRecord - Authentication record previously serialized into string.
	 * @returns AuthenticationRecord.
	 */
	function deserializeAuthenticationRecord(serializedRecord) {
	    const parsed = JSON.parse(serializedRecord);
	    if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {
	        throw Error("Unsupported AuthenticationRecord version");
	    }
	    return parsed;
	}
	
	return utils$3;
}

var identityClient = {};

var commonjs$3 = {};

var serializer = {};

var base64 = {};

var hasRequiredBase64;

function requireBase64 () {
	if (hasRequiredBase64) return base64;
	hasRequiredBase64 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(base64, "__esModule", { value: true });
	base64.encodeString = encodeString;
	base64.encodeByteArray = encodeByteArray;
	base64.decodeString = decodeString;
	base64.decodeStringToString = decodeStringToString;
	/**
	 * Encodes a string in base64 format.
	 * @param value - the string to encode
	 * @internal
	 */
	function encodeString(value) {
	    return Buffer.from(value).toString("base64");
	}
	/**
	 * Encodes a byte array in base64 format.
	 * @param value - the Uint8Aray to encode
	 * @internal
	 */
	function encodeByteArray(value) {
	    const bufferValue = value instanceof Buffer ? value : Buffer.from(value.buffer);
	    return bufferValue.toString("base64");
	}
	/**
	 * Decodes a base64 string into a byte array.
	 * @param value - the base64 string to decode
	 * @internal
	 */
	function decodeString(value) {
	    return Buffer.from(value, "base64");
	}
	/**
	 * Decodes a base64 string into a string.
	 * @param value - the base64 string to decode
	 * @internal
	 */
	function decodeStringToString(value) {
	    return Buffer.from(value, "base64").toString();
	}
	
	return base64;
}

var interfaces = {};

var hasRequiredInterfaces;

function requireInterfaces () {
	if (hasRequiredInterfaces) return interfaces;
	hasRequiredInterfaces = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(interfaces, "__esModule", { value: true });
	interfaces.XML_CHARKEY = interfaces.XML_ATTRKEY = void 0;
	/**
	 * Default key used to access the XML attributes.
	 */
	interfaces.XML_ATTRKEY = "$";
	/**
	 * Default key used to access the XML value content.
	 */
	interfaces.XML_CHARKEY = "_";
	
	return interfaces;
}

var utils$2 = {};

var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$2;
	hasRequiredUtils$2 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(utils$2, "__esModule", { value: true });
	utils$2.isPrimitiveBody = isPrimitiveBody;
	utils$2.isDuration = isDuration;
	utils$2.isValidUuid = isValidUuid;
	utils$2.flattenResponse = flattenResponse;
	/**
	 * A type guard for a primitive response body.
	 * @param value - Value to test
	 *
	 * @internal
	 */
	function isPrimitiveBody(value, mapperTypeName) {
	    return (mapperTypeName !== "Composite" &&
	        mapperTypeName !== "Dictionary" &&
	        (typeof value === "string" ||
	            typeof value === "number" ||
	            typeof value === "boolean" ||
	            mapperTypeName?.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i) !==
	                null ||
	            value === undefined ||
	            value === null));
	}
	const validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
	/**
	 * Returns true if the given string is in ISO 8601 format.
	 * @param value - The value to be validated for ISO 8601 duration format.
	 * @internal
	 */
	function isDuration(value) {
	    return validateISODuration.test(value);
	}
	const validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
	/**
	 * Returns true if the provided uuid is valid.
	 *
	 * @param uuid - The uuid that needs to be validated.
	 *
	 * @internal
	 */
	function isValidUuid(uuid) {
	    return validUuidRegex.test(uuid);
	}
	/**
	 * Maps the response as follows:
	 * - wraps the response body if needed (typically if its type is primitive).
	 * - returns null if the combination of the headers and the body is empty.
	 * - otherwise, returns the combination of the headers and the body.
	 *
	 * @param responseObject - a representation of the parsed response
	 * @returns the response that will be returned to the user which can be null and/or wrapped
	 *
	 * @internal
	 */
	function handleNullableResponseAndWrappableBody(responseObject) {
	    const combinedHeadersAndBody = {
	        ...responseObject.headers,
	        ...responseObject.body,
	    };
	    if (responseObject.hasNullableType &&
	        Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
	        return responseObject.shouldWrapBody ? { body: null } : null;
	    }
	    else {
	        return responseObject.shouldWrapBody
	            ? {
	                ...responseObject.headers,
	                body: responseObject.body,
	            }
	            : combinedHeadersAndBody;
	    }
	}
	/**
	 * Take a `FullOperationResponse` and turn it into a flat
	 * response object to hand back to the consumer.
	 * @param fullResponse - The processed response from the operation request
	 * @param responseSpec - The response map from the OperationSpec
	 *
	 * @internal
	 */
	function flattenResponse(fullResponse, responseSpec) {
	    const parsedHeaders = fullResponse.parsedHeaders;
	    // head methods never have a body, but we return a boolean set to body property
	    // to indicate presence/absence of the resource
	    if (fullResponse.request.method === "HEAD") {
	        return {
	            ...parsedHeaders,
	            body: fullResponse.parsedBody,
	        };
	    }
	    const bodyMapper = responseSpec && responseSpec.bodyMapper;
	    const isNullable = Boolean(bodyMapper?.nullable);
	    const expectedBodyTypeName = bodyMapper?.type.name;
	    /** If the body is asked for, we look at the expected body type to handle it */
	    if (expectedBodyTypeName === "Stream") {
	        return {
	            ...parsedHeaders,
	            blobBody: fullResponse.blobBody,
	            readableStreamBody: fullResponse.readableStreamBody,
	        };
	    }
	    const modelProperties = (expectedBodyTypeName === "Composite" &&
	        bodyMapper.type.modelProperties) ||
	        {};
	    const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
	    if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
	        const arrayResponse = fullResponse.parsedBody ?? [];
	        for (const key of Object.keys(modelProperties)) {
	            if (modelProperties[key].serializedName) {
	                arrayResponse[key] = fullResponse.parsedBody?.[key];
	            }
	        }
	        if (parsedHeaders) {
	            for (const key of Object.keys(parsedHeaders)) {
	                arrayResponse[key] = parsedHeaders[key];
	            }
	        }
	        return isNullable &&
	            !fullResponse.parsedBody &&
	            !parsedHeaders &&
	            Object.getOwnPropertyNames(modelProperties).length === 0
	            ? null
	            : arrayResponse;
	    }
	    return handleNullableResponseAndWrappableBody({
	        body: fullResponse.parsedBody,
	        headers: parsedHeaders,
	        hasNullableType: isNullable,
	        shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName),
	    });
	}
	
	return utils$2;
}

var hasRequiredSerializer;

function requireSerializer () {
	if (hasRequiredSerializer) return serializer;
	hasRequiredSerializer = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(serializer, "__esModule", { value: true });
	serializer.MapperTypeNames = void 0;
	serializer.createSerializer = createSerializer;
	const tslib_1 = require$$0$3;
	const base64 = tslib_1.__importStar(requireBase64());
	const interfaces_js_1 = requireInterfaces();
	const utils_js_1 = requireUtils$2();
	class SerializerImpl {
	    modelMappers;
	    isXML;
	    constructor(modelMappers = {}, isXML = false) {
	        this.modelMappers = modelMappers;
	        this.isXML = isXML;
	    }
	    /**
	     * @deprecated Removing the constraints validation on client side.
	     */
	    validateConstraints(mapper, value, objectName) {
	        const failValidation = (constraintName, constraintValue) => {
	            throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
	        };
	        if (mapper.constraints && value !== undefined && value !== null) {
	            const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems, } = mapper.constraints;
	            if (ExclusiveMaximum !== undefined && value >= ExclusiveMaximum) {
	                failValidation("ExclusiveMaximum", ExclusiveMaximum);
	            }
	            if (ExclusiveMinimum !== undefined && value <= ExclusiveMinimum) {
	                failValidation("ExclusiveMinimum", ExclusiveMinimum);
	            }
	            if (InclusiveMaximum !== undefined && value > InclusiveMaximum) {
	                failValidation("InclusiveMaximum", InclusiveMaximum);
	            }
	            if (InclusiveMinimum !== undefined && value < InclusiveMinimum) {
	                failValidation("InclusiveMinimum", InclusiveMinimum);
	            }
	            if (MaxItems !== undefined && value.length > MaxItems) {
	                failValidation("MaxItems", MaxItems);
	            }
	            if (MaxLength !== undefined && value.length > MaxLength) {
	                failValidation("MaxLength", MaxLength);
	            }
	            if (MinItems !== undefined && value.length < MinItems) {
	                failValidation("MinItems", MinItems);
	            }
	            if (MinLength !== undefined && value.length < MinLength) {
	                failValidation("MinLength", MinLength);
	            }
	            if (MultipleOf !== undefined && value % MultipleOf !== 0) {
	                failValidation("MultipleOf", MultipleOf);
	            }
	            if (Pattern) {
	                const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
	                if (typeof value !== "string" || value.match(pattern) === null) {
	                    failValidation("Pattern", Pattern);
	                }
	            }
	            if (UniqueItems &&
	                value.some((item, i, ar) => ar.indexOf(item) !== i)) {
	                failValidation("UniqueItems", UniqueItems);
	            }
	        }
	    }
	    /**
	     * Serialize the given object based on its metadata defined in the mapper
	     *
	     * @param mapper - The mapper which defines the metadata of the serializable object
	     *
	     * @param object - A valid Javascript object to be serialized
	     *
	     * @param objectName - Name of the serialized object
	     *
	     * @param options - additional options to serialization
	     *
	     * @returns A valid serialized Javascript object
	     */
	    serialize(mapper, object, objectName, options = { xml: {} }) {
	        const updatedOptions = {
	            xml: {
	                rootName: options.xml.rootName ?? "",
	                includeRoot: options.xml.includeRoot ?? false,
	                xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY,
	            },
	        };
	        let payload = {};
	        const mapperType = mapper.type.name;
	        if (!objectName) {
	            objectName = mapper.serializedName;
	        }
	        if (mapperType.match(/^Sequence$/i) !== null) {
	            payload = [];
	        }
	        if (mapper.isConstant) {
	            object = mapper.defaultValue;
	        }
	        // This table of allowed values should help explain
	        // the mapper.required and mapper.nullable properties.
	        // X means "neither undefined or null are allowed".
	        //           || required
	        //           || true      | false
	        //  nullable || ==========================
	        //      true || null      | undefined/null
	        //     false || X         | undefined
	        // undefined || X         | undefined/null
	        const { required, nullable } = mapper;
	        if (required && nullable && object === undefined) {
	            throw new Error(`${objectName} cannot be undefined.`);
	        }
	        if (required && !nullable && (object === undefined || object === null)) {
	            throw new Error(`${objectName} cannot be null or undefined.`);
	        }
	        if (!required && nullable === false && object === null) {
	            throw new Error(`${objectName} cannot be null.`);
	        }
	        if (object === undefined || object === null) {
	            payload = object;
	        }
	        else {
	            if (mapperType.match(/^any$/i) !== null) {
	                payload = object;
	            }
	            else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
	                payload = serializeBasicTypes(mapperType, objectName, object);
	            }
	            else if (mapperType.match(/^Enum$/i) !== null) {
	                const enumMapper = mapper;
	                payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
	            }
	            else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
	                payload = serializeDateTypes(mapperType, object, objectName);
	            }
	            else if (mapperType.match(/^ByteArray$/i) !== null) {
	                payload = serializeByteArrayType(objectName, object);
	            }
	            else if (mapperType.match(/^Base64Url$/i) !== null) {
	                payload = serializeBase64UrlType(objectName, object);
	            }
	            else if (mapperType.match(/^Sequence$/i) !== null) {
	                payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
	            }
	            else if (mapperType.match(/^Dictionary$/i) !== null) {
	                payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
	            }
	            else if (mapperType.match(/^Composite$/i) !== null) {
	                payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
	            }
	        }
	        return payload;
	    }
	    /**
	     * Deserialize the given object based on its metadata defined in the mapper
	     *
	     * @param mapper - The mapper which defines the metadata of the serializable object
	     *
	     * @param responseBody - A valid Javascript entity to be deserialized
	     *
	     * @param objectName - Name of the deserialized object
	     *
	     * @param options - Controls behavior of XML parser and builder.
	     *
	     * @returns A valid deserialized Javascript object
	     */
	    deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
	        const updatedOptions = {
	            xml: {
	                rootName: options.xml.rootName ?? "",
	                includeRoot: options.xml.includeRoot ?? false,
	                xmlCharKey: options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY,
	            },
	            ignoreUnknownProperties: options.ignoreUnknownProperties ?? false,
	        };
	        if (responseBody === undefined || responseBody === null) {
	            if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
	                // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
	                // between the list being empty versus being missing,
	                // so let's do the more user-friendly thing and return an empty list.
	                responseBody = [];
	            }
	            // specifically check for undefined as default value can be a falsey value `0, "", false, null`
	            if (mapper.defaultValue !== undefined) {
	                responseBody = mapper.defaultValue;
	            }
	            return responseBody;
	        }
	        let payload;
	        const mapperType = mapper.type.name;
	        if (!objectName) {
	            objectName = mapper.serializedName;
	        }
	        if (mapperType.match(/^Composite$/i) !== null) {
	            payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
	        }
	        else {
	            if (this.isXML) {
	                const xmlCharKey = updatedOptions.xml.xmlCharKey;
	                /**
	                 * If the mapper specifies this as a non-composite type value but the responseBody contains
	                 * both header ("$" i.e., XML_ATTRKEY) and body ("#" i.e., XML_CHARKEY) properties,
	                 * then just reduce the responseBody value to the body ("#" i.e., XML_CHARKEY) property.
	                 */
	                if (responseBody[interfaces_js_1.XML_ATTRKEY] !== undefined && responseBody[xmlCharKey] !== undefined) {
	                    responseBody = responseBody[xmlCharKey];
	                }
	            }
	            if (mapperType.match(/^Number$/i) !== null) {
	                payload = parseFloat(responseBody);
	                if (isNaN(payload)) {
	                    payload = responseBody;
	                }
	            }
	            else if (mapperType.match(/^Boolean$/i) !== null) {
	                if (responseBody === "true") {
	                    payload = true;
	                }
	                else if (responseBody === "false") {
	                    payload = false;
	                }
	                else {
	                    payload = responseBody;
	                }
	            }
	            else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
	                payload = responseBody;
	            }
	            else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
	                payload = new Date(responseBody);
	            }
	            else if (mapperType.match(/^UnixTime$/i) !== null) {
	                payload = unixTimeToDate(responseBody);
	            }
	            else if (mapperType.match(/^ByteArray$/i) !== null) {
	                payload = base64.decodeString(responseBody);
	            }
	            else if (mapperType.match(/^Base64Url$/i) !== null) {
	                payload = base64UrlToByteArray(responseBody);
	            }
	            else if (mapperType.match(/^Sequence$/i) !== null) {
	                payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
	            }
	            else if (mapperType.match(/^Dictionary$/i) !== null) {
	                payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
	            }
	        }
	        if (mapper.isConstant) {
	            payload = mapper.defaultValue;
	        }
	        return payload;
	    }
	}
	/**
	 * Method that creates and returns a Serializer.
	 * @param modelMappers - Known models to map
	 * @param isXML - If XML should be supported
	 */
	function createSerializer(modelMappers = {}, isXML = false) {
	    return new SerializerImpl(modelMappers, isXML);
	}
	function trimEnd(str, ch) {
	    let len = str.length;
	    while (len - 1 >= 0 && str[len - 1] === ch) {
	        --len;
	    }
	    return str.substr(0, len);
	}
	function bufferToBase64Url(buffer) {
	    if (!buffer) {
	        return undefined;
	    }
	    if (!(buffer instanceof Uint8Array)) {
	        throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
	    }
	    // Uint8Array to Base64.
	    const str = base64.encodeByteArray(buffer);
	    // Base64 to Base64Url.
	    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
	}
	function base64UrlToByteArray(str) {
	    if (!str) {
	        return undefined;
	    }
	    if (str && typeof str.valueOf() !== "string") {
	        throw new Error("Please provide an input of type string for converting to Uint8Array");
	    }
	    // Base64Url to Base64.
	    str = str.replace(/-/g, "+").replace(/_/g, "/");
	    // Base64 to Uint8Array.
	    return base64.decodeString(str);
	}
	function splitSerializeName(prop) {
	    const classes = [];
	    let partialclass = "";
	    if (prop) {
	        const subwords = prop.split(".");
	        for (const item of subwords) {
	            if (item.charAt(item.length - 1) === "\\") {
	                partialclass += item.substr(0, item.length - 1) + ".";
	            }
	            else {
	                partialclass += item;
	                classes.push(partialclass);
	                partialclass = "";
	            }
	        }
	    }
	    return classes;
	}
	function dateToUnixTime(d) {
	    if (!d) {
	        return undefined;
	    }
	    if (typeof d.valueOf() === "string") {
	        d = new Date(d);
	    }
	    return Math.floor(d.getTime() / 1000);
	}
	function unixTimeToDate(n) {
	    if (!n) {
	        return undefined;
	    }
	    return new Date(n * 1000);
	}
	function serializeBasicTypes(typeName, objectName, value) {
	    if (value !== null && value !== undefined) {
	        if (typeName.match(/^Number$/i) !== null) {
	            if (typeof value !== "number") {
	                throw new Error(`${objectName} with value ${value} must be of type number.`);
	            }
	        }
	        else if (typeName.match(/^String$/i) !== null) {
	            if (typeof value.valueOf() !== "string") {
	                throw new Error(`${objectName} with value "${value}" must be of type string.`);
	            }
	        }
	        else if (typeName.match(/^Uuid$/i) !== null) {
	            if (!(typeof value.valueOf() === "string" && (0, utils_js_1.isValidUuid)(value))) {
	                throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
	            }
	        }
	        else if (typeName.match(/^Boolean$/i) !== null) {
	            if (typeof value !== "boolean") {
	                throw new Error(`${objectName} with value ${value} must be of type boolean.`);
	            }
	        }
	        else if (typeName.match(/^Stream$/i) !== null) {
	            const objectType = typeof value;
	            if (objectType !== "string" &&
	                typeof value.pipe !== "function" && // NodeJS.ReadableStream
	                typeof value.tee !== "function" && // browser ReadableStream
	                !(value instanceof ArrayBuffer) &&
	                !ArrayBuffer.isView(value) &&
	                // File objects count as a type of Blob, so we want to use instanceof explicitly
	                !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) &&
	                objectType !== "function") {
	                throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
	            }
	        }
	    }
	    return value;
	}
	function serializeEnumType(objectName, allowedValues, value) {
	    if (!allowedValues) {
	        throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
	    }
	    const isPresent = allowedValues.some((item) => {
	        if (typeof item.valueOf() === "string") {
	            return item.toLowerCase() === value.toLowerCase();
	        }
	        return item === value;
	    });
	    if (!isPresent) {
	        throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
	    }
	    return value;
	}
	function serializeByteArrayType(objectName, value) {
	    if (value !== undefined && value !== null) {
	        if (!(value instanceof Uint8Array)) {
	            throw new Error(`${objectName} must be of type Uint8Array.`);
	        }
	        value = base64.encodeByteArray(value);
	    }
	    return value;
	}
	function serializeBase64UrlType(objectName, value) {
	    if (value !== undefined && value !== null) {
	        if (!(value instanceof Uint8Array)) {
	            throw new Error(`${objectName} must be of type Uint8Array.`);
	        }
	        value = bufferToBase64Url(value);
	    }
	    return value;
	}
	function serializeDateTypes(typeName, value, objectName) {
	    if (value !== undefined && value !== null) {
	        if (typeName.match(/^Date$/i) !== null) {
	            if (!(value instanceof Date ||
	                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
	                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
	            }
	            value =
	                value instanceof Date
	                    ? value.toISOString().substring(0, 10)
	                    : new Date(value).toISOString().substring(0, 10);
	        }
	        else if (typeName.match(/^DateTime$/i) !== null) {
	            if (!(value instanceof Date ||
	                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
	                throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
	            }
	            value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
	        }
	        else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
	            if (!(value instanceof Date ||
	                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
	                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
	            }
	            value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
	        }
	        else if (typeName.match(/^UnixTime$/i) !== null) {
	            if (!(value instanceof Date ||
	                (typeof value.valueOf() === "string" && !isNaN(Date.parse(value))))) {
	                throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format ` +
	                    `for it to be serialized in UnixTime/Epoch format.`);
	            }
	            value = dateToUnixTime(value);
	        }
	        else if (typeName.match(/^TimeSpan$/i) !== null) {
	            if (!(0, utils_js_1.isDuration)(value)) {
	                throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
	            }
	        }
	    }
	    return value;
	}
	function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
	    if (!Array.isArray(object)) {
	        throw new Error(`${objectName} must be of type Array.`);
	    }
	    let elementType = mapper.type.element;
	    if (!elementType || typeof elementType !== "object") {
	        throw new Error(`element" metadata for an Array must be defined in the ` +
	            `mapper and it must of type "object" in ${objectName}.`);
	    }
	    // Quirk: Composite mappers referenced by `element` might
	    // not have *all* properties declared (like uberParent),
	    // so let's try to look up the full definition by name.
	    if (elementType.type.name === "Composite" && elementType.type.className) {
	        elementType = serializer.modelMappers[elementType.type.className] ?? elementType;
	    }
	    const tempArray = [];
	    for (let i = 0; i < object.length; i++) {
	        const serializedValue = serializer.serialize(elementType, object[i], objectName, options);
	        if (isXml && elementType.xmlNamespace) {
	            const xmlnsKey = elementType.xmlNamespacePrefix
	                ? `xmlns:${elementType.xmlNamespacePrefix}`
	                : "xmlns";
	            if (elementType.type.name === "Composite") {
	                tempArray[i] = { ...serializedValue };
	                tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
	            }
	            else {
	                tempArray[i] = {};
	                tempArray[i][options.xml.xmlCharKey] = serializedValue;
	                tempArray[i][interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
	            }
	        }
	        else {
	            tempArray[i] = serializedValue;
	        }
	    }
	    return tempArray;
	}
	function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
	    if (typeof object !== "object") {
	        throw new Error(`${objectName} must be of type object.`);
	    }
	    const valueType = mapper.type.value;
	    if (!valueType || typeof valueType !== "object") {
	        throw new Error(`"value" metadata for a Dictionary must be defined in the ` +
	            `mapper and it must of type "object" in ${objectName}.`);
	    }
	    const tempDictionary = {};
	    for (const key of Object.keys(object)) {
	        const serializedValue = serializer.serialize(valueType, object[key], objectName, options);
	        // If the element needs an XML namespace we need to add it within the $ property
	        tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
	    }
	    // Add the namespace to the root element if needed
	    if (isXml && mapper.xmlNamespace) {
	        const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
	        const result = tempDictionary;
	        result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
	        return result;
	    }
	    return tempDictionary;
	}
	/**
	 * Resolves the additionalProperties property from a referenced mapper
	 * @param serializer - the serializer containing the entire set of mappers
	 * @param mapper - the composite mapper to resolve
	 * @param objectName - name of the object being serialized
	 */
	function resolveAdditionalProperties(serializer, mapper, objectName) {
	    const additionalProperties = mapper.type.additionalProperties;
	    if (!additionalProperties && mapper.type.className) {
	        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
	        return modelMapper?.type.additionalProperties;
	    }
	    return additionalProperties;
	}
	/**
	 * Finds the mapper referenced by className
	 * @param serializer - the serializer containing the entire set of mappers
	 * @param mapper - the composite mapper to resolve
	 * @param objectName - name of the object being serialized
	 */
	function resolveReferencedMapper(serializer, mapper, objectName) {
	    const className = mapper.type.className;
	    if (!className) {
	        throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, undefined, 2)}".`);
	    }
	    return serializer.modelMappers[className];
	}
	/**
	 * Resolves a composite mapper's modelProperties.
	 * @param serializer - the serializer containing the entire set of mappers
	 * @param mapper - the composite mapper to resolve
	 */
	function resolveModelProperties(serializer, mapper, objectName) {
	    let modelProps = mapper.type.modelProperties;
	    if (!modelProps) {
	        const modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
	        if (!modelMapper) {
	            throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
	        }
	        modelProps = modelMapper?.type.modelProperties;
	        if (!modelProps) {
	            throw new Error(`modelProperties cannot be null or undefined in the ` +
	                `mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
	        }
	    }
	    return modelProps;
	}
	function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
	    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
	        mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
	    }
	    if (object !== undefined && object !== null) {
	        const payload = {};
	        const modelProps = resolveModelProperties(serializer, mapper, objectName);
	        for (const key of Object.keys(modelProps)) {
	            const propertyMapper = modelProps[key];
	            if (propertyMapper.readOnly) {
	                continue;
	            }
	            let propName;
	            let parentObject = payload;
	            if (serializer.isXML) {
	                if (propertyMapper.xmlIsWrapped) {
	                    propName = propertyMapper.xmlName;
	                }
	                else {
	                    propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
	                }
	            }
	            else {
	                const paths = splitSerializeName(propertyMapper.serializedName);
	                propName = paths.pop();
	                for (const pathName of paths) {
	                    const childObject = parentObject[pathName];
	                    if ((childObject === undefined || childObject === null) &&
	                        ((object[key] !== undefined && object[key] !== null) ||
	                            propertyMapper.defaultValue !== undefined)) {
	                        parentObject[pathName] = {};
	                    }
	                    parentObject = parentObject[pathName];
	                }
	            }
	            if (parentObject !== undefined && parentObject !== null) {
	                if (isXml && mapper.xmlNamespace) {
	                    const xmlnsKey = mapper.xmlNamespacePrefix
	                        ? `xmlns:${mapper.xmlNamespacePrefix}`
	                        : "xmlns";
	                    parentObject[interfaces_js_1.XML_ATTRKEY] = {
	                        ...parentObject[interfaces_js_1.XML_ATTRKEY],
	                        [xmlnsKey]: mapper.xmlNamespace,
	                    };
	                }
	                const propertyObjectName = propertyMapper.serializedName !== ""
	                    ? objectName + "." + propertyMapper.serializedName
	                    : objectName;
	                let toSerialize = object[key];
	                const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
	                if (polymorphicDiscriminator &&
	                    polymorphicDiscriminator.clientName === key &&
	                    (toSerialize === undefined || toSerialize === null)) {
	                    toSerialize = mapper.serializedName;
	                }
	                const serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
	                if (serializedValue !== undefined && propName !== undefined && propName !== null) {
	                    const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
	                    if (isXml && propertyMapper.xmlIsAttribute) {
	                        // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.
	                        // This keeps things simple while preventing name collision
	                        // with names in user documents.
	                        parentObject[interfaces_js_1.XML_ATTRKEY] = parentObject[interfaces_js_1.XML_ATTRKEY] || {};
	                        parentObject[interfaces_js_1.XML_ATTRKEY][propName] = serializedValue;
	                    }
	                    else if (isXml && propertyMapper.xmlIsWrapped) {
	                        parentObject[propName] = { [propertyMapper.xmlElementName]: value };
	                    }
	                    else {
	                        parentObject[propName] = value;
	                    }
	                }
	            }
	        }
	        const additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
	        if (additionalPropertiesMapper) {
	            const propNames = Object.keys(modelProps);
	            for (const clientPropName in object) {
	                const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
	                if (isAdditionalProperty) {
	                    payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
	                }
	            }
	        }
	        return payload;
	    }
	    return object;
	}
	function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
	    if (!isXml || !propertyMapper.xmlNamespace) {
	        return serializedValue;
	    }
	    const xmlnsKey = propertyMapper.xmlNamespacePrefix
	        ? `xmlns:${propertyMapper.xmlNamespacePrefix}`
	        : "xmlns";
	    const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
	    if (["Composite"].includes(propertyMapper.type.name)) {
	        if (serializedValue[interfaces_js_1.XML_ATTRKEY]) {
	            return serializedValue;
	        }
	        else {
	            const result = { ...serializedValue };
	            result[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
	            return result;
	        }
	    }
	    const result = {};
	    result[options.xml.xmlCharKey] = serializedValue;
	    result[interfaces_js_1.XML_ATTRKEY] = xmlNamespace;
	    return result;
	}
	function isSpecialXmlProperty(propertyName, options) {
	    return [interfaces_js_1.XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
	}
	function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
	    const xmlCharKey = options.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY;
	    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) {
	        mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
	    }
	    const modelProps = resolveModelProperties(serializer, mapper, objectName);
	    let instance = {};
	    const handledPropertyNames = [];
	    for (const key of Object.keys(modelProps)) {
	        const propertyMapper = modelProps[key];
	        const paths = splitSerializeName(modelProps[key].serializedName);
	        handledPropertyNames.push(paths[0]);
	        const { serializedName, xmlName, xmlElementName } = propertyMapper;
	        let propertyObjectName = objectName;
	        if (serializedName !== "" && serializedName !== undefined) {
	            propertyObjectName = objectName + "." + serializedName;
	        }
	        const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
	        if (headerCollectionPrefix) {
	            const dictionary = {};
	            for (const headerKey of Object.keys(responseBody)) {
	                if (headerKey.startsWith(headerCollectionPrefix)) {
	                    dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
	                }
	                handledPropertyNames.push(headerKey);
	            }
	            instance[key] = dictionary;
	        }
	        else if (serializer.isXML) {
	            if (propertyMapper.xmlIsAttribute && responseBody[interfaces_js_1.XML_ATTRKEY]) {
	                instance[key] = serializer.deserialize(propertyMapper, responseBody[interfaces_js_1.XML_ATTRKEY][xmlName], propertyObjectName, options);
	            }
	            else if (propertyMapper.xmlIsMsText) {
	                if (responseBody[xmlCharKey] !== undefined) {
	                    instance[key] = responseBody[xmlCharKey];
	                }
	                else if (typeof responseBody === "string") {
	                    // The special case where xml parser parses "<Name>content</Name>" into JSON of
	                    //   `{ name: "content"}` instead of `{ name: { "_": "content" }}`
	                    instance[key] = responseBody;
	                }
	            }
	            else {
	                const propertyName = xmlElementName || xmlName || serializedName;
	                if (propertyMapper.xmlIsWrapped) {
	                    /* a list of <xmlElementName> wrapped by <xmlName>
	                      For the xml example below
	                        <Cors>
	                          <CorsRule>...</CorsRule>
	                          <CorsRule>...</CorsRule>
	                        </Cors>
	                      the responseBody has
	                        {
	                          Cors: {
	                            CorsRule: [{...}, {...}]
	                          }
	                        }
	                      xmlName is "Cors" and xmlElementName is"CorsRule".
	                    */
	                    const wrapped = responseBody[xmlName];
	                    const elementList = wrapped?.[xmlElementName] ?? [];
	                    instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
	                    handledPropertyNames.push(xmlName);
	                }
	                else {
	                    const property = responseBody[propertyName];
	                    instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
	                    handledPropertyNames.push(propertyName);
	                }
	            }
	        }
	        else {
	            // deserialize the property if it is present in the provided responseBody instance
	            let propertyInstance;
	            let res = responseBody;
	            // traversing the object step by step.
	            let steps = 0;
	            for (const item of paths) {
	                if (!res)
	                    break;
	                steps++;
	                res = res[item];
	            }
	            // only accept null when reaching the last position of object otherwise it would be undefined
	            if (res === null && steps < paths.length) {
	                res = undefined;
	            }
	            propertyInstance = res;
	            const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
	            // checking that the model property name (key)(ex: "fishtype") and the
	            // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
	            // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
	            // is a better approach. The generator is not consistent with escaping '\.' in the
	            // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
	            // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
	            // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
	            // the transformation of model property name (ex: "fishtype") is done consistently.
	            // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.
	            if (polymorphicDiscriminator &&
	                key === polymorphicDiscriminator.clientName &&
	                (propertyInstance === undefined || propertyInstance === null)) {
	                propertyInstance = mapper.serializedName;
	            }
	            let serializedValue;
	            // paging
	            if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
	                propertyInstance = responseBody[key];
	                const arrayInstance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
	                // Copy over any properties that have already been added into the instance, where they do
	                // not exist on the newly de-serialized array
	                for (const [k, v] of Object.entries(instance)) {
	                    if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
	                        arrayInstance[k] = v;
	                    }
	                }
	                instance = arrayInstance;
	            }
	            else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
	                serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
	                instance[key] = serializedValue;
	            }
	        }
	    }
	    const additionalPropertiesMapper = mapper.type.additionalProperties;
	    if (additionalPropertiesMapper) {
	        const isAdditionalProperty = (responsePropName) => {
	            for (const clientPropName in modelProps) {
	                const paths = splitSerializeName(modelProps[clientPropName].serializedName);
	                if (paths[0] === responsePropName) {
	                    return false;
	                }
	            }
	            return true;
	        };
	        for (const responsePropName in responseBody) {
	            if (isAdditionalProperty(responsePropName)) {
	                instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
	            }
	        }
	    }
	    else if (responseBody && !options.ignoreUnknownProperties) {
	        for (const key of Object.keys(responseBody)) {
	            if (instance[key] === undefined &&
	                !handledPropertyNames.includes(key) &&
	                !isSpecialXmlProperty(key, options)) {
	                instance[key] = responseBody[key];
	            }
	        }
	    }
	    return instance;
	}
	function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
	    /* jshint validthis: true */
	    const value = mapper.type.value;
	    if (!value || typeof value !== "object") {
	        throw new Error(`"value" metadata for a Dictionary must be defined in the ` +
	            `mapper and it must of type "object" in ${objectName}`);
	    }
	    if (responseBody) {
	        const tempDictionary = {};
	        for (const key of Object.keys(responseBody)) {
	            tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
	        }
	        return tempDictionary;
	    }
	    return responseBody;
	}
	function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
	    let element = mapper.type.element;
	    if (!element || typeof element !== "object") {
	        throw new Error(`element" metadata for an Array must be defined in the ` +
	            `mapper and it must of type "object" in ${objectName}`);
	    }
	    if (responseBody) {
	        if (!Array.isArray(responseBody)) {
	            // xml2js will interpret a single element array as just the element, so force it to be an array
	            responseBody = [responseBody];
	        }
	        // Quirk: Composite mappers referenced by `element` might
	        // not have *all* properties declared (like uberParent),
	        // so let's try to look up the full definition by name.
	        if (element.type.name === "Composite" && element.type.className) {
	            element = serializer.modelMappers[element.type.className] ?? element;
	        }
	        const tempArray = [];
	        for (let i = 0; i < responseBody.length; i++) {
	            tempArray[i] = serializer.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
	        }
	        return tempArray;
	    }
	    return responseBody;
	}
	function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
	    const typeNamesToCheck = [typeName];
	    while (typeNamesToCheck.length) {
	        const currentName = typeNamesToCheck.shift();
	        const indexDiscriminator = discriminatorValue === currentName
	            ? discriminatorValue
	            : currentName + "." + discriminatorValue;
	        if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
	            return discriminators[indexDiscriminator];
	        }
	        else {
	            for (const [name, mapper] of Object.entries(discriminators)) {
	                if (name.startsWith(currentName + ".") &&
	                    mapper.type.uberParent === currentName &&
	                    mapper.type.className) {
	                    typeNamesToCheck.push(mapper.type.className);
	                }
	            }
	        }
	    }
	    return undefined;
	}
	function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
	    const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
	    if (polymorphicDiscriminator) {
	        let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
	        if (discriminatorName) {
	            // The serializedName might have \\, which we just want to ignore
	            if (polymorphicPropertyName === "serializedName") {
	                discriminatorName = discriminatorName.replace(/\\/gi, "");
	            }
	            const discriminatorValue = object[discriminatorName];
	            const typeName = mapper.type.uberParent ?? mapper.type.className;
	            if (typeof discriminatorValue === "string" && typeName) {
	                const polymorphicMapper = getIndexDiscriminator(serializer.modelMappers.discriminators, discriminatorValue, typeName);
	                if (polymorphicMapper) {
	                    mapper = polymorphicMapper;
	                }
	            }
	        }
	    }
	    return mapper;
	}
	function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
	    return (mapper.type.polymorphicDiscriminator ||
	        getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) ||
	        getPolymorphicDiscriminatorSafely(serializer, mapper.type.className));
	}
	function getPolymorphicDiscriminatorSafely(serializer, typeName) {
	    return (typeName &&
	        serializer.modelMappers[typeName] &&
	        serializer.modelMappers[typeName].type.polymorphicDiscriminator);
	}
	/**
	 * Known types of Mappers
	 */
	serializer.MapperTypeNames = {
	    Base64Url: "Base64Url",
	    Boolean: "Boolean",
	    ByteArray: "ByteArray",
	    Composite: "Composite",
	    Date: "Date",
	    DateTime: "DateTime",
	    DateTimeRfc1123: "DateTimeRfc1123",
	    Dictionary: "Dictionary",
	    Enum: "Enum",
	    Number: "Number",
	    Object: "Object",
	    Sequence: "Sequence",
	    String: "String",
	    Stream: "Stream",
	    TimeSpan: "TimeSpan",
	    UnixTime: "UnixTime",
	};
	
	return serializer;
}

var serviceClient = {};

var commonjs$2 = {};

var pipeline$2 = {};

var commonjs$1 = {};

var AbortError = {};

var hasRequiredAbortError$1;

function requireAbortError$1 () {
	if (hasRequiredAbortError$1) return AbortError;
	hasRequiredAbortError$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(AbortError, "__esModule", { value: true });
	AbortError.AbortError = void 0;
	/**
	 * This error is thrown when an asynchronous operation has been aborted.
	 * Check for this error by testing the `name` that the name property of the
	 * error matches `"AbortError"`.
	 *
	 * @example
	 * ```ts snippet:ReadmeSampleAbortError
	 * import { AbortError } from "@typespec/ts-http-runtime";
	 *
	 * async function doAsyncWork(options: { abortSignal: AbortSignal }): Promise<void> {
	 *   if (options.abortSignal.aborted) {
	 *     throw new AbortError();
	 *   }
	 *
	 *   // do async work
	 * }
	 *
	 * const controller = new AbortController();
	 * controller.abort();
	 *
	 * try {
	 *   doAsyncWork({ abortSignal: controller.signal });
	 * } catch (e) {
	 *   if (e instanceof Error && e.name === "AbortError") {
	 *     // handle abort error here.
	 *   }
	 * }
	 * ```
	 */
	let AbortError$1 = class AbortError extends Error {
	    constructor(message) {
	        super(message);
	        this.name = "AbortError";
	    }
	};
	AbortError.AbortError = AbortError$1;
	
	return AbortError;
}

var httpHeaders$1 = {};

var hasRequiredHttpHeaders$1;

function requireHttpHeaders$1 () {
	if (hasRequiredHttpHeaders$1) return httpHeaders$1;
	hasRequiredHttpHeaders$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(httpHeaders$1, "__esModule", { value: true });
	httpHeaders$1.createHttpHeaders = createHttpHeaders;
	function normalizeName(name) {
	    return name.toLowerCase();
	}
	function* headerIterator(map) {
	    for (const entry of map.values()) {
	        yield [entry.name, entry.value];
	    }
	}
	class HttpHeadersImpl {
	    _headersMap;
	    constructor(rawHeaders) {
	        this._headersMap = new Map();
	        if (rawHeaders) {
	            for (const headerName of Object.keys(rawHeaders)) {
	                this.set(headerName, rawHeaders[headerName]);
	            }
	        }
	    }
	    /**
	     * Set a header in this collection with the provided name and value. The name is
	     * case-insensitive.
	     * @param name - The name of the header to set. This value is case-insensitive.
	     * @param value - The value of the header to set.
	     */
	    set(name, value) {
	        this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });
	    }
	    /**
	     * Get the header value for the provided header name, or undefined if no header exists in this
	     * collection with the provided name.
	     * @param name - The name of the header. This value is case-insensitive.
	     */
	    get(name) {
	        return this._headersMap.get(normalizeName(name))?.value;
	    }
	    /**
	     * Get whether or not this header collection contains a header entry for the provided header name.
	     * @param name - The name of the header to set. This value is case-insensitive.
	     */
	    has(name) {
	        return this._headersMap.has(normalizeName(name));
	    }
	    /**
	     * Remove the header with the provided headerName.
	     * @param name - The name of the header to remove.
	     */
	    delete(name) {
	        this._headersMap.delete(normalizeName(name));
	    }
	    /**
	     * Get the JSON object representation of this HTTP header collection.
	     */
	    toJSON(options = {}) {
	        const result = {};
	        if (options.preserveCase) {
	            for (const entry of this._headersMap.values()) {
	                result[entry.name] = entry.value;
	            }
	        }
	        else {
	            for (const [normalizedName, entry] of this._headersMap) {
	                result[normalizedName] = entry.value;
	            }
	        }
	        return result;
	    }
	    /**
	     * Get the string representation of this HTTP header collection.
	     */
	    toString() {
	        return JSON.stringify(this.toJSON({ preserveCase: true }));
	    }
	    /**
	     * Iterate over tuples of header [name, value] pairs.
	     */
	    [Symbol.iterator]() {
	        return headerIterator(this._headersMap);
	    }
	}
	/**
	 * Creates an object that satisfies the `HttpHeaders` interface.
	 * @param rawHeaders - A simple object representing initial headers
	 */
	function createHttpHeaders(rawHeaders) {
	    return new HttpHeadersImpl(rawHeaders);
	}
	
	return httpHeaders$1;
}

var schemes = {};

var hasRequiredSchemes;

function requireSchemes () {
	if (hasRequiredSchemes) return schemes;
	hasRequiredSchemes = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(schemes, "__esModule", { value: true });
	
	return schemes;
}

var oauth2Flows = {};

var hasRequiredOauth2Flows;

function requireOauth2Flows () {
	if (hasRequiredOauth2Flows) return oauth2Flows;
	hasRequiredOauth2Flows = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(oauth2Flows, "__esModule", { value: true });
	
	return oauth2Flows;
}

var pipelineRequest$1 = {};

var hasRequiredPipelineRequest$1;

function requirePipelineRequest$1 () {
	if (hasRequiredPipelineRequest$1) return pipelineRequest$1;
	hasRequiredPipelineRequest$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(pipelineRequest$1, "__esModule", { value: true });
	pipelineRequest$1.createPipelineRequest = createPipelineRequest;
	const httpHeaders_js_1 = requireHttpHeaders$1();
	const uuidUtils_js_1 = requireUuidUtils();
	class PipelineRequestImpl {
	    url;
	    method;
	    headers;
	    timeout;
	    withCredentials;
	    body;
	    multipartBody;
	    formData;
	    streamResponseStatusCodes;
	    enableBrowserStreams;
	    proxySettings;
	    disableKeepAlive;
	    abortSignal;
	    requestId;
	    allowInsecureConnection;
	    onUploadProgress;
	    onDownloadProgress;
	    requestOverrides;
	    authSchemes;
	    constructor(options) {
	        this.url = options.url;
	        this.body = options.body;
	        this.headers = options.headers ?? (0, httpHeaders_js_1.createHttpHeaders)();
	        this.method = options.method ?? "GET";
	        this.timeout = options.timeout ?? 0;
	        this.multipartBody = options.multipartBody;
	        this.formData = options.formData;
	        this.disableKeepAlive = options.disableKeepAlive ?? false;
	        this.proxySettings = options.proxySettings;
	        this.streamResponseStatusCodes = options.streamResponseStatusCodes;
	        this.withCredentials = options.withCredentials ?? false;
	        this.abortSignal = options.abortSignal;
	        this.onUploadProgress = options.onUploadProgress;
	        this.onDownloadProgress = options.onDownloadProgress;
	        this.requestId = options.requestId || (0, uuidUtils_js_1.randomUUID)();
	        this.allowInsecureConnection = options.allowInsecureConnection ?? false;
	        this.enableBrowserStreams = options.enableBrowserStreams ?? false;
	        this.requestOverrides = options.requestOverrides;
	        this.authSchemes = options.authSchemes;
	    }
	}
	/**
	 * Creates a new pipeline request with the given options.
	 * This method is to allow for the easy setting of default values and not required.
	 * @param options - The options to create the request with.
	 */
	function createPipelineRequest(options) {
	    return new PipelineRequestImpl(options);
	}
	
	return pipelineRequest$1;
}

var pipeline$1 = {};

var hasRequiredPipeline$3;

function requirePipeline$3 () {
	if (hasRequiredPipeline$3) return pipeline$1;
	hasRequiredPipeline$3 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(pipeline$1, "__esModule", { value: true });
	pipeline$1.createEmptyPipeline = createEmptyPipeline;
	const ValidPhaseNames = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
	/**
	 * A private implementation of Pipeline.
	 * Do not export this class from the package.
	 * @internal
	 */
	class HttpPipeline {
	    _policies = [];
	    _orderedPolicies;
	    constructor(policies) {
	        this._policies = policies?.slice(0) ?? [];
	        this._orderedPolicies = undefined;
	    }
	    addPolicy(policy, options = {}) {
	        if (options.phase && options.afterPhase) {
	            throw new Error("Policies inside a phase cannot specify afterPhase.");
	        }
	        if (options.phase && !ValidPhaseNames.has(options.phase)) {
	            throw new Error(`Invalid phase name: ${options.phase}`);
	        }
	        if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {
	            throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);
	        }
	        this._policies.push({
	            policy,
	            options,
	        });
	        this._orderedPolicies = undefined;
	    }
	    removePolicy(options) {
	        const removedPolicies = [];
	        this._policies = this._policies.filter((policyDescriptor) => {
	            if ((options.name && policyDescriptor.policy.name === options.name) ||
	                (options.phase && policyDescriptor.options.phase === options.phase)) {
	                removedPolicies.push(policyDescriptor.policy);
	                return false;
	            }
	            else {
	                return true;
	            }
	        });
	        this._orderedPolicies = undefined;
	        return removedPolicies;
	    }
	    sendRequest(httpClient, request) {
	        const policies = this.getOrderedPolicies();
	        const pipeline = policies.reduceRight((next, policy) => {
	            return (req) => {
	                return policy.sendRequest(req, next);
	            };
	        }, (req) => httpClient.sendRequest(req));
	        return pipeline(request);
	    }
	    getOrderedPolicies() {
	        if (!this._orderedPolicies) {
	            this._orderedPolicies = this.orderPolicies();
	        }
	        return this._orderedPolicies;
	    }
	    clone() {
	        return new HttpPipeline(this._policies);
	    }
	    static create() {
	        return new HttpPipeline();
	    }
	    orderPolicies() {
	        /**
	         * The goal of this method is to reliably order pipeline policies
	         * based on their declared requirements when they were added.
	         *
	         * Order is first determined by phase:
	         *
	         * 1. Serialize Phase
	         * 2. Policies not in a phase
	         * 3. Deserialize Phase
	         * 4. Retry Phase
	         * 5. Sign Phase
	         *
	         * Within each phase, policies are executed in the order
	         * they were added unless they were specified to execute
	         * before/after other policies or after a particular phase.
	         *
	         * To determine the final order, we will walk the policy list
	         * in phase order multiple times until all dependencies are
	         * satisfied.
	         *
	         * `afterPolicies` are the set of policies that must be
	         * executed before a given policy. This requirement is
	         * considered satisfied when each of the listed policies
	         * have been scheduled.
	         *
	         * `beforePolicies` are the set of policies that must be
	         * executed after a given policy. Since this dependency
	         * can be expressed by converting it into a equivalent
	         * `afterPolicies` declarations, they are normalized
	         * into that form for simplicity.
	         *
	         * An `afterPhase` dependency is considered satisfied when all
	         * policies in that phase have scheduled.
	         *
	         */
	        const result = [];
	        // Track all policies we know about.
	        const policyMap = new Map();
	        function createPhase(name) {
	            return {
	                name,
	                policies: new Set(),
	                hasRun: false,
	                hasAfterPolicies: false,
	            };
	        }
	        // Track policies for each phase.
	        const serializePhase = createPhase("Serialize");
	        const noPhase = createPhase("None");
	        const deserializePhase = createPhase("Deserialize");
	        const retryPhase = createPhase("Retry");
	        const signPhase = createPhase("Sign");
	        // a list of phases in order
	        const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];
	        // Small helper function to map phase name to each Phase
	        function getPhase(phase) {
	            if (phase === "Retry") {
	                return retryPhase;
	            }
	            else if (phase === "Serialize") {
	                return serializePhase;
	            }
	            else if (phase === "Deserialize") {
	                return deserializePhase;
	            }
	            else if (phase === "Sign") {
	                return signPhase;
	            }
	            else {
	                return noPhase;
	            }
	        }
	        // First walk each policy and create a node to track metadata.
	        for (const descriptor of this._policies) {
	            const policy = descriptor.policy;
	            const options = descriptor.options;
	            const policyName = policy.name;
	            if (policyMap.has(policyName)) {
	                throw new Error("Duplicate policy names not allowed in pipeline");
	            }
	            const node = {
	                policy,
	                dependsOn: new Set(),
	                dependants: new Set(),
	            };
	            if (options.afterPhase) {
	                node.afterPhase = getPhase(options.afterPhase);
	                node.afterPhase.hasAfterPolicies = true;
	            }
	            policyMap.set(policyName, node);
	            const phase = getPhase(options.phase);
	            phase.policies.add(node);
	        }
	        // Now that each policy has a node, connect dependency references.
	        for (const descriptor of this._policies) {
	            const { policy, options } = descriptor;
	            const policyName = policy.name;
	            const node = policyMap.get(policyName);
	            if (!node) {
	                throw new Error(`Missing node for policy ${policyName}`);
	            }
	            if (options.afterPolicies) {
	                for (const afterPolicyName of options.afterPolicies) {
	                    const afterNode = policyMap.get(afterPolicyName);
	                    if (afterNode) {
	                        // Linking in both directions helps later
	                        // when we want to notify dependants.
	                        node.dependsOn.add(afterNode);
	                        afterNode.dependants.add(node);
	                    }
	                }
	            }
	            if (options.beforePolicies) {
	                for (const beforePolicyName of options.beforePolicies) {
	                    const beforeNode = policyMap.get(beforePolicyName);
	                    if (beforeNode) {
	                        // To execute before another node, make it
	                        // depend on the current node.
	                        beforeNode.dependsOn.add(node);
	                        node.dependants.add(beforeNode);
	                    }
	                }
	            }
	        }
	        function walkPhase(phase) {
	            phase.hasRun = true;
	            // Sets iterate in insertion order
	            for (const node of phase.policies) {
	                if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {
	                    // If this node is waiting on a phase to complete,
	                    // we need to skip it for now.
	                    // Even if the phase is empty, we should wait for it
	                    // to be walked to avoid re-ordering policies.
	                    continue;
	                }
	                if (node.dependsOn.size === 0) {
	                    // If there's nothing else we're waiting for, we can
	                    // add this policy to the result list.
	                    result.push(node.policy);
	                    // Notify anything that depends on this policy that
	                    // the policy has been scheduled.
	                    for (const dependant of node.dependants) {
	                        dependant.dependsOn.delete(node);
	                    }
	                    policyMap.delete(node.policy.name);
	                    phase.policies.delete(node);
	                }
	            }
	        }
	        function walkPhases() {
	            for (const phase of orderedPhases) {
	                walkPhase(phase);
	                // if the phase isn't complete
	                if (phase.policies.size > 0 && phase !== noPhase) {
	                    if (!noPhase.hasRun) {
	                        // Try running noPhase to see if that unblocks this phase next tick.
	                        // This can happen if a phase that happens before noPhase
	                        // is waiting on a noPhase policy to complete.
	                        walkPhase(noPhase);
	                    }
	                    // Don't proceed to the next phase until this phase finishes.
	                    return;
	                }
	                if (phase.hasAfterPolicies) {
	                    // Run any policies unblocked by this phase
	                    walkPhase(noPhase);
	                }
	            }
	        }
	        // Iterate until we've put every node in the result list.
	        let iteration = 0;
	        while (policyMap.size > 0) {
	            iteration++;
	            const initialResultLength = result.length;
	            // Keep walking each phase in order until we can order every node.
	            walkPhases();
	            // The result list *should* get at least one larger each time
	            // after the first full pass.
	            // Otherwise, we're going to loop forever.
	            if (result.length <= initialResultLength && iteration > 1) {
	                throw new Error("Cannot satisfy policy dependencies due to requirements cycle.");
	            }
	        }
	        return result;
	    }
	}
	/**
	 * Creates a totally empty pipeline.
	 * Useful for testing or creating a custom one.
	 */
	function createEmptyPipeline() {
	    return HttpPipeline.create();
	}
	
	return pipeline$1;
}

var restError$2 = {};

var inspect$1 = {};

var hasRequiredInspect$1;

function requireInspect$1 () {
	if (hasRequiredInspect$1) return inspect$1;
	hasRequiredInspect$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(inspect$1, "__esModule", { value: true });
	inspect$1.custom = void 0;
	const node_util_1 = __require$8();
	inspect$1.custom = node_util_1.inspect.custom;
	
	return inspect$1;
}

var hasRequiredRestError$2;

function requireRestError$2 () {
	if (hasRequiredRestError$2) return restError$2;
	hasRequiredRestError$2 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(restError$2, "__esModule", { value: true });
	restError$2.RestError = void 0;
	restError$2.isRestError = isRestError;
	const error_js_1 = requireError$1();
	const inspect_js_1 = requireInspect$1();
	const sanitizer_js_1 = requireSanitizer();
	const errorSanitizer = new sanitizer_js_1.Sanitizer();
	/**
	 * A custom error type for failed pipeline requests.
	 */
	class RestError extends Error {
	    /**
	     * Something went wrong when making the request.
	     * This means the actual request failed for some reason,
	     * such as a DNS issue or the connection being lost.
	     */
	    static REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
	    /**
	     * This means that parsing the response from the server failed.
	     * It may have been malformed.
	     */
	    static PARSE_ERROR = "PARSE_ERROR";
	    /**
	     * The code of the error itself (use statics on RestError if possible.)
	     */
	    code;
	    /**
	     * The HTTP status code of the request (if applicable.)
	     */
	    statusCode;
	    /**
	     * The request that was made.
	     * This property is non-enumerable.
	     */
	    request;
	    /**
	     * The response received (if any.)
	     * This property is non-enumerable.
	     */
	    response;
	    /**
	     * Bonus property set by the throw site.
	     */
	    details;
	    constructor(message, options = {}) {
	        super(message);
	        this.name = "RestError";
	        this.code = options.code;
	        this.statusCode = options.statusCode;
	        // The request and response may contain sensitive information in the headers or body.
	        // To help prevent this sensitive information being accidentally logged, the request and response
	        // properties are marked as non-enumerable here. This prevents them showing up in the output of
	        // JSON.stringify and console.log.
	        Object.defineProperty(this, "request", { value: options.request, enumerable: false });
	        Object.defineProperty(this, "response", { value: options.response, enumerable: false });
	        // Only include useful agent information in the request for logging, as the full agent object
	        // may contain large binary data.
	        const agent = this.request?.agent
	            ? {
	                maxFreeSockets: this.request.agent.maxFreeSockets,
	                maxSockets: this.request.agent.maxSockets,
	            }
	            : undefined;
	        // Logging method for util.inspect in Node
	        Object.defineProperty(this, inspect_js_1.custom, {
	            value: () => {
	                // Extract non-enumerable properties and add them back. This is OK since in this output the request and
	                // response get sanitized.
	                return `RestError: ${this.message} \n ${errorSanitizer.sanitize({
	                    ...this,
	                    request: { ...this.request, agent },
	                    response: this.response,
	                })}`;
	            },
	            enumerable: false,
	        });
	        Object.setPrototypeOf(this, RestError.prototype);
	    }
	}
	restError$2.RestError = RestError;
	/**
	 * Typeguard for RestError
	 * @param e - Something caught by a catch clause.
	 */
	function isRestError(e) {
	    if (e instanceof RestError) {
	        return true;
	    }
	    return (0, error_js_1.isError)(e) && e.name === "RestError";
	}
	
	return restError$2;
}

var defaultHttpClient$1 = {};

var nodeHttpClient = {};

const require$6 = createRequire(import.meta.url);
function __require$5() { return require$6("node:http"); }

const require$5 = createRequire(import.meta.url);
function __require$4() { return require$5("node:https"); }

const require$4 = createRequire(import.meta.url);
function __require$3() { return require$4("node:zlib"); }

var log$2 = {};

var hasRequiredLog$2;

function requireLog$2 () {
	if (hasRequiredLog$2) return log$2;
	hasRequiredLog$2 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(log$2, "__esModule", { value: true });
	log$2.logger = void 0;
	const logger_js_1 = requireLogger();
	log$2.logger = (0, logger_js_1.createClientLogger)("ts-http-runtime");
	
	return log$2;
}

var hasRequiredNodeHttpClient;

function requireNodeHttpClient () {
	if (hasRequiredNodeHttpClient) return nodeHttpClient;
	hasRequiredNodeHttpClient = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(nodeHttpClient, "__esModule", { value: true });
	nodeHttpClient.getBodyLength = getBodyLength;
	nodeHttpClient.createNodeHttpClient = createNodeHttpClient;
	const tslib_1 = require$$0$3;
	const node_http_1 = tslib_1.__importDefault(__require$5());
	const node_https_1 = tslib_1.__importDefault(__require$4());
	const node_zlib_1 = tslib_1.__importDefault(__require$3());
	const node_stream_1 = __require$a();
	const AbortError_js_1 = requireAbortError$1();
	const httpHeaders_js_1 = requireHttpHeaders$1();
	const restError_js_1 = requireRestError$2();
	const log_js_1 = requireLog$2();
	const sanitizer_js_1 = requireSanitizer();
	const DEFAULT_TLS_SETTINGS = {};
	function isReadableStream(body) {
	    return body && typeof body.pipe === "function";
	}
	function isStreamComplete(stream) {
	    if (stream.readable === false) {
	        return Promise.resolve();
	    }
	    return new Promise((resolve) => {
	        const handler = () => {
	            resolve();
	            stream.removeListener("close", handler);
	            stream.removeListener("end", handler);
	            stream.removeListener("error", handler);
	        };
	        stream.on("close", handler);
	        stream.on("end", handler);
	        stream.on("error", handler);
	    });
	}
	function isArrayBuffer(body) {
	    return body && typeof body.byteLength === "number";
	}
	class ReportTransform extends node_stream_1.Transform {
	    loadedBytes = 0;
	    progressCallback;
	    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
	    _transform(chunk, _encoding, callback) {
	        this.push(chunk);
	        this.loadedBytes += chunk.length;
	        try {
	            this.progressCallback({ loadedBytes: this.loadedBytes });
	            callback();
	        }
	        catch (e) {
	            callback(e);
	        }
	    }
	    constructor(progressCallback) {
	        super();
	        this.progressCallback = progressCallback;
	    }
	}
	/**
	 * A HttpClient implementation that uses Node's "https" module to send HTTPS requests.
	 * @internal
	 */
	class NodeHttpClient {
	    cachedHttpAgent;
	    cachedHttpsAgents = new WeakMap();
	    /**
	     * Makes a request over an underlying transport layer and returns the response.
	     * @param request - The request to be made.
	     */
	    async sendRequest(request) {
	        const abortController = new AbortController();
	        let abortListener;
	        if (request.abortSignal) {
	            if (request.abortSignal.aborted) {
	                throw new AbortError_js_1.AbortError("The operation was aborted. Request has already been canceled.");
	            }
	            abortListener = (event) => {
	                if (event.type === "abort") {
	                    abortController.abort();
	                }
	            };
	            request.abortSignal.addEventListener("abort", abortListener);
	        }
	        let timeoutId;
	        if (request.timeout > 0) {
	            timeoutId = setTimeout(() => {
	                const sanitizer = new sanitizer_js_1.Sanitizer();
	                log_js_1.logger.info(`request to '${sanitizer.sanitizeUrl(request.url)}' timed out. canceling...`);
	                abortController.abort();
	            }, request.timeout);
	        }
	        const acceptEncoding = request.headers.get("Accept-Encoding");
	        const shouldDecompress = acceptEncoding?.includes("gzip") || acceptEncoding?.includes("deflate");
	        let body = typeof request.body === "function" ? request.body() : request.body;
	        if (body && !request.headers.has("Content-Length")) {
	            const bodyLength = getBodyLength(body);
	            if (bodyLength !== null) {
	                request.headers.set("Content-Length", bodyLength);
	            }
	        }
	        let responseStream;
	        try {
	            if (body && request.onUploadProgress) {
	                const onUploadProgress = request.onUploadProgress;
	                const uploadReportStream = new ReportTransform(onUploadProgress);
	                uploadReportStream.on("error", (e) => {
	                    log_js_1.logger.error("Error in upload progress", e);
	                });
	                if (isReadableStream(body)) {
	                    body.pipe(uploadReportStream);
	                }
	                else {
	                    uploadReportStream.end(body);
	                }
	                body = uploadReportStream;
	            }
	            const res = await this.makeRequest(request, abortController, body);
	            if (timeoutId !== undefined) {
	                clearTimeout(timeoutId);
	            }
	            const headers = getResponseHeaders(res);
	            const status = res.statusCode ?? 0;
	            const response = {
	                status,
	                headers,
	                request,
	            };
	            // Responses to HEAD must not have a body.
	            // If they do return a body, that body must be ignored.
	            if (request.method === "HEAD") {
	                // call resume() and not destroy() to avoid closing the socket
	                // and losing keep alive
	                res.resume();
	                return response;
	            }
	            responseStream = shouldDecompress ? getDecodedResponseStream(res, headers) : res;
	            const onDownloadProgress = request.onDownloadProgress;
	            if (onDownloadProgress) {
	                const downloadReportStream = new ReportTransform(onDownloadProgress);
	                downloadReportStream.on("error", (e) => {
	                    log_js_1.logger.error("Error in download progress", e);
	                });
	                responseStream.pipe(downloadReportStream);
	                responseStream = downloadReportStream;
	            }
	            if (
	            // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code
	            request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||
	                request.streamResponseStatusCodes?.has(response.status)) {
	                response.readableStreamBody = responseStream;
	            }
	            else {
	                response.bodyAsText = await streamToText(responseStream);
	            }
	            return response;
	        }
	        finally {
	            // clean up event listener
	            if (request.abortSignal && abortListener) {
	                let uploadStreamDone = Promise.resolve();
	                if (isReadableStream(body)) {
	                    uploadStreamDone = isStreamComplete(body);
	                }
	                let downloadStreamDone = Promise.resolve();
	                if (isReadableStream(responseStream)) {
	                    downloadStreamDone = isStreamComplete(responseStream);
	                }
	                Promise.all([uploadStreamDone, downloadStreamDone])
	                    .then(() => {
	                    // eslint-disable-next-line promise/always-return
	                    if (abortListener) {
	                        request.abortSignal?.removeEventListener("abort", abortListener);
	                    }
	                })
	                    .catch((e) => {
	                    log_js_1.logger.warning("Error when cleaning up abortListener on httpRequest", e);
	                });
	            }
	        }
	    }
	    makeRequest(request, abortController, body) {
	        const url = new URL(request.url);
	        const isInsecure = url.protocol !== "https:";
	        if (isInsecure && !request.allowInsecureConnection) {
	            throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);
	        }
	        const agent = request.agent ?? this.getOrCreateAgent(request, isInsecure);
	        const options = {
	            agent,
	            hostname: url.hostname,
	            path: `${url.pathname}${url.search}`,
	            port: url.port,
	            method: request.method,
	            headers: request.headers.toJSON({ preserveCase: true }),
	            ...request.requestOverrides,
	        };
	        return new Promise((resolve, reject) => {
	            const req = isInsecure ? node_http_1.default.request(options, resolve) : node_https_1.default.request(options, resolve);
	            req.once("error", (err) => {
	                reject(new restError_js_1.RestError(err.message, { code: err.code ?? restError_js_1.RestError.REQUEST_SEND_ERROR, request }));
	            });
	            abortController.signal.addEventListener("abort", () => {
	                const abortError = new AbortError_js_1.AbortError("The operation was aborted. Rejecting from abort signal callback while making request.");
	                req.destroy(abortError);
	                reject(abortError);
	            });
	            if (body && isReadableStream(body)) {
	                body.pipe(req);
	            }
	            else if (body) {
	                if (typeof body === "string" || Buffer.isBuffer(body)) {
	                    req.end(body);
	                }
	                else if (isArrayBuffer(body)) {
	                    req.end(ArrayBuffer.isView(body) ? Buffer.from(body.buffer) : Buffer.from(body));
	                }
	                else {
	                    log_js_1.logger.error("Unrecognized body type", body);
	                    reject(new restError_js_1.RestError("Unrecognized body type"));
	                }
	            }
	            else {
	                // streams don't like "undefined" being passed as data
	                req.end();
	            }
	        });
	    }
	    getOrCreateAgent(request, isInsecure) {
	        const disableKeepAlive = request.disableKeepAlive;
	        // Handle Insecure requests first
	        if (isInsecure) {
	            if (disableKeepAlive) {
	                // keepAlive:false is the default so we don't need a custom Agent
	                return node_http_1.default.globalAgent;
	            }
	            if (!this.cachedHttpAgent) {
	                // If there is no cached agent create a new one and cache it.
	                this.cachedHttpAgent = new node_http_1.default.Agent({ keepAlive: true });
	            }
	            return this.cachedHttpAgent;
	        }
	        else {
	            if (disableKeepAlive && !request.tlsSettings) {
	                // When there are no tlsSettings and keepAlive is false
	                // we don't need a custom agent
	                return node_https_1.default.globalAgent;
	            }
	            // We use the tlsSettings to index cached clients
	            const tlsSettings = request.tlsSettings ?? DEFAULT_TLS_SETTINGS;
	            // Get the cached agent or create a new one with the
	            // provided values for keepAlive and tlsSettings
	            let agent = this.cachedHttpsAgents.get(tlsSettings);
	            if (agent && agent.options.keepAlive === !disableKeepAlive) {
	                return agent;
	            }
	            log_js_1.logger.info("No cached TLS Agent exist, creating a new Agent");
	            agent = new node_https_1.default.Agent({
	                // keepAlive is true if disableKeepAlive is false.
	                keepAlive: !disableKeepAlive,
	                // Since we are spreading, if no tslSettings were provided, nothing is added to the agent options.
	                ...tlsSettings,
	            });
	            this.cachedHttpsAgents.set(tlsSettings, agent);
	            return agent;
	        }
	    }
	}
	function getResponseHeaders(res) {
	    const headers = (0, httpHeaders_js_1.createHttpHeaders)();
	    for (const header of Object.keys(res.headers)) {
	        const value = res.headers[header];
	        if (Array.isArray(value)) {
	            if (value.length > 0) {
	                headers.set(header, value[0]);
	            }
	        }
	        else if (value) {
	            headers.set(header, value);
	        }
	    }
	    return headers;
	}
	function getDecodedResponseStream(stream, headers) {
	    const contentEncoding = headers.get("Content-Encoding");
	    if (contentEncoding === "gzip") {
	        const unzip = node_zlib_1.default.createGunzip();
	        stream.pipe(unzip);
	        return unzip;
	    }
	    else if (contentEncoding === "deflate") {
	        const inflate = node_zlib_1.default.createInflate();
	        stream.pipe(inflate);
	        return inflate;
	    }
	    return stream;
	}
	function streamToText(stream) {
	    return new Promise((resolve, reject) => {
	        const buffer = [];
	        stream.on("data", (chunk) => {
	            if (Buffer.isBuffer(chunk)) {
	                buffer.push(chunk);
	            }
	            else {
	                buffer.push(Buffer.from(chunk));
	            }
	        });
	        stream.on("end", () => {
	            resolve(Buffer.concat(buffer).toString("utf8"));
	        });
	        stream.on("error", (e) => {
	            if (e && e?.name === "AbortError") {
	                reject(e);
	            }
	            else {
	                reject(new restError_js_1.RestError(`Error reading response as text: ${e.message}`, {
	                    code: restError_js_1.RestError.PARSE_ERROR,
	                }));
	            }
	        });
	    });
	}
	/** @internal */
	function getBodyLength(body) {
	    if (!body) {
	        return 0;
	    }
	    else if (Buffer.isBuffer(body)) {
	        return body.length;
	    }
	    else if (isReadableStream(body)) {
	        return null;
	    }
	    else if (isArrayBuffer(body)) {
	        return body.byteLength;
	    }
	    else if (typeof body === "string") {
	        return Buffer.from(body).length;
	    }
	    else {
	        return null;
	    }
	}
	/**
	 * Create a new HttpClient instance for the NodeJS environment.
	 * @internal
	 */
	function createNodeHttpClient() {
	    return new NodeHttpClient();
	}
	
	return nodeHttpClient;
}

var hasRequiredDefaultHttpClient$1;

function requireDefaultHttpClient$1 () {
	if (hasRequiredDefaultHttpClient$1) return defaultHttpClient$1;
	hasRequiredDefaultHttpClient$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(defaultHttpClient$1, "__esModule", { value: true });
	defaultHttpClient$1.createDefaultHttpClient = createDefaultHttpClient;
	const nodeHttpClient_js_1 = requireNodeHttpClient();
	/**
	 * Create the correct HttpClient for the current environment.
	 */
	function createDefaultHttpClient() {
	    return (0, nodeHttpClient_js_1.createNodeHttpClient)();
	}
	
	return defaultHttpClient$1;
}

var getClient = {};

var clientHelpers = {};

var createPipelineFromOptions$1 = {};

var logPolicy$1 = {};

var hasRequiredLogPolicy$1;

function requireLogPolicy$1 () {
	if (hasRequiredLogPolicy$1) return logPolicy$1;
	hasRequiredLogPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.logPolicyName = void 0;
		exports$1.logPolicy = logPolicy;
		const log_js_1 = requireLog$2();
		const sanitizer_js_1 = requireSanitizer();
		/**
		 * The programmatic identifier of the logPolicy.
		 */
		exports$1.logPolicyName = "logPolicy";
		/**
		 * A policy that logs all requests and responses.
		 * @param options - Options to configure logPolicy.
		 */
		function logPolicy(options = {}) {
		    const logger = options.logger ?? log_js_1.logger.info;
		    const sanitizer = new sanitizer_js_1.Sanitizer({
		        additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,
		        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,
		    });
		    return {
		        name: exports$1.logPolicyName,
		        async sendRequest(request, next) {
		            if (!logger.enabled) {
		                return next(request);
		            }
		            logger(`Request: ${sanitizer.sanitize(request)}`);
		            const response = await next(request);
		            logger(`Response status code: ${response.status}`);
		            logger(`Headers: ${sanitizer.sanitize(response.headers)}`);
		            return response;
		        },
		    };
		}
		
	} (logPolicy$1));
	return logPolicy$1;
}

var redirectPolicy$1 = {};

var hasRequiredRedirectPolicy$1;

function requireRedirectPolicy$1 () {
	if (hasRequiredRedirectPolicy$1) return redirectPolicy$1;
	hasRequiredRedirectPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.redirectPolicyName = void 0;
		exports$1.redirectPolicy = redirectPolicy;
		/**
		 * The programmatic identifier of the redirectPolicy.
		 */
		exports$1.redirectPolicyName = "redirectPolicy";
		/**
		 * Methods that are allowed to follow redirects 301 and 302
		 */
		const allowedRedirect = ["GET", "HEAD"];
		/**
		 * A policy to follow Location headers from the server in order
		 * to support server-side redirection.
		 * In the browser, this policy is not used.
		 * @param options - Options to control policy behavior.
		 */
		function redirectPolicy(options = {}) {
		    const { maxRetries = 20 } = options;
		    return {
		        name: exports$1.redirectPolicyName,
		        async sendRequest(request, next) {
		            const response = await next(request);
		            return handleRedirect(next, response, maxRetries);
		        },
		    };
		}
		async function handleRedirect(next, response, maxRetries, currentRetries = 0) {
		    const { request, status, headers } = response;
		    const locationHeader = headers.get("location");
		    if (locationHeader &&
		        (status === 300 ||
		            (status === 301 && allowedRedirect.includes(request.method)) ||
		            (status === 302 && allowedRedirect.includes(request.method)) ||
		            (status === 303 && request.method === "POST") ||
		            status === 307) &&
		        currentRetries < maxRetries) {
		        const url = new URL(locationHeader, request.url);
		        request.url = url.toString();
		        // POST request with Status code 303 should be converted into a
		        // redirected GET request if the redirect url is present in the location header
		        if (status === 303) {
		            request.method = "GET";
		            request.headers.delete("Content-Length");
		            delete request.body;
		        }
		        request.headers.delete("Authorization");
		        const res = await next(request);
		        return handleRedirect(next, res, maxRetries, currentRetries + 1);
		    }
		    return response;
		}
		
	} (redirectPolicy$1));
	return redirectPolicy$1;
}

var userAgentPolicy$1 = {};

var userAgent$1 = {};

var userAgentPlatform$1 = {};

var hasRequiredUserAgentPlatform$1;

function requireUserAgentPlatform$1 () {
	if (hasRequiredUserAgentPlatform$1) return userAgentPlatform$1;
	hasRequiredUserAgentPlatform$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(userAgentPlatform$1, "__esModule", { value: true });
	userAgentPlatform$1.getHeaderName = getHeaderName;
	userAgentPlatform$1.setPlatformSpecificData = setPlatformSpecificData;
	const tslib_1 = require$$0$3;
	const node_os_1 = tslib_1.__importDefault(__require$9());
	const node_process_1 = tslib_1.__importDefault(__require$7());
	/**
	 * @internal
	 */
	function getHeaderName() {
	    return "User-Agent";
	}
	/**
	 * @internal
	 */
	async function setPlatformSpecificData(map) {
	    if (node_process_1.default && node_process_1.default.versions) {
	        const osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`;
	        const versions = node_process_1.default.versions;
	        if (versions.bun) {
	            map.set("Bun", `${versions.bun} (${osInfo})`);
	        }
	        else if (versions.deno) {
	            map.set("Deno", `${versions.deno} (${osInfo})`);
	        }
	        else if (versions.node) {
	            map.set("Node", `${versions.node} (${osInfo})`);
	        }
	    }
	}
	
	return userAgentPlatform$1;
}

var constants$1 = {};

var hasRequiredConstants$1;

function requireConstants$1 () {
	if (hasRequiredConstants$1) return constants$1;
	hasRequiredConstants$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(constants$1, "__esModule", { value: true });
	constants$1.DEFAULT_RETRY_POLICY_COUNT = constants$1.SDK_VERSION = void 0;
	constants$1.SDK_VERSION = "0.3.2";
	constants$1.DEFAULT_RETRY_POLICY_COUNT = 3;
	
	return constants$1;
}

var hasRequiredUserAgent$1;

function requireUserAgent$1 () {
	if (hasRequiredUserAgent$1) return userAgent$1;
	hasRequiredUserAgent$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(userAgent$1, "__esModule", { value: true });
	userAgent$1.getUserAgentHeaderName = getUserAgentHeaderName;
	userAgent$1.getUserAgentValue = getUserAgentValue;
	const userAgentPlatform_js_1 = requireUserAgentPlatform$1();
	const constants_js_1 = requireConstants$1();
	function getUserAgentString(telemetryInfo) {
	    const parts = [];
	    for (const [key, value] of telemetryInfo) {
	        const token = value ? `${key}/${value}` : key;
	        parts.push(token);
	    }
	    return parts.join(" ");
	}
	/**
	 * @internal
	 */
	function getUserAgentHeaderName() {
	    return (0, userAgentPlatform_js_1.getHeaderName)();
	}
	/**
	 * @internal
	 */
	async function getUserAgentValue(prefix) {
	    const runtimeInfo = new Map();
	    runtimeInfo.set("ts-http-runtime", constants_js_1.SDK_VERSION);
	    await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
	    const defaultAgent = getUserAgentString(runtimeInfo);
	    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
	    return userAgentValue;
	}
	
	return userAgent$1;
}

var hasRequiredUserAgentPolicy$1;

function requireUserAgentPolicy$1 () {
	if (hasRequiredUserAgentPolicy$1) return userAgentPolicy$1;
	hasRequiredUserAgentPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.userAgentPolicyName = void 0;
		exports$1.userAgentPolicy = userAgentPolicy;
		const userAgent_js_1 = requireUserAgent$1();
		const UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
		/**
		 * The programmatic identifier of the userAgentPolicy.
		 */
		exports$1.userAgentPolicyName = "userAgentPolicy";
		/**
		 * A policy that sets the User-Agent header (or equivalent) to reflect
		 * the library version.
		 * @param options - Options to customize the user agent value.
		 */
		function userAgentPolicy(options = {}) {
		    const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
		    return {
		        name: exports$1.userAgentPolicyName,
		        async sendRequest(request, next) {
		            if (!request.headers.has(UserAgentHeaderName)) {
		                request.headers.set(UserAgentHeaderName, await userAgentValue);
		            }
		            return next(request);
		        },
		    };
		}
		
	} (userAgentPolicy$1));
	return userAgentPolicy$1;
}

var decompressResponsePolicy$1 = {};

var hasRequiredDecompressResponsePolicy$1;

function requireDecompressResponsePolicy$1 () {
	if (hasRequiredDecompressResponsePolicy$1) return decompressResponsePolicy$1;
	hasRequiredDecompressResponsePolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.decompressResponsePolicyName = void 0;
		exports$1.decompressResponsePolicy = decompressResponsePolicy;
		/**
		 * The programmatic identifier of the decompressResponsePolicy.
		 */
		exports$1.decompressResponsePolicyName = "decompressResponsePolicy";
		/**
		 * A policy to enable response decompression according to Accept-Encoding header
		 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding
		 */
		function decompressResponsePolicy() {
		    return {
		        name: exports$1.decompressResponsePolicyName,
		        async sendRequest(request, next) {
		            // HEAD requests have no body
		            if (request.method !== "HEAD") {
		                request.headers.set("Accept-Encoding", "gzip,deflate");
		            }
		            return next(request);
		        },
		    };
		}
		
	} (decompressResponsePolicy$1));
	return decompressResponsePolicy$1;
}

var defaultRetryPolicy$1 = {};

var exponentialRetryStrategy = {};

var throttlingRetryStrategy = {};

var helpers$2 = {};

var hasRequiredHelpers$2;

function requireHelpers$2 () {
	if (hasRequiredHelpers$2) return helpers$2;
	hasRequiredHelpers$2 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(helpers$2, "__esModule", { value: true });
	helpers$2.delay = delay;
	helpers$2.parseHeaderValueAsNumber = parseHeaderValueAsNumber;
	const AbortError_js_1 = requireAbortError$1();
	const StandardAbortMessage = "The operation was aborted.";
	/**
	 * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.
	 * @param delayInMs - The number of milliseconds to be delayed.
	 * @param value - The value to be resolved with after a timeout of t milliseconds.
	 * @param options - The options for delay - currently abort options
	 *                  - abortSignal - The abortSignal associated with containing operation.
	 *                  - abortErrorMsg - The abort error message associated with containing operation.
	 * @returns Resolved promise
	 */
	function delay(delayInMs, value, options) {
	    return new Promise((resolve, reject) => {
	        let timer = undefined;
	        let onAborted = undefined;
	        const rejectOnAbort = () => {
	            return reject(new AbortError_js_1.AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage));
	        };
	        const removeListeners = () => {
	            if (options?.abortSignal && onAborted) {
	                options.abortSignal.removeEventListener("abort", onAborted);
	            }
	        };
	        onAborted = () => {
	            if (timer) {
	                clearTimeout(timer);
	            }
	            removeListeners();
	            return rejectOnAbort();
	        };
	        if (options?.abortSignal && options.abortSignal.aborted) {
	            return rejectOnAbort();
	        }
	        timer = setTimeout(() => {
	            removeListeners();
	            resolve(value);
	        }, delayInMs);
	        if (options?.abortSignal) {
	            options.abortSignal.addEventListener("abort", onAborted);
	        }
	    });
	}
	/**
	 * @internal
	 * @returns the parsed value or undefined if the parsed value is invalid.
	 */
	function parseHeaderValueAsNumber(response, headerName) {
	    const value = response.headers.get(headerName);
	    if (!value)
	        return;
	    const valueAsNum = Number(value);
	    if (Number.isNaN(valueAsNum))
	        return;
	    return valueAsNum;
	}
	
	return helpers$2;
}

var hasRequiredThrottlingRetryStrategy;

function requireThrottlingRetryStrategy () {
	if (hasRequiredThrottlingRetryStrategy) return throttlingRetryStrategy;
	hasRequiredThrottlingRetryStrategy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(throttlingRetryStrategy, "__esModule", { value: true });
	throttlingRetryStrategy.isThrottlingRetryResponse = isThrottlingRetryResponse;
	throttlingRetryStrategy.throttlingRetryStrategy = throttlingRetryStrategy$1;
	const helpers_js_1 = requireHelpers$2();
	/**
	 * The header that comes back from services representing
	 * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).
	 */
	const RetryAfterHeader = "Retry-After";
	/**
	 * The headers that come back from services representing
	 * the amount of time (minimum) to wait to retry.
	 *
	 * "retry-after-ms", "x-ms-retry-after-ms" : milliseconds
	 * "Retry-After" : seconds or timestamp
	 */
	const AllRetryAfterHeaders = ["retry-after-ms", "x-ms-retry-after-ms", RetryAfterHeader];
	/**
	 * A response is a throttling retry response if it has a throttling status code (429 or 503),
	 * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
	 *
	 * Returns the `retryAfterInMs` value if the response is a throttling retry response.
	 * If not throttling retry response, returns `undefined`.
	 *
	 * @internal
	 */
	function getRetryAfterInMs(response) {
	    if (!(response && [429, 503].includes(response.status)))
	        return undefined;
	    try {
	        // Headers: "retry-after-ms", "x-ms-retry-after-ms", "Retry-After"
	        for (const header of AllRetryAfterHeaders) {
	            const retryAfterValue = (0, helpers_js_1.parseHeaderValueAsNumber)(response, header);
	            if (retryAfterValue === 0 || retryAfterValue) {
	                // "Retry-After" header ==> seconds
	                // "retry-after-ms", "x-ms-retry-after-ms" headers ==> milli-seconds
	                const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;
	                return retryAfterValue * multiplyingFactor; // in milli-seconds
	            }
	        }
	        // RetryAfterHeader ("Retry-After") has a special case where it might be formatted as a date instead of a number of seconds
	        const retryAfterHeader = response.headers.get(RetryAfterHeader);
	        if (!retryAfterHeader)
	            return;
	        const date = Date.parse(retryAfterHeader);
	        const diff = date - Date.now();
	        // negative diff would mean a date in the past, so retry asap with 0 milliseconds
	        return Number.isFinite(diff) ? Math.max(0, diff) : undefined;
	    }
	    catch {
	        return undefined;
	    }
	}
	/**
	 * A response is a retry response if it has a throttling status code (429 or 503),
	 * as long as one of the [ "Retry-After" or "retry-after-ms" or "x-ms-retry-after-ms" ] headers has a valid value.
	 */
	function isThrottlingRetryResponse(response) {
	    return Number.isFinite(getRetryAfterInMs(response));
	}
	function throttlingRetryStrategy$1() {
	    return {
	        name: "throttlingRetryStrategy",
	        retry({ response }) {
	            const retryAfterInMs = getRetryAfterInMs(response);
	            if (!Number.isFinite(retryAfterInMs)) {
	                return { skipStrategy: true };
	            }
	            return {
	                retryAfterInMs,
	            };
	        },
	    };
	}
	
	return throttlingRetryStrategy;
}

var hasRequiredExponentialRetryStrategy;

function requireExponentialRetryStrategy () {
	if (hasRequiredExponentialRetryStrategy) return exponentialRetryStrategy;
	hasRequiredExponentialRetryStrategy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(exponentialRetryStrategy, "__esModule", { value: true });
	exponentialRetryStrategy.exponentialRetryStrategy = exponentialRetryStrategy$1;
	exponentialRetryStrategy.isExponentialRetryResponse = isExponentialRetryResponse;
	exponentialRetryStrategy.isSystemError = isSystemError;
	const delay_js_1 = requireDelay$1();
	const throttlingRetryStrategy_js_1 = requireThrottlingRetryStrategy();
	// intervals are in milliseconds
	const DEFAULT_CLIENT_RETRY_INTERVAL = 1000;
	const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
	/**
	 * A retry strategy that retries with an exponentially increasing delay in these two cases:
	 * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
	 * - Or otherwise if the outgoing request fails (408, greater or equal than 500, except for 501 and 505).
	 */
	function exponentialRetryStrategy$1(options = {}) {
	    const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;
	    const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
	    return {
	        name: "exponentialRetryStrategy",
	        retry({ retryCount, response, responseError }) {
	            const matchedSystemError = isSystemError(responseError);
	            const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;
	            const isExponential = isExponentialRetryResponse(response);
	            const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;
	            const unknownResponse = response && ((0, throttlingRetryStrategy_js_1.isThrottlingRetryResponse)(response) || !isExponential);
	            if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {
	                return { skipStrategy: true };
	            }
	            if (responseError && !matchedSystemError && !isExponential) {
	                return { errorToThrow: responseError };
	            }
	            return (0, delay_js_1.calculateRetryDelay)(retryCount, {
	                retryDelayInMs: retryInterval,
	                maxRetryDelayInMs: maxRetryInterval,
	            });
	        },
	    };
	}
	/**
	 * A response is a retry response if it has status codes:
	 * - 408, or
	 * - Greater or equal than 500, except for 501 and 505.
	 */
	function isExponentialRetryResponse(response) {
	    return Boolean(response &&
	        response.status !== undefined &&
	        (response.status >= 500 || response.status === 408) &&
	        response.status !== 501 &&
	        response.status !== 505);
	}
	/**
	 * Determines whether an error from a pipeline response was triggered in the network layer.
	 */
	function isSystemError(err) {
	    if (!err) {
	        return false;
	    }
	    return (err.code === "ETIMEDOUT" ||
	        err.code === "ESOCKETTIMEDOUT" ||
	        err.code === "ECONNREFUSED" ||
	        err.code === "ECONNRESET" ||
	        err.code === "ENOENT" ||
	        err.code === "ENOTFOUND");
	}
	
	return exponentialRetryStrategy;
}

var retryPolicy$1 = {};

var hasRequiredRetryPolicy$1;

function requireRetryPolicy$1 () {
	if (hasRequiredRetryPolicy$1) return retryPolicy$1;
	hasRequiredRetryPolicy$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(retryPolicy$1, "__esModule", { value: true });
	retryPolicy$1.retryPolicy = retryPolicy;
	const helpers_js_1 = requireHelpers$2();
	const AbortError_js_1 = requireAbortError$1();
	const logger_js_1 = requireLogger();
	const constants_js_1 = requireConstants$1();
	const retryPolicyLogger = (0, logger_js_1.createClientLogger)("ts-http-runtime retryPolicy");
	/**
	 * The programmatic identifier of the retryPolicy.
	 */
	const retryPolicyName = "retryPolicy";
	/**
	 * retryPolicy is a generic policy to enable retrying requests when certain conditions are met
	 */
	function retryPolicy(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
	    const logger = options.logger || retryPolicyLogger;
	    return {
	        name: retryPolicyName,
	        async sendRequest(request, next) {
	            let response;
	            let responseError;
	            let retryCount = -1;
	            retryRequest: while (true) {
	                retryCount += 1;
	                response = undefined;
	                responseError = undefined;
	                try {
	                    logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);
	                    response = await next(request);
	                    logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);
	                }
	                catch (e) {
	                    logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);
	                    // RestErrors are valid targets for the retry strategies.
	                    // If none of the retry strategies can work with them, they will be thrown later in this policy.
	                    // If the received error is not a RestError, it is immediately thrown.
	                    responseError = e;
	                    if (!e || responseError.name !== "RestError") {
	                        throw e;
	                    }
	                    response = responseError.response;
	                }
	                if (request.abortSignal?.aborted) {
	                    logger.error(`Retry ${retryCount}: Request aborted.`);
	                    const abortError = new AbortError_js_1.AbortError();
	                    throw abortError;
	                }
	                if (retryCount >= (options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT)) {
	                    logger.info(`Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`);
	                    if (responseError) {
	                        throw responseError;
	                    }
	                    else if (response) {
	                        return response;
	                    }
	                    else {
	                        throw new Error("Maximum retries reached with no response or error to throw");
	                    }
	                }
	                logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);
	                strategiesLoop: for (const strategy of strategies) {
	                    const strategyLogger = strategy.logger || logger;
	                    strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);
	                    const modifiers = strategy.retry({
	                        retryCount,
	                        response,
	                        responseError,
	                    });
	                    if (modifiers.skipStrategy) {
	                        strategyLogger.info(`Retry ${retryCount}: Skipped.`);
	                        continue strategiesLoop;
	                    }
	                    const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;
	                    if (errorToThrow) {
	                        strategyLogger.error(`Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`, errorToThrow);
	                        throw errorToThrow;
	                    }
	                    if (retryAfterInMs || retryAfterInMs === 0) {
	                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`);
	                        await (0, helpers_js_1.delay)(retryAfterInMs, undefined, { abortSignal: request.abortSignal });
	                        continue retryRequest;
	                    }
	                    if (redirectTo) {
	                        strategyLogger.info(`Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`);
	                        request.url = redirectTo;
	                        continue retryRequest;
	                    }
	                }
	                if (responseError) {
	                    logger.info(`None of the retry strategies could work with the received error. Throwing it.`);
	                    throw responseError;
	                }
	                if (response) {
	                    logger.info(`None of the retry strategies could work with the received response. Returning it.`);
	                    return response;
	                }
	                // If all the retries skip and there's no response,
	                // we're still in the retry loop, so a new request will be sent
	                // until `maxRetries` is reached.
	            }
	        },
	    };
	}
	
	return retryPolicy$1;
}

var hasRequiredDefaultRetryPolicy$1;

function requireDefaultRetryPolicy$1 () {
	if (hasRequiredDefaultRetryPolicy$1) return defaultRetryPolicy$1;
	hasRequiredDefaultRetryPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.defaultRetryPolicyName = void 0;
		exports$1.defaultRetryPolicy = defaultRetryPolicy;
		const exponentialRetryStrategy_js_1 = requireExponentialRetryStrategy();
		const throttlingRetryStrategy_js_1 = requireThrottlingRetryStrategy();
		const retryPolicy_js_1 = requireRetryPolicy$1();
		const constants_js_1 = requireConstants$1();
		/**
		 * Name of the {@link defaultRetryPolicy}
		 */
		exports$1.defaultRetryPolicyName = "defaultRetryPolicy";
		/**
		 * A policy that retries according to three strategies:
		 * - When the server sends a 429 response with a Retry-After header.
		 * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
		 * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.
		 */
		function defaultRetryPolicy(options = {}) {
		    return {
		        name: exports$1.defaultRetryPolicyName,
		        sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)(), (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)(options)], {
		            maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT,
		        }).sendRequest,
		    };
		}
		
	} (defaultRetryPolicy$1));
	return defaultRetryPolicy$1;
}

var formDataPolicy$1 = {};

var hasRequiredFormDataPolicy$1;

function requireFormDataPolicy$1 () {
	if (hasRequiredFormDataPolicy$1) return formDataPolicy$1;
	hasRequiredFormDataPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.formDataPolicyName = void 0;
		exports$1.formDataPolicy = formDataPolicy;
		const bytesEncoding_js_1 = requireBytesEncoding();
		const checkEnvironment_js_1 = requireCheckEnvironment();
		const httpHeaders_js_1 = requireHttpHeaders$1();
		/**
		 * The programmatic identifier of the formDataPolicy.
		 */
		exports$1.formDataPolicyName = "formDataPolicy";
		function formDataToFormDataMap(formData) {
		    const formDataMap = {};
		    for (const [key, value] of formData.entries()) {
		        formDataMap[key] ??= [];
		        formDataMap[key].push(value);
		    }
		    return formDataMap;
		}
		/**
		 * A policy that encodes FormData on the request into the body.
		 */
		function formDataPolicy() {
		    return {
		        name: exports$1.formDataPolicyName,
		        async sendRequest(request, next) {
		            if (checkEnvironment_js_1.isNodeLike && typeof FormData !== "undefined" && request.body instanceof FormData) {
		                request.formData = formDataToFormDataMap(request.body);
		                request.body = undefined;
		            }
		            if (request.formData) {
		                const contentType = request.headers.get("Content-Type");
		                if (contentType && contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
		                    request.body = wwwFormUrlEncode(request.formData);
		                }
		                else {
		                    await prepareFormData(request.formData, request);
		                }
		                request.formData = undefined;
		            }
		            return next(request);
		        },
		    };
		}
		function wwwFormUrlEncode(formData) {
		    const urlSearchParams = new URLSearchParams();
		    for (const [key, value] of Object.entries(formData)) {
		        if (Array.isArray(value)) {
		            for (const subValue of value) {
		                urlSearchParams.append(key, subValue.toString());
		            }
		        }
		        else {
		            urlSearchParams.append(key, value.toString());
		        }
		    }
		    return urlSearchParams.toString();
		}
		async function prepareFormData(formData, request) {
		    // validate content type (multipart/form-data)
		    const contentType = request.headers.get("Content-Type");
		    if (contentType && !contentType.startsWith("multipart/form-data")) {
		        // content type is specified and is not multipart/form-data. Exit.
		        return;
		    }
		    request.headers.set("Content-Type", contentType ?? "multipart/form-data");
		    // set body to MultipartRequestBody using content from FormDataMap
		    const parts = [];
		    for (const [fieldName, values] of Object.entries(formData)) {
		        for (const value of Array.isArray(values) ? values : [values]) {
		            if (typeof value === "string") {
		                parts.push({
		                    headers: (0, httpHeaders_js_1.createHttpHeaders)({
		                        "Content-Disposition": `form-data; name="${fieldName}"`,
		                    }),
		                    body: (0, bytesEncoding_js_1.stringToUint8Array)(value, "utf-8"),
		                });
		            }
		            else if (value === undefined || value === null || typeof value !== "object") {
		                throw new Error(`Unexpected value for key ${fieldName}: ${value}. Value should be serialized to string first.`);
		            }
		            else {
		                // using || instead of ?? here since if value.name is empty we should create a file name
		                const fileName = value.name || "blob";
		                const headers = (0, httpHeaders_js_1.createHttpHeaders)();
		                headers.set("Content-Disposition", `form-data; name="${fieldName}"; filename="${fileName}"`);
		                // again, || is used since an empty value.type means the content type is unset
		                headers.set("Content-Type", value.type || "application/octet-stream");
		                parts.push({
		                    headers,
		                    body: value,
		                });
		            }
		        }
		    }
		    request.multipartBody = { parts };
		}
		
	} (formDataPolicy$1));
	return formDataPolicy$1;
}

var proxyPolicy$1 = {};

var dist$2 = {};

var dist$1 = {};

var helpers$1 = {};

var hasRequiredHelpers$1;

function requireHelpers$1 () {
	if (hasRequiredHelpers$1) return helpers$1;
	hasRequiredHelpers$1 = 1;
	var __createBinding = (helpers$1 && helpers$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (helpers$1 && helpers$1.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (helpers$1 && helpers$1.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	Object.defineProperty(helpers$1, "__esModule", { value: true });
	helpers$1.req = helpers$1.json = helpers$1.toBuffer = void 0;
	const http = __importStar(require$$0$8);
	const https = __importStar(require$$1$2);
	async function toBuffer(stream) {
	    let length = 0;
	    const chunks = [];
	    for await (const chunk of stream) {
	        length += chunk.length;
	        chunks.push(chunk);
	    }
	    return Buffer.concat(chunks, length);
	}
	helpers$1.toBuffer = toBuffer;
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	async function json(stream) {
	    const buf = await toBuffer(stream);
	    const str = buf.toString('utf8');
	    try {
	        return JSON.parse(str);
	    }
	    catch (_err) {
	        const err = _err;
	        err.message += ` (input: ${str})`;
	        throw err;
	    }
	}
	helpers$1.json = json;
	function req(url, opts = {}) {
	    const href = typeof url === 'string' ? url : url.href;
	    const req = (href.startsWith('https:') ? https : http).request(url, opts);
	    const promise = new Promise((resolve, reject) => {
	        req
	            .once('response', resolve)
	            .once('error', reject)
	            .end();
	    });
	    req.then = promise.then.bind(promise);
	    return req;
	}
	helpers$1.req = req;
	
	return helpers$1;
}

var hasRequiredDist$2;

function requireDist$2 () {
	if (hasRequiredDist$2) return dist$1;
	hasRequiredDist$2 = 1;
	(function (exports$1) {
		var __createBinding = (dist$1 && dist$1.__createBinding) || (Object.create ? (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    var desc = Object.getOwnPropertyDescriptor(m, k);
		    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
		      desc = { enumerable: true, get: function() { return m[k]; } };
		    }
		    Object.defineProperty(o, k2, desc);
		}) : (function(o, m, k, k2) {
		    if (k2 === undefined) k2 = k;
		    o[k2] = m[k];
		}));
		var __setModuleDefault = (dist$1 && dist$1.__setModuleDefault) || (Object.create ? (function(o, v) {
		    Object.defineProperty(o, "default", { enumerable: true, value: v });
		}) : function(o, v) {
		    o["default"] = v;
		});
		var __importStar = (dist$1 && dist$1.__importStar) || function (mod) {
		    if (mod && mod.__esModule) return mod;
		    var result = {};
		    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
		    __setModuleDefault(result, mod);
		    return result;
		};
		var __exportStar = (dist$1 && dist$1.__exportStar) || function(m, exports$1) {
		    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports$1, p)) __createBinding(exports$1, m, p);
		};
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.Agent = void 0;
		const net = __importStar(require$$0$9);
		const http = __importStar(require$$0$8);
		const https_1 = require$$1$2;
		__exportStar(requireHelpers$1(), exports$1);
		const INTERNAL = Symbol('AgentBaseInternalState');
		class Agent extends http.Agent {
		    constructor(opts) {
		        super(opts);
		        this[INTERNAL] = {};
		    }
		    /**
		     * Determine whether this is an `http` or `https` request.
		     */
		    isSecureEndpoint(options) {
		        if (options) {
		            // First check the `secureEndpoint` property explicitly, since this
		            // means that a parent `Agent` is "passing through" to this instance.
		            // eslint-disable-next-line @typescript-eslint/no-explicit-any
		            if (typeof options.secureEndpoint === 'boolean') {
		                return options.secureEndpoint;
		            }
		            // If no explicit `secure` endpoint, check if `protocol` property is
		            // set. This will usually be the case since using a full string URL
		            // or `URL` instance should be the most common usage.
		            if (typeof options.protocol === 'string') {
		                return options.protocol === 'https:';
		            }
		        }
		        // Finally, if no `protocol` property was set, then fall back to
		        // checking the stack trace of the current call stack, and try to
		        // detect the "https" module.
		        const { stack } = new Error();
		        if (typeof stack !== 'string')
		            return false;
		        return stack
		            .split('\n')
		            .some((l) => l.indexOf('(https.js:') !== -1 ||
		            l.indexOf('node:https:') !== -1);
		    }
		    // In order to support async signatures in `connect()` and Node's native
		    // connection pooling in `http.Agent`, the array of sockets for each origin
		    // has to be updated synchronously. This is so the length of the array is
		    // accurate when `addRequest()` is next called. We achieve this by creating a
		    // fake socket and adding it to `sockets[origin]` and incrementing
		    // `totalSocketCount`.
		    incrementSockets(name) {
		        // If `maxSockets` and `maxTotalSockets` are both Infinity then there is no
		        // need to create a fake socket because Node.js native connection pooling
		        // will never be invoked.
		        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
		            return null;
		        }
		        // All instances of `sockets` are expected TypeScript errors. The
		        // alternative is to add it as a private property of this class but that
		        // will break TypeScript subclassing.
		        if (!this.sockets[name]) {
		            // @ts-expect-error `sockets` is readonly in `@types/node`
		            this.sockets[name] = [];
		        }
		        const fakeSocket = new net.Socket({ writable: false });
		        this.sockets[name].push(fakeSocket);
		        // @ts-expect-error `totalSocketCount` isn't defined in `@types/node`
		        this.totalSocketCount++;
		        return fakeSocket;
		    }
		    decrementSockets(name, socket) {
		        if (!this.sockets[name] || socket === null) {
		            return;
		        }
		        const sockets = this.sockets[name];
		        const index = sockets.indexOf(socket);
		        if (index !== -1) {
		            sockets.splice(index, 1);
		            // @ts-expect-error  `totalSocketCount` isn't defined in `@types/node`
		            this.totalSocketCount--;
		            if (sockets.length === 0) {
		                // @ts-expect-error `sockets` is readonly in `@types/node`
		                delete this.sockets[name];
		            }
		        }
		    }
		    // In order to properly update the socket pool, we need to call `getName()` on
		    // the core `https.Agent` if it is a secureEndpoint.
		    getName(options) {
		        const secureEndpoint = this.isSecureEndpoint(options);
		        if (secureEndpoint) {
		            // @ts-expect-error `getName()` isn't defined in `@types/node`
		            return https_1.Agent.prototype.getName.call(this, options);
		        }
		        // @ts-expect-error `getName()` isn't defined in `@types/node`
		        return super.getName(options);
		    }
		    createSocket(req, options, cb) {
		        const connectOpts = {
		            ...options,
		            secureEndpoint: this.isSecureEndpoint(options),
		        };
		        const name = this.getName(connectOpts);
		        const fakeSocket = this.incrementSockets(name);
		        Promise.resolve()
		            .then(() => this.connect(req, connectOpts))
		            .then((socket) => {
		            this.decrementSockets(name, fakeSocket);
		            if (socket instanceof http.Agent) {
		                try {
		                    // @ts-expect-error `addRequest()` isn't defined in `@types/node`
		                    return socket.addRequest(req, connectOpts);
		                }
		                catch (err) {
		                    return cb(err);
		                }
		            }
		            this[INTERNAL].currentSocket = socket;
		            // @ts-expect-error `createSocket()` isn't defined in `@types/node`
		            super.createSocket(req, options, cb);
		        }, (err) => {
		            this.decrementSockets(name, fakeSocket);
		            cb(err);
		        });
		    }
		    createConnection() {
		        const socket = this[INTERNAL].currentSocket;
		        this[INTERNAL].currentSocket = undefined;
		        if (!socket) {
		            throw new Error('No socket was returned in the `connect()` function');
		        }
		        return socket;
		    }
		    get defaultPort() {
		        return (this[INTERNAL].defaultPort ??
		            (this.protocol === 'https:' ? 443 : 80));
		    }
		    set defaultPort(v) {
		        if (this[INTERNAL]) {
		            this[INTERNAL].defaultPort = v;
		        }
		    }
		    get protocol() {
		        return (this[INTERNAL].protocol ??
		            (this.isSecureEndpoint() ? 'https:' : 'http:'));
		    }
		    set protocol(v) {
		        if (this[INTERNAL]) {
		            this[INTERNAL].protocol = v;
		        }
		    }
		}
		exports$1.Agent = Agent;
		
	} (dist$1));
	return dist$1;
}

var parseProxyResponse = {};

var hasRequiredParseProxyResponse;

function requireParseProxyResponse () {
	if (hasRequiredParseProxyResponse) return parseProxyResponse;
	hasRequiredParseProxyResponse = 1;
	var __importDefault = (parseProxyResponse && parseProxyResponse.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(parseProxyResponse, "__esModule", { value: true });
	parseProxyResponse.parseProxyResponse = void 0;
	const debug_1 = __importDefault(requireSrc());
	const debug = (0, debug_1.default)('https-proxy-agent:parse-proxy-response');
	function parseProxyResponse$1(socket) {
	    return new Promise((resolve, reject) => {
	        // we need to buffer any HTTP traffic that happens with the proxy before we get
	        // the CONNECT response, so that if the response is anything other than an "200"
	        // response code, then we can re-play the "data" events on the socket once the
	        // HTTP parser is hooked up...
	        let buffersLength = 0;
	        const buffers = [];
	        function read() {
	            const b = socket.read();
	            if (b)
	                ondata(b);
	            else
	                socket.once('readable', read);
	        }
	        function cleanup() {
	            socket.removeListener('end', onend);
	            socket.removeListener('error', onerror);
	            socket.removeListener('readable', read);
	        }
	        function onend() {
	            cleanup();
	            debug('onend');
	            reject(new Error('Proxy connection ended before receiving CONNECT response'));
	        }
	        function onerror(err) {
	            cleanup();
	            debug('onerror %o', err);
	            reject(err);
	        }
	        function ondata(b) {
	            buffers.push(b);
	            buffersLength += b.length;
	            const buffered = Buffer.concat(buffers, buffersLength);
	            const endOfHeaders = buffered.indexOf('\r\n\r\n');
	            if (endOfHeaders === -1) {
	                // keep buffering
	                debug('have not received end of HTTP headers yet...');
	                read();
	                return;
	            }
	            const headerParts = buffered
	                .slice(0, endOfHeaders)
	                .toString('ascii')
	                .split('\r\n');
	            const firstLine = headerParts.shift();
	            if (!firstLine) {
	                socket.destroy();
	                return reject(new Error('No header received from proxy CONNECT response'));
	            }
	            const firstLineParts = firstLine.split(' ');
	            const statusCode = +firstLineParts[1];
	            const statusText = firstLineParts.slice(2).join(' ');
	            const headers = {};
	            for (const header of headerParts) {
	                if (!header)
	                    continue;
	                const firstColon = header.indexOf(':');
	                if (firstColon === -1) {
	                    socket.destroy();
	                    return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
	                }
	                const key = header.slice(0, firstColon).toLowerCase();
	                const value = header.slice(firstColon + 1).trimStart();
	                const current = headers[key];
	                if (typeof current === 'string') {
	                    headers[key] = [current, value];
	                }
	                else if (Array.isArray(current)) {
	                    current.push(value);
	                }
	                else {
	                    headers[key] = value;
	                }
	            }
	            debug('got proxy server response: %o %o', firstLine, headers);
	            cleanup();
	            resolve({
	                connect: {
	                    statusCode,
	                    statusText,
	                    headers,
	                },
	                buffered,
	            });
	        }
	        socket.on('error', onerror);
	        socket.on('end', onend);
	        read();
	    });
	}
	parseProxyResponse.parseProxyResponse = parseProxyResponse$1;
	
	return parseProxyResponse;
}

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$2;
	hasRequiredDist$1 = 1;
	var __createBinding = (dist$2 && dist$2.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (dist$2 && dist$2.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (dist$2 && dist$2.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (dist$2 && dist$2.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(dist$2, "__esModule", { value: true });
	dist$2.HttpsProxyAgent = void 0;
	const net = __importStar(require$$0$9);
	const tls = __importStar(require$$1$3);
	const assert_1 = __importDefault(require$$2$2);
	const debug_1 = __importDefault(requireSrc());
	const agent_base_1 = requireDist$2();
	const url_1 = require$$5$2;
	const parse_proxy_response_1 = requireParseProxyResponse();
	const debug = (0, debug_1.default)('https-proxy-agent');
	const setServernameFromNonIpHost = (options) => {
	    if (options.servername === undefined &&
	        options.host &&
	        !net.isIP(options.host)) {
	        return {
	            ...options,
	            servername: options.host,
	        };
	    }
	    return options;
	};
	/**
	 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
	 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
	 *
	 * Outgoing HTTP requests are first tunneled through the proxy server using the
	 * `CONNECT` HTTP request method to establish a connection to the proxy server,
	 * and then the proxy server connects to the destination target and issues the
	 * HTTP request from the proxy server.
	 *
	 * `https:` requests have their socket connection upgraded to TLS once
	 * the connection to the proxy server has been established.
	 */
	class HttpsProxyAgent extends agent_base_1.Agent {
	    constructor(proxy, opts) {
	        super(opts);
	        this.options = { path: undefined };
	        this.proxy = typeof proxy === 'string' ? new url_1.URL(proxy) : proxy;
	        this.proxyHeaders = opts?.headers ?? {};
	        debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);
	        // Trim off the brackets from IPv6 addresses
	        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, '');
	        const port = this.proxy.port
	            ? parseInt(this.proxy.port, 10)
	            : this.proxy.protocol === 'https:'
	                ? 443
	                : 80;
	        this.connectOpts = {
	            // Attempt to negotiate http/1.1 for proxy servers that support http/2
	            ALPNProtocols: ['http/1.1'],
	            ...(opts ? omit(opts, 'headers') : null),
	            host,
	            port,
	        };
	    }
	    /**
	     * Called when the node-core HTTP client library is creating a
	     * new HTTP request.
	     */
	    async connect(req, opts) {
	        const { proxy } = this;
	        if (!opts.host) {
	            throw new TypeError('No "host" provided');
	        }
	        // Create a socket connection to the proxy server.
	        let socket;
	        if (proxy.protocol === 'https:') {
	            debug('Creating `tls.Socket`: %o', this.connectOpts);
	            socket = tls.connect(setServernameFromNonIpHost(this.connectOpts));
	        }
	        else {
	            debug('Creating `net.Socket`: %o', this.connectOpts);
	            socket = net.connect(this.connectOpts);
	        }
	        const headers = typeof this.proxyHeaders === 'function'
	            ? this.proxyHeaders()
	            : { ...this.proxyHeaders };
	        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
	        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
	        // Inject the `Proxy-Authorization` header if necessary.
	        if (proxy.username || proxy.password) {
	            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
	            headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;
	        }
	        headers.Host = `${host}:${opts.port}`;
	        if (!headers['Proxy-Connection']) {
	            headers['Proxy-Connection'] = this.keepAlive
	                ? 'Keep-Alive'
	                : 'close';
	        }
	        for (const name of Object.keys(headers)) {
	            payload += `${name}: ${headers[name]}\r\n`;
	        }
	        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
	        socket.write(`${payload}\r\n`);
	        const { connect, buffered } = await proxyResponsePromise;
	        req.emit('proxyConnect', connect);
	        this.emit('proxyConnect', connect, req);
	        if (connect.statusCode === 200) {
	            req.once('socket', resume);
	            if (opts.secureEndpoint) {
	                // The proxy is connecting to a TLS server, so upgrade
	                // this socket connection to a TLS connection.
	                debug('Upgrading socket connection to TLS');
	                return tls.connect({
	                    ...omit(setServernameFromNonIpHost(opts), 'host', 'path', 'port'),
	                    socket,
	                });
	            }
	            return socket;
	        }
	        // Some other status code that's not 200... need to re-play the HTTP
	        // header "data" events onto the socket once the HTTP machinery is
	        // attached so that the node core `http` can parse and handle the
	        // error status code.
	        // Close the original socket, and a new "fake" socket is returned
	        // instead, so that the proxy doesn't get the HTTP request
	        // written to it (which may contain `Authorization` headers or other
	        // sensitive data).
	        //
	        // See: https://hackerone.com/reports/541502
	        socket.destroy();
	        const fakeSocket = new net.Socket({ writable: false });
	        fakeSocket.readable = true;
	        // Need to wait for the "socket" event to re-play the "data" events.
	        req.once('socket', (s) => {
	            debug('Replaying proxy buffer for failed request');
	            (0, assert_1.default)(s.listenerCount('data') > 0);
	            // Replay the "buffered" Buffer onto the fake `socket`, since at
	            // this point the HTTP module machinery has been hooked up for
	            // the user.
	            s.push(buffered);
	            s.push(null);
	        });
	        return fakeSocket;
	    }
	}
	HttpsProxyAgent.protocols = ['http', 'https'];
	dist$2.HttpsProxyAgent = HttpsProxyAgent;
	function resume(socket) {
	    socket.resume();
	}
	function omit(obj, ...keys) {
	    const ret = {};
	    let key;
	    for (key in obj) {
	        if (!keys.includes(key)) {
	            ret[key] = obj[key];
	        }
	    }
	    return ret;
	}
	
	return dist$2;
}

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	var __createBinding = (dist && dist.__createBinding) || (Object.create ? (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    var desc = Object.getOwnPropertyDescriptor(m, k);
	    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
	      desc = { enumerable: true, get: function() { return m[k]; } };
	    }
	    Object.defineProperty(o, k2, desc);
	}) : (function(o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	}));
	var __setModuleDefault = (dist && dist.__setModuleDefault) || (Object.create ? (function(o, v) {
	    Object.defineProperty(o, "default", { enumerable: true, value: v });
	}) : function(o, v) {
	    o["default"] = v;
	});
	var __importStar = (dist && dist.__importStar) || function (mod) {
	    if (mod && mod.__esModule) return mod;
	    var result = {};
	    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
	    __setModuleDefault(result, mod);
	    return result;
	};
	var __importDefault = (dist && dist.__importDefault) || function (mod) {
	    return (mod && mod.__esModule) ? mod : { "default": mod };
	};
	Object.defineProperty(dist, "__esModule", { value: true });
	dist.HttpProxyAgent = void 0;
	const net = __importStar(require$$0$9);
	const tls = __importStar(require$$1$3);
	const debug_1 = __importDefault(requireSrc());
	const events_1 = require$$0$5;
	const agent_base_1 = requireDist$2();
	const url_1 = require$$5$2;
	const debug = (0, debug_1.default)('http-proxy-agent');
	/**
	 * The `HttpProxyAgent` implements an HTTP Agent subclass that connects
	 * to the specified "HTTP proxy server" in order to proxy HTTP requests.
	 */
	class HttpProxyAgent extends agent_base_1.Agent {
	    constructor(proxy, opts) {
	        super(opts);
	        this.proxy = typeof proxy === 'string' ? new url_1.URL(proxy) : proxy;
	        this.proxyHeaders = opts?.headers ?? {};
	        debug('Creating new HttpProxyAgent instance: %o', this.proxy.href);
	        // Trim off the brackets from IPv6 addresses
	        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, '');
	        const port = this.proxy.port
	            ? parseInt(this.proxy.port, 10)
	            : this.proxy.protocol === 'https:'
	                ? 443
	                : 80;
	        this.connectOpts = {
	            ...(opts ? omit(opts, 'headers') : null),
	            host,
	            port,
	        };
	    }
	    addRequest(req, opts) {
	        req._header = null;
	        this.setRequestProps(req, opts);
	        // @ts-expect-error `addRequest()` isn't defined in `@types/node`
	        super.addRequest(req, opts);
	    }
	    setRequestProps(req, opts) {
	        const { proxy } = this;
	        const protocol = opts.secureEndpoint ? 'https:' : 'http:';
	        const hostname = req.getHeader('host') || 'localhost';
	        const base = `${protocol}//${hostname}`;
	        const url = new url_1.URL(req.path, base);
	        if (opts.port !== 80) {
	            url.port = String(opts.port);
	        }
	        // Change the `http.ClientRequest` instance's "path" field
	        // to the absolute path of the URL that will be requested.
	        req.path = String(url);
	        // Inject the `Proxy-Authorization` header if necessary.
	        const headers = typeof this.proxyHeaders === 'function'
	            ? this.proxyHeaders()
	            : { ...this.proxyHeaders };
	        if (proxy.username || proxy.password) {
	            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
	            headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;
	        }
	        if (!headers['Proxy-Connection']) {
	            headers['Proxy-Connection'] = this.keepAlive
	                ? 'Keep-Alive'
	                : 'close';
	        }
	        for (const name of Object.keys(headers)) {
	            const value = headers[name];
	            if (value) {
	                req.setHeader(name, value);
	            }
	        }
	    }
	    async connect(req, opts) {
	        req._header = null;
	        if (!req.path.includes('://')) {
	            this.setRequestProps(req, opts);
	        }
	        // At this point, the http ClientRequest's internal `_header` field
	        // might have already been set. If this is the case then we'll need
	        // to re-generate the string since we just changed the `req.path`.
	        let first;
	        let endOfHeaders;
	        debug('Regenerating stored HTTP header string for request');
	        req._implicitHeader();
	        if (req.outputData && req.outputData.length > 0) {
	            debug('Patching connection write() output buffer with updated header');
	            first = req.outputData[0].data;
	            endOfHeaders = first.indexOf('\r\n\r\n') + 4;
	            req.outputData[0].data =
	                req._header + first.substring(endOfHeaders);
	            debug('Output buffer: %o', req.outputData[0].data);
	        }
	        // Create a socket connection to the proxy server.
	        let socket;
	        if (this.proxy.protocol === 'https:') {
	            debug('Creating `tls.Socket`: %o', this.connectOpts);
	            socket = tls.connect(this.connectOpts);
	        }
	        else {
	            debug('Creating `net.Socket`: %o', this.connectOpts);
	            socket = net.connect(this.connectOpts);
	        }
	        // Wait for the socket's `connect` event, so that this `callback()`
	        // function throws instead of the `http` request machinery. This is
	        // important for i.e. `PacProxyAgent` which determines a failed proxy
	        // connection via the `callback()` function throwing.
	        await (0, events_1.once)(socket, 'connect');
	        return socket;
	    }
	}
	HttpProxyAgent.protocols = ['http', 'https'];
	dist.HttpProxyAgent = HttpProxyAgent;
	function omit(obj, ...keys) {
	    const ret = {};
	    let key;
	    for (key in obj) {
	        if (!keys.includes(key)) {
	            ret[key] = obj[key];
	        }
	    }
	    return ret;
	}
	
	return dist;
}

var hasRequiredProxyPolicy$1;

function requireProxyPolicy$1 () {
	if (hasRequiredProxyPolicy$1) return proxyPolicy$1;
	hasRequiredProxyPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.globalNoProxyList = exports$1.proxyPolicyName = void 0;
		exports$1.loadNoProxy = loadNoProxy;
		exports$1.getDefaultProxySettings = getDefaultProxySettings;
		exports$1.proxyPolicy = proxyPolicy;
		const https_proxy_agent_1 = requireDist$1();
		const http_proxy_agent_1 = requireDist();
		const log_js_1 = requireLog$2();
		const HTTPS_PROXY = "HTTPS_PROXY";
		const HTTP_PROXY = "HTTP_PROXY";
		const ALL_PROXY = "ALL_PROXY";
		const NO_PROXY = "NO_PROXY";
		/**
		 * The programmatic identifier of the proxyPolicy.
		 */
		exports$1.proxyPolicyName = "proxyPolicy";
		/**
		 * Stores the patterns specified in NO_PROXY environment variable.
		 * @internal
		 */
		exports$1.globalNoProxyList = [];
		let noProxyListLoaded = false;
		/** A cache of whether a host should bypass the proxy. */
		const globalBypassedMap = new Map();
		function getEnvironmentValue(name) {
		    if (process.env[name]) {
		        return process.env[name];
		    }
		    else if (process.env[name.toLowerCase()]) {
		        return process.env[name.toLowerCase()];
		    }
		    return undefined;
		}
		function loadEnvironmentProxyValue() {
		    if (!process) {
		        return undefined;
		    }
		    const httpsProxy = getEnvironmentValue(HTTPS_PROXY);
		    const allProxy = getEnvironmentValue(ALL_PROXY);
		    const httpProxy = getEnvironmentValue(HTTP_PROXY);
		    return httpsProxy || allProxy || httpProxy;
		}
		/**
		 * Check whether the host of a given `uri` matches any pattern in the no proxy list.
		 * If there's a match, any request sent to the same host shouldn't have the proxy settings set.
		 * This implementation is a port of https://github.com/Azure/azure-sdk-for-net/blob/8cca811371159e527159c7eb65602477898683e2/sdk/core/Azure.Core/src/Pipeline/Internal/HttpEnvironmentProxy.cs#L210
		 */
		function isBypassed(uri, noProxyList, bypassedMap) {
		    if (noProxyList.length === 0) {
		        return false;
		    }
		    const host = new URL(uri).hostname;
		    if (bypassedMap?.has(host)) {
		        return bypassedMap.get(host);
		    }
		    let isBypassedFlag = false;
		    for (const pattern of noProxyList) {
		        if (pattern[0] === ".") {
		            // This should match either domain it self or any subdomain or host
		            // .foo.com will match foo.com it self or *.foo.com
		            if (host.endsWith(pattern)) {
		                isBypassedFlag = true;
		            }
		            else {
		                if (host.length === pattern.length - 1 && host === pattern.slice(1)) {
		                    isBypassedFlag = true;
		                }
		            }
		        }
		        else {
		            if (host === pattern) {
		                isBypassedFlag = true;
		            }
		        }
		    }
		    bypassedMap?.set(host, isBypassedFlag);
		    return isBypassedFlag;
		}
		function loadNoProxy() {
		    const noProxy = getEnvironmentValue(NO_PROXY);
		    noProxyListLoaded = true;
		    if (noProxy) {
		        return noProxy
		            .split(",")
		            .map((item) => item.trim())
		            .filter((item) => item.length);
		    }
		    return [];
		}
		/**
		 * This method converts a proxy url into `ProxySettings` for use with ProxyPolicy.
		 * If no argument is given, it attempts to parse a proxy URL from the environment
		 * variables `HTTPS_PROXY` or `HTTP_PROXY`.
		 * @param proxyUrl - The url of the proxy to use. May contain authentication information.
		 * @deprecated - Internally this method is no longer necessary when setting proxy information.
		 */
		function getDefaultProxySettings(proxyUrl) {
		    if (!proxyUrl) {
		        proxyUrl = loadEnvironmentProxyValue();
		        if (!proxyUrl) {
		            return undefined;
		        }
		    }
		    const parsedUrl = new URL(proxyUrl);
		    const schema = parsedUrl.protocol ? parsedUrl.protocol + "//" : "";
		    return {
		        host: schema + parsedUrl.hostname,
		        port: Number.parseInt(parsedUrl.port || "80"),
		        username: parsedUrl.username,
		        password: parsedUrl.password,
		    };
		}
		/**
		 * This method attempts to parse a proxy URL from the environment
		 * variables `HTTPS_PROXY` or `HTTP_PROXY`.
		 */
		function getDefaultProxySettingsInternal() {
		    const envProxy = loadEnvironmentProxyValue();
		    return envProxy ? new URL(envProxy) : undefined;
		}
		function getUrlFromProxySettings(settings) {
		    let parsedProxyUrl;
		    try {
		        parsedProxyUrl = new URL(settings.host);
		    }
		    catch {
		        throw new Error(`Expecting a valid host string in proxy settings, but found "${settings.host}".`);
		    }
		    parsedProxyUrl.port = String(settings.port);
		    if (settings.username) {
		        parsedProxyUrl.username = settings.username;
		    }
		    if (settings.password) {
		        parsedProxyUrl.password = settings.password;
		    }
		    return parsedProxyUrl;
		}
		function setProxyAgentOnRequest(request, cachedAgents, proxyUrl) {
		    // Custom Agent should take precedence so if one is present
		    // we should skip to avoid overwriting it.
		    if (request.agent) {
		        return;
		    }
		    const url = new URL(request.url);
		    const isInsecure = url.protocol !== "https:";
		    if (request.tlsSettings) {
		        log_js_1.logger.warning("TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.");
		    }
		    const headers = request.headers.toJSON();
		    if (isInsecure) {
		        if (!cachedAgents.httpProxyAgent) {
		            cachedAgents.httpProxyAgent = new http_proxy_agent_1.HttpProxyAgent(proxyUrl, { headers });
		        }
		        request.agent = cachedAgents.httpProxyAgent;
		    }
		    else {
		        if (!cachedAgents.httpsProxyAgent) {
		            cachedAgents.httpsProxyAgent = new https_proxy_agent_1.HttpsProxyAgent(proxyUrl, { headers });
		        }
		        request.agent = cachedAgents.httpsProxyAgent;
		    }
		}
		/**
		 * A policy that allows one to apply proxy settings to all requests.
		 * If not passed static settings, they will be retrieved from the HTTPS_PROXY
		 * or HTTP_PROXY environment variables.
		 * @param proxySettings - ProxySettings to use on each request.
		 * @param options - additional settings, for example, custom NO_PROXY patterns
		 */
		function proxyPolicy(proxySettings, options) {
		    if (!noProxyListLoaded) {
		        exports$1.globalNoProxyList.push(...loadNoProxy());
		    }
		    const defaultProxy = proxySettings
		        ? getUrlFromProxySettings(proxySettings)
		        : getDefaultProxySettingsInternal();
		    const cachedAgents = {};
		    return {
		        name: exports$1.proxyPolicyName,
		        async sendRequest(request, next) {
		            if (!request.proxySettings &&
		                defaultProxy &&
		                !isBypassed(request.url, options?.customNoProxyList ?? exports$1.globalNoProxyList, options?.customNoProxyList ? undefined : globalBypassedMap)) {
		                setProxyAgentOnRequest(request, cachedAgents, defaultProxy);
		            }
		            else if (request.proxySettings) {
		                setProxyAgentOnRequest(request, cachedAgents, getUrlFromProxySettings(request.proxySettings));
		            }
		            return next(request);
		        },
		    };
		}
		
	} (proxyPolicy$1));
	return proxyPolicy$1;
}

var agentPolicy$1 = {};

var hasRequiredAgentPolicy$1;

function requireAgentPolicy$1 () {
	if (hasRequiredAgentPolicy$1) return agentPolicy$1;
	hasRequiredAgentPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.agentPolicyName = void 0;
		exports$1.agentPolicy = agentPolicy;
		/**
		 * Name of the Agent Policy
		 */
		exports$1.agentPolicyName = "agentPolicy";
		/**
		 * Gets a pipeline policy that sets http.agent
		 */
		function agentPolicy(agent) {
		    return {
		        name: exports$1.agentPolicyName,
		        sendRequest: async (req, next) => {
		            // Users may define an agent on the request, honor it over the client level one
		            if (!req.agent) {
		                req.agent = agent;
		            }
		            return next(req);
		        },
		    };
		}
		
	} (agentPolicy$1));
	return agentPolicy$1;
}

var tlsPolicy$1 = {};

var hasRequiredTlsPolicy$1;

function requireTlsPolicy$1 () {
	if (hasRequiredTlsPolicy$1) return tlsPolicy$1;
	hasRequiredTlsPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.tlsPolicyName = void 0;
		exports$1.tlsPolicy = tlsPolicy;
		/**
		 * Name of the TLS Policy
		 */
		exports$1.tlsPolicyName = "tlsPolicy";
		/**
		 * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.
		 */
		function tlsPolicy(tlsSettings) {
		    return {
		        name: exports$1.tlsPolicyName,
		        sendRequest: async (req, next) => {
		            // Users may define a request tlsSettings, honor those over the client level one
		            if (!req.tlsSettings) {
		                req.tlsSettings = tlsSettings;
		            }
		            return next(req);
		        },
		    };
		}
		
	} (tlsPolicy$1));
	return tlsPolicy$1;
}

var multipartPolicy$1 = {};

var typeGuards = {};

var hasRequiredTypeGuards;

function requireTypeGuards () {
	if (hasRequiredTypeGuards) return typeGuards;
	hasRequiredTypeGuards = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(typeGuards, "__esModule", { value: true });
	typeGuards.isNodeReadableStream = isNodeReadableStream;
	typeGuards.isWebReadableStream = isWebReadableStream;
	typeGuards.isBinaryBody = isBinaryBody;
	typeGuards.isReadableStream = isReadableStream;
	typeGuards.isBlob = isBlob;
	function isNodeReadableStream(x) {
	    return Boolean(x && typeof x["pipe"] === "function");
	}
	function isWebReadableStream(x) {
	    return Boolean(x &&
	        typeof x.getReader === "function" &&
	        typeof x.tee === "function");
	}
	function isBinaryBody(body) {
	    return (body !== undefined &&
	        (body instanceof Uint8Array ||
	            isReadableStream(body) ||
	            typeof body === "function" ||
	            body instanceof Blob));
	}
	function isReadableStream(x) {
	    return isNodeReadableStream(x) || isWebReadableStream(x);
	}
	function isBlob(x) {
	    return typeof x.stream === "function";
	}
	
	return typeGuards;
}

var concat = {};

var hasRequiredConcat;

function requireConcat () {
	if (hasRequiredConcat) return concat;
	hasRequiredConcat = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(concat, "__esModule", { value: true });
	concat.concat = concat$1;
	const stream_1 = require$$0$6;
	const typeGuards_js_1 = requireTypeGuards();
	async function* streamAsyncIterator() {
	    const reader = this.getReader();
	    try {
	        while (true) {
	            const { done, value } = await reader.read();
	            if (done) {
	                return;
	            }
	            yield value;
	        }
	    }
	    finally {
	        reader.releaseLock();
	    }
	}
	function makeAsyncIterable(webStream) {
	    if (!webStream[Symbol.asyncIterator]) {
	        webStream[Symbol.asyncIterator] = streamAsyncIterator.bind(webStream);
	    }
	    if (!webStream.values) {
	        webStream.values = streamAsyncIterator.bind(webStream);
	    }
	}
	function ensureNodeStream(stream) {
	    if (stream instanceof ReadableStream) {
	        makeAsyncIterable(stream);
	        return stream_1.Readable.fromWeb(stream);
	    }
	    else {
	        return stream;
	    }
	}
	function toStream(source) {
	    if (source instanceof Uint8Array) {
	        return stream_1.Readable.from(Buffer.from(source));
	    }
	    else if ((0, typeGuards_js_1.isBlob)(source)) {
	        return ensureNodeStream(source.stream());
	    }
	    else {
	        return ensureNodeStream(source);
	    }
	}
	/**
	 * Utility function that concatenates a set of binary inputs into one combined output.
	 *
	 * @param sources - array of sources for the concatenation
	 * @returns - in Node, a (() =\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.
	 *           In browser, returns a `Blob` representing all the concatenated inputs.
	 *
	 * @internal
	 */
	async function concat$1(sources) {
	    return function () {
	        const streams = sources.map((x) => (typeof x === "function" ? x() : x)).map(toStream);
	        return stream_1.Readable.from((async function* () {
	            for (const stream of streams) {
	                for await (const chunk of stream) {
	                    yield chunk;
	                }
	            }
	        })());
	    };
	}
	
	return concat;
}

var hasRequiredMultipartPolicy$1;

function requireMultipartPolicy$1 () {
	if (hasRequiredMultipartPolicy$1) return multipartPolicy$1;
	hasRequiredMultipartPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.multipartPolicyName = void 0;
		exports$1.multipartPolicy = multipartPolicy;
		const bytesEncoding_js_1 = requireBytesEncoding();
		const typeGuards_js_1 = requireTypeGuards();
		const uuidUtils_js_1 = requireUuidUtils();
		const concat_js_1 = requireConcat();
		function generateBoundary() {
		    return `----AzSDKFormBoundary${(0, uuidUtils_js_1.randomUUID)()}`;
		}
		function encodeHeaders(headers) {
		    let result = "";
		    for (const [key, value] of headers) {
		        result += `${key}: ${value}\r\n`;
		    }
		    return result;
		}
		function getLength(source) {
		    if (source instanceof Uint8Array) {
		        return source.byteLength;
		    }
		    else if ((0, typeGuards_js_1.isBlob)(source)) {
		        // if was created using createFile then -1 means we have an unknown size
		        return source.size === -1 ? undefined : source.size;
		    }
		    else {
		        return undefined;
		    }
		}
		function getTotalLength(sources) {
		    let total = 0;
		    for (const source of sources) {
		        const partLength = getLength(source);
		        if (partLength === undefined) {
		            return undefined;
		        }
		        else {
		            total += partLength;
		        }
		    }
		    return total;
		}
		async function buildRequestBody(request, parts, boundary) {
		    const sources = [
		        (0, bytesEncoding_js_1.stringToUint8Array)(`--${boundary}`, "utf-8"),
		        ...parts.flatMap((part) => [
		            (0, bytesEncoding_js_1.stringToUint8Array)("\r\n", "utf-8"),
		            (0, bytesEncoding_js_1.stringToUint8Array)(encodeHeaders(part.headers), "utf-8"),
		            (0, bytesEncoding_js_1.stringToUint8Array)("\r\n", "utf-8"),
		            part.body,
		            (0, bytesEncoding_js_1.stringToUint8Array)(`\r\n--${boundary}`, "utf-8"),
		        ]),
		        (0, bytesEncoding_js_1.stringToUint8Array)("--\r\n\r\n", "utf-8"),
		    ];
		    const contentLength = getTotalLength(sources);
		    if (contentLength) {
		        request.headers.set("Content-Length", contentLength);
		    }
		    request.body = await (0, concat_js_1.concat)(sources);
		}
		/**
		 * Name of multipart policy
		 */
		exports$1.multipartPolicyName = "multipartPolicy";
		const maxBoundaryLength = 70;
		const validBoundaryCharacters = new Set(`abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`);
		function assertValidBoundary(boundary) {
		    if (boundary.length > maxBoundaryLength) {
		        throw new Error(`Multipart boundary "${boundary}" exceeds maximum length of 70 characters`);
		    }
		    if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {
		        throw new Error(`Multipart boundary "${boundary}" contains invalid characters`);
		    }
		}
		/**
		 * Pipeline policy for multipart requests
		 */
		function multipartPolicy() {
		    return {
		        name: exports$1.multipartPolicyName,
		        async sendRequest(request, next) {
		            if (!request.multipartBody) {
		                return next(request);
		            }
		            if (request.body) {
		                throw new Error("multipartBody and regular body cannot be set at the same time");
		            }
		            let boundary = request.multipartBody.boundary;
		            const contentTypeHeader = request.headers.get("Content-Type") ?? "multipart/mixed";
		            const parsedHeader = contentTypeHeader.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
		            if (!parsedHeader) {
		                throw new Error(`Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`);
		            }
		            const [, contentType, parsedBoundary] = parsedHeader;
		            if (parsedBoundary && boundary && parsedBoundary !== boundary) {
		                throw new Error(`Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`);
		            }
		            boundary ??= parsedBoundary;
		            if (boundary) {
		                assertValidBoundary(boundary);
		            }
		            else {
		                boundary = generateBoundary();
		            }
		            request.headers.set("Content-Type", `${contentType}; boundary=${boundary}`);
		            await buildRequestBody(request, request.multipartBody.parts, boundary);
		            request.multipartBody = undefined;
		            return next(request);
		        },
		    };
		}
		
	} (multipartPolicy$1));
	return multipartPolicy$1;
}

var hasRequiredCreatePipelineFromOptions$1;

function requireCreatePipelineFromOptions$1 () {
	if (hasRequiredCreatePipelineFromOptions$1) return createPipelineFromOptions$1;
	hasRequiredCreatePipelineFromOptions$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(createPipelineFromOptions$1, "__esModule", { value: true });
	createPipelineFromOptions$1.createPipelineFromOptions = createPipelineFromOptions;
	const logPolicy_js_1 = requireLogPolicy$1();
	const pipeline_js_1 = requirePipeline$3();
	const redirectPolicy_js_1 = requireRedirectPolicy$1();
	const userAgentPolicy_js_1 = requireUserAgentPolicy$1();
	const decompressResponsePolicy_js_1 = requireDecompressResponsePolicy$1();
	const defaultRetryPolicy_js_1 = requireDefaultRetryPolicy$1();
	const formDataPolicy_js_1 = requireFormDataPolicy$1();
	const checkEnvironment_js_1 = requireCheckEnvironment();
	const proxyPolicy_js_1 = requireProxyPolicy$1();
	const agentPolicy_js_1 = requireAgentPolicy$1();
	const tlsPolicy_js_1 = requireTlsPolicy$1();
	const multipartPolicy_js_1 = requireMultipartPolicy$1();
	/**
	 * Create a new pipeline with a default set of customizable policies.
	 * @param options - Options to configure a custom pipeline.
	 */
	function createPipelineFromOptions(options) {
	    const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
	    if (checkEnvironment_js_1.isNodeLike) {
	        if (options.agent) {
	            pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
	        }
	        if (options.tlsOptions) {
	            pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
	        }
	        pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
	        pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
	    }
	    pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
	    pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
	    // The multipart policy is added after policies with no phase, so that
	    // policies can be added between it and formDataPolicy to modify
	    // properties (e.g., making the boundary constant in recorded tests).
	    pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
	    pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
	    if (checkEnvironment_js_1.isNodeLike) {
	        // Both XHR and Fetch expect to handle redirects automatically,
	        // so only include this policy when we're in Node.
	        pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
	    }
	    pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
	    return pipeline;
	}
	
	return createPipelineFromOptions$1;
}

var apiVersionPolicy = {};

var hasRequiredApiVersionPolicy;

function requireApiVersionPolicy () {
	if (hasRequiredApiVersionPolicy) return apiVersionPolicy;
	hasRequiredApiVersionPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.apiVersionPolicyName = void 0;
		exports$1.apiVersionPolicy = apiVersionPolicy;
		exports$1.apiVersionPolicyName = "ApiVersionPolicy";
		/**
		 * Creates a policy that sets the apiVersion as a query parameter on every request
		 * @param options - Client options
		 * @returns Pipeline policy that sets the apiVersion as a query parameter on every request
		 */
		function apiVersionPolicy(options) {
		    return {
		        name: exports$1.apiVersionPolicyName,
		        sendRequest: (req, next) => {
		            // Use the apiVesion defined in request url directly
		            // Append one if there is no apiVesion and we have one at client options
		            const url = new URL(req.url);
		            if (!url.searchParams.get("api-version") && options.apiVersion) {
		                req.url = `${req.url}${Array.from(url.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${options.apiVersion}`;
		            }
		            return next(req);
		        },
		    };
		}
		
	} (apiVersionPolicy));
	return apiVersionPolicy;
}

var credentials = {};

var hasRequiredCredentials;

function requireCredentials () {
	if (hasRequiredCredentials) return credentials;
	hasRequiredCredentials = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(credentials, "__esModule", { value: true });
	credentials.isOAuth2TokenCredential = isOAuth2TokenCredential;
	credentials.isBearerTokenCredential = isBearerTokenCredential;
	credentials.isBasicCredential = isBasicCredential;
	credentials.isApiKeyCredential = isApiKeyCredential;
	/**
	 * Type guard to check if a credential is an OAuth2 token credential.
	 */
	function isOAuth2TokenCredential(credential) {
	    return "getOAuth2Token" in credential;
	}
	/**
	 * Type guard to check if a credential is a Bearer token credential.
	 */
	function isBearerTokenCredential(credential) {
	    return "getBearerToken" in credential;
	}
	/**
	 * Type guard to check if a credential is a Basic auth credential.
	 */
	function isBasicCredential(credential) {
	    return "username" in credential && "password" in credential;
	}
	/**
	 * Type guard to check if a credential is an API key credential.
	 */
	function isApiKeyCredential(credential) {
	    return "key" in credential;
	}
	
	return credentials;
}

var apiKeyAuthenticationPolicy = {};

var checkInsecureConnection = {};

var hasRequiredCheckInsecureConnection;

function requireCheckInsecureConnection () {
	if (hasRequiredCheckInsecureConnection) return checkInsecureConnection;
	hasRequiredCheckInsecureConnection = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(checkInsecureConnection, "__esModule", { value: true });
	checkInsecureConnection.ensureSecureConnection = ensureSecureConnection;
	const log_js_1 = requireLog$2();
	// Ensure the warining is only emitted once
	let insecureConnectionWarningEmmitted = false;
	/**
	 * Checks if the request is allowed to be sent over an insecure connection.
	 *
	 * A request is allowed to be sent over an insecure connection when:
	 * - The `allowInsecureConnection` option is set to `true`.
	 * - The request has the `allowInsecureConnection` property set to `true`.
	 * - The request is being sent to `localhost` or `127.0.0.1`
	 */
	function allowInsecureConnection(request, options) {
	    if (options.allowInsecureConnection && request.allowInsecureConnection) {
	        const url = new URL(request.url);
	        if (url.hostname === "localhost" || url.hostname === "127.0.0.1") {
	            return true;
	        }
	    }
	    return false;
	}
	/**
	 * Logs a warning about sending a token over an insecure connection.
	 *
	 * This function will emit a node warning once, but log the warning every time.
	 */
	function emitInsecureConnectionWarning() {
	    const warning = "Sending token over insecure transport. Assume any token issued is compromised.";
	    log_js_1.logger.warning(warning);
	    if (typeof process?.emitWarning === "function" && !insecureConnectionWarningEmmitted) {
	        insecureConnectionWarningEmmitted = true;
	        process.emitWarning(warning);
	    }
	}
	/**
	 * Ensures that authentication is only allowed over HTTPS unless explicitly allowed.
	 * Throws an error if the connection is not secure and not explicitly allowed.
	 */
	function ensureSecureConnection(request, options) {
	    if (!request.url.toLowerCase().startsWith("https://")) {
	        if (allowInsecureConnection(request, options)) {
	            emitInsecureConnectionWarning();
	        }
	        else {
	            throw new Error("Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.");
	        }
	    }
	}
	
	return checkInsecureConnection;
}

var hasRequiredApiKeyAuthenticationPolicy;

function requireApiKeyAuthenticationPolicy () {
	if (hasRequiredApiKeyAuthenticationPolicy) return apiKeyAuthenticationPolicy;
	hasRequiredApiKeyAuthenticationPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.apiKeyAuthenticationPolicyName = void 0;
		exports$1.apiKeyAuthenticationPolicy = apiKeyAuthenticationPolicy;
		const checkInsecureConnection_js_1 = requireCheckInsecureConnection();
		/**
		 * Name of the API Key Authentication Policy
		 */
		exports$1.apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
		/**
		 * Gets a pipeline policy that adds API key authentication to requests
		 */
		function apiKeyAuthenticationPolicy(options) {
		    return {
		        name: exports$1.apiKeyAuthenticationPolicyName,
		        async sendRequest(request, next) {
		            // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
		            (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
		            const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "apiKey");
		            // Skip adding authentication header if no API key authentication scheme is found
		            if (!scheme) {
		                return next(request);
		            }
		            if (scheme.apiKeyLocation !== "header") {
		                throw new Error(`Unsupported API key location: ${scheme.apiKeyLocation}`);
		            }
		            request.headers.set(scheme.name, options.credential.key);
		            return next(request);
		        },
		    };
		}
		
	} (apiKeyAuthenticationPolicy));
	return apiKeyAuthenticationPolicy;
}

var basicAuthenticationPolicy = {};

var hasRequiredBasicAuthenticationPolicy;

function requireBasicAuthenticationPolicy () {
	if (hasRequiredBasicAuthenticationPolicy) return basicAuthenticationPolicy;
	hasRequiredBasicAuthenticationPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.basicAuthenticationPolicyName = void 0;
		exports$1.basicAuthenticationPolicy = basicAuthenticationPolicy;
		const bytesEncoding_js_1 = requireBytesEncoding();
		const checkInsecureConnection_js_1 = requireCheckInsecureConnection();
		/**
		 * Name of the Basic Authentication Policy
		 */
		exports$1.basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
		/**
		 * Gets a pipeline policy that adds basic authentication to requests
		 */
		function basicAuthenticationPolicy(options) {
		    return {
		        name: exports$1.basicAuthenticationPolicyName,
		        async sendRequest(request, next) {
		            // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
		            (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
		            const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "basic");
		            // Skip adding authentication header if no basic authentication scheme is found
		            if (!scheme) {
		                return next(request);
		            }
		            const { username, password } = options.credential;
		            const headerValue = (0, bytesEncoding_js_1.uint8ArrayToString)((0, bytesEncoding_js_1.stringToUint8Array)(`${username}:${password}`, "utf-8"), "base64");
		            request.headers.set("Authorization", `Basic ${headerValue}`);
		            return next(request);
		        },
		    };
		}
		
	} (basicAuthenticationPolicy));
	return basicAuthenticationPolicy;
}

var bearerAuthenticationPolicy = {};

var hasRequiredBearerAuthenticationPolicy;

function requireBearerAuthenticationPolicy () {
	if (hasRequiredBearerAuthenticationPolicy) return bearerAuthenticationPolicy;
	hasRequiredBearerAuthenticationPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.bearerAuthenticationPolicyName = void 0;
		exports$1.bearerAuthenticationPolicy = bearerAuthenticationPolicy;
		const checkInsecureConnection_js_1 = requireCheckInsecureConnection();
		/**
		 * Name of the Bearer Authentication Policy
		 */
		exports$1.bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
		/**
		 * Gets a pipeline policy that adds bearer token authentication to requests
		 */
		function bearerAuthenticationPolicy(options) {
		    return {
		        name: exports$1.bearerAuthenticationPolicyName,
		        async sendRequest(request, next) {
		            // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
		            (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
		            const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "http" && x.scheme === "bearer");
		            // Skip adding authentication header if no bearer authentication scheme is found
		            if (!scheme) {
		                return next(request);
		            }
		            const token = await options.credential.getBearerToken({
		                abortSignal: request.abortSignal,
		            });
		            request.headers.set("Authorization", `Bearer ${token}`);
		            return next(request);
		        },
		    };
		}
		
	} (bearerAuthenticationPolicy));
	return bearerAuthenticationPolicy;
}

var oauth2AuthenticationPolicy = {};

var hasRequiredOauth2AuthenticationPolicy;

function requireOauth2AuthenticationPolicy () {
	if (hasRequiredOauth2AuthenticationPolicy) return oauth2AuthenticationPolicy;
	hasRequiredOauth2AuthenticationPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.oauth2AuthenticationPolicyName = void 0;
		exports$1.oauth2AuthenticationPolicy = oauth2AuthenticationPolicy;
		const checkInsecureConnection_js_1 = requireCheckInsecureConnection();
		/**
		 * Name of the OAuth2 Authentication Policy
		 */
		exports$1.oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
		/**
		 * Gets a pipeline policy that adds authorization header from OAuth2 schemes
		 */
		function oauth2AuthenticationPolicy(options) {
		    return {
		        name: exports$1.oauth2AuthenticationPolicyName,
		        async sendRequest(request, next) {
		            // Ensure allowInsecureConnection is explicitly set when sending request to non-https URLs
		            (0, checkInsecureConnection_js_1.ensureSecureConnection)(request, options);
		            const scheme = (request.authSchemes ?? options.authSchemes)?.find((x) => x.kind === "oauth2");
		            // Skip adding authentication header if no OAuth2 authentication scheme is found
		            if (!scheme) {
		                return next(request);
		            }
		            const token = await options.credential.getOAuth2Token(scheme.flows, {
		                abortSignal: request.abortSignal,
		            });
		            request.headers.set("Authorization", `Bearer ${token}`);
		            return next(request);
		        },
		    };
		}
		
	} (oauth2AuthenticationPolicy));
	return oauth2AuthenticationPolicy;
}

var hasRequiredClientHelpers;

function requireClientHelpers () {
	if (hasRequiredClientHelpers) return clientHelpers;
	hasRequiredClientHelpers = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(clientHelpers, "__esModule", { value: true });
	clientHelpers.createDefaultPipeline = createDefaultPipeline;
	clientHelpers.getCachedDefaultHttpsClient = getCachedDefaultHttpsClient;
	const defaultHttpClient_js_1 = requireDefaultHttpClient$1();
	const createPipelineFromOptions_js_1 = requireCreatePipelineFromOptions$1();
	const apiVersionPolicy_js_1 = requireApiVersionPolicy();
	const credentials_js_1 = requireCredentials();
	const apiKeyAuthenticationPolicy_js_1 = requireApiKeyAuthenticationPolicy();
	const basicAuthenticationPolicy_js_1 = requireBasicAuthenticationPolicy();
	const bearerAuthenticationPolicy_js_1 = requireBearerAuthenticationPolicy();
	const oauth2AuthenticationPolicy_js_1 = requireOauth2AuthenticationPolicy();
	let cachedHttpClient;
	/**
	 * Creates a default rest pipeline to re-use accross Rest Level Clients
	 */
	function createDefaultPipeline(options = {}) {
	    const pipeline = (0, createPipelineFromOptions_js_1.createPipelineFromOptions)(options);
	    pipeline.addPolicy((0, apiVersionPolicy_js_1.apiVersionPolicy)(options));
	    const { credential, authSchemes, allowInsecureConnection } = options;
	    if (credential) {
	        if ((0, credentials_js_1.isApiKeyCredential)(credential)) {
	            pipeline.addPolicy((0, apiKeyAuthenticationPolicy_js_1.apiKeyAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
	        }
	        else if ((0, credentials_js_1.isBasicCredential)(credential)) {
	            pipeline.addPolicy((0, basicAuthenticationPolicy_js_1.basicAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
	        }
	        else if ((0, credentials_js_1.isBearerTokenCredential)(credential)) {
	            pipeline.addPolicy((0, bearerAuthenticationPolicy_js_1.bearerAuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
	        }
	        else if ((0, credentials_js_1.isOAuth2TokenCredential)(credential)) {
	            pipeline.addPolicy((0, oauth2AuthenticationPolicy_js_1.oauth2AuthenticationPolicy)({ authSchemes, credential, allowInsecureConnection }));
	        }
	    }
	    return pipeline;
	}
	function getCachedDefaultHttpsClient() {
	    if (!cachedHttpClient) {
	        cachedHttpClient = (0, defaultHttpClient_js_1.createDefaultHttpClient)();
	    }
	    return cachedHttpClient;
	}
	
	return clientHelpers;
}

var sendRequest = {};

var multipart = {};

var hasRequiredMultipart;

function requireMultipart () {
	if (hasRequiredMultipart) return multipart;
	hasRequiredMultipart = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(multipart, "__esModule", { value: true });
	multipart.buildBodyPart = buildBodyPart;
	multipart.buildMultipartBody = buildMultipartBody;
	const restError_js_1 = requireRestError$2();
	const httpHeaders_js_1 = requireHttpHeaders$1();
	const bytesEncoding_js_1 = requireBytesEncoding();
	const typeGuards_js_1 = requireTypeGuards();
	/**
	 * Get value of a header in the part descriptor ignoring case
	 */
	function getHeaderValue(descriptor, headerName) {
	    if (descriptor.headers) {
	        const actualHeaderName = Object.keys(descriptor.headers).find((x) => x.toLowerCase() === headerName.toLowerCase());
	        if (actualHeaderName) {
	            return descriptor.headers[actualHeaderName];
	        }
	    }
	    return undefined;
	}
	function getPartContentType(descriptor) {
	    const contentTypeHeader = getHeaderValue(descriptor, "content-type");
	    if (contentTypeHeader) {
	        return contentTypeHeader;
	    }
	    // Special value of null means content type is to be omitted
	    if (descriptor.contentType === null) {
	        return undefined;
	    }
	    if (descriptor.contentType) {
	        return descriptor.contentType;
	    }
	    const { body } = descriptor;
	    if (body === null || body === undefined) {
	        return undefined;
	    }
	    if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
	        return "text/plain; charset=UTF-8";
	    }
	    if (body instanceof Blob) {
	        return body.type || "application/octet-stream";
	    }
	    if ((0, typeGuards_js_1.isBinaryBody)(body)) {
	        return "application/octet-stream";
	    }
	    // arbitrary non-text object -> generic JSON content type by default. We will try to JSON.stringify the body.
	    return "application/json";
	}
	/**
	 * Enclose value in quotes and escape special characters, for use in the Content-Disposition header
	 */
	function escapeDispositionField(value) {
	    return JSON.stringify(value);
	}
	function getContentDisposition(descriptor) {
	    const contentDispositionHeader = getHeaderValue(descriptor, "content-disposition");
	    if (contentDispositionHeader) {
	        return contentDispositionHeader;
	    }
	    if (descriptor.dispositionType === undefined &&
	        descriptor.name === undefined &&
	        descriptor.filename === undefined) {
	        return undefined;
	    }
	    const dispositionType = descriptor.dispositionType ?? "form-data";
	    let disposition = dispositionType;
	    if (descriptor.name) {
	        disposition += `; name=${escapeDispositionField(descriptor.name)}`;
	    }
	    let filename = undefined;
	    if (descriptor.filename) {
	        filename = descriptor.filename;
	    }
	    else if (typeof File !== "undefined" && descriptor.body instanceof File) {
	        const filenameFromFile = descriptor.body.name;
	        if (filenameFromFile !== "") {
	            filename = filenameFromFile;
	        }
	    }
	    if (filename) {
	        disposition += `; filename=${escapeDispositionField(filename)}`;
	    }
	    return disposition;
	}
	function normalizeBody(body, contentType) {
	    if (body === undefined) {
	        // zero-length body
	        return new Uint8Array([]);
	    }
	    // binary and primitives should go straight on the wire regardless of content type
	    if ((0, typeGuards_js_1.isBinaryBody)(body)) {
	        return body;
	    }
	    if (typeof body === "string" || typeof body === "number" || typeof body === "boolean") {
	        return (0, bytesEncoding_js_1.stringToUint8Array)(String(body), "utf-8");
	    }
	    // stringify objects for JSON-ish content types e.g. application/json, application/merge-patch+json, application/vnd.oci.manifest.v1+json, application.json; charset=UTF-8
	    if (contentType && /application\/(.+\+)?json(;.+)?/i.test(String(contentType))) {
	        return (0, bytesEncoding_js_1.stringToUint8Array)(JSON.stringify(body), "utf-8");
	    }
	    throw new restError_js_1.RestError(`Unsupported body/content-type combination: ${body}, ${contentType}`);
	}
	function buildBodyPart(descriptor) {
	    const contentType = getPartContentType(descriptor);
	    const contentDisposition = getContentDisposition(descriptor);
	    const headers = (0, httpHeaders_js_1.createHttpHeaders)(descriptor.headers ?? {});
	    if (contentType) {
	        headers.set("content-type", contentType);
	    }
	    if (contentDisposition) {
	        headers.set("content-disposition", contentDisposition);
	    }
	    const body = normalizeBody(descriptor.body, contentType);
	    return {
	        headers,
	        body,
	    };
	}
	function buildMultipartBody(parts) {
	    return { parts: parts.map(buildBodyPart) };
	}
	
	return multipart;
}

var hasRequiredSendRequest;

function requireSendRequest () {
	if (hasRequiredSendRequest) return sendRequest;
	hasRequiredSendRequest = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(sendRequest, "__esModule", { value: true });
	sendRequest.sendRequest = sendRequest$1;
	const restError_js_1 = requireRestError$2();
	const httpHeaders_js_1 = requireHttpHeaders$1();
	const pipelineRequest_js_1 = requirePipelineRequest$1();
	const clientHelpers_js_1 = requireClientHelpers();
	const typeGuards_js_1 = requireTypeGuards();
	const multipart_js_1 = requireMultipart();
	/**
	 * Helper function to send request used by the client
	 * @param method - method to use to send the request
	 * @param url - url to send the request to
	 * @param pipeline - pipeline with the policies to run when sending the request
	 * @param options - request options
	 * @param customHttpClient - a custom HttpClient to use when making the request
	 * @returns returns and HttpResponse
	 */
	async function sendRequest$1(method, url, pipeline, options = {}, customHttpClient) {
	    const httpClient = customHttpClient ?? (0, clientHelpers_js_1.getCachedDefaultHttpsClient)();
	    const request = buildPipelineRequest(method, url, options);
	    try {
	        const response = await pipeline.sendRequest(httpClient, request);
	        const headers = response.headers.toJSON();
	        const stream = response.readableStreamBody ?? response.browserStreamBody;
	        const parsedBody = options.responseAsStream || stream !== undefined ? undefined : getResponseBody(response);
	        const body = stream ?? parsedBody;
	        if (options?.onResponse) {
	            options.onResponse({ ...response, request, rawHeaders: headers, parsedBody });
	        }
	        return {
	            request,
	            headers,
	            status: `${response.status}`,
	            body,
	        };
	    }
	    catch (e) {
	        if ((0, restError_js_1.isRestError)(e) && e.response && options.onResponse) {
	            const { response } = e;
	            const rawHeaders = response.headers.toJSON();
	            // UNBRANDED DIFFERENCE: onResponse callback does not have a second __legacyError property
	            options?.onResponse({ ...response, request, rawHeaders }, e);
	        }
	        throw e;
	    }
	}
	/**
	 * Function to determine the request content type
	 * @param options - request options InternalRequestParameters
	 * @returns returns the content-type
	 */
	function getRequestContentType(options = {}) {
	    return (options.contentType ??
	        options.headers?.["content-type"] ??
	        getContentType(options.body));
	}
	/**
	 * Function to determine the content-type of a body
	 * this is used if an explicit content-type is not provided
	 * @param body - body in the request
	 * @returns returns the content-type
	 */
	function getContentType(body) {
	    if (ArrayBuffer.isView(body)) {
	        return "application/octet-stream";
	    }
	    if (typeof body === "string") {
	        try {
	            JSON.parse(body);
	            return "application/json";
	        }
	        catch (error) {
	            // If we fail to parse the body, it is not json
	            return undefined;
	        }
	    }
	    // By default return json
	    return "application/json";
	}
	function buildPipelineRequest(method, url, options = {}) {
	    const requestContentType = getRequestContentType(options);
	    const { body, multipartBody } = getRequestBody(options.body, requestContentType);
	    const hasContent = body !== undefined || multipartBody !== undefined;
	    const headers = (0, httpHeaders_js_1.createHttpHeaders)({
	        ...(options.headers ? options.headers : {}),
	        accept: options.accept ?? options.headers?.accept ?? "application/json",
	        ...(hasContent &&
	            requestContentType && {
	            "content-type": requestContentType,
	        }),
	    });
	    return (0, pipelineRequest_js_1.createPipelineRequest)({
	        url,
	        method,
	        body,
	        multipartBody,
	        headers,
	        allowInsecureConnection: options.allowInsecureConnection,
	        abortSignal: options.abortSignal,
	        onUploadProgress: options.onUploadProgress,
	        onDownloadProgress: options.onDownloadProgress,
	        timeout: options.timeout,
	        enableBrowserStreams: true,
	        streamResponseStatusCodes: options.responseAsStream
	            ? new Set([Number.POSITIVE_INFINITY])
	            : undefined,
	    });
	}
	/**
	 * Prepares the body before sending the request
	 */
	function getRequestBody(body, contentType = "") {
	    if (body === undefined) {
	        return { body: undefined };
	    }
	    if (typeof FormData !== "undefined" && body instanceof FormData) {
	        return { body };
	    }
	    if ((0, typeGuards_js_1.isReadableStream)(body)) {
	        return { body };
	    }
	    if (ArrayBuffer.isView(body)) {
	        return { body: body instanceof Uint8Array ? body : JSON.stringify(body) };
	    }
	    const firstType = contentType.split(";")[0];
	    switch (firstType) {
	        case "application/json":
	            return { body: JSON.stringify(body) };
	        case "multipart/form-data":
	            if (Array.isArray(body)) {
	                return { multipartBody: (0, multipart_js_1.buildMultipartBody)(body) };
	            }
	            return { body: JSON.stringify(body) };
	        case "text/plain":
	            return { body: String(body) };
	        default:
	            if (typeof body === "string") {
	                return { body };
	            }
	            return { body: JSON.stringify(body) };
	    }
	}
	/**
	 * Prepares the response body
	 */
	function getResponseBody(response) {
	    // Set the default response type
	    const contentType = response.headers.get("content-type") ?? "";
	    const firstType = contentType.split(";")[0];
	    const bodyToParse = response.bodyAsText ?? "";
	    if (firstType === "text/plain") {
	        return String(bodyToParse);
	    }
	    // Default to "application/json" and fallback to string;
	    try {
	        return bodyToParse ? JSON.parse(bodyToParse) : undefined;
	    }
	    catch (error) {
	        // If we were supposed to get a JSON object and failed to
	        // parse, throw a parse error
	        if (firstType === "application/json") {
	            throw createParseError(response, error);
	        }
	        // We are not sure how to handle the response so we return it as
	        // plain text.
	        return String(bodyToParse);
	    }
	}
	function createParseError(response, err) {
	    const msg = `Error "${err}" occurred while parsing the response body - ${response.bodyAsText}.`;
	    const errCode = err.code ?? restError_js_1.RestError.PARSE_ERROR;
	    return new restError_js_1.RestError(msg, {
	        code: errCode,
	        statusCode: response.status,
	        request: response.request,
	        response: response,
	    });
	}
	
	return sendRequest;
}

var urlHelpers$1 = {};

var hasRequiredUrlHelpers$1;

function requireUrlHelpers$1 () {
	if (hasRequiredUrlHelpers$1) return urlHelpers$1;
	hasRequiredUrlHelpers$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(urlHelpers$1, "__esModule", { value: true });
	urlHelpers$1.buildRequestUrl = buildRequestUrl;
	urlHelpers$1.buildBaseUrl = buildBaseUrl;
	urlHelpers$1.replaceAll = replaceAll;
	function isQueryParameterWithOptions(x) {
	    const value = x.value;
	    return (value !== undefined && value.toString !== undefined && typeof value.toString === "function");
	}
	/**
	 * Builds the request url, filling in query and path parameters
	 * @param endpoint - base url which can be a template url
	 * @param routePath - path to append to the endpoint
	 * @param pathParameters - values of the path parameters
	 * @param options - request parameters including query parameters
	 * @returns a full url with path and query parameters
	 */
	function buildRequestUrl(endpoint, routePath, pathParameters, options = {}) {
	    if (routePath.startsWith("https://") || routePath.startsWith("http://")) {
	        return routePath;
	    }
	    endpoint = buildBaseUrl(endpoint, options);
	    routePath = buildRoutePath(routePath, pathParameters, options);
	    const requestUrl = appendQueryParams(`${endpoint}/${routePath}`, options);
	    const url = new URL(requestUrl);
	    return (url
	        .toString()
	        // Remove double forward slashes
	        .replace(/([^:]\/)\/+/g, "$1"));
	}
	function getQueryParamValue(key, allowReserved, style, param) {
	    let separator;
	    if (style === "pipeDelimited") {
	        separator = "|";
	    }
	    else if (style === "spaceDelimited") {
	        separator = "%20";
	    }
	    else {
	        separator = ",";
	    }
	    let paramValues;
	    if (Array.isArray(param)) {
	        paramValues = param;
	    }
	    else if (typeof param === "object" && param.toString === Object.prototype.toString) {
	        // If the parameter is an object without a custom toString implementation (e.g. a Date),
	        // then we should deconstruct the object into an array [key1, value1, key2, value2, ...].
	        paramValues = Object.entries(param).flat();
	    }
	    else {
	        paramValues = [param];
	    }
	    const value = paramValues
	        .map((p) => {
	        if (p === null || p === undefined) {
	            return "";
	        }
	        if (!p.toString || typeof p.toString !== "function") {
	            throw new Error(`Query parameters must be able to be represented as string, ${key} can't`);
	        }
	        const rawValue = p.toISOString !== undefined ? p.toISOString() : p.toString();
	        return allowReserved ? rawValue : encodeURIComponent(rawValue);
	    })
	        .join(separator);
	    return `${allowReserved ? key : encodeURIComponent(key)}=${value}`;
	}
	function appendQueryParams(url, options = {}) {
	    if (!options.queryParameters) {
	        return url;
	    }
	    const parsedUrl = new URL(url);
	    const queryParams = options.queryParameters;
	    const paramStrings = [];
	    for (const key of Object.keys(queryParams)) {
	        const param = queryParams[key];
	        if (param === undefined || param === null) {
	            continue;
	        }
	        const hasMetadata = isQueryParameterWithOptions(param);
	        const rawValue = hasMetadata ? param.value : param;
	        const explode = hasMetadata ? (param.explode ?? false) : false;
	        const style = hasMetadata && param.style ? param.style : "form";
	        if (explode) {
	            if (Array.isArray(rawValue)) {
	                for (const item of rawValue) {
	                    paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, item));
	                }
	            }
	            else if (typeof rawValue === "object") {
	                // For object explode, the name of the query parameter is ignored and we use the object key instead
	                for (const [actualKey, value] of Object.entries(rawValue)) {
	                    paramStrings.push(getQueryParamValue(actualKey, options.skipUrlEncoding ?? false, style, value));
	                }
	            }
	            else {
	                // Explode doesn't really make sense for primitives
	                throw new Error("explode can only be set to true for objects and arrays");
	            }
	        }
	        else {
	            paramStrings.push(getQueryParamValue(key, options.skipUrlEncoding ?? false, style, rawValue));
	        }
	    }
	    if (parsedUrl.search !== "") {
	        parsedUrl.search += "&";
	    }
	    parsedUrl.search += paramStrings.join("&");
	    return parsedUrl.toString();
	}
	function buildBaseUrl(endpoint, options) {
	    if (!options.pathParameters) {
	        return endpoint;
	    }
	    const pathParams = options.pathParameters;
	    for (const [key, param] of Object.entries(pathParams)) {
	        if (param === undefined || param === null) {
	            throw new Error(`Path parameters ${key} must not be undefined or null`);
	        }
	        if (!param.toString || typeof param.toString !== "function") {
	            throw new Error(`Path parameters must be able to be represented as string, ${key} can't`);
	        }
	        let value = param.toISOString !== undefined ? param.toISOString() : String(param);
	        if (!options.skipUrlEncoding) {
	            value = encodeURIComponent(param);
	        }
	        endpoint = replaceAll(endpoint, `{${key}}`, value) ?? "";
	    }
	    return endpoint;
	}
	function buildRoutePath(routePath, pathParameters, options = {}) {
	    for (const pathParam of pathParameters) {
	        const allowReserved = typeof pathParam === "object" && (pathParam.allowReserved ?? false);
	        let value = typeof pathParam === "object" ? pathParam.value : pathParam;
	        if (!options.skipUrlEncoding && !allowReserved) {
	            value = encodeURIComponent(value);
	        }
	        routePath = routePath.replace(/\{[\w-]+\}/, String(value));
	    }
	    return routePath;
	}
	/**
	 * Replace all of the instances of searchValue in value with the provided replaceValue.
	 * @param value - The value to search and replace in.
	 * @param searchValue - The value to search for in the value argument.
	 * @param replaceValue - The value to replace searchValue with in the value argument.
	 * @returns The value where each instance of searchValue was replaced with replacedValue.
	 */
	function replaceAll(value, searchValue, replaceValue) {
	    return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
	}
	
	return urlHelpers$1;
}

var hasRequiredGetClient;

function requireGetClient () {
	if (hasRequiredGetClient) return getClient;
	hasRequiredGetClient = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(getClient, "__esModule", { value: true });
	getClient.getClient = getClient$1;
	const clientHelpers_js_1 = requireClientHelpers();
	const sendRequest_js_1 = requireSendRequest();
	const urlHelpers_js_1 = requireUrlHelpers$1();
	const checkEnvironment_js_1 = requireCheckEnvironment();
	/**
	 * Creates a client with a default pipeline
	 * @param endpoint - Base endpoint for the client
	 * @param credentials - Credentials to authenticate the requests
	 * @param options - Client options
	 */
	function getClient$1(endpoint, clientOptions = {}) {
	    const pipeline = clientOptions.pipeline ?? (0, clientHelpers_js_1.createDefaultPipeline)(clientOptions);
	    if (clientOptions.additionalPolicies?.length) {
	        for (const { policy, position } of clientOptions.additionalPolicies) {
	            // Sign happens after Retry and is commonly needed to occur
	            // before policies that intercept post-retry.
	            const afterPhase = position === "perRetry" ? "Sign" : undefined;
	            pipeline.addPolicy(policy, {
	                afterPhase,
	            });
	        }
	    }
	    const { allowInsecureConnection, httpClient } = clientOptions;
	    const endpointUrl = clientOptions.endpoint ?? endpoint;
	    const client = (path, ...args) => {
	        const getUrl = (requestOptions) => (0, urlHelpers_js_1.buildRequestUrl)(endpointUrl, path, args, { allowInsecureConnection, ...requestOptions });
	        return {
	            get: (requestOptions = {}) => {
	                return buildOperation("GET", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
	            },
	            post: (requestOptions = {}) => {
	                return buildOperation("POST", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
	            },
	            put: (requestOptions = {}) => {
	                return buildOperation("PUT", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
	            },
	            patch: (requestOptions = {}) => {
	                return buildOperation("PATCH", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
	            },
	            delete: (requestOptions = {}) => {
	                return buildOperation("DELETE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
	            },
	            head: (requestOptions = {}) => {
	                return buildOperation("HEAD", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
	            },
	            options: (requestOptions = {}) => {
	                return buildOperation("OPTIONS", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
	            },
	            trace: (requestOptions = {}) => {
	                return buildOperation("TRACE", getUrl(requestOptions), pipeline, requestOptions, allowInsecureConnection, httpClient);
	            },
	        };
	    };
	    return {
	        path: client,
	        pathUnchecked: client,
	        pipeline,
	    };
	}
	function buildOperation(method, url, pipeline, options, allowInsecureConnection, httpClient) {
	    allowInsecureConnection = options.allowInsecureConnection ?? allowInsecureConnection;
	    return {
	        then: function (onFulfilled, onrejected) {
	            return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection }, httpClient).then(onFulfilled, onrejected);
	        },
	        async asBrowserStream() {
	            if (checkEnvironment_js_1.isNodeLike) {
	                throw new Error("`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.");
	            }
	            else {
	                return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection, responseAsStream: true }, httpClient);
	            }
	        },
	        async asNodeStream() {
	            if (checkEnvironment_js_1.isNodeLike) {
	                return (0, sendRequest_js_1.sendRequest)(method, url, pipeline, { ...options, allowInsecureConnection, responseAsStream: true }, httpClient);
	            }
	            else {
	                throw new Error("`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.");
	            }
	        },
	    };
	}
	
	return getClient;
}

var operationOptionHelpers = {};

var hasRequiredOperationOptionHelpers;

function requireOperationOptionHelpers () {
	if (hasRequiredOperationOptionHelpers) return operationOptionHelpers;
	hasRequiredOperationOptionHelpers = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(operationOptionHelpers, "__esModule", { value: true });
	operationOptionHelpers.operationOptionsToRequestParameters = operationOptionsToRequestParameters;
	/**
	 * Helper function to convert OperationOptions to RequestParameters
	 * @param options - the options that are used by Modular layer to send the request
	 * @returns the result of the conversion in RequestParameters of RLC layer
	 */
	function operationOptionsToRequestParameters(options) {
	    return {
	        allowInsecureConnection: options.requestOptions?.allowInsecureConnection,
	        timeout: options.requestOptions?.timeout,
	        skipUrlEncoding: options.requestOptions?.skipUrlEncoding,
	        abortSignal: options.abortSignal,
	        onUploadProgress: options.requestOptions?.onUploadProgress,
	        onDownloadProgress: options.requestOptions?.onDownloadProgress,
	        headers: { ...options.requestOptions?.headers },
	        onResponse: options.onResponse,
	    };
	}
	
	return operationOptionHelpers;
}

var restError$1 = {};

var hasRequiredRestError$1;

function requireRestError$1 () {
	if (hasRequiredRestError$1) return restError$1;
	hasRequiredRestError$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(restError$1, "__esModule", { value: true });
	restError$1.createRestError = createRestError;
	const restError_js_1 = requireRestError$2();
	const httpHeaders_js_1 = requireHttpHeaders$1();
	function createRestError(messageOrResponse, response) {
	    const resp = typeof messageOrResponse === "string" ? response : messageOrResponse;
	    const internalError = resp.body?.error ?? resp.body;
	    const message = typeof messageOrResponse === "string"
	        ? messageOrResponse
	        : (internalError?.message ?? `Unexpected status code: ${resp.status}`);
	    return new restError_js_1.RestError(message, {
	        statusCode: statusCodeToNumber(resp.status),
	        code: internalError?.code,
	        request: resp.request,
	        response: toPipelineResponse(resp),
	    });
	}
	function toPipelineResponse(response) {
	    return {
	        headers: (0, httpHeaders_js_1.createHttpHeaders)(response.headers),
	        request: response.request,
	        status: statusCodeToNumber(response.status) ?? -1,
	    };
	}
	function statusCodeToNumber(statusCode) {
	    const status = Number.parseInt(statusCode);
	    return Number.isNaN(status) ? undefined : status;
	}
	
	return restError$1;
}

var hasRequiredCommonjs$4;

function requireCommonjs$4 () {
	if (hasRequiredCommonjs$4) return commonjs$1;
	hasRequiredCommonjs$4 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.createRestError = exports$1.operationOptionsToRequestParameters = exports$1.getClient = exports$1.createDefaultHttpClient = exports$1.uint8ArrayToString = exports$1.stringToUint8Array = exports$1.isRestError = exports$1.RestError = exports$1.createEmptyPipeline = exports$1.createPipelineRequest = exports$1.createHttpHeaders = exports$1.TypeSpecRuntimeLogger = exports$1.setLogLevel = exports$1.getLogLevel = exports$1.createClientLogger = exports$1.AbortError = void 0;
		const tslib_1 = require$$0$3;
		var AbortError_js_1 = requireAbortError$1();
		Object.defineProperty(exports$1, "AbortError", { enumerable: true, get: function () { return AbortError_js_1.AbortError; } });
		var logger_js_1 = requireLogger();
		Object.defineProperty(exports$1, "createClientLogger", { enumerable: true, get: function () { return logger_js_1.createClientLogger; } });
		Object.defineProperty(exports$1, "getLogLevel", { enumerable: true, get: function () { return logger_js_1.getLogLevel; } });
		Object.defineProperty(exports$1, "setLogLevel", { enumerable: true, get: function () { return logger_js_1.setLogLevel; } });
		Object.defineProperty(exports$1, "TypeSpecRuntimeLogger", { enumerable: true, get: function () { return logger_js_1.TypeSpecRuntimeLogger; } });
		var httpHeaders_js_1 = requireHttpHeaders$1();
		Object.defineProperty(exports$1, "createHttpHeaders", { enumerable: true, get: function () { return httpHeaders_js_1.createHttpHeaders; } });
		tslib_1.__exportStar(requireSchemes(), exports$1);
		tslib_1.__exportStar(requireOauth2Flows(), exports$1);
		var pipelineRequest_js_1 = requirePipelineRequest$1();
		Object.defineProperty(exports$1, "createPipelineRequest", { enumerable: true, get: function () { return pipelineRequest_js_1.createPipelineRequest; } });
		var pipeline_js_1 = requirePipeline$3();
		Object.defineProperty(exports$1, "createEmptyPipeline", { enumerable: true, get: function () { return pipeline_js_1.createEmptyPipeline; } });
		var restError_js_1 = requireRestError$2();
		Object.defineProperty(exports$1, "RestError", { enumerable: true, get: function () { return restError_js_1.RestError; } });
		Object.defineProperty(exports$1, "isRestError", { enumerable: true, get: function () { return restError_js_1.isRestError; } });
		var bytesEncoding_js_1 = requireBytesEncoding();
		Object.defineProperty(exports$1, "stringToUint8Array", { enumerable: true, get: function () { return bytesEncoding_js_1.stringToUint8Array; } });
		Object.defineProperty(exports$1, "uint8ArrayToString", { enumerable: true, get: function () { return bytesEncoding_js_1.uint8ArrayToString; } });
		var defaultHttpClient_js_1 = requireDefaultHttpClient$1();
		Object.defineProperty(exports$1, "createDefaultHttpClient", { enumerable: true, get: function () { return defaultHttpClient_js_1.createDefaultHttpClient; } });
		var getClient_js_1 = requireGetClient();
		Object.defineProperty(exports$1, "getClient", { enumerable: true, get: function () { return getClient_js_1.getClient; } });
		var operationOptionHelpers_js_1 = requireOperationOptionHelpers();
		Object.defineProperty(exports$1, "operationOptionsToRequestParameters", { enumerable: true, get: function () { return operationOptionHelpers_js_1.operationOptionsToRequestParameters; } });
		var restError_js_2 = requireRestError$1();
		Object.defineProperty(exports$1, "createRestError", { enumerable: true, get: function () { return restError_js_2.createRestError; } });
		
	} (commonjs$1));
	return commonjs$1;
}

var hasRequiredPipeline$2;

function requirePipeline$2 () {
	if (hasRequiredPipeline$2) return pipeline$2;
	hasRequiredPipeline$2 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(pipeline$2, "__esModule", { value: true });
	pipeline$2.createEmptyPipeline = createEmptyPipeline;
	const ts_http_runtime_1 = /*@__PURE__*/ requireCommonjs$4();
	/**
	 * Creates a totally empty pipeline.
	 * Useful for testing or creating a custom one.
	 */
	function createEmptyPipeline() {
	    return (0, ts_http_runtime_1.createEmptyPipeline)();
	}
	
	return pipeline$2;
}

var createPipelineFromOptions = {};

var logPolicy = {};

var log$1 = {};

var hasRequiredLog$1;

function requireLog$1 () {
	if (hasRequiredLog$1) return log$1;
	hasRequiredLog$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(log$1, "__esModule", { value: true });
	log$1.logger = void 0;
	const logger_1 = /*@__PURE__*/ requireCommonjs$8();
	log$1.logger = (0, logger_1.createClientLogger)("core-rest-pipeline");
	
	return log$1;
}

var internal$1 = {};

var exponentialRetryPolicy$1 = {};

var hasRequiredExponentialRetryPolicy$1;

function requireExponentialRetryPolicy$1 () {
	if (hasRequiredExponentialRetryPolicy$1) return exponentialRetryPolicy$1;
	hasRequiredExponentialRetryPolicy$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(exponentialRetryPolicy$1, "__esModule", { value: true });
	exponentialRetryPolicy$1.exponentialRetryPolicyName = void 0;
	exponentialRetryPolicy$1.exponentialRetryPolicy = exponentialRetryPolicy;
	const exponentialRetryStrategy_js_1 = requireExponentialRetryStrategy();
	const retryPolicy_js_1 = requireRetryPolicy$1();
	const constants_js_1 = requireConstants$1();
	/**
	 * The programmatic identifier of the exponentialRetryPolicy.
	 */
	exponentialRetryPolicy$1.exponentialRetryPolicyName = "exponentialRetryPolicy";
	/**
	 * A policy that attempts to retry requests while introducing an exponentially increasing delay.
	 * @param options - Options that configure retry logic.
	 */
	function exponentialRetryPolicy(options = {}) {
	    return (0, retryPolicy_js_1.retryPolicy)([
	        (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
	            ...options,
	            ignoreSystemErrors: true,
	        }),
	    ], {
	        maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT,
	    });
	}
	
	return exponentialRetryPolicy$1;
}

var systemErrorRetryPolicy$1 = {};

var hasRequiredSystemErrorRetryPolicy$1;

function requireSystemErrorRetryPolicy$1 () {
	if (hasRequiredSystemErrorRetryPolicy$1) return systemErrorRetryPolicy$1;
	hasRequiredSystemErrorRetryPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.systemErrorRetryPolicyName = void 0;
		exports$1.systemErrorRetryPolicy = systemErrorRetryPolicy;
		const exponentialRetryStrategy_js_1 = requireExponentialRetryStrategy();
		const retryPolicy_js_1 = requireRetryPolicy$1();
		const constants_js_1 = requireConstants$1();
		/**
		 * Name of the {@link systemErrorRetryPolicy}
		 */
		exports$1.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
		/**
		 * A retry policy that specifically seeks to handle errors in the
		 * underlying transport layer (e.g. DNS lookup failures) rather than
		 * retryable error codes from the server itself.
		 * @param options - Options that customize the policy.
		 */
		function systemErrorRetryPolicy(options = {}) {
		    return {
		        name: exports$1.systemErrorRetryPolicyName,
		        sendRequest: (0, retryPolicy_js_1.retryPolicy)([
		            (0, exponentialRetryStrategy_js_1.exponentialRetryStrategy)({
		                ...options,
		                ignoreHttpStatusCodes: true,
		            }),
		        ], {
		            maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT,
		        }).sendRequest,
		    };
		}
		
	} (systemErrorRetryPolicy$1));
	return systemErrorRetryPolicy$1;
}

var throttlingRetryPolicy$1 = {};

var hasRequiredThrottlingRetryPolicy$1;

function requireThrottlingRetryPolicy$1 () {
	if (hasRequiredThrottlingRetryPolicy$1) return throttlingRetryPolicy$1;
	hasRequiredThrottlingRetryPolicy$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.throttlingRetryPolicyName = void 0;
		exports$1.throttlingRetryPolicy = throttlingRetryPolicy;
		const throttlingRetryStrategy_js_1 = requireThrottlingRetryStrategy();
		const retryPolicy_js_1 = requireRetryPolicy$1();
		const constants_js_1 = requireConstants$1();
		/**
		 * Name of the {@link throttlingRetryPolicy}
		 */
		exports$1.throttlingRetryPolicyName = "throttlingRetryPolicy";
		/**
		 * A policy that retries when the server sends a 429 response with a Retry-After header.
		 *
		 * To learn more, please refer to
		 * https://learn.microsoft.com/azure/azure-resource-manager/resource-manager-request-limits,
		 * https://learn.microsoft.com/azure/azure-subscription-service-limits and
		 * https://learn.microsoft.com/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors
		 *
		 * @param options - Options that configure retry logic.
		 */
		function throttlingRetryPolicy(options = {}) {
		    return {
		        name: exports$1.throttlingRetryPolicyName,
		        sendRequest: (0, retryPolicy_js_1.retryPolicy)([(0, throttlingRetryStrategy_js_1.throttlingRetryStrategy)()], {
		            maxRetries: options.maxRetries ?? constants_js_1.DEFAULT_RETRY_POLICY_COUNT,
		        }).sendRequest,
		    };
		}
		
	} (throttlingRetryPolicy$1));
	return throttlingRetryPolicy$1;
}

var hasRequiredInternal$1;

function requireInternal$1 () {
	if (hasRequiredInternal$1) return internal$1;
	hasRequiredInternal$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.userAgentPolicyName = exports$1.userAgentPolicy = exports$1.tlsPolicyName = exports$1.tlsPolicy = exports$1.redirectPolicyName = exports$1.redirectPolicy = exports$1.getDefaultProxySettings = exports$1.proxyPolicyName = exports$1.proxyPolicy = exports$1.multipartPolicyName = exports$1.multipartPolicy = exports$1.logPolicyName = exports$1.logPolicy = exports$1.formDataPolicyName = exports$1.formDataPolicy = exports$1.throttlingRetryPolicyName = exports$1.throttlingRetryPolicy = exports$1.systemErrorRetryPolicyName = exports$1.systemErrorRetryPolicy = exports$1.retryPolicy = exports$1.exponentialRetryPolicyName = exports$1.exponentialRetryPolicy = exports$1.defaultRetryPolicyName = exports$1.defaultRetryPolicy = exports$1.decompressResponsePolicyName = exports$1.decompressResponsePolicy = exports$1.agentPolicyName = exports$1.agentPolicy = void 0;
		var agentPolicy_js_1 = requireAgentPolicy$1();
		Object.defineProperty(exports$1, "agentPolicy", { enumerable: true, get: function () { return agentPolicy_js_1.agentPolicy; } });
		Object.defineProperty(exports$1, "agentPolicyName", { enumerable: true, get: function () { return agentPolicy_js_1.agentPolicyName; } });
		var decompressResponsePolicy_js_1 = requireDecompressResponsePolicy$1();
		Object.defineProperty(exports$1, "decompressResponsePolicy", { enumerable: true, get: function () { return decompressResponsePolicy_js_1.decompressResponsePolicy; } });
		Object.defineProperty(exports$1, "decompressResponsePolicyName", { enumerable: true, get: function () { return decompressResponsePolicy_js_1.decompressResponsePolicyName; } });
		var defaultRetryPolicy_js_1 = requireDefaultRetryPolicy$1();
		Object.defineProperty(exports$1, "defaultRetryPolicy", { enumerable: true, get: function () { return defaultRetryPolicy_js_1.defaultRetryPolicy; } });
		Object.defineProperty(exports$1, "defaultRetryPolicyName", { enumerable: true, get: function () { return defaultRetryPolicy_js_1.defaultRetryPolicyName; } });
		var exponentialRetryPolicy_js_1 = requireExponentialRetryPolicy$1();
		Object.defineProperty(exports$1, "exponentialRetryPolicy", { enumerable: true, get: function () { return exponentialRetryPolicy_js_1.exponentialRetryPolicy; } });
		Object.defineProperty(exports$1, "exponentialRetryPolicyName", { enumerable: true, get: function () { return exponentialRetryPolicy_js_1.exponentialRetryPolicyName; } });
		var retryPolicy_js_1 = requireRetryPolicy$1();
		Object.defineProperty(exports$1, "retryPolicy", { enumerable: true, get: function () { return retryPolicy_js_1.retryPolicy; } });
		var systemErrorRetryPolicy_js_1 = requireSystemErrorRetryPolicy$1();
		Object.defineProperty(exports$1, "systemErrorRetryPolicy", { enumerable: true, get: function () { return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy; } });
		Object.defineProperty(exports$1, "systemErrorRetryPolicyName", { enumerable: true, get: function () { return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName; } });
		var throttlingRetryPolicy_js_1 = requireThrottlingRetryPolicy$1();
		Object.defineProperty(exports$1, "throttlingRetryPolicy", { enumerable: true, get: function () { return throttlingRetryPolicy_js_1.throttlingRetryPolicy; } });
		Object.defineProperty(exports$1, "throttlingRetryPolicyName", { enumerable: true, get: function () { return throttlingRetryPolicy_js_1.throttlingRetryPolicyName; } });
		var formDataPolicy_js_1 = requireFormDataPolicy$1();
		Object.defineProperty(exports$1, "formDataPolicy", { enumerable: true, get: function () { return formDataPolicy_js_1.formDataPolicy; } });
		Object.defineProperty(exports$1, "formDataPolicyName", { enumerable: true, get: function () { return formDataPolicy_js_1.formDataPolicyName; } });
		var logPolicy_js_1 = requireLogPolicy$1();
		Object.defineProperty(exports$1, "logPolicy", { enumerable: true, get: function () { return logPolicy_js_1.logPolicy; } });
		Object.defineProperty(exports$1, "logPolicyName", { enumerable: true, get: function () { return logPolicy_js_1.logPolicyName; } });
		var multipartPolicy_js_1 = requireMultipartPolicy$1();
		Object.defineProperty(exports$1, "multipartPolicy", { enumerable: true, get: function () { return multipartPolicy_js_1.multipartPolicy; } });
		Object.defineProperty(exports$1, "multipartPolicyName", { enumerable: true, get: function () { return multipartPolicy_js_1.multipartPolicyName; } });
		var proxyPolicy_js_1 = requireProxyPolicy$1();
		Object.defineProperty(exports$1, "proxyPolicy", { enumerable: true, get: function () { return proxyPolicy_js_1.proxyPolicy; } });
		Object.defineProperty(exports$1, "proxyPolicyName", { enumerable: true, get: function () { return proxyPolicy_js_1.proxyPolicyName; } });
		Object.defineProperty(exports$1, "getDefaultProxySettings", { enumerable: true, get: function () { return proxyPolicy_js_1.getDefaultProxySettings; } });
		var redirectPolicy_js_1 = requireRedirectPolicy$1();
		Object.defineProperty(exports$1, "redirectPolicy", { enumerable: true, get: function () { return redirectPolicy_js_1.redirectPolicy; } });
		Object.defineProperty(exports$1, "redirectPolicyName", { enumerable: true, get: function () { return redirectPolicy_js_1.redirectPolicyName; } });
		var tlsPolicy_js_1 = requireTlsPolicy$1();
		Object.defineProperty(exports$1, "tlsPolicy", { enumerable: true, get: function () { return tlsPolicy_js_1.tlsPolicy; } });
		Object.defineProperty(exports$1, "tlsPolicyName", { enumerable: true, get: function () { return tlsPolicy_js_1.tlsPolicyName; } });
		var userAgentPolicy_js_1 = requireUserAgentPolicy$1();
		Object.defineProperty(exports$1, "userAgentPolicy", { enumerable: true, get: function () { return userAgentPolicy_js_1.userAgentPolicy; } });
		Object.defineProperty(exports$1, "userAgentPolicyName", { enumerable: true, get: function () { return userAgentPolicy_js_1.userAgentPolicyName; } });
		
	} (internal$1));
	return internal$1;
}

var hasRequiredLogPolicy;

function requireLogPolicy () {
	if (hasRequiredLogPolicy) return logPolicy;
	hasRequiredLogPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(logPolicy, "__esModule", { value: true });
	logPolicy.logPolicyName = void 0;
	logPolicy.logPolicy = logPolicy$1;
	const log_js_1 = requireLog$1();
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * The programmatic identifier of the logPolicy.
	 */
	logPolicy.logPolicyName = policies_1.logPolicyName;
	/**
	 * A policy that logs all requests and responses.
	 * @param options - Options to configure logPolicy.
	 */
	function logPolicy$1(options = {}) {
	    return (0, policies_1.logPolicy)({
	        logger: log_js_1.logger.info,
	        ...options,
	    });
	}
	
	return logPolicy;
}

var redirectPolicy = {};

var hasRequiredRedirectPolicy;

function requireRedirectPolicy () {
	if (hasRequiredRedirectPolicy) return redirectPolicy;
	hasRequiredRedirectPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(redirectPolicy, "__esModule", { value: true });
	redirectPolicy.redirectPolicyName = void 0;
	redirectPolicy.redirectPolicy = redirectPolicy$1;
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * The programmatic identifier of the redirectPolicy.
	 */
	redirectPolicy.redirectPolicyName = policies_1.redirectPolicyName;
	/**
	 * A policy to follow Location headers from the server in order
	 * to support server-side redirection.
	 * In the browser, this policy is not used.
	 * @param options - Options to control policy behavior.
	 */
	function redirectPolicy$1(options = {}) {
	    return (0, policies_1.redirectPolicy)(options);
	}
	
	return redirectPolicy;
}

var userAgentPolicy = {};

var userAgent = {};

var userAgentPlatform = {};

var hasRequiredUserAgentPlatform;

function requireUserAgentPlatform () {
	if (hasRequiredUserAgentPlatform) return userAgentPlatform;
	hasRequiredUserAgentPlatform = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(userAgentPlatform, "__esModule", { value: true });
	userAgentPlatform.getHeaderName = getHeaderName;
	userAgentPlatform.setPlatformSpecificData = setPlatformSpecificData;
	const tslib_1 = require$$0$3;
	const node_os_1 = tslib_1.__importDefault(__require$9());
	const node_process_1 = tslib_1.__importDefault(__require$7());
	/**
	 * @internal
	 */
	function getHeaderName() {
	    return "User-Agent";
	}
	/**
	 * @internal
	 */
	async function setPlatformSpecificData(map) {
	    if (node_process_1.default && node_process_1.default.versions) {
	        const osInfo = `${node_os_1.default.type()} ${node_os_1.default.release()}; ${node_os_1.default.arch()}`;
	        const versions = node_process_1.default.versions;
	        if (versions.bun) {
	            map.set("Bun", `${versions.bun} (${osInfo})`);
	        }
	        else if (versions.deno) {
	            map.set("Deno", `${versions.deno} (${osInfo})`);
	        }
	        else if (versions.node) {
	            map.set("Node", `${versions.node} (${osInfo})`);
	        }
	    }
	}
	
	return userAgentPlatform;
}

var constants = {};

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(constants, "__esModule", { value: true });
	constants.DEFAULT_RETRY_POLICY_COUNT = constants.SDK_VERSION = void 0;
	constants.SDK_VERSION = "1.22.2";
	constants.DEFAULT_RETRY_POLICY_COUNT = 3;
	
	return constants;
}

var hasRequiredUserAgent;

function requireUserAgent () {
	if (hasRequiredUserAgent) return userAgent;
	hasRequiredUserAgent = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(userAgent, "__esModule", { value: true });
	userAgent.getUserAgentHeaderName = getUserAgentHeaderName;
	userAgent.getUserAgentValue = getUserAgentValue;
	const userAgentPlatform_js_1 = requireUserAgentPlatform();
	const constants_js_1 = requireConstants();
	function getUserAgentString(telemetryInfo) {
	    const parts = [];
	    for (const [key, value] of telemetryInfo) {
	        const token = value ? `${key}/${value}` : key;
	        parts.push(token);
	    }
	    return parts.join(" ");
	}
	/**
	 * @internal
	 */
	function getUserAgentHeaderName() {
	    return (0, userAgentPlatform_js_1.getHeaderName)();
	}
	/**
	 * @internal
	 */
	async function getUserAgentValue(prefix) {
	    const runtimeInfo = new Map();
	    runtimeInfo.set("core-rest-pipeline", constants_js_1.SDK_VERSION);
	    await (0, userAgentPlatform_js_1.setPlatformSpecificData)(runtimeInfo);
	    const defaultAgent = getUserAgentString(runtimeInfo);
	    const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;
	    return userAgentValue;
	}
	
	return userAgent;
}

var hasRequiredUserAgentPolicy;

function requireUserAgentPolicy () {
	if (hasRequiredUserAgentPolicy) return userAgentPolicy;
	hasRequiredUserAgentPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.userAgentPolicyName = void 0;
		exports$1.userAgentPolicy = userAgentPolicy;
		const userAgent_js_1 = requireUserAgent();
		const UserAgentHeaderName = (0, userAgent_js_1.getUserAgentHeaderName)();
		/**
		 * The programmatic identifier of the userAgentPolicy.
		 */
		exports$1.userAgentPolicyName = "userAgentPolicy";
		/**
		 * A policy that sets the User-Agent header (or equivalent) to reflect
		 * the library version.
		 * @param options - Options to customize the user agent value.
		 */
		function userAgentPolicy(options = {}) {
		    const userAgentValue = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
		    return {
		        name: exports$1.userAgentPolicyName,
		        async sendRequest(request, next) {
		            if (!request.headers.has(UserAgentHeaderName)) {
		                request.headers.set(UserAgentHeaderName, await userAgentValue);
		            }
		            return next(request);
		        },
		    };
		}
		
	} (userAgentPolicy));
	return userAgentPolicy;
}

var multipartPolicy = {};

var file = {};

var hasRequiredFile;

function requireFile () {
	if (hasRequiredFile) return file;
	hasRequiredFile = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(file, "__esModule", { value: true });
	file.hasRawContent = hasRawContent;
	file.getRawContent = getRawContent;
	file.createFileFromStream = createFileFromStream;
	file.createFile = createFile;
	const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
	function isNodeReadableStream(x) {
	    return Boolean(x && typeof x["pipe"] === "function");
	}
	const unimplementedMethods = {
	    arrayBuffer: () => {
	        throw new Error("Not implemented");
	    },
	    bytes: () => {
	        throw new Error("Not implemented");
	    },
	    slice: () => {
	        throw new Error("Not implemented");
	    },
	    text: () => {
	        throw new Error("Not implemented");
	    },
	};
	/**
	 * Private symbol used as key on objects created using createFile containing the
	 * original source of the file object.
	 *
	 * This is used in Node to access the original Node stream without using Blob#stream, which
	 * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and
	 * Readable#to/fromWeb in Node versions we support:
	 * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)
	 * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)
	 *
	 * Once these versions are no longer supported, we may be able to stop doing this.
	 *
	 * @internal
	 */
	const rawContent = Symbol("rawContent");
	/**
	 * Type guard to check if a given object is a blob-like object with a raw content property.
	 */
	function hasRawContent(x) {
	    return typeof x[rawContent] === "function";
	}
	/**
	 * Extract the raw content from a given blob-like object. If the input was created using createFile
	 * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.
	 * For true instances of Blob and File, returns the actual blob.
	 *
	 * @internal
	 */
	function getRawContent(blob) {
	    if (hasRawContent(blob)) {
	        return blob[rawContent]();
	    }
	    else {
	        return blob;
	    }
	}
	/**
	 * Create an object that implements the File interface. This object is intended to be
	 * passed into RequestBodyType.formData, and is not guaranteed to work as expected in
	 * other situations.
	 *
	 * Use this function to:
	 * - Create a File object for use in RequestBodyType.formData in environments where the
	 *   global File object is unavailable.
	 * - Create a File-like object from a readable stream without reading the stream into memory.
	 *
	 * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is
	 *                  passed in a request's form data map, the stream will not be read into memory
	 *                  and instead will be streamed when the request is made. In the event of a retry, the
	 *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.
	 * @param name - the name of the file.
	 * @param options - optional metadata about the file, e.g. file name, file size, MIME type.
	 */
	function createFileFromStream(stream, name, options = {}) {
	    return {
	        ...unimplementedMethods,
	        type: options.type ?? "",
	        lastModified: options.lastModified ?? new Date().getTime(),
	        webkitRelativePath: options.webkitRelativePath ?? "",
	        size: options.size ?? -1,
	        name,
	        stream: () => {
	            const s = stream();
	            if (isNodeReadableStream(s)) {
	                throw new Error("Not supported: a Node stream was provided as input to createFileFromStream.");
	            }
	            return s;
	        },
	        [rawContent]: stream,
	    };
	}
	/**
	 * Create an object that implements the File interface. This object is intended to be
	 * passed into RequestBodyType.formData, and is not guaranteed to work as expected in
	 * other situations.
	 *
	 * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.
	 *
	 * @param content - the content of the file as a Uint8Array in memory.
	 * @param name - the name of the file.
	 * @param options - optional metadata about the file, e.g. file name, file size, MIME type.
	 */
	function createFile(content, name, options = {}) {
	    if (core_util_1.isNodeLike) {
	        return {
	            ...unimplementedMethods,
	            type: options.type ?? "",
	            lastModified: options.lastModified ?? new Date().getTime(),
	            webkitRelativePath: options.webkitRelativePath ?? "",
	            size: content.byteLength,
	            name,
	            arrayBuffer: async () => content.buffer,
	            stream: () => new Blob([toArrayBuffer(content)]).stream(),
	            [rawContent]: () => content,
	        };
	    }
	    else {
	        return new File([toArrayBuffer(content)], name, options);
	    }
	}
	function toArrayBuffer(source) {
	    if ("resize" in source.buffer) {
	        // ArrayBuffer
	        return source;
	    }
	    // SharedArrayBuffer
	    return source.map((x) => x);
	}
	
	return file;
}

var hasRequiredMultipartPolicy;

function requireMultipartPolicy () {
	if (hasRequiredMultipartPolicy) return multipartPolicy;
	hasRequiredMultipartPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.multipartPolicyName = void 0;
		exports$1.multipartPolicy = multipartPolicy;
		const policies_1 = /*@__PURE__*/ requireInternal$1();
		const file_js_1 = requireFile();
		/**
		 * Name of multipart policy
		 */
		exports$1.multipartPolicyName = policies_1.multipartPolicyName;
		/**
		 * Pipeline policy for multipart requests
		 */
		function multipartPolicy() {
		    const tspPolicy = (0, policies_1.multipartPolicy)();
		    return {
		        name: exports$1.multipartPolicyName,
		        sendRequest: async (request, next) => {
		            if (request.multipartBody) {
		                for (const part of request.multipartBody.parts) {
		                    if ((0, file_js_1.hasRawContent)(part.body)) {
		                        part.body = (0, file_js_1.getRawContent)(part.body);
		                    }
		                }
		            }
		            return tspPolicy.sendRequest(request, next);
		        },
		    };
		}
		
	} (multipartPolicy));
	return multipartPolicy;
}

var decompressResponsePolicy = {};

var hasRequiredDecompressResponsePolicy;

function requireDecompressResponsePolicy () {
	if (hasRequiredDecompressResponsePolicy) return decompressResponsePolicy;
	hasRequiredDecompressResponsePolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(decompressResponsePolicy, "__esModule", { value: true });
	decompressResponsePolicy.decompressResponsePolicyName = void 0;
	decompressResponsePolicy.decompressResponsePolicy = decompressResponsePolicy$1;
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * The programmatic identifier of the decompressResponsePolicy.
	 */
	decompressResponsePolicy.decompressResponsePolicyName = policies_1.decompressResponsePolicyName;
	/**
	 * A policy to enable response decompression according to Accept-Encoding header
	 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding
	 */
	function decompressResponsePolicy$1() {
	    return (0, policies_1.decompressResponsePolicy)();
	}
	
	return decompressResponsePolicy;
}

var defaultRetryPolicy = {};

var hasRequiredDefaultRetryPolicy;

function requireDefaultRetryPolicy () {
	if (hasRequiredDefaultRetryPolicy) return defaultRetryPolicy;
	hasRequiredDefaultRetryPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(defaultRetryPolicy, "__esModule", { value: true });
	defaultRetryPolicy.defaultRetryPolicyName = void 0;
	defaultRetryPolicy.defaultRetryPolicy = defaultRetryPolicy$1;
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * Name of the {@link defaultRetryPolicy}
	 */
	defaultRetryPolicy.defaultRetryPolicyName = policies_1.defaultRetryPolicyName;
	/**
	 * A policy that retries according to three strategies:
	 * - When the server sends a 429 response with a Retry-After header.
	 * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).
	 * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.
	 */
	function defaultRetryPolicy$1(options = {}) {
	    return (0, policies_1.defaultRetryPolicy)(options);
	}
	
	return defaultRetryPolicy;
}

var formDataPolicy = {};

var hasRequiredFormDataPolicy;

function requireFormDataPolicy () {
	if (hasRequiredFormDataPolicy) return formDataPolicy;
	hasRequiredFormDataPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(formDataPolicy, "__esModule", { value: true });
	formDataPolicy.formDataPolicyName = void 0;
	formDataPolicy.formDataPolicy = formDataPolicy$1;
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * The programmatic identifier of the formDataPolicy.
	 */
	formDataPolicy.formDataPolicyName = policies_1.formDataPolicyName;
	/**
	 * A policy that encodes FormData on the request into the body.
	 */
	function formDataPolicy$1() {
	    return (0, policies_1.formDataPolicy)();
	}
	
	return formDataPolicy;
}

var proxyPolicy = {};

var hasRequiredProxyPolicy;

function requireProxyPolicy () {
	if (hasRequiredProxyPolicy) return proxyPolicy;
	hasRequiredProxyPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(proxyPolicy, "__esModule", { value: true });
	proxyPolicy.proxyPolicyName = void 0;
	proxyPolicy.getDefaultProxySettings = getDefaultProxySettings;
	proxyPolicy.proxyPolicy = proxyPolicy$1;
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * The programmatic identifier of the proxyPolicy.
	 */
	proxyPolicy.proxyPolicyName = policies_1.proxyPolicyName;
	/**
	 * This method converts a proxy url into `ProxySettings` for use with ProxyPolicy.
	 * If no argument is given, it attempts to parse a proxy URL from the environment
	 * variables `HTTPS_PROXY` or `HTTP_PROXY`.
	 * @param proxyUrl - The url of the proxy to use. May contain authentication information.
	 * @deprecated - Internally this method is no longer necessary when setting proxy information.
	 */
	function getDefaultProxySettings(proxyUrl) {
	    return (0, policies_1.getDefaultProxySettings)(proxyUrl);
	}
	/**
	 * A policy that allows one to apply proxy settings to all requests.
	 * If not passed static settings, they will be retrieved from the HTTPS_PROXY
	 * or HTTP_PROXY environment variables.
	 * @param proxySettings - ProxySettings to use on each request.
	 * @param options - additional settings, for example, custom NO_PROXY patterns
	 */
	function proxyPolicy$1(proxySettings, options) {
	    return (0, policies_1.proxyPolicy)(proxySettings, options);
	}
	
	return proxyPolicy;
}

var setClientRequestIdPolicy = {};

var hasRequiredSetClientRequestIdPolicy;

function requireSetClientRequestIdPolicy () {
	if (hasRequiredSetClientRequestIdPolicy) return setClientRequestIdPolicy;
	hasRequiredSetClientRequestIdPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.setClientRequestIdPolicyName = void 0;
		exports$1.setClientRequestIdPolicy = setClientRequestIdPolicy;
		/**
		 * The programmatic identifier of the setClientRequestIdPolicy.
		 */
		exports$1.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
		/**
		 * Each PipelineRequest gets a unique id upon creation.
		 * This policy passes that unique id along via an HTTP header to enable better
		 * telemetry and tracing.
		 * @param requestIdHeaderName - The name of the header to pass the request ID to.
		 */
		function setClientRequestIdPolicy(requestIdHeaderName = "x-ms-client-request-id") {
		    return {
		        name: exports$1.setClientRequestIdPolicyName,
		        async sendRequest(request, next) {
		            if (!request.headers.has(requestIdHeaderName)) {
		                request.headers.set(requestIdHeaderName, request.requestId);
		            }
		            return next(request);
		        },
		    };
		}
		
	} (setClientRequestIdPolicy));
	return setClientRequestIdPolicy;
}

var agentPolicy = {};

var hasRequiredAgentPolicy;

function requireAgentPolicy () {
	if (hasRequiredAgentPolicy) return agentPolicy;
	hasRequiredAgentPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(agentPolicy, "__esModule", { value: true });
	agentPolicy.agentPolicyName = void 0;
	agentPolicy.agentPolicy = agentPolicy$1;
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * Name of the Agent Policy
	 */
	agentPolicy.agentPolicyName = policies_1.agentPolicyName;
	/**
	 * Gets a pipeline policy that sets http.agent
	 */
	function agentPolicy$1(agent) {
	    return (0, policies_1.agentPolicy)(agent);
	}
	
	return agentPolicy;
}

var tlsPolicy = {};

var hasRequiredTlsPolicy;

function requireTlsPolicy () {
	if (hasRequiredTlsPolicy) return tlsPolicy;
	hasRequiredTlsPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(tlsPolicy, "__esModule", { value: true });
	tlsPolicy.tlsPolicyName = void 0;
	tlsPolicy.tlsPolicy = tlsPolicy$1;
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * Name of the TLS Policy
	 */
	tlsPolicy.tlsPolicyName = policies_1.tlsPolicyName;
	/**
	 * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.
	 */
	function tlsPolicy$1(tlsSettings) {
	    return (0, policies_1.tlsPolicy)(tlsSettings);
	}
	
	return tlsPolicy;
}

var tracingPolicy = {};

var restError = {};

var hasRequiredRestError;

function requireRestError () {
	if (hasRequiredRestError) return restError;
	hasRequiredRestError = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(restError, "__esModule", { value: true });
	restError.RestError = void 0;
	restError.isRestError = isRestError;
	const ts_http_runtime_1 = /*@__PURE__*/ requireCommonjs$4();
	/**
	 * A custom error type for failed pipeline requests.
	 */
	// eslint-disable-next-line @typescript-eslint/no-redeclare
	restError.RestError = ts_http_runtime_1.RestError;
	/**
	 * Typeguard for RestError
	 * @param e - Something caught by a catch clause.
	 */
	function isRestError(e) {
	    return (0, ts_http_runtime_1.isRestError)(e);
	}
	
	return restError;
}

var hasRequiredTracingPolicy;

function requireTracingPolicy () {
	if (hasRequiredTracingPolicy) return tracingPolicy;
	hasRequiredTracingPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.tracingPolicyName = void 0;
		exports$1.tracingPolicy = tracingPolicy;
		const core_tracing_1 = /*@__PURE__*/ requireCommonjs$7();
		const constants_js_1 = requireConstants();
		const userAgent_js_1 = requireUserAgent();
		const log_js_1 = requireLog$1();
		const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
		const restError_js_1 = requireRestError();
		const util_1 = /*@__PURE__*/ requireInternal$2();
		/**
		 * The programmatic identifier of the tracingPolicy.
		 */
		exports$1.tracingPolicyName = "tracingPolicy";
		/**
		 * A simple policy to create OpenTelemetry Spans for each request made by the pipeline
		 * that has SpanOptions with a parent.
		 * Requests made without a parent Span will not be recorded.
		 * @param options - Options to configure the telemetry logged by the tracing policy.
		 */
		function tracingPolicy(options = {}) {
		    const userAgentPromise = (0, userAgent_js_1.getUserAgentValue)(options.userAgentPrefix);
		    const sanitizer = new util_1.Sanitizer({
		        additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,
		    });
		    const tracingClient = tryCreateTracingClient();
		    return {
		        name: exports$1.tracingPolicyName,
		        async sendRequest(request, next) {
		            if (!tracingClient) {
		                return next(request);
		            }
		            const userAgent = await userAgentPromise;
		            const spanAttributes = {
		                "http.url": sanitizer.sanitizeUrl(request.url),
		                "http.method": request.method,
		                "http.user_agent": userAgent,
		                requestId: request.requestId,
		            };
		            if (userAgent) {
		                spanAttributes["http.user_agent"] = userAgent;
		            }
		            const { span, tracingContext } = tryCreateSpan(tracingClient, request, spanAttributes) ?? {};
		            if (!span || !tracingContext) {
		                return next(request);
		            }
		            try {
		                const response = await tracingClient.withContext(tracingContext, next, request);
		                tryProcessResponse(span, response);
		                return response;
		            }
		            catch (err) {
		                tryProcessError(span, err);
		                throw err;
		            }
		        },
		    };
		}
		function tryCreateTracingClient() {
		    try {
		        return (0, core_tracing_1.createTracingClient)({
		            namespace: "",
		            packageName: "@azure/core-rest-pipeline",
		            packageVersion: constants_js_1.SDK_VERSION,
		        });
		    }
		    catch (e) {
		        log_js_1.logger.warning(`Error when creating the TracingClient: ${(0, core_util_1.getErrorMessage)(e)}`);
		        return undefined;
		    }
		}
		function tryCreateSpan(tracingClient, request, spanAttributes) {
		    try {
		        // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.
		        const { span, updatedOptions } = tracingClient.startSpan(`HTTP ${request.method}`, { tracingOptions: request.tracingOptions }, {
		            spanKind: "client",
		            spanAttributes,
		        });
		        // If the span is not recording, don't do any more work.
		        if (!span.isRecording()) {
		            span.end();
		            return undefined;
		        }
		        // set headers
		        const headers = tracingClient.createRequestHeaders(updatedOptions.tracingOptions.tracingContext);
		        for (const [key, value] of Object.entries(headers)) {
		            request.headers.set(key, value);
		        }
		        return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };
		    }
		    catch (e) {
		        log_js_1.logger.warning(`Skipping creating a tracing span due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
		        return undefined;
		    }
		}
		function tryProcessError(span, error) {
		    try {
		        span.setStatus({
		            status: "error",
		            error: (0, core_util_1.isError)(error) ? error : undefined,
		        });
		        if ((0, restError_js_1.isRestError)(error) && error.statusCode) {
		            span.setAttribute("http.status_code", error.statusCode);
		        }
		        span.end();
		    }
		    catch (e) {
		        log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
		    }
		}
		function tryProcessResponse(span, response) {
		    try {
		        span.setAttribute("http.status_code", response.status);
		        const serviceRequestId = response.headers.get("x-ms-request-id");
		        if (serviceRequestId) {
		            span.setAttribute("serviceRequestId", serviceRequestId);
		        }
		        // Per semantic conventions, only set the status to error if the status code is 4xx or 5xx.
		        // Otherwise, the status MUST remain unset.
		        // https://opentelemetry.io/docs/specs/semconv/http/http-spans/#status
		        if (response.status >= 400) {
		            span.setStatus({
		                status: "error",
		            });
		        }
		        span.end();
		    }
		    catch (e) {
		        log_js_1.logger.warning(`Skipping tracing span processing due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
		    }
		}
		
	} (tracingPolicy));
	return tracingPolicy;
}

var wrapAbortSignalLikePolicy = {};

var wrapAbortSignal = {};

var hasRequiredWrapAbortSignal;

function requireWrapAbortSignal () {
	if (hasRequiredWrapAbortSignal) return wrapAbortSignal;
	hasRequiredWrapAbortSignal = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(wrapAbortSignal, "__esModule", { value: true });
	wrapAbortSignal.wrapAbortSignalLike = wrapAbortSignalLike;
	/**
	 * Creates a native AbortSignal which reflects the state of the provided AbortSignalLike.
	 * If the AbortSignalLike is already a native AbortSignal, it is returned as is.
	 * @param abortSignalLike - The AbortSignalLike to wrap.
	 * @returns - An object containing the native AbortSignal and an optional cleanup function. The cleanup function should be called when the AbortSignal is no longer needed.
	 */
	function wrapAbortSignalLike(abortSignalLike) {
	    if (abortSignalLike instanceof AbortSignal) {
	        return { abortSignal: abortSignalLike };
	    }
	    if (abortSignalLike.aborted) {
	        return { abortSignal: AbortSignal.abort(abortSignalLike.reason) };
	    }
	    const controller = new AbortController();
	    let needsCleanup = true;
	    function cleanup() {
	        if (needsCleanup) {
	            abortSignalLike.removeEventListener("abort", listener);
	            needsCleanup = false;
	        }
	    }
	    function listener() {
	        controller.abort(abortSignalLike.reason);
	        cleanup();
	    }
	    abortSignalLike.addEventListener("abort", listener);
	    return { abortSignal: controller.signal, cleanup };
	}
	
	return wrapAbortSignal;
}

var hasRequiredWrapAbortSignalLikePolicy;

function requireWrapAbortSignalLikePolicy () {
	if (hasRequiredWrapAbortSignalLikePolicy) return wrapAbortSignalLikePolicy;
	hasRequiredWrapAbortSignalLikePolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.wrapAbortSignalLikePolicyName = void 0;
		exports$1.wrapAbortSignalLikePolicy = wrapAbortSignalLikePolicy;
		const wrapAbortSignal_js_1 = requireWrapAbortSignal();
		exports$1.wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
		/**
		 * Policy that ensure that any AbortSignalLike is wrapped in a native AbortSignal for processing by the pipeline.
		 * Since the ts-http-runtime expects a native AbortSignal, this policy is used to ensure that any AbortSignalLike is wrapped in a native AbortSignal.
		 *
		 * @returns - created policy
		 */
		function wrapAbortSignalLikePolicy() {
		    return {
		        name: exports$1.wrapAbortSignalLikePolicyName,
		        sendRequest: async (request, next) => {
		            if (!request.abortSignal) {
		                return next(request);
		            }
		            const { abortSignal, cleanup } = (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request.abortSignal);
		            request.abortSignal = abortSignal;
		            try {
		                return await next(request);
		            }
		            finally {
		                cleanup?.();
		            }
		        },
		    };
		}
		
	} (wrapAbortSignalLikePolicy));
	return wrapAbortSignalLikePolicy;
}

var hasRequiredCreatePipelineFromOptions;

function requireCreatePipelineFromOptions () {
	if (hasRequiredCreatePipelineFromOptions) return createPipelineFromOptions;
	hasRequiredCreatePipelineFromOptions = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(createPipelineFromOptions, "__esModule", { value: true });
	createPipelineFromOptions.createPipelineFromOptions = createPipelineFromOptions$1;
	const logPolicy_js_1 = requireLogPolicy();
	const pipeline_js_1 = requirePipeline$2();
	const redirectPolicy_js_1 = requireRedirectPolicy();
	const userAgentPolicy_js_1 = requireUserAgentPolicy();
	const multipartPolicy_js_1 = requireMultipartPolicy();
	const decompressResponsePolicy_js_1 = requireDecompressResponsePolicy();
	const defaultRetryPolicy_js_1 = requireDefaultRetryPolicy();
	const formDataPolicy_js_1 = requireFormDataPolicy();
	const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
	const proxyPolicy_js_1 = requireProxyPolicy();
	const setClientRequestIdPolicy_js_1 = requireSetClientRequestIdPolicy();
	const agentPolicy_js_1 = requireAgentPolicy();
	const tlsPolicy_js_1 = requireTlsPolicy();
	const tracingPolicy_js_1 = requireTracingPolicy();
	const wrapAbortSignalLikePolicy_js_1 = requireWrapAbortSignalLikePolicy();
	/**
	 * Create a new pipeline with a default set of customizable policies.
	 * @param options - Options to configure a custom pipeline.
	 */
	function createPipelineFromOptions$1(options) {
	    const pipeline = (0, pipeline_js_1.createEmptyPipeline)();
	    if (core_util_1.isNodeLike) {
	        if (options.agent) {
	            pipeline.addPolicy((0, agentPolicy_js_1.agentPolicy)(options.agent));
	        }
	        if (options.tlsOptions) {
	            pipeline.addPolicy((0, tlsPolicy_js_1.tlsPolicy)(options.tlsOptions));
	        }
	        pipeline.addPolicy((0, proxyPolicy_js_1.proxyPolicy)(options.proxyOptions));
	        pipeline.addPolicy((0, decompressResponsePolicy_js_1.decompressResponsePolicy)());
	    }
	    pipeline.addPolicy((0, wrapAbortSignalLikePolicy_js_1.wrapAbortSignalLikePolicy)());
	    pipeline.addPolicy((0, formDataPolicy_js_1.formDataPolicy)(), { beforePolicies: [multipartPolicy_js_1.multipartPolicyName] });
	    pipeline.addPolicy((0, userAgentPolicy_js_1.userAgentPolicy)(options.userAgentOptions));
	    pipeline.addPolicy((0, setClientRequestIdPolicy_js_1.setClientRequestIdPolicy)(options.telemetryOptions?.clientRequestIdHeaderName));
	    // The multipart policy is added after policies with no phase, so that
	    // policies can be added between it and formDataPolicy to modify
	    // properties (e.g., making the boundary constant in recorded tests).
	    pipeline.addPolicy((0, multipartPolicy_js_1.multipartPolicy)(), { afterPhase: "Deserialize" });
	    pipeline.addPolicy((0, defaultRetryPolicy_js_1.defaultRetryPolicy)(options.retryOptions), { phase: "Retry" });
	    pipeline.addPolicy((0, tracingPolicy_js_1.tracingPolicy)({ ...options.userAgentOptions, ...options.loggingOptions }), {
	        afterPhase: "Retry",
	    });
	    if (core_util_1.isNodeLike) {
	        // Both XHR and Fetch expect to handle redirects automatically,
	        // so only include this policy when we're in Node.
	        pipeline.addPolicy((0, redirectPolicy_js_1.redirectPolicy)(options.redirectOptions), { afterPhase: "Retry" });
	    }
	    pipeline.addPolicy((0, logPolicy_js_1.logPolicy)(options.loggingOptions), { afterPhase: "Sign" });
	    return pipeline;
	}
	
	return createPipelineFromOptions;
}

var defaultHttpClient = {};

var hasRequiredDefaultHttpClient;

function requireDefaultHttpClient () {
	if (hasRequiredDefaultHttpClient) return defaultHttpClient;
	hasRequiredDefaultHttpClient = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(defaultHttpClient, "__esModule", { value: true });
	defaultHttpClient.createDefaultHttpClient = createDefaultHttpClient;
	const ts_http_runtime_1 = /*@__PURE__*/ requireCommonjs$4();
	const wrapAbortSignal_js_1 = requireWrapAbortSignal();
	/**
	 * Create the correct HttpClient for the current environment.
	 */
	function createDefaultHttpClient() {
	    const client = (0, ts_http_runtime_1.createDefaultHttpClient)();
	    return {
	        async sendRequest(request) {
	            // we wrap any AbortSignalLike here since the TypeSpec runtime expects a native AbortSignal.
	            // 99% of the time, this should be a no-op since a native AbortSignal is passed in.
	            const { abortSignal, cleanup } = request.abortSignal
	                ? (0, wrapAbortSignal_js_1.wrapAbortSignalLike)(request.abortSignal)
	                : {};
	            try {
	                request.abortSignal = abortSignal;
	                return await client.sendRequest(request);
	            }
	            finally {
	                cleanup?.();
	            }
	        },
	    };
	}
	
	return defaultHttpClient;
}

var httpHeaders = {};

var hasRequiredHttpHeaders;

function requireHttpHeaders () {
	if (hasRequiredHttpHeaders) return httpHeaders;
	hasRequiredHttpHeaders = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(httpHeaders, "__esModule", { value: true });
	httpHeaders.createHttpHeaders = createHttpHeaders;
	const ts_http_runtime_1 = /*@__PURE__*/ requireCommonjs$4();
	/**
	 * Creates an object that satisfies the `HttpHeaders` interface.
	 * @param rawHeaders - A simple object representing initial headers
	 */
	function createHttpHeaders(rawHeaders) {
	    return (0, ts_http_runtime_1.createHttpHeaders)(rawHeaders);
	}
	
	return httpHeaders;
}

var pipelineRequest = {};

var hasRequiredPipelineRequest;

function requirePipelineRequest () {
	if (hasRequiredPipelineRequest) return pipelineRequest;
	hasRequiredPipelineRequest = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(pipelineRequest, "__esModule", { value: true });
	pipelineRequest.createPipelineRequest = createPipelineRequest;
	const ts_http_runtime_1 = /*@__PURE__*/ requireCommonjs$4();
	/**
	 * Creates a new pipeline request with the given options.
	 * This method is to allow for the easy setting of default values and not required.
	 * @param options - The options to create the request with.
	 */
	function createPipelineRequest(options) {
	    // Cast required due to difference between ts-http-runtime requiring AbortSignal while core-rest-pipeline allows
	    // the more generic AbortSignalLike. The wrapAbortSignalLike pipeline policy will take care of ensuring that any AbortSignalLike in the request
	    // is converted into a true AbortSignal.
	    return (0, ts_http_runtime_1.createPipelineRequest)(options);
	}
	
	return pipelineRequest;
}

var exponentialRetryPolicy = {};

var hasRequiredExponentialRetryPolicy;

function requireExponentialRetryPolicy () {
	if (hasRequiredExponentialRetryPolicy) return exponentialRetryPolicy;
	hasRequiredExponentialRetryPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(exponentialRetryPolicy, "__esModule", { value: true });
	exponentialRetryPolicy.exponentialRetryPolicyName = void 0;
	exponentialRetryPolicy.exponentialRetryPolicy = exponentialRetryPolicy$1;
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * The programmatic identifier of the exponentialRetryPolicy.
	 */
	exponentialRetryPolicy.exponentialRetryPolicyName = policies_1.exponentialRetryPolicyName;
	/**
	 * A policy that attempts to retry requests while introducing an exponentially increasing delay.
	 * @param options - Options that configure retry logic.
	 */
	function exponentialRetryPolicy$1(options = {}) {
	    return (0, policies_1.exponentialRetryPolicy)(options);
	}
	
	return exponentialRetryPolicy;
}

var systemErrorRetryPolicy = {};

var hasRequiredSystemErrorRetryPolicy;

function requireSystemErrorRetryPolicy () {
	if (hasRequiredSystemErrorRetryPolicy) return systemErrorRetryPolicy;
	hasRequiredSystemErrorRetryPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(systemErrorRetryPolicy, "__esModule", { value: true });
	systemErrorRetryPolicy.systemErrorRetryPolicyName = void 0;
	systemErrorRetryPolicy.systemErrorRetryPolicy = systemErrorRetryPolicy$1;
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * Name of the {@link systemErrorRetryPolicy}
	 */
	systemErrorRetryPolicy.systemErrorRetryPolicyName = policies_1.systemErrorRetryPolicyName;
	/**
	 * A retry policy that specifically seeks to handle errors in the
	 * underlying transport layer (e.g. DNS lookup failures) rather than
	 * retryable error codes from the server itself.
	 * @param options - Options that customize the policy.
	 */
	function systemErrorRetryPolicy$1(options = {}) {
	    return (0, policies_1.systemErrorRetryPolicy)(options);
	}
	
	return systemErrorRetryPolicy;
}

var throttlingRetryPolicy = {};

var hasRequiredThrottlingRetryPolicy;

function requireThrottlingRetryPolicy () {
	if (hasRequiredThrottlingRetryPolicy) return throttlingRetryPolicy;
	hasRequiredThrottlingRetryPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(throttlingRetryPolicy, "__esModule", { value: true });
	throttlingRetryPolicy.throttlingRetryPolicyName = void 0;
	throttlingRetryPolicy.throttlingRetryPolicy = throttlingRetryPolicy$1;
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	/**
	 * Name of the {@link throttlingRetryPolicy}
	 */
	throttlingRetryPolicy.throttlingRetryPolicyName = policies_1.throttlingRetryPolicyName;
	/**
	 * A policy that retries when the server sends a 429 response with a Retry-After header.
	 *
	 * To learn more, please refer to
	 * https://learn.microsoft.com/azure/azure-resource-manager/resource-manager-request-limits,
	 * https://learn.microsoft.com/azure/azure-subscription-service-limits and
	 * https://learn.microsoft.com/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors
	 *
	 * @param options - Options that configure retry logic.
	 */
	function throttlingRetryPolicy$1(options = {}) {
	    return (0, policies_1.throttlingRetryPolicy)(options);
	}
	
	return throttlingRetryPolicy;
}

var retryPolicy = {};

var hasRequiredRetryPolicy;

function requireRetryPolicy () {
	if (hasRequiredRetryPolicy) return retryPolicy;
	hasRequiredRetryPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(retryPolicy, "__esModule", { value: true });
	retryPolicy.retryPolicy = retryPolicy$1;
	const logger_1 = /*@__PURE__*/ requireCommonjs$8();
	const constants_js_1 = requireConstants();
	const policies_1 = /*@__PURE__*/ requireInternal$1();
	const retryPolicyLogger = (0, logger_1.createClientLogger)("core-rest-pipeline retryPolicy");
	/**
	 * retryPolicy is a generic policy to enable retrying requests when certain conditions are met
	 */
	function retryPolicy$1(strategies, options = { maxRetries: constants_js_1.DEFAULT_RETRY_POLICY_COUNT }) {
	    // Cast is required since the TSP runtime retry strategy type is slightly different
	    // very deep down (using real AbortSignal vs. AbortSignalLike in RestError).
	    // In practice the difference doesn't actually matter.
	    return (0, policies_1.retryPolicy)(strategies, {
	        logger: retryPolicyLogger,
	        ...options,
	    });
	}
	
	return retryPolicy;
}

var bearerTokenAuthenticationPolicy = {};

var tokenCycler = {};

var hasRequiredTokenCycler;

function requireTokenCycler () {
	if (hasRequiredTokenCycler) return tokenCycler;
	hasRequiredTokenCycler = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.DEFAULT_CYCLER_OPTIONS = void 0;
		exports$1.createTokenCycler = createTokenCycler;
		const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
		// Default options for the cycler if none are provided
		exports$1.DEFAULT_CYCLER_OPTIONS = {
		    forcedRefreshWindowInMs: 1000, // Force waiting for a refresh 1s before the token expires
		    retryIntervalInMs: 3000, // Allow refresh attempts every 3s
		    refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry
		};
		/**
		 * Converts an an unreliable access token getter (which may resolve with null)
		 * into an AccessTokenGetter by retrying the unreliable getter in a regular
		 * interval.
		 *
		 * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.
		 * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.
		 * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.
		 * @returns - A promise that, if it resolves, will resolve with an access token.
		 */
		async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
		    // This wrapper handles exceptions gracefully as long as we haven't exceeded
		    // the timeout.
		    async function tryGetAccessToken() {
		        if (Date.now() < refreshTimeout) {
		            try {
		                return await getAccessToken();
		            }
		            catch {
		                return null;
		            }
		        }
		        else {
		            const finalToken = await getAccessToken();
		            // Timeout is up, so throw if it's still null
		            if (finalToken === null) {
		                throw new Error("Failed to refresh access token.");
		            }
		            return finalToken;
		        }
		    }
		    let token = await tryGetAccessToken();
		    while (token === null) {
		        await (0, core_util_1.delay)(retryIntervalInMs);
		        token = await tryGetAccessToken();
		    }
		    return token;
		}
		/**
		 * Creates a token cycler from a credential, scopes, and optional settings.
		 *
		 * A token cycler represents a way to reliably retrieve a valid access token
		 * from a TokenCredential. It will handle initializing the token, refreshing it
		 * when it nears expiration, and synchronizes refresh attempts to avoid
		 * concurrency hazards.
		 *
		 * @param credential - the underlying TokenCredential that provides the access
		 * token
		 * @param tokenCyclerOptions - optionally override default settings for the cycler
		 *
		 * @returns - a function that reliably produces a valid access token
		 */
		function createTokenCycler(credential, tokenCyclerOptions) {
		    let refreshWorker = null;
		    let token = null;
		    let tenantId;
		    const options = {
		        ...exports$1.DEFAULT_CYCLER_OPTIONS,
		        ...tokenCyclerOptions,
		    };
		    /**
		     * This little holder defines several predicates that we use to construct
		     * the rules of refreshing the token.
		     */
		    const cycler = {
		        /**
		         * Produces true if a refresh job is currently in progress.
		         */
		        get isRefreshing() {
		            return refreshWorker !== null;
		        },
		        /**
		         * Produces true if the cycler SHOULD refresh (we are within the refresh
		         * window and not already refreshing)
		         */
		        get shouldRefresh() {
		            if (cycler.isRefreshing) {
		                return false;
		            }
		            if (token?.refreshAfterTimestamp && token.refreshAfterTimestamp < Date.now()) {
		                return true;
		            }
		            return (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now();
		        },
		        /**
		         * Produces true if the cycler MUST refresh (null or nearly-expired
		         * token).
		         */
		        get mustRefresh() {
		            return (token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now());
		        },
		    };
		    /**
		     * Starts a refresh job or returns the existing job if one is already
		     * running.
		     */
		    function refresh(scopes, getTokenOptions) {
		        if (!cycler.isRefreshing) {
		            // We bind `scopes` here to avoid passing it around a lot
		            const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
		            // Take advantage of promise chaining to insert an assignment to `token`
		            // before the refresh can be considered done.
		            refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, 
		            // If we don't have a token, then we should timeout immediately
		            token?.expiresOnTimestamp ?? Date.now())
		                .then((_token) => {
		                refreshWorker = null;
		                token = _token;
		                tenantId = getTokenOptions.tenantId;
		                return token;
		            })
		                .catch((reason) => {
		                // We also should reset the refresher if we enter a failed state.  All
		                // existing awaiters will throw, but subsequent requests will start a
		                // new retry chain.
		                refreshWorker = null;
		                token = null;
		                tenantId = undefined;
		                throw reason;
		            });
		        }
		        return refreshWorker;
		    }
		    return async (scopes, tokenOptions) => {
		        //
		        // Simple rules:
		        // - If we MUST refresh, then return the refresh task, blocking
		        //   the pipeline until a token is available.
		        // - If we SHOULD refresh, then run refresh but don't return it
		        //   (we can still use the cached token).
		        // - Return the token, since it's fine if we didn't return in
		        //   step 1.
		        //
		        const hasClaimChallenge = Boolean(tokenOptions.claims);
		        const tenantIdChanged = tenantId !== tokenOptions.tenantId;
		        if (hasClaimChallenge) {
		            // If we've received a claim, we know the existing token isn't valid
		            // We want to clear it so that that refresh worker won't use the old expiration time as a timeout
		            token = null;
		        }
		        // If the tenantId passed in token options is different to the one we have
		        // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to
		        // refresh the token with the new tenantId or token.
		        const mustRefresh = tenantIdChanged || hasClaimChallenge || cycler.mustRefresh;
		        if (mustRefresh) {
		            return refresh(scopes, tokenOptions);
		        }
		        if (cycler.shouldRefresh) {
		            refresh(scopes, tokenOptions);
		        }
		        return token;
		    };
		}
		
	} (tokenCycler));
	return tokenCycler;
}

var hasRequiredBearerTokenAuthenticationPolicy;

function requireBearerTokenAuthenticationPolicy () {
	if (hasRequiredBearerTokenAuthenticationPolicy) return bearerTokenAuthenticationPolicy;
	hasRequiredBearerTokenAuthenticationPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.bearerTokenAuthenticationPolicyName = void 0;
		exports$1.bearerTokenAuthenticationPolicy = bearerTokenAuthenticationPolicy;
		exports$1.parseChallenges = parseChallenges;
		const tokenCycler_js_1 = requireTokenCycler();
		const log_js_1 = requireLog$1();
		const restError_js_1 = requireRestError();
		/**
		 * The programmatic identifier of the bearerTokenAuthenticationPolicy.
		 */
		exports$1.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
		/**
		 * Try to send the given request.
		 *
		 * When a response is received, returns a tuple of the response received and, if the response was received
		 * inside a thrown RestError, the RestError that was thrown.
		 *
		 * Otherwise, if an error was thrown while sending the request that did not provide an underlying response, it
		 * will be rethrown.
		 */
		async function trySendRequest(request, next) {
		    try {
		        return [await next(request), undefined];
		    }
		    catch (e) {
		        if ((0, restError_js_1.isRestError)(e) && e.response) {
		            return [e.response, e];
		        }
		        else {
		            throw e;
		        }
		    }
		}
		/**
		 * Default authorize request handler
		 */
		async function defaultAuthorizeRequest(options) {
		    const { scopes, getAccessToken, request } = options;
		    // Enable CAE true by default
		    const getTokenOptions = {
		        abortSignal: request.abortSignal,
		        tracingOptions: request.tracingOptions,
		        enableCae: true,
		    };
		    const accessToken = await getAccessToken(scopes, getTokenOptions);
		    if (accessToken) {
		        options.request.headers.set("Authorization", `Bearer ${accessToken.token}`);
		    }
		}
		/**
		 * We will retrieve the challenge only if the response status code was 401,
		 * and if the response contained the header "WWW-Authenticate" with a non-empty value.
		 */
		function isChallengeResponse(response) {
		    return response.status === 401 && response.headers.has("WWW-Authenticate");
		}
		/**
		 * Re-authorize the request for CAE challenge.
		 * The response containing the challenge is `options.response`.
		 * If this method returns true, the underlying request will be sent once again.
		 */
		async function authorizeRequestOnCaeChallenge(onChallengeOptions, caeClaims) {
		    const { scopes } = onChallengeOptions;
		    const accessToken = await onChallengeOptions.getAccessToken(scopes, {
		        enableCae: true,
		        claims: caeClaims,
		    });
		    if (!accessToken) {
		        return false;
		    }
		    onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
		    return true;
		}
		/**
		 * A policy that can request a token from a TokenCredential implementation and
		 * then apply it to the Authorization header of a request as a Bearer token.
		 */
		function bearerTokenAuthenticationPolicy(options) {
		    const { credential, scopes, challengeCallbacks } = options;
		    const logger = options.logger || log_js_1.logger;
		    const callbacks = {
		        authorizeRequest: challengeCallbacks?.authorizeRequest?.bind(challengeCallbacks) ?? defaultAuthorizeRequest,
		        authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge?.bind(challengeCallbacks),
		    };
		    // This function encapsulates the entire process of reliably retrieving the token
		    // The options are left out of the public API until there's demand to configure this.
		    // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`
		    // in order to pass through the `options` object.
		    const getAccessToken = credential
		        ? (0, tokenCycler_js_1.createTokenCycler)(credential /* , options */)
		        : () => Promise.resolve(null);
		    return {
		        name: exports$1.bearerTokenAuthenticationPolicyName,
		        /**
		         * If there's no challenge parameter:
		         * - It will try to retrieve the token using the cache, or the credential's getToken.
		         * - Then it will try the next policy with or without the retrieved token.
		         *
		         * It uses the challenge parameters to:
		         * - Skip a first attempt to get the token from the credential if there's no cached token,
		         *   since it expects the token to be retrievable only after the challenge.
		         * - Prepare the outgoing request if the `prepareRequest` method has been provided.
		         * - Send an initial request to receive the challenge if it fails.
		         * - Process a challenge if the response contains it.
		         * - Retrieve a token with the challenge information, then re-send the request.
		         */
		        async sendRequest(request, next) {
		            if (!request.url.toLowerCase().startsWith("https://")) {
		                throw new Error("Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.");
		            }
		            await callbacks.authorizeRequest({
		                scopes: Array.isArray(scopes) ? scopes : [scopes],
		                request,
		                getAccessToken,
		                logger,
		            });
		            let response;
		            let error;
		            let shouldSendRequest;
		            [response, error] = await trySendRequest(request, next);
		            if (isChallengeResponse(response)) {
		                let claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
		                // Handle CAE by default when receive CAE claim
		                if (claims) {
		                    let parsedClaim;
		                    // Return the response immediately if claims is not a valid base64 encoded string
		                    try {
		                        parsedClaim = atob(claims);
		                    }
		                    catch (e) {
		                        logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
		                        return response;
		                    }
		                    shouldSendRequest = await authorizeRequestOnCaeChallenge({
		                        scopes: Array.isArray(scopes) ? scopes : [scopes],
		                        response,
		                        request,
		                        getAccessToken,
		                        logger,
		                    }, parsedClaim);
		                    // Send updated request and handle response for RestError
		                    if (shouldSendRequest) {
		                        [response, error] = await trySendRequest(request, next);
		                    }
		                }
		                else if (callbacks.authorizeRequestOnChallenge) {
		                    // Handle custom challenges when client provides custom callback
		                    shouldSendRequest = await callbacks.authorizeRequestOnChallenge({
		                        scopes: Array.isArray(scopes) ? scopes : [scopes],
		                        request,
		                        response,
		                        getAccessToken,
		                        logger,
		                    });
		                    // Send updated request and handle response for RestError
		                    if (shouldSendRequest) {
		                        [response, error] = await trySendRequest(request, next);
		                    }
		                    // If we get another CAE Claim, we will handle it by default and return whatever value we receive for this
		                    if (isChallengeResponse(response)) {
		                        claims = getCaeChallengeClaims(response.headers.get("WWW-Authenticate"));
		                        if (claims) {
		                            let parsedClaim;
		                            try {
		                                parsedClaim = atob(claims);
		                            }
		                            catch (e) {
		                                logger.warning(`The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${claims}`);
		                                return response;
		                            }
		                            shouldSendRequest = await authorizeRequestOnCaeChallenge({
		                                scopes: Array.isArray(scopes) ? scopes : [scopes],
		                                response,
		                                request,
		                                getAccessToken,
		                                logger,
		                            }, parsedClaim);
		                            // Send updated request and handle response for RestError
		                            if (shouldSendRequest) {
		                                [response, error] = await trySendRequest(request, next);
		                            }
		                        }
		                    }
		                }
		            }
		            if (error) {
		                throw error;
		            }
		            else {
		                return response;
		            }
		        },
		    };
		}
		/**
		 * Converts: `Bearer a="b", c="d", Pop e="f", g="h"`.
		 * Into: `[ { scheme: 'Bearer', params: { a: 'b', c: 'd' } }, { scheme: 'Pop', params: { e: 'f', g: 'h' } } ]`.
		 *
		 * @internal
		 */
		function parseChallenges(challenges) {
		    // Challenge regex seperates the string to individual challenges with different schemes in the format `Scheme a="b", c=d`
		    // The challenge regex captures parameteres with either quotes values or unquoted values
		    const challengeRegex = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g;
		    // Parameter regex captures the claims group removed from the scheme in the format `a="b"` and `c="d"`
		    // CAE challenge always have quoted parameters. For more reference, https://learn.microsoft.com/entra/identity-platform/claims-challenge
		    const paramRegex = /(\w+)="([^"]*)"/g;
		    const parsedChallenges = [];
		    let match;
		    // Iterate over each challenge match
		    while ((match = challengeRegex.exec(challenges)) !== null) {
		        const scheme = match[1];
		        const paramsString = match[2];
		        const params = {};
		        let paramMatch;
		        // Iterate over each parameter match
		        while ((paramMatch = paramRegex.exec(paramsString)) !== null) {
		            params[paramMatch[1]] = paramMatch[2];
		        }
		        parsedChallenges.push({ scheme, params });
		    }
		    return parsedChallenges;
		}
		/**
		 * Parse a pipeline response and look for a CAE challenge with "Bearer" scheme
		 * Return the value in the header without parsing the challenge
		 * @internal
		 */
		function getCaeChallengeClaims(challenges) {
		    if (!challenges) {
		        return;
		    }
		    // Find all challenges present in the header
		    const parsedChallenges = parseChallenges(challenges);
		    return parsedChallenges.find((x) => x.scheme === "Bearer" && x.params.claims && x.params.error === "insufficient_claims")?.params.claims;
		}
		
	} (bearerTokenAuthenticationPolicy));
	return bearerTokenAuthenticationPolicy;
}

var ndJsonPolicy = {};

var hasRequiredNdJsonPolicy;

function requireNdJsonPolicy () {
	if (hasRequiredNdJsonPolicy) return ndJsonPolicy;
	hasRequiredNdJsonPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.ndJsonPolicyName = void 0;
		exports$1.ndJsonPolicy = ndJsonPolicy;
		/**
		 * The programmatic identifier of the ndJsonPolicy.
		 */
		exports$1.ndJsonPolicyName = "ndJsonPolicy";
		/**
		 * ndJsonPolicy is a policy used to control keep alive settings for every request.
		 */
		function ndJsonPolicy() {
		    return {
		        name: exports$1.ndJsonPolicyName,
		        async sendRequest(request, next) {
		            // There currently isn't a good way to bypass the serializer
		            if (typeof request.body === "string" && request.body.startsWith("[")) {
		                const body = JSON.parse(request.body);
		                if (Array.isArray(body)) {
		                    request.body = body.map((item) => JSON.stringify(item) + "\n").join("");
		                }
		            }
		            return next(request);
		        },
		    };
		}
		
	} (ndJsonPolicy));
	return ndJsonPolicy;
}

var auxiliaryAuthenticationHeaderPolicy = {};

var hasRequiredAuxiliaryAuthenticationHeaderPolicy;

function requireAuxiliaryAuthenticationHeaderPolicy () {
	if (hasRequiredAuxiliaryAuthenticationHeaderPolicy) return auxiliaryAuthenticationHeaderPolicy;
	hasRequiredAuxiliaryAuthenticationHeaderPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.auxiliaryAuthenticationHeaderPolicyName = void 0;
		exports$1.auxiliaryAuthenticationHeaderPolicy = auxiliaryAuthenticationHeaderPolicy;
		const tokenCycler_js_1 = requireTokenCycler();
		const log_js_1 = requireLog$1();
		/**
		 * The programmatic identifier of the auxiliaryAuthenticationHeaderPolicy.
		 */
		exports$1.auxiliaryAuthenticationHeaderPolicyName = "auxiliaryAuthenticationHeaderPolicy";
		const AUTHORIZATION_AUXILIARY_HEADER = "x-ms-authorization-auxiliary";
		async function sendAuthorizeRequest(options) {
		    const { scopes, getAccessToken, request } = options;
		    const getTokenOptions = {
		        abortSignal: request.abortSignal,
		        tracingOptions: request.tracingOptions,
		    };
		    return (await getAccessToken(scopes, getTokenOptions))?.token ?? "";
		}
		/**
		 * A policy for external tokens to `x-ms-authorization-auxiliary` header.
		 * This header will be used when creating a cross-tenant application we may need to handle authentication requests
		 * for resources that are in different tenants.
		 * You could see [ARM docs](https://learn.microsoft.com/azure/azure-resource-manager/management/authenticate-multi-tenant) for a rundown of how this feature works
		 */
		function auxiliaryAuthenticationHeaderPolicy(options) {
		    const { credentials, scopes } = options;
		    const logger = options.logger || log_js_1.logger;
		    const tokenCyclerMap = new WeakMap();
		    return {
		        name: exports$1.auxiliaryAuthenticationHeaderPolicyName,
		        async sendRequest(request, next) {
		            if (!request.url.toLowerCase().startsWith("https://")) {
		                throw new Error("Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.");
		            }
		            if (!credentials || credentials.length === 0) {
		                logger.info(`${exports$1.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`);
		                return next(request);
		            }
		            const tokenPromises = [];
		            for (const credential of credentials) {
		                let getAccessToken = tokenCyclerMap.get(credential);
		                if (!getAccessToken) {
		                    getAccessToken = (0, tokenCycler_js_1.createTokenCycler)(credential);
		                    tokenCyclerMap.set(credential, getAccessToken);
		                }
		                tokenPromises.push(sendAuthorizeRequest({
		                    scopes: Array.isArray(scopes) ? scopes : [scopes],
		                    request,
		                    getAccessToken}));
		            }
		            const auxiliaryTokens = (await Promise.all(tokenPromises)).filter((token) => Boolean(token));
		            if (auxiliaryTokens.length === 0) {
		                logger.warning(`None of the auxiliary tokens are valid. ${AUTHORIZATION_AUXILIARY_HEADER} header will not be set.`);
		                return next(request);
		            }
		            request.headers.set(AUTHORIZATION_AUXILIARY_HEADER, auxiliaryTokens.map((token) => `Bearer ${token}`).join(", "));
		            return next(request);
		        },
		    };
		}
		
	} (auxiliaryAuthenticationHeaderPolicy));
	return auxiliaryAuthenticationHeaderPolicy;
}

var hasRequiredCommonjs$3;

function requireCommonjs$3 () {
	if (hasRequiredCommonjs$3) return commonjs$2;
	hasRequiredCommonjs$3 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.createFileFromStream = exports$1.createFile = exports$1.agentPolicyName = exports$1.agentPolicy = exports$1.auxiliaryAuthenticationHeaderPolicyName = exports$1.auxiliaryAuthenticationHeaderPolicy = exports$1.ndJsonPolicyName = exports$1.ndJsonPolicy = exports$1.bearerTokenAuthenticationPolicyName = exports$1.bearerTokenAuthenticationPolicy = exports$1.formDataPolicyName = exports$1.formDataPolicy = exports$1.tlsPolicyName = exports$1.tlsPolicy = exports$1.userAgentPolicyName = exports$1.userAgentPolicy = exports$1.defaultRetryPolicy = exports$1.tracingPolicyName = exports$1.tracingPolicy = exports$1.retryPolicy = exports$1.throttlingRetryPolicyName = exports$1.throttlingRetryPolicy = exports$1.systemErrorRetryPolicyName = exports$1.systemErrorRetryPolicy = exports$1.redirectPolicyName = exports$1.redirectPolicy = exports$1.getDefaultProxySettings = exports$1.proxyPolicyName = exports$1.proxyPolicy = exports$1.multipartPolicyName = exports$1.multipartPolicy = exports$1.logPolicyName = exports$1.logPolicy = exports$1.setClientRequestIdPolicyName = exports$1.setClientRequestIdPolicy = exports$1.exponentialRetryPolicyName = exports$1.exponentialRetryPolicy = exports$1.decompressResponsePolicyName = exports$1.decompressResponsePolicy = exports$1.isRestError = exports$1.RestError = exports$1.createPipelineRequest = exports$1.createHttpHeaders = exports$1.createDefaultHttpClient = exports$1.createPipelineFromOptions = exports$1.createEmptyPipeline = void 0;
		var pipeline_js_1 = requirePipeline$2();
		Object.defineProperty(exports$1, "createEmptyPipeline", { enumerable: true, get: function () { return pipeline_js_1.createEmptyPipeline; } });
		var createPipelineFromOptions_js_1 = requireCreatePipelineFromOptions();
		Object.defineProperty(exports$1, "createPipelineFromOptions", { enumerable: true, get: function () { return createPipelineFromOptions_js_1.createPipelineFromOptions; } });
		var defaultHttpClient_js_1 = requireDefaultHttpClient();
		Object.defineProperty(exports$1, "createDefaultHttpClient", { enumerable: true, get: function () { return defaultHttpClient_js_1.createDefaultHttpClient; } });
		var httpHeaders_js_1 = requireHttpHeaders();
		Object.defineProperty(exports$1, "createHttpHeaders", { enumerable: true, get: function () { return httpHeaders_js_1.createHttpHeaders; } });
		var pipelineRequest_js_1 = requirePipelineRequest();
		Object.defineProperty(exports$1, "createPipelineRequest", { enumerable: true, get: function () { return pipelineRequest_js_1.createPipelineRequest; } });
		var restError_js_1 = requireRestError();
		Object.defineProperty(exports$1, "RestError", { enumerable: true, get: function () { return restError_js_1.RestError; } });
		Object.defineProperty(exports$1, "isRestError", { enumerable: true, get: function () { return restError_js_1.isRestError; } });
		var decompressResponsePolicy_js_1 = requireDecompressResponsePolicy();
		Object.defineProperty(exports$1, "decompressResponsePolicy", { enumerable: true, get: function () { return decompressResponsePolicy_js_1.decompressResponsePolicy; } });
		Object.defineProperty(exports$1, "decompressResponsePolicyName", { enumerable: true, get: function () { return decompressResponsePolicy_js_1.decompressResponsePolicyName; } });
		var exponentialRetryPolicy_js_1 = requireExponentialRetryPolicy();
		Object.defineProperty(exports$1, "exponentialRetryPolicy", { enumerable: true, get: function () { return exponentialRetryPolicy_js_1.exponentialRetryPolicy; } });
		Object.defineProperty(exports$1, "exponentialRetryPolicyName", { enumerable: true, get: function () { return exponentialRetryPolicy_js_1.exponentialRetryPolicyName; } });
		var setClientRequestIdPolicy_js_1 = requireSetClientRequestIdPolicy();
		Object.defineProperty(exports$1, "setClientRequestIdPolicy", { enumerable: true, get: function () { return setClientRequestIdPolicy_js_1.setClientRequestIdPolicy; } });
		Object.defineProperty(exports$1, "setClientRequestIdPolicyName", { enumerable: true, get: function () { return setClientRequestIdPolicy_js_1.setClientRequestIdPolicyName; } });
		var logPolicy_js_1 = requireLogPolicy();
		Object.defineProperty(exports$1, "logPolicy", { enumerable: true, get: function () { return logPolicy_js_1.logPolicy; } });
		Object.defineProperty(exports$1, "logPolicyName", { enumerable: true, get: function () { return logPolicy_js_1.logPolicyName; } });
		var multipartPolicy_js_1 = requireMultipartPolicy();
		Object.defineProperty(exports$1, "multipartPolicy", { enumerable: true, get: function () { return multipartPolicy_js_1.multipartPolicy; } });
		Object.defineProperty(exports$1, "multipartPolicyName", { enumerable: true, get: function () { return multipartPolicy_js_1.multipartPolicyName; } });
		var proxyPolicy_js_1 = requireProxyPolicy();
		Object.defineProperty(exports$1, "proxyPolicy", { enumerable: true, get: function () { return proxyPolicy_js_1.proxyPolicy; } });
		Object.defineProperty(exports$1, "proxyPolicyName", { enumerable: true, get: function () { return proxyPolicy_js_1.proxyPolicyName; } });
		Object.defineProperty(exports$1, "getDefaultProxySettings", { enumerable: true, get: function () { return proxyPolicy_js_1.getDefaultProxySettings; } });
		var redirectPolicy_js_1 = requireRedirectPolicy();
		Object.defineProperty(exports$1, "redirectPolicy", { enumerable: true, get: function () { return redirectPolicy_js_1.redirectPolicy; } });
		Object.defineProperty(exports$1, "redirectPolicyName", { enumerable: true, get: function () { return redirectPolicy_js_1.redirectPolicyName; } });
		var systemErrorRetryPolicy_js_1 = requireSystemErrorRetryPolicy();
		Object.defineProperty(exports$1, "systemErrorRetryPolicy", { enumerable: true, get: function () { return systemErrorRetryPolicy_js_1.systemErrorRetryPolicy; } });
		Object.defineProperty(exports$1, "systemErrorRetryPolicyName", { enumerable: true, get: function () { return systemErrorRetryPolicy_js_1.systemErrorRetryPolicyName; } });
		var throttlingRetryPolicy_js_1 = requireThrottlingRetryPolicy();
		Object.defineProperty(exports$1, "throttlingRetryPolicy", { enumerable: true, get: function () { return throttlingRetryPolicy_js_1.throttlingRetryPolicy; } });
		Object.defineProperty(exports$1, "throttlingRetryPolicyName", { enumerable: true, get: function () { return throttlingRetryPolicy_js_1.throttlingRetryPolicyName; } });
		var retryPolicy_js_1 = requireRetryPolicy();
		Object.defineProperty(exports$1, "retryPolicy", { enumerable: true, get: function () { return retryPolicy_js_1.retryPolicy; } });
		var tracingPolicy_js_1 = requireTracingPolicy();
		Object.defineProperty(exports$1, "tracingPolicy", { enumerable: true, get: function () { return tracingPolicy_js_1.tracingPolicy; } });
		Object.defineProperty(exports$1, "tracingPolicyName", { enumerable: true, get: function () { return tracingPolicy_js_1.tracingPolicyName; } });
		var defaultRetryPolicy_js_1 = requireDefaultRetryPolicy();
		Object.defineProperty(exports$1, "defaultRetryPolicy", { enumerable: true, get: function () { return defaultRetryPolicy_js_1.defaultRetryPolicy; } });
		var userAgentPolicy_js_1 = requireUserAgentPolicy();
		Object.defineProperty(exports$1, "userAgentPolicy", { enumerable: true, get: function () { return userAgentPolicy_js_1.userAgentPolicy; } });
		Object.defineProperty(exports$1, "userAgentPolicyName", { enumerable: true, get: function () { return userAgentPolicy_js_1.userAgentPolicyName; } });
		var tlsPolicy_js_1 = requireTlsPolicy();
		Object.defineProperty(exports$1, "tlsPolicy", { enumerable: true, get: function () { return tlsPolicy_js_1.tlsPolicy; } });
		Object.defineProperty(exports$1, "tlsPolicyName", { enumerable: true, get: function () { return tlsPolicy_js_1.tlsPolicyName; } });
		var formDataPolicy_js_1 = requireFormDataPolicy();
		Object.defineProperty(exports$1, "formDataPolicy", { enumerable: true, get: function () { return formDataPolicy_js_1.formDataPolicy; } });
		Object.defineProperty(exports$1, "formDataPolicyName", { enumerable: true, get: function () { return formDataPolicy_js_1.formDataPolicyName; } });
		var bearerTokenAuthenticationPolicy_js_1 = requireBearerTokenAuthenticationPolicy();
		Object.defineProperty(exports$1, "bearerTokenAuthenticationPolicy", { enumerable: true, get: function () { return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicy; } });
		Object.defineProperty(exports$1, "bearerTokenAuthenticationPolicyName", { enumerable: true, get: function () { return bearerTokenAuthenticationPolicy_js_1.bearerTokenAuthenticationPolicyName; } });
		var ndJsonPolicy_js_1 = requireNdJsonPolicy();
		Object.defineProperty(exports$1, "ndJsonPolicy", { enumerable: true, get: function () { return ndJsonPolicy_js_1.ndJsonPolicy; } });
		Object.defineProperty(exports$1, "ndJsonPolicyName", { enumerable: true, get: function () { return ndJsonPolicy_js_1.ndJsonPolicyName; } });
		var auxiliaryAuthenticationHeaderPolicy_js_1 = requireAuxiliaryAuthenticationHeaderPolicy();
		Object.defineProperty(exports$1, "auxiliaryAuthenticationHeaderPolicy", { enumerable: true, get: function () { return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicy; } });
		Object.defineProperty(exports$1, "auxiliaryAuthenticationHeaderPolicyName", { enumerable: true, get: function () { return auxiliaryAuthenticationHeaderPolicy_js_1.auxiliaryAuthenticationHeaderPolicyName; } });
		var agentPolicy_js_1 = requireAgentPolicy();
		Object.defineProperty(exports$1, "agentPolicy", { enumerable: true, get: function () { return agentPolicy_js_1.agentPolicy; } });
		Object.defineProperty(exports$1, "agentPolicyName", { enumerable: true, get: function () { return agentPolicy_js_1.agentPolicyName; } });
		var file_js_1 = requireFile();
		Object.defineProperty(exports$1, "createFile", { enumerable: true, get: function () { return file_js_1.createFile; } });
		Object.defineProperty(exports$1, "createFileFromStream", { enumerable: true, get: function () { return file_js_1.createFileFromStream; } });
		
	} (commonjs$2));
	return commonjs$2;
}

var pipeline = {};

var deserializationPolicy = {};

var operationHelpers = {};

var state$1 = {};

var hasRequiredState$1;

function requireState$1 () {
	if (hasRequiredState$1) return state$1;
	hasRequiredState$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(state$1, "__esModule", { value: true });
	state$1.state = void 0;
	/**
	 * Holds the singleton operationRequestMap, to be shared across CJS and ESM imports.
	 */
	state$1.state = {
	    operationRequestMap: new WeakMap(),
	};
	
	return state$1;
}

var hasRequiredOperationHelpers;

function requireOperationHelpers () {
	if (hasRequiredOperationHelpers) return operationHelpers;
	hasRequiredOperationHelpers = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(operationHelpers, "__esModule", { value: true });
	operationHelpers.getOperationArgumentValueFromParameter = getOperationArgumentValueFromParameter;
	operationHelpers.getOperationRequestInfo = getOperationRequestInfo;
	const state_js_1 = requireState$1();
	/**
	 * @internal
	 * Retrieves the value to use for a given operation argument
	 * @param operationArguments - The arguments passed from the generated client
	 * @param parameter - The parameter description
	 * @param fallbackObject - If something isn't found in the arguments bag, look here.
	 *  Generally used to look at the service client properties.
	 */
	function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
	    let parameterPath = parameter.parameterPath;
	    const parameterMapper = parameter.mapper;
	    let value;
	    if (typeof parameterPath === "string") {
	        parameterPath = [parameterPath];
	    }
	    if (Array.isArray(parameterPath)) {
	        if (parameterPath.length > 0) {
	            if (parameterMapper.isConstant) {
	                value = parameterMapper.defaultValue;
	            }
	            else {
	                let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
	                if (!propertySearchResult.propertyFound && fallbackObject) {
	                    propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
	                }
	                let useDefaultValue = false;
	                if (!propertySearchResult.propertyFound) {
	                    useDefaultValue =
	                        parameterMapper.required ||
	                            (parameterPath[0] === "options" && parameterPath.length === 2);
	                }
	                value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
	            }
	        }
	    }
	    else {
	        if (parameterMapper.required) {
	            value = {};
	        }
	        for (const propertyName in parameterPath) {
	            const propertyMapper = parameterMapper.type.modelProperties[propertyName];
	            const propertyPath = parameterPath[propertyName];
	            const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
	                parameterPath: propertyPath,
	                mapper: propertyMapper,
	            }, fallbackObject);
	            if (propertyValue !== undefined) {
	                if (!value) {
	                    value = {};
	                }
	                value[propertyName] = propertyValue;
	            }
	        }
	    }
	    return value;
	}
	function getPropertyFromParameterPath(parent, parameterPath) {
	    const result = { propertyFound: false };
	    let i = 0;
	    for (; i < parameterPath.length; ++i) {
	        const parameterPathPart = parameterPath[i];
	        // Make sure to check inherited properties too, so don't use hasOwnProperty().
	        if (parent && parameterPathPart in parent) {
	            parent = parent[parameterPathPart];
	        }
	        else {
	            break;
	        }
	    }
	    if (i === parameterPath.length) {
	        result.propertyValue = parent;
	        result.propertyFound = true;
	    }
	    return result;
	}
	const originalRequestSymbol = Symbol.for("@azure/core-client original request");
	function hasOriginalRequest(request) {
	    return originalRequestSymbol in request;
	}
	function getOperationRequestInfo(request) {
	    if (hasOriginalRequest(request)) {
	        return getOperationRequestInfo(request[originalRequestSymbol]);
	    }
	    let info = state_js_1.state.operationRequestMap.get(request);
	    if (!info) {
	        info = {};
	        state_js_1.state.operationRequestMap.set(request, info);
	    }
	    return info;
	}
	
	return operationHelpers;
}

var hasRequiredDeserializationPolicy;

function requireDeserializationPolicy () {
	if (hasRequiredDeserializationPolicy) return deserializationPolicy;
	hasRequiredDeserializationPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.deserializationPolicyName = void 0;
		exports$1.deserializationPolicy = deserializationPolicy;
		const interfaces_js_1 = requireInterfaces();
		const core_rest_pipeline_1 = /*@__PURE__*/ requireCommonjs$3();
		const serializer_js_1 = requireSerializer();
		const operationHelpers_js_1 = requireOperationHelpers();
		const defaultJsonContentTypes = ["application/json", "text/json"];
		const defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
		/**
		 * The programmatic identifier of the deserializationPolicy.
		 */
		exports$1.deserializationPolicyName = "deserializationPolicy";
		/**
		 * This policy handles parsing out responses according to OperationSpecs on the request.
		 */
		function deserializationPolicy(options = {}) {
		    const jsonContentTypes = options.expectedContentTypes?.json ?? defaultJsonContentTypes;
		    const xmlContentTypes = options.expectedContentTypes?.xml ?? defaultXmlContentTypes;
		    const parseXML = options.parseXML;
		    const serializerOptions = options.serializerOptions;
		    const updatedOptions = {
		        xml: {
		            rootName: serializerOptions?.xml.rootName ?? "",
		            includeRoot: serializerOptions?.xml.includeRoot ?? false,
		            xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY,
		        },
		    };
		    return {
		        name: exports$1.deserializationPolicyName,
		        async sendRequest(request, next) {
		            const response = await next(request);
		            return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
		        },
		    };
		}
		function getOperationResponseMap(parsedResponse) {
		    let result;
		    const request = parsedResponse.request;
		    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
		    const operationSpec = operationInfo?.operationSpec;
		    if (operationSpec) {
		        if (!operationInfo?.operationResponseGetter) {
		            result = operationSpec.responses[parsedResponse.status];
		        }
		        else {
		            result = operationInfo?.operationResponseGetter(operationSpec, parsedResponse);
		        }
		    }
		    return result;
		}
		function shouldDeserializeResponse(parsedResponse) {
		    const request = parsedResponse.request;
		    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
		    const shouldDeserialize = operationInfo?.shouldDeserialize;
		    let result;
		    if (shouldDeserialize === undefined) {
		        result = true;
		    }
		    else if (typeof shouldDeserialize === "boolean") {
		        result = shouldDeserialize;
		    }
		    else {
		        result = shouldDeserialize(parsedResponse);
		    }
		    return result;
		}
		async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
		    const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
		    if (!shouldDeserializeResponse(parsedResponse)) {
		        return parsedResponse;
		    }
		    const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(parsedResponse.request);
		    const operationSpec = operationInfo?.operationSpec;
		    if (!operationSpec || !operationSpec.responses) {
		        return parsedResponse;
		    }
		    const responseSpec = getOperationResponseMap(parsedResponse);
		    const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
		    if (error) {
		        throw error;
		    }
		    else if (shouldReturnResponse) {
		        return parsedResponse;
		    }
		    // An operation response spec does exist for current status code, so
		    // use it to deserialize the response.
		    if (responseSpec) {
		        if (responseSpec.bodyMapper) {
		            let valueToDeserialize = parsedResponse.parsedBody;
		            if (operationSpec.isXML && responseSpec.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
		                valueToDeserialize =
		                    typeof valueToDeserialize === "object"
		                        ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName]
		                        : [];
		            }
		            try {
		                parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
		            }
		            catch (deserializeError) {
		                const restError = new core_rest_pipeline_1.RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
		                    statusCode: parsedResponse.status,
		                    request: parsedResponse.request,
		                    response: parsedResponse,
		                });
		                throw restError;
		            }
		        }
		        else if (operationSpec.httpMethod === "HEAD") {
		            // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
		            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
		        }
		        if (responseSpec.headersMapper) {
		            parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
		        }
		    }
		    return parsedResponse;
		}
		function isOperationSpecEmpty(operationSpec) {
		    const expectedStatusCodes = Object.keys(operationSpec.responses);
		    return (expectedStatusCodes.length === 0 ||
		        (expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default"));
		}
		function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
		    const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
		    const isExpectedStatusCode = isOperationSpecEmpty(operationSpec)
		        ? isSuccessByStatus
		        : !!responseSpec;
		    if (isExpectedStatusCode) {
		        if (responseSpec) {
		            if (!responseSpec.isError) {
		                return { error: null, shouldReturnResponse: false };
		            }
		        }
		        else {
		            return { error: null, shouldReturnResponse: false };
		        }
		    }
		    const errorResponseSpec = responseSpec ?? operationSpec.responses.default;
		    const initialErrorMessage = parsedResponse.request.streamResponseStatusCodes?.has(parsedResponse.status)
		        ? `Unexpected status code: ${parsedResponse.status}`
		        : parsedResponse.bodyAsText;
		    const error = new core_rest_pipeline_1.RestError(initialErrorMessage, {
		        statusCode: parsedResponse.status,
		        request: parsedResponse.request,
		        response: parsedResponse,
		    });
		    // If the item failed but there's no error spec or default spec to deserialize the error,
		    // and the parsed body doesn't look like an error object,
		    // we should fail so we just throw the parsed response
		    if (!errorResponseSpec &&
		        !(parsedResponse.parsedBody?.error?.code && parsedResponse.parsedBody?.error?.message)) {
		        throw error;
		    }
		    const defaultBodyMapper = errorResponseSpec?.bodyMapper;
		    const defaultHeadersMapper = errorResponseSpec?.headersMapper;
		    try {
		        // If error response has a body, try to deserialize it using default body mapper.
		        // Then try to extract error code & message from it
		        if (parsedResponse.parsedBody) {
		            const parsedBody = parsedResponse.parsedBody;
		            let deserializedError;
		            if (defaultBodyMapper) {
		                let valueToDeserialize = parsedBody;
		                if (operationSpec.isXML && defaultBodyMapper.type.name === serializer_js_1.MapperTypeNames.Sequence) {
		                    valueToDeserialize = [];
		                    const elementName = defaultBodyMapper.xmlElementName;
		                    if (typeof parsedBody === "object" && elementName) {
		                        valueToDeserialize = parsedBody[elementName];
		                    }
		                }
		                deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
		            }
		            const internalError = parsedBody.error || deserializedError || parsedBody;
		            error.code = internalError.code;
		            if (internalError.message) {
		                error.message = internalError.message;
		            }
		            if (defaultBodyMapper) {
		                error.response.parsedBody = deserializedError;
		            }
		        }
		        // If error response has headers, try to deserialize it using default header mapper
		        if (parsedResponse.headers && defaultHeadersMapper) {
		            error.response.parsedHeaders =
		                operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
		        }
		    }
		    catch (defaultError) {
		        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
		    }
		    return { error, shouldReturnResponse: false };
		}
		async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
		    if (!operationResponse.request.streamResponseStatusCodes?.has(operationResponse.status) &&
		        operationResponse.bodyAsText) {
		        const text = operationResponse.bodyAsText;
		        const contentType = operationResponse.headers.get("Content-Type") || "";
		        const contentComponents = !contentType
		            ? []
		            : contentType.split(";").map((component) => component.toLowerCase());
		        try {
		            if (contentComponents.length === 0 ||
		                contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
		                operationResponse.parsedBody = JSON.parse(text);
		                return operationResponse;
		            }
		            else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
		                if (!parseXML) {
		                    throw new Error("Parsing XML not supported.");
		                }
		                const body = await parseXML(text, opts.xml);
		                operationResponse.parsedBody = body;
		                return operationResponse;
		            }
		        }
		        catch (err) {
		            const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
		            const errCode = err.code || core_rest_pipeline_1.RestError.PARSE_ERROR;
		            const e = new core_rest_pipeline_1.RestError(msg, {
		                code: errCode,
		                statusCode: operationResponse.status,
		                request: operationResponse.request,
		                response: operationResponse,
		            });
		            throw e;
		        }
		    }
		    return operationResponse;
		}
		
	} (deserializationPolicy));
	return deserializationPolicy;
}

var serializationPolicy = {};

var interfaceHelpers = {};

var hasRequiredInterfaceHelpers;

function requireInterfaceHelpers () {
	if (hasRequiredInterfaceHelpers) return interfaceHelpers;
	hasRequiredInterfaceHelpers = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(interfaceHelpers, "__esModule", { value: true });
	interfaceHelpers.getStreamingResponseStatusCodes = getStreamingResponseStatusCodes;
	interfaceHelpers.getPathStringFromParameter = getPathStringFromParameter;
	const serializer_js_1 = requireSerializer();
	/**
	 * Gets the list of status codes for streaming responses.
	 * @internal
	 */
	function getStreamingResponseStatusCodes(operationSpec) {
	    const result = new Set();
	    for (const statusCode in operationSpec.responses) {
	        const operationResponse = operationSpec.responses[statusCode];
	        if (operationResponse.bodyMapper &&
	            operationResponse.bodyMapper.type.name === serializer_js_1.MapperTypeNames.Stream) {
	            result.add(Number(statusCode));
	        }
	    }
	    return result;
	}
	/**
	 * Get the path to this parameter's value as a dotted string (a.b.c).
	 * @param parameter - The parameter to get the path string for.
	 * @returns The path to this parameter's value as a dotted string.
	 * @internal
	 */
	function getPathStringFromParameter(parameter) {
	    const { parameterPath, mapper } = parameter;
	    let result;
	    if (typeof parameterPath === "string") {
	        result = parameterPath;
	    }
	    else if (Array.isArray(parameterPath)) {
	        result = parameterPath.join(".");
	    }
	    else {
	        result = mapper.serializedName;
	    }
	    return result;
	}
	
	return interfaceHelpers;
}

var hasRequiredSerializationPolicy;

function requireSerializationPolicy () {
	if (hasRequiredSerializationPolicy) return serializationPolicy;
	hasRequiredSerializationPolicy = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.serializationPolicyName = void 0;
		exports$1.serializationPolicy = serializationPolicy;
		exports$1.serializeHeaders = serializeHeaders;
		exports$1.serializeRequestBody = serializeRequestBody;
		const interfaces_js_1 = requireInterfaces();
		const operationHelpers_js_1 = requireOperationHelpers();
		const serializer_js_1 = requireSerializer();
		const interfaceHelpers_js_1 = requireInterfaceHelpers();
		/**
		 * The programmatic identifier of the serializationPolicy.
		 */
		exports$1.serializationPolicyName = "serializationPolicy";
		/**
		 * This policy handles assembling the request body and headers using
		 * an OperationSpec and OperationArguments on the request.
		 */
		function serializationPolicy(options = {}) {
		    const stringifyXML = options.stringifyXML;
		    return {
		        name: exports$1.serializationPolicyName,
		        async sendRequest(request, next) {
		            const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
		            const operationSpec = operationInfo?.operationSpec;
		            const operationArguments = operationInfo?.operationArguments;
		            if (operationSpec && operationArguments) {
		                serializeHeaders(request, operationArguments, operationSpec);
		                serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
		            }
		            return next(request);
		        },
		    };
		}
		/**
		 * @internal
		 */
		function serializeHeaders(request, operationArguments, operationSpec) {
		    if (operationSpec.headerParameters) {
		        for (const headerParameter of operationSpec.headerParameters) {
		            let headerValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, headerParameter);
		            if ((headerValue !== null && headerValue !== undefined) || headerParameter.mapper.required) {
		                headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter));
		                const headerCollectionPrefix = headerParameter.mapper
		                    .headerCollectionPrefix;
		                if (headerCollectionPrefix) {
		                    for (const key of Object.keys(headerValue)) {
		                        request.headers.set(headerCollectionPrefix + key, headerValue[key]);
		                    }
		                }
		                else {
		                    request.headers.set(headerParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(headerParameter), headerValue);
		                }
		            }
		        }
		    }
		    const customHeaders = operationArguments.options?.requestOptions?.customHeaders;
		    if (customHeaders) {
		        for (const customHeaderName of Object.keys(customHeaders)) {
		            request.headers.set(customHeaderName, customHeaders[customHeaderName]);
		        }
		    }
		}
		/**
		 * @internal
		 */
		function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function () {
		    throw new Error("XML serialization unsupported!");
		}) {
		    const serializerOptions = operationArguments.options?.serializerOptions;
		    const updatedOptions = {
		        xml: {
		            rootName: serializerOptions?.xml.rootName ?? "",
		            includeRoot: serializerOptions?.xml.includeRoot ?? false,
		            xmlCharKey: serializerOptions?.xml.xmlCharKey ?? interfaces_js_1.XML_CHARKEY,
		        },
		    };
		    const xmlCharKey = updatedOptions.xml.xmlCharKey;
		    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
		        request.body = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, operationSpec.requestBody);
		        const bodyMapper = operationSpec.requestBody.mapper;
		        const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable, } = bodyMapper;
		        const typeName = bodyMapper.type.name;
		        try {
		            if ((request.body !== undefined && request.body !== null) ||
		                (nullable && request.body === null) ||
		                required) {
		                const requestBodyParameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(operationSpec.requestBody);
		                request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
		                const isStream = typeName === serializer_js_1.MapperTypeNames.Stream;
		                if (operationSpec.isXML) {
		                    const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
		                    const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
		                    if (typeName === serializer_js_1.MapperTypeNames.Sequence) {
		                        request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
		                    }
		                    else if (!isStream) {
		                        request.body = stringifyXML(value, {
		                            rootName: xmlName || serializedName,
		                            xmlCharKey,
		                        });
		                    }
		                }
		                else if (typeName === serializer_js_1.MapperTypeNames.String &&
		                    (operationSpec.contentType?.match("text/plain") || operationSpec.mediaType === "text")) {
		                    // the String serializer has validated that request body is a string
		                    // so just send the string.
		                    return;
		                }
		                else if (!isStream) {
		                    request.body = JSON.stringify(request.body);
		                }
		            }
		        }
		        catch (error) {
		            throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, undefined, "  ")}.`);
		        }
		    }
		    else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
		        request.formData = {};
		        for (const formDataParameter of operationSpec.formDataParameters) {
		            const formDataParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, formDataParameter);
		            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
		                const formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter);
		                request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(formDataParameter), updatedOptions);
		            }
		        }
		    }
		}
		/**
		 * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself
		 */
		function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
		    // Composite and Sequence schemas already got their root namespace set during serialization
		    // We just need to add xmlns to the other schema types
		    if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
		        const result = {};
		        result[options.xml.xmlCharKey] = serializedValue;
		        result[interfaces_js_1.XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
		        return result;
		    }
		    return serializedValue;
		}
		function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
		    if (!Array.isArray(obj)) {
		        obj = [obj];
		    }
		    if (!xmlNamespaceKey || !xmlNamespace) {
		        return { [elementName]: obj };
		    }
		    const result = { [elementName]: obj };
		    result[interfaces_js_1.XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
		    return result;
		}
		
	} (serializationPolicy));
	return serializationPolicy;
}

var hasRequiredPipeline$1;

function requirePipeline$1 () {
	if (hasRequiredPipeline$1) return pipeline;
	hasRequiredPipeline$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(pipeline, "__esModule", { value: true });
	pipeline.createClientPipeline = createClientPipeline;
	const deserializationPolicy_js_1 = requireDeserializationPolicy();
	const core_rest_pipeline_1 = /*@__PURE__*/ requireCommonjs$3();
	const serializationPolicy_js_1 = requireSerializationPolicy();
	/**
	 * Creates a new Pipeline for use with a Service Client.
	 * Adds in deserializationPolicy by default.
	 * Also adds in bearerTokenAuthenticationPolicy if passed a TokenCredential.
	 * @param options - Options to customize the created pipeline.
	 */
	function createClientPipeline(options = {}) {
	    const pipeline = (0, core_rest_pipeline_1.createPipelineFromOptions)(options ?? {});
	    if (options.credentialOptions) {
	        pipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({
	            credential: options.credentialOptions.credential,
	            scopes: options.credentialOptions.credentialScopes,
	        }));
	    }
	    pipeline.addPolicy((0, serializationPolicy_js_1.serializationPolicy)(options.serializationOptions), { phase: "Serialize" });
	    pipeline.addPolicy((0, deserializationPolicy_js_1.deserializationPolicy)(options.deserializationOptions), {
	        phase: "Deserialize",
	    });
	    return pipeline;
	}
	
	return pipeline;
}

var httpClientCache = {};

var hasRequiredHttpClientCache;

function requireHttpClientCache () {
	if (hasRequiredHttpClientCache) return httpClientCache;
	hasRequiredHttpClientCache = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(httpClientCache, "__esModule", { value: true });
	httpClientCache.getCachedDefaultHttpClient = getCachedDefaultHttpClient;
	const core_rest_pipeline_1 = /*@__PURE__*/ requireCommonjs$3();
	let cachedHttpClient;
	function getCachedDefaultHttpClient() {
	    if (!cachedHttpClient) {
	        cachedHttpClient = (0, core_rest_pipeline_1.createDefaultHttpClient)();
	    }
	    return cachedHttpClient;
	}
	
	return httpClientCache;
}

var urlHelpers = {};

var hasRequiredUrlHelpers;

function requireUrlHelpers () {
	if (hasRequiredUrlHelpers) return urlHelpers;
	hasRequiredUrlHelpers = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(urlHelpers, "__esModule", { value: true });
	urlHelpers.getRequestUrl = getRequestUrl;
	urlHelpers.appendQueryParams = appendQueryParams;
	const operationHelpers_js_1 = requireOperationHelpers();
	const interfaceHelpers_js_1 = requireInterfaceHelpers();
	const CollectionFormatToDelimiterMap = {
	    CSV: ",",
	    SSV: " ",
	    Multi: "Multi",
	    TSV: "\t",
	    Pipes: "|",
	};
	function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
	    const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
	    let isAbsolutePath = false;
	    let requestUrl = replaceAll(baseUri, urlReplacements);
	    if (operationSpec.path) {
	        let path = replaceAll(operationSpec.path, urlReplacements);
	        // QUIRK: sometimes we get a path component like /{nextLink}
	        // which may be a fully formed URL with a leading /. In that case, we should
	        // remove the leading /
	        if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
	            path = path.substring(1);
	        }
	        // QUIRK: sometimes we get a path component like {nextLink}
	        // which may be a fully formed URL. In that case, we should
	        // ignore the baseUri.
	        if (isAbsoluteUrl(path)) {
	            requestUrl = path;
	            isAbsolutePath = true;
	        }
	        else {
	            requestUrl = appendPath(requestUrl, path);
	        }
	    }
	    const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
	    /**
	     * Notice that this call sets the `noOverwrite` parameter to true if the `requestUrl`
	     * is an absolute path. This ensures that existing query parameter values in `requestUrl`
	     * do not get overwritten. On the other hand when `requestUrl` is not absolute path, it
	     * is still being built so there is nothing to overwrite.
	     */
	    requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
	    return requestUrl;
	}
	function replaceAll(input, replacements) {
	    let result = input;
	    for (const [searchValue, replaceValue] of replacements) {
	        result = result.split(searchValue).join(replaceValue);
	    }
	    return result;
	}
	function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
	    const result = new Map();
	    if (operationSpec.urlParameters?.length) {
	        for (const urlParameter of operationSpec.urlParameters) {
	            let urlParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, urlParameter, fallbackObject);
	            const parameterPathString = (0, interfaceHelpers_js_1.getPathStringFromParameter)(urlParameter);
	            urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
	            if (!urlParameter.skipEncoding) {
	                urlParameterValue = encodeURIComponent(urlParameterValue);
	            }
	            result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
	        }
	    }
	    return result;
	}
	function isAbsoluteUrl(url) {
	    return url.includes("://");
	}
	function appendPath(url, pathToAppend) {
	    if (!pathToAppend) {
	        return url;
	    }
	    const parsedUrl = new URL(url);
	    let newPath = parsedUrl.pathname;
	    if (!newPath.endsWith("/")) {
	        newPath = `${newPath}/`;
	    }
	    if (pathToAppend.startsWith("/")) {
	        pathToAppend = pathToAppend.substring(1);
	    }
	    const searchStart = pathToAppend.indexOf("?");
	    if (searchStart !== -1) {
	        const path = pathToAppend.substring(0, searchStart);
	        const search = pathToAppend.substring(searchStart + 1);
	        newPath = newPath + path;
	        if (search) {
	            parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
	        }
	    }
	    else {
	        newPath = newPath + pathToAppend;
	    }
	    parsedUrl.pathname = newPath;
	    return parsedUrl.toString();
	}
	function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
	    const result = new Map();
	    const sequenceParams = new Set();
	    if (operationSpec.queryParameters?.length) {
	        for (const queryParameter of operationSpec.queryParameters) {
	            if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
	                sequenceParams.add(queryParameter.mapper.serializedName);
	            }
	            let queryParameterValue = (0, operationHelpers_js_1.getOperationArgumentValueFromParameter)(operationArguments, queryParameter, fallbackObject);
	            if ((queryParameterValue !== undefined && queryParameterValue !== null) ||
	                queryParameter.mapper.required) {
	                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter));
	                const delimiter = queryParameter.collectionFormat
	                    ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat]
	                    : "";
	                if (Array.isArray(queryParameterValue)) {
	                    // replace null and undefined
	                    queryParameterValue = queryParameterValue.map((item) => {
	                        if (item === null || item === undefined) {
	                            return "";
	                        }
	                        return item;
	                    });
	                }
	                if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
	                    continue;
	                }
	                else if (Array.isArray(queryParameterValue) &&
	                    (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
	                    queryParameterValue = queryParameterValue.join(delimiter);
	                }
	                if (!queryParameter.skipEncoding) {
	                    if (Array.isArray(queryParameterValue)) {
	                        queryParameterValue = queryParameterValue.map((item) => {
	                            return encodeURIComponent(item);
	                        });
	                    }
	                    else {
	                        queryParameterValue = encodeURIComponent(queryParameterValue);
	                    }
	                }
	                // Join pipes and CSV *after* encoding, or the server will be upset.
	                if (Array.isArray(queryParameterValue) &&
	                    (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
	                    queryParameterValue = queryParameterValue.join(delimiter);
	                }
	                result.set(queryParameter.mapper.serializedName || (0, interfaceHelpers_js_1.getPathStringFromParameter)(queryParameter), queryParameterValue);
	            }
	        }
	    }
	    return {
	        queryParams: result,
	        sequenceParams,
	    };
	}
	function simpleParseQueryParams(queryString) {
	    const result = new Map();
	    if (!queryString || queryString[0] !== "?") {
	        return result;
	    }
	    // remove the leading ?
	    queryString = queryString.slice(1);
	    const pairs = queryString.split("&");
	    for (const pair of pairs) {
	        const [name, value] = pair.split("=", 2);
	        const existingValue = result.get(name);
	        if (existingValue) {
	            if (Array.isArray(existingValue)) {
	                existingValue.push(value);
	            }
	            else {
	                result.set(name, [existingValue, value]);
	            }
	        }
	        else {
	            result.set(name, value);
	        }
	    }
	    return result;
	}
	/** @internal */
	function appendQueryParams(url, queryParams, sequenceParams, noOverwrite = false) {
	    if (queryParams.size === 0) {
	        return url;
	    }
	    const parsedUrl = new URL(url);
	    // QUIRK: parsedUrl.searchParams will have their name/value pairs decoded, which
	    // can change their meaning to the server, such as in the case of a SAS signature.
	    // To avoid accidentally un-encoding a query param, we parse the key/values ourselves
	    const combinedParams = simpleParseQueryParams(parsedUrl.search);
	    for (const [name, value] of queryParams) {
	        const existingValue = combinedParams.get(name);
	        if (Array.isArray(existingValue)) {
	            if (Array.isArray(value)) {
	                existingValue.push(...value);
	                const valueSet = new Set(existingValue);
	                combinedParams.set(name, Array.from(valueSet));
	            }
	            else {
	                existingValue.push(value);
	            }
	        }
	        else if (existingValue) {
	            if (Array.isArray(value)) {
	                value.unshift(existingValue);
	            }
	            else if (sequenceParams.has(name)) {
	                combinedParams.set(name, [existingValue, value]);
	            }
	            if (!noOverwrite) {
	                combinedParams.set(name, value);
	            }
	        }
	        else {
	            combinedParams.set(name, value);
	        }
	    }
	    const searchPieces = [];
	    for (const [name, value] of combinedParams) {
	        if (typeof value === "string") {
	            searchPieces.push(`${name}=${value}`);
	        }
	        else if (Array.isArray(value)) {
	            // QUIRK: If we get an array of values, include multiple key/value pairs
	            for (const subValue of value) {
	                searchPieces.push(`${name}=${subValue}`);
	            }
	        }
	        else {
	            searchPieces.push(`${name}=${value}`);
	        }
	    }
	    // QUIRK: we have to set search manually as searchParams will encode comma when it shouldn't.
	    parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
	    return parsedUrl.toString();
	}
	
	return urlHelpers;
}

var log = {};

var hasRequiredLog;

function requireLog () {
	if (hasRequiredLog) return log;
	hasRequiredLog = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(log, "__esModule", { value: true });
	log.logger = void 0;
	const logger_1 = /*@__PURE__*/ requireCommonjs$8();
	log.logger = (0, logger_1.createClientLogger)("core-client");
	
	return log;
}

var hasRequiredServiceClient;

function requireServiceClient () {
	if (hasRequiredServiceClient) return serviceClient;
	hasRequiredServiceClient = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(serviceClient, "__esModule", { value: true });
	serviceClient.ServiceClient = void 0;
	const core_rest_pipeline_1 = /*@__PURE__*/ requireCommonjs$3();
	const pipeline_js_1 = requirePipeline$1();
	const utils_js_1 = requireUtils$2();
	const httpClientCache_js_1 = requireHttpClientCache();
	const operationHelpers_js_1 = requireOperationHelpers();
	const urlHelpers_js_1 = requireUrlHelpers();
	const interfaceHelpers_js_1 = requireInterfaceHelpers();
	const log_js_1 = requireLog();
	/**
	 * Initializes a new instance of the ServiceClient.
	 */
	class ServiceClient {
	    /**
	     * If specified, this is the base URI that requests will be made against for this ServiceClient.
	     * If it is not specified, then all OperationSpecs must contain a baseUrl property.
	     */
	    _endpoint;
	    /**
	     * The default request content type for the service.
	     * Used if no requestContentType is present on an OperationSpec.
	     */
	    _requestContentType;
	    /**
	     * Set to true if the request is sent over HTTP instead of HTTPS
	     */
	    _allowInsecureConnection;
	    /**
	     * The HTTP client that will be used to send requests.
	     */
	    _httpClient;
	    /**
	     * The pipeline used by this client to make requests
	     */
	    pipeline;
	    /**
	     * The ServiceClient constructor
	     * @param options - The service client options that govern the behavior of the client.
	     */
	    constructor(options = {}) {
	        this._requestContentType = options.requestContentType;
	        this._endpoint = options.endpoint ?? options.baseUri;
	        if (options.baseUri) {
	            log_js_1.logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
	        }
	        this._allowInsecureConnection = options.allowInsecureConnection;
	        this._httpClient = options.httpClient || (0, httpClientCache_js_1.getCachedDefaultHttpClient)();
	        this.pipeline = options.pipeline || createDefaultPipeline(options);
	        if (options.additionalPolicies?.length) {
	            for (const { policy, position } of options.additionalPolicies) {
	                // Sign happens after Retry and is commonly needed to occur
	                // before policies that intercept post-retry.
	                const afterPhase = position === "perRetry" ? "Sign" : undefined;
	                this.pipeline.addPolicy(policy, {
	                    afterPhase,
	                });
	            }
	        }
	    }
	    /**
	     * Send the provided httpRequest.
	     */
	    async sendRequest(request) {
	        return this.pipeline.sendRequest(this._httpClient, request);
	    }
	    /**
	     * Send an HTTP request that is populated using the provided OperationSpec.
	     * @typeParam T - The typed result of the request, based on the OperationSpec.
	     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
	     * @param operationSpec - The OperationSpec to use to populate the httpRequest.
	     */
	    async sendOperationRequest(operationArguments, operationSpec) {
	        const endpoint = operationSpec.baseUrl || this._endpoint;
	        if (!endpoint) {
	            throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
	        }
	        // Templatized URLs sometimes reference properties on the ServiceClient child class,
	        // so we have to pass `this` below in order to search these properties if they're
	        // not part of OperationArguments
	        const url = (0, urlHelpers_js_1.getRequestUrl)(endpoint, operationSpec, operationArguments, this);
	        const request = (0, core_rest_pipeline_1.createPipelineRequest)({
	            url,
	        });
	        request.method = operationSpec.httpMethod;
	        const operationInfo = (0, operationHelpers_js_1.getOperationRequestInfo)(request);
	        operationInfo.operationSpec = operationSpec;
	        operationInfo.operationArguments = operationArguments;
	        const contentType = operationSpec.contentType || this._requestContentType;
	        if (contentType && operationSpec.requestBody) {
	            request.headers.set("Content-Type", contentType);
	        }
	        const options = operationArguments.options;
	        if (options) {
	            const requestOptions = options.requestOptions;
	            if (requestOptions) {
	                if (requestOptions.timeout) {
	                    request.timeout = requestOptions.timeout;
	                }
	                if (requestOptions.onUploadProgress) {
	                    request.onUploadProgress = requestOptions.onUploadProgress;
	                }
	                if (requestOptions.onDownloadProgress) {
	                    request.onDownloadProgress = requestOptions.onDownloadProgress;
	                }
	                if (requestOptions.shouldDeserialize !== undefined) {
	                    operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
	                }
	                if (requestOptions.allowInsecureConnection) {
	                    request.allowInsecureConnection = true;
	                }
	            }
	            if (options.abortSignal) {
	                request.abortSignal = options.abortSignal;
	            }
	            if (options.tracingOptions) {
	                request.tracingOptions = options.tracingOptions;
	            }
	        }
	        if (this._allowInsecureConnection) {
	            request.allowInsecureConnection = true;
	        }
	        if (request.streamResponseStatusCodes === undefined) {
	            request.streamResponseStatusCodes = (0, interfaceHelpers_js_1.getStreamingResponseStatusCodes)(operationSpec);
	        }
	        try {
	            const rawResponse = await this.sendRequest(request);
	            const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[rawResponse.status]);
	            if (options?.onResponse) {
	                options.onResponse(rawResponse, flatResponse);
	            }
	            return flatResponse;
	        }
	        catch (error) {
	            if (typeof error === "object" && error?.response) {
	                const rawResponse = error.response;
	                const flatResponse = (0, utils_js_1.flattenResponse)(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
	                error.details = flatResponse;
	                if (options?.onResponse) {
	                    options.onResponse(rawResponse, flatResponse, error);
	                }
	            }
	            throw error;
	        }
	    }
	}
	serviceClient.ServiceClient = ServiceClient;
	function createDefaultPipeline(options) {
	    const credentialScopes = getCredentialScopes(options);
	    const credentialOptions = options.credential && credentialScopes
	        ? { credentialScopes, credential: options.credential }
	        : undefined;
	    return (0, pipeline_js_1.createClientPipeline)({
	        ...options,
	        credentialOptions,
	    });
	}
	function getCredentialScopes(options) {
	    if (options.credentialScopes) {
	        return options.credentialScopes;
	    }
	    if (options.endpoint) {
	        return `${options.endpoint}/.default`;
	    }
	    if (options.baseUri) {
	        return `${options.baseUri}/.default`;
	    }
	    if (options.credential && !options.credentialScopes) {
	        throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
	    }
	    return undefined;
	}
	
	return serviceClient;
}

var authorizeRequestOnClaimChallenge = {};

var hasRequiredAuthorizeRequestOnClaimChallenge;

function requireAuthorizeRequestOnClaimChallenge () {
	if (hasRequiredAuthorizeRequestOnClaimChallenge) return authorizeRequestOnClaimChallenge;
	hasRequiredAuthorizeRequestOnClaimChallenge = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(authorizeRequestOnClaimChallenge, "__esModule", { value: true });
	authorizeRequestOnClaimChallenge.parseCAEChallenge = parseCAEChallenge;
	authorizeRequestOnClaimChallenge.authorizeRequestOnClaimChallenge = authorizeRequestOnClaimChallenge$1;
	const log_js_1 = requireLog();
	const base64_js_1 = requireBase64();
	/**
	 * Converts: `Bearer a="b", c="d", Bearer d="e", f="g"`.
	 * Into: `[ { a: 'b', c: 'd' }, { d: 'e', f: 'g' } ]`.
	 *
	 * @internal
	 */
	function parseCAEChallenge(challenges) {
	    const bearerChallenges = `, ${challenges.trim()}`.split(", Bearer ").filter((x) => x);
	    return bearerChallenges.map((challenge) => {
	        const challengeParts = `${challenge.trim()}, `.split('", ').filter((x) => x);
	        const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split('="')));
	        // Key-value pairs to plain object:
	        return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {});
	    });
	}
	/**
	 * This function can be used as a callback for the `bearerTokenAuthenticationPolicy` of `@azure/core-rest-pipeline`, to support CAE challenges:
	 * [Continuous Access Evaluation](https://learn.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation).
	 *
	 * Call the `bearerTokenAuthenticationPolicy` with the following options:
	 *
	 * ```ts snippet:AuthorizeRequestOnClaimChallenge
	 * import { bearerTokenAuthenticationPolicy } from "@azure/core-rest-pipeline";
	 * import { authorizeRequestOnClaimChallenge } from "@azure/core-client";
	 *
	 * const policy = bearerTokenAuthenticationPolicy({
	 *   challengeCallbacks: {
	 *     authorizeRequestOnChallenge: authorizeRequestOnClaimChallenge,
	 *   },
	 *   scopes: ["https://service/.default"],
	 * });
	 * ```
	 *
	 * Once provided, the `bearerTokenAuthenticationPolicy` policy will internally handle Continuous Access Evaluation (CAE) challenges.
	 * When it can't complete a challenge it will return the 401 (unauthorized) response from ARM.
	 *
	 * Example challenge with claims:
	 *
	 * ```
	 * Bearer authorization_uri="https://login.windows-ppe.net/", error="invalid_token",
	 * error_description="User session has been revoked",
	 * claims="eyJhY2Nlc3NfdG9rZW4iOnsibmJmIjp7ImVzc2VudGlhbCI6dHJ1ZSwgInZhbHVlIjoiMTYwMzc0MjgwMCJ9fX0="
	 * ```
	 */
	async function authorizeRequestOnClaimChallenge$1(onChallengeOptions) {
	    const { scopes, response } = onChallengeOptions;
	    const logger = onChallengeOptions.logger || log_js_1.logger;
	    const challenge = response.headers.get("WWW-Authenticate");
	    if (!challenge) {
	        logger.info(`The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.`);
	        return false;
	    }
	    const challenges = parseCAEChallenge(challenge) || [];
	    const parsedChallenge = challenges.find((x) => x.claims);
	    if (!parsedChallenge) {
	        logger.info(`The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.`);
	        return false;
	    }
	    const accessToken = await onChallengeOptions.getAccessToken(parsedChallenge.scope ? [parsedChallenge.scope] : scopes, {
	        claims: (0, base64_js_1.decodeStringToString)(parsedChallenge.claims),
	    });
	    if (!accessToken) {
	        return false;
	    }
	    onChallengeOptions.request.headers.set("Authorization", `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
	    return true;
	}
	
	return authorizeRequestOnClaimChallenge;
}

var authorizeRequestOnTenantChallenge = {};

var hasRequiredAuthorizeRequestOnTenantChallenge;

function requireAuthorizeRequestOnTenantChallenge () {
	if (hasRequiredAuthorizeRequestOnTenantChallenge) return authorizeRequestOnTenantChallenge;
	hasRequiredAuthorizeRequestOnTenantChallenge = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(authorizeRequestOnTenantChallenge, "__esModule", { value: true });
	authorizeRequestOnTenantChallenge.authorizeRequestOnTenantChallenge = void 0;
	/**
	 * A set of constants used internally when processing requests.
	 */
	const Constants = {
	    DefaultScope: "/.default",
	    /**
	     * Defines constants for use with HTTP headers.
	     */
	    HeaderConstants: {
	        /**
	         * The Authorization header.
	         */
	        AUTHORIZATION: "authorization",
	    },
	};
	function isUuid(text) {
	    return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(text);
	}
	/**
	 * Defines a callback to handle auth challenge for Storage APIs.
	 * This implements the bearer challenge process described here: https://learn.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge
	 * Handling has specific features for storage that departs to the general AAD challenge docs.
	 **/
	const authorizeRequestOnTenantChallenge$1 = async (challengeOptions) => {
	    const requestOptions = requestToOptions(challengeOptions.request);
	    const challenge = getChallenge(challengeOptions.response);
	    if (challenge) {
	        const challengeInfo = parseChallenge(challenge);
	        const challengeScopes = buildScopes(challengeOptions, challengeInfo);
	        const tenantId = extractTenantId(challengeInfo);
	        if (!tenantId) {
	            return false;
	        }
	        const accessToken = await challengeOptions.getAccessToken(challengeScopes, {
	            ...requestOptions,
	            tenantId,
	        });
	        if (!accessToken) {
	            return false;
	        }
	        challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `${accessToken.tokenType ?? "Bearer"} ${accessToken.token}`);
	        return true;
	    }
	    return false;
	};
	authorizeRequestOnTenantChallenge.authorizeRequestOnTenantChallenge = authorizeRequestOnTenantChallenge$1;
	/**
	 * Extracts the tenant id from the challenge information
	 * The tenant id is contained in the authorization_uri as the first
	 * path part.
	 */
	function extractTenantId(challengeInfo) {
	    const parsedAuthUri = new URL(challengeInfo.authorization_uri);
	    const pathSegments = parsedAuthUri.pathname.split("/");
	    const tenantId = pathSegments[1];
	    if (tenantId && isUuid(tenantId)) {
	        return tenantId;
	    }
	    return undefined;
	}
	/**
	 * Builds the authentication scopes based on the information that comes in the
	 * challenge information. Scopes url is present in the resource_id, if it is empty
	 * we keep using the original scopes.
	 */
	function buildScopes(challengeOptions, challengeInfo) {
	    if (!challengeInfo.resource_id) {
	        return challengeOptions.scopes;
	    }
	    const challengeScopes = new URL(challengeInfo.resource_id);
	    challengeScopes.pathname = Constants.DefaultScope;
	    let scope = challengeScopes.toString();
	    if (scope === "https://disk.azure.com/.default") {
	        // the extra slash is required by the service
	        scope = "https://disk.azure.com//.default";
	    }
	    return [scope];
	}
	/**
	 * We will retrieve the challenge only if the response status code was 401,
	 * and if the response contained the header "WWW-Authenticate" with a non-empty value.
	 */
	function getChallenge(response) {
	    const challenge = response.headers.get("WWW-Authenticate");
	    if (response.status === 401 && challenge) {
	        return challenge;
	    }
	    return;
	}
	/**
	 * Converts: `Bearer a="b" c="d"`.
	 * Into: `[ { a: 'b', c: 'd' }]`.
	 *
	 * @internal
	 */
	function parseChallenge(challenge) {
	    const bearerChallenge = challenge.slice("Bearer ".length);
	    const challengeParts = `${bearerChallenge.trim()} `.split(" ").filter((x) => x);
	    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split("=")));
	    // Key-value pairs to plain object:
	    return keyValuePairs.reduce((a, b) => ({ ...a, ...b }), {});
	}
	/**
	 * Extracts the options form a Pipeline Request for later re-use
	 */
	function requestToOptions(request) {
	    return {
	        abortSignal: request.abortSignal,
	        requestOptions: {
	            timeout: request.timeout,
	        },
	        tracingOptions: request.tracingOptions,
	    };
	}
	
	return authorizeRequestOnTenantChallenge;
}

var hasRequiredCommonjs$2;

function requireCommonjs$2 () {
	if (hasRequiredCommonjs$2) return commonjs$3;
	hasRequiredCommonjs$2 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.authorizeRequestOnTenantChallenge = exports$1.authorizeRequestOnClaimChallenge = exports$1.serializationPolicyName = exports$1.serializationPolicy = exports$1.deserializationPolicyName = exports$1.deserializationPolicy = exports$1.XML_CHARKEY = exports$1.XML_ATTRKEY = exports$1.createClientPipeline = exports$1.ServiceClient = exports$1.MapperTypeNames = exports$1.createSerializer = void 0;
		var serializer_js_1 = requireSerializer();
		Object.defineProperty(exports$1, "createSerializer", { enumerable: true, get: function () { return serializer_js_1.createSerializer; } });
		Object.defineProperty(exports$1, "MapperTypeNames", { enumerable: true, get: function () { return serializer_js_1.MapperTypeNames; } });
		var serviceClient_js_1 = requireServiceClient();
		Object.defineProperty(exports$1, "ServiceClient", { enumerable: true, get: function () { return serviceClient_js_1.ServiceClient; } });
		var pipeline_js_1 = requirePipeline$1();
		Object.defineProperty(exports$1, "createClientPipeline", { enumerable: true, get: function () { return pipeline_js_1.createClientPipeline; } });
		var interfaces_js_1 = requireInterfaces();
		Object.defineProperty(exports$1, "XML_ATTRKEY", { enumerable: true, get: function () { return interfaces_js_1.XML_ATTRKEY; } });
		Object.defineProperty(exports$1, "XML_CHARKEY", { enumerable: true, get: function () { return interfaces_js_1.XML_CHARKEY; } });
		var deserializationPolicy_js_1 = requireDeserializationPolicy();
		Object.defineProperty(exports$1, "deserializationPolicy", { enumerable: true, get: function () { return deserializationPolicy_js_1.deserializationPolicy; } });
		Object.defineProperty(exports$1, "deserializationPolicyName", { enumerable: true, get: function () { return deserializationPolicy_js_1.deserializationPolicyName; } });
		var serializationPolicy_js_1 = requireSerializationPolicy();
		Object.defineProperty(exports$1, "serializationPolicy", { enumerable: true, get: function () { return serializationPolicy_js_1.serializationPolicy; } });
		Object.defineProperty(exports$1, "serializationPolicyName", { enumerable: true, get: function () { return serializationPolicy_js_1.serializationPolicyName; } });
		var authorizeRequestOnClaimChallenge_js_1 = requireAuthorizeRequestOnClaimChallenge();
		Object.defineProperty(exports$1, "authorizeRequestOnClaimChallenge", { enumerable: true, get: function () { return authorizeRequestOnClaimChallenge_js_1.authorizeRequestOnClaimChallenge; } });
		var authorizeRequestOnTenantChallenge_js_1 = requireAuthorizeRequestOnTenantChallenge();
		Object.defineProperty(exports$1, "authorizeRequestOnTenantChallenge", { enumerable: true, get: function () { return authorizeRequestOnTenantChallenge_js_1.authorizeRequestOnTenantChallenge; } });
		
	} (commonjs$3));
	return commonjs$3;
}

var identityTokenEndpoint = {};

var hasRequiredIdentityTokenEndpoint;

function requireIdentityTokenEndpoint () {
	if (hasRequiredIdentityTokenEndpoint) return identityTokenEndpoint;
	hasRequiredIdentityTokenEndpoint = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(identityTokenEndpoint, "__esModule", { value: true });
	identityTokenEndpoint.getIdentityTokenEndpointSuffix = getIdentityTokenEndpointSuffix;
	function getIdentityTokenEndpointSuffix(tenantId) {
	    if (tenantId === "adfs") {
	        return "oauth2/token";
	    }
	    else {
	        return "oauth2/v2.0/token";
	    }
	}
	
	return identityTokenEndpoint;
}

var utils$1 = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(utils$1, "__esModule", { value: true });
	utils$1.serviceFabricErrorMessage = void 0;
	utils$1.mapScopesToResource = mapScopesToResource;
	utils$1.parseExpirationTimestamp = parseExpirationTimestamp;
	utils$1.parseRefreshTimestamp = parseRefreshTimestamp;
	const DefaultScopeSuffix = "/.default";
	/**
	 * Error message for Service Fabric Managed Identity environment.
	 */
	utils$1.serviceFabricErrorMessage = "Specifying a `clientId` or `resourceId` is not supported by the Service Fabric managed identity environment. The managed identity configuration is determined by the Service Fabric cluster resource configuration. See https://aka.ms/servicefabricmi for more information";
	/**
	 * Most MSIs send requests to the IMDS endpoint, or a similar endpoint.
	 * These are GET requests that require sending a `resource` parameter on the query.
	 * This resource can be derived from the scopes received through the getToken call, as long as only one scope is received.
	 * Multiple scopes assume that the resulting token will have access to multiple resources, which won't be the case.
	 *
	 * For that reason, when we encounter multiple scopes, we return undefined.
	 * It's up to the individual MSI implementations to throw the errors (which helps us provide less generic errors).
	 */
	function mapScopesToResource(scopes) {
	    let scope = "";
	    if (Array.isArray(scopes)) {
	        if (scopes.length !== 1) {
	            return;
	        }
	        scope = scopes[0];
	    }
	    else if (typeof scopes === "string") {
	        scope = scopes;
	    }
	    if (!scope.endsWith(DefaultScopeSuffix)) {
	        return scope;
	    }
	    return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));
	}
	/**
	 * Given a token response, return the expiration timestamp as the number of milliseconds from the Unix epoch.
	 * @param body - A parsed response body from the authentication endpoint.
	 */
	function parseExpirationTimestamp(body) {
	    if (typeof body.expires_on === "number") {
	        return body.expires_on * 1000;
	    }
	    if (typeof body.expires_on === "string") {
	        const asNumber = +body.expires_on;
	        if (!isNaN(asNumber)) {
	            return asNumber * 1000;
	        }
	        const asDate = Date.parse(body.expires_on);
	        if (!isNaN(asDate)) {
	            return asDate;
	        }
	    }
	    if (typeof body.expires_in === "number") {
	        return Date.now() + body.expires_in * 1000;
	    }
	    throw new Error(`Failed to parse token expiration from body. expires_in="${body.expires_in}", expires_on="${body.expires_on}"`);
	}
	/**
	 * Given a token response, return the expiration timestamp as the number of milliseconds from the Unix epoch.
	 * @param body - A parsed response body from the authentication endpoint.
	 */
	function parseRefreshTimestamp(body) {
	    if (body.refresh_on) {
	        if (typeof body.refresh_on === "number") {
	            return body.refresh_on * 1000;
	        }
	        if (typeof body.refresh_on === "string") {
	            const asNumber = +body.refresh_on;
	            if (!isNaN(asNumber)) {
	                return asNumber * 1000;
	            }
	            const asDate = Date.parse(body.refresh_on);
	            if (!isNaN(asDate)) {
	                return asDate;
	            }
	        }
	        throw new Error(`Failed to parse refresh_on from body. refresh_on="${body.refresh_on}"`);
	    }
	    else {
	        return undefined;
	    }
	}
	
	return utils$1;
}

var hasRequiredIdentityClient;

function requireIdentityClient () {
	if (hasRequiredIdentityClient) return identityClient;
	hasRequiredIdentityClient = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(identityClient, "__esModule", { value: true });
	identityClient.IdentityClient = void 0;
	identityClient.getIdentityClientAuthorityHost = getIdentityClientAuthorityHost;
	const core_client_1 = /*@__PURE__*/ requireCommonjs$2();
	const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
	const core_rest_pipeline_1 = /*@__PURE__*/ requireCommonjs$3();
	const errors_js_1 = requireErrors$2();
	const identityTokenEndpoint_js_1 = requireIdentityTokenEndpoint();
	const constants_js_1 = requireConstants$3();
	const tracing_js_1 = requireTracing();
	const logging_js_1 = requireLogging();
	const utils_js_1 = requireUtils$1();
	const noCorrelationId = "noCorrelationId";
	/**
	 * @internal
	 */
	function getIdentityClientAuthorityHost(options) {
	    // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.
	    let authorityHost = options?.authorityHost;
	    // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.
	    if (core_util_1.isNode) {
	        authorityHost = authorityHost ?? process.env.AZURE_AUTHORITY_HOST;
	    }
	    // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com
	    return authorityHost ?? constants_js_1.DefaultAuthorityHost;
	}
	/**
	 * The network module used by the Identity credentials.
	 *
	 * It allows for credentials to abort any pending request independently of the MSAL flow,
	 * by calling to the `abortRequests()` method.
	 *
	 */
	class IdentityClient extends core_client_1.ServiceClient {
	    authorityHost;
	    allowLoggingAccountIdentifiers;
	    abortControllers;
	    allowInsecureConnection = false;
	    // used for WorkloadIdentity
	    tokenCredentialOptions;
	    constructor(options) {
	        const packageDetails = `azsdk-js-identity/${constants_js_1.SDK_VERSION}`;
	        const userAgentPrefix = options?.userAgentOptions?.userAgentPrefix
	            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
	            : `${packageDetails}`;
	        const baseUri = getIdentityClientAuthorityHost(options);
	        if (!baseUri.startsWith("https:")) {
	            throw new Error("The authorityHost address must use the 'https' protocol.");
	        }
	        super({
	            requestContentType: "application/json; charset=utf-8",
	            retryOptions: {
	                maxRetries: 3,
	            },
	            ...options,
	            userAgentOptions: {
	                userAgentPrefix,
	            },
	            baseUri,
	        });
	        this.authorityHost = baseUri;
	        this.abortControllers = new Map();
	        this.allowLoggingAccountIdentifiers = options?.loggingOptions?.allowLoggingAccountIdentifiers;
	        // used for WorkloadIdentity
	        this.tokenCredentialOptions = { ...options };
	        // used for ManagedIdentity
	        if (options?.allowInsecureConnection) {
	            this.allowInsecureConnection = options.allowInsecureConnection;
	        }
	    }
	    async sendTokenRequest(request) {
	        logging_js_1.logger.info(`IdentityClient: sending token request to [${request.url}]`);
	        const response = await this.sendRequest(request);
	        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {
	            const parsedBody = JSON.parse(response.bodyAsText);
	            if (!parsedBody.access_token) {
	                return null;
	            }
	            this.logIdentifiers(response);
	            const token = {
	                accessToken: {
	                    token: parsedBody.access_token,
	                    expiresOnTimestamp: (0, utils_js_1.parseExpirationTimestamp)(parsedBody),
	                    refreshAfterTimestamp: (0, utils_js_1.parseRefreshTimestamp)(parsedBody),
	                    tokenType: "Bearer",
	                },
	                refreshToken: parsedBody.refresh_token,
	            };
	            logging_js_1.logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);
	            return token;
	        }
	        else {
	            const error = new errors_js_1.AuthenticationError(response.status, response.bodyAsText);
	            logging_js_1.logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);
	            throw error;
	        }
	    }
	    async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, options = {}) {
	        if (refreshToken === undefined) {
	            return null;
	        }
	        logging_js_1.logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
	        const refreshParams = {
	            grant_type: "refresh_token",
	            client_id: clientId,
	            refresh_token: refreshToken,
	            scope: scopes,
	        };
	        if (clientSecret !== undefined) {
	            refreshParams.client_secret = clientSecret;
	        }
	        const query = new URLSearchParams(refreshParams);
	        return tracing_js_1.tracingClient.withSpan("IdentityClient.refreshAccessToken", options, async (updatedOptions) => {
	            try {
	                const urlSuffix = (0, identityTokenEndpoint_js_1.getIdentityTokenEndpointSuffix)(tenantId);
	                const request = (0, core_rest_pipeline_1.createPipelineRequest)({
	                    url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,
	                    method: "POST",
	                    body: query.toString(),
	                    abortSignal: options.abortSignal,
	                    headers: (0, core_rest_pipeline_1.createHttpHeaders)({
	                        Accept: "application/json",
	                        "Content-Type": "application/x-www-form-urlencoded",
	                    }),
	                    tracingOptions: updatedOptions.tracingOptions,
	                });
	                const response = await this.sendTokenRequest(request);
	                logging_js_1.logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
	                return response;
	            }
	            catch (err) {
	                if (err.name === errors_js_1.AuthenticationErrorName &&
	                    err.errorResponse.error === "interaction_required") {
	                    // It's likely that the refresh token has expired, so
	                    // return null so that the credential implementation will
	                    // initiate the authentication flow again.
	                    logging_js_1.logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);
	                    return null;
	                }
	                else {
	                    logging_js_1.logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
	                    throw err;
	                }
	            }
	        });
	    }
	    // Here is a custom layer that allows us to abort requests that go through MSAL,
	    // since MSAL doesn't allow us to pass options all the way through.
	    generateAbortSignal(correlationId) {
	        const controller = new AbortController();
	        const controllers = this.abortControllers.get(correlationId) || [];
	        controllers.push(controller);
	        this.abortControllers.set(correlationId, controllers);
	        const existingOnAbort = controller.signal.onabort;
	        controller.signal.onabort = (...params) => {
	            this.abortControllers.set(correlationId, undefined);
	            if (existingOnAbort) {
	                existingOnAbort.apply(controller.signal, params);
	            }
	        };
	        return controller.signal;
	    }
	    abortRequests(correlationId) {
	        const key = correlationId || noCorrelationId;
	        const controllers = [
	            ...(this.abortControllers.get(key) || []),
	            // MSAL passes no correlation ID to the get requests...
	            ...(this.abortControllers.get(noCorrelationId) || []),
	        ];
	        if (!controllers.length) {
	            return;
	        }
	        for (const controller of controllers) {
	            controller.abort();
	        }
	        this.abortControllers.set(key, undefined);
	    }
	    getCorrelationId(options) {
	        const parameter = options?.body
	            ?.split("&")
	            .map((part) => part.split("="))
	            .find(([key]) => key === "client-request-id");
	        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;
	    }
	    // The MSAL network module methods follow
	    async sendGetRequestAsync(url, options) {
	        const request = (0, core_rest_pipeline_1.createPipelineRequest)({
	            url,
	            method: "GET",
	            body: options?.body,
	            allowInsecureConnection: this.allowInsecureConnection,
	            headers: (0, core_rest_pipeline_1.createHttpHeaders)(options?.headers),
	            abortSignal: this.generateAbortSignal(noCorrelationId),
	        });
	        const response = await this.sendRequest(request);
	        this.logIdentifiers(response);
	        return {
	            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,
	            headers: response.headers.toJSON(),
	            status: response.status,
	        };
	    }
	    async sendPostRequestAsync(url, options) {
	        const request = (0, core_rest_pipeline_1.createPipelineRequest)({
	            url,
	            method: "POST",
	            body: options?.body,
	            headers: (0, core_rest_pipeline_1.createHttpHeaders)(options?.headers),
	            allowInsecureConnection: this.allowInsecureConnection,
	            // MSAL doesn't send the correlation ID on the get requests.
	            abortSignal: this.generateAbortSignal(this.getCorrelationId(options)),
	        });
	        const response = await this.sendRequest(request);
	        this.logIdentifiers(response);
	        return {
	            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,
	            headers: response.headers.toJSON(),
	            status: response.status,
	        };
	    }
	    /**
	     *
	     * @internal
	     */
	    getTokenCredentialOptions() {
	        return this.tokenCredentialOptions;
	    }
	    /**
	     * If allowLoggingAccountIdentifiers was set on the constructor options
	     * we try to log the account identifiers by parsing the received access token.
	     *
	     * The account identifiers we try to log are:
	     * - `appid`: The application or Client Identifier.
	     * - `upn`: User Principal Name.
	     *   - It might not be available in some authentication scenarios.
	     *   - If it's not available, we put a placeholder: "No User Principal Name available".
	     * - `tid`: Tenant Identifier.
	     * - `oid`: Object Identifier of the authenticated user.
	     */
	    logIdentifiers(response) {
	        if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {
	            return;
	        }
	        const unavailableUpn = "No User Principal Name available";
	        try {
	            const parsed = response.parsedBody || JSON.parse(response.bodyAsText);
	            const accessToken = parsed.access_token;
	            if (!accessToken) {
	                // Without an access token allowLoggingAccountIdentifiers isn't useful.
	                return;
	            }
	            const base64Metadata = accessToken.split(".")[1];
	            const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, "base64").toString("utf8"));
	            logging_js_1.logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);
	        }
	        catch (e) {
	            logging_js_1.logger.warning("allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:", e.message);
	        }
	    }
	}
	identityClient.IdentityClient = IdentityClient;
	
	return identityClient;
}

var regionalAuthority = {};

var hasRequiredRegionalAuthority;

function requireRegionalAuthority () {
	if (hasRequiredRegionalAuthority) return regionalAuthority;
	hasRequiredRegionalAuthority = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(regionalAuthority, "__esModule", { value: true });
	regionalAuthority.RegionalAuthority = void 0;
	regionalAuthority.calculateRegionalAuthority = calculateRegionalAuthority;
	/**
	 * Helps specify a regional authority, or "AutoDiscoverRegion" to auto-detect the region.
	 */
	var RegionalAuthority;
	(function (RegionalAuthority) {
	    /** Instructs MSAL to attempt to discover the region */
	    RegionalAuthority["AutoDiscoverRegion"] = "AutoDiscoverRegion";
	    /** Uses the {@link RegionalAuthority} for the Azure 'westus' region. */
	    RegionalAuthority["USWest"] = "westus";
	    /** Uses the {@link RegionalAuthority} for the Azure 'westus2' region. */
	    RegionalAuthority["USWest2"] = "westus2";
	    /** Uses the {@link RegionalAuthority} for the Azure 'centralus' region. */
	    RegionalAuthority["USCentral"] = "centralus";
	    /** Uses the {@link RegionalAuthority} for the Azure 'eastus' region. */
	    RegionalAuthority["USEast"] = "eastus";
	    /** Uses the {@link RegionalAuthority} for the Azure 'eastus2' region. */
	    RegionalAuthority["USEast2"] = "eastus2";
	    /** Uses the {@link RegionalAuthority} for the Azure 'northcentralus' region. */
	    RegionalAuthority["USNorthCentral"] = "northcentralus";
	    /** Uses the {@link RegionalAuthority} for the Azure 'southcentralus' region. */
	    RegionalAuthority["USSouthCentral"] = "southcentralus";
	    /** Uses the {@link RegionalAuthority} for the Azure 'westcentralus' region. */
	    RegionalAuthority["USWestCentral"] = "westcentralus";
	    /** Uses the {@link RegionalAuthority} for the Azure 'canadacentral' region. */
	    RegionalAuthority["CanadaCentral"] = "canadacentral";
	    /** Uses the {@link RegionalAuthority} for the Azure 'canadaeast' region. */
	    RegionalAuthority["CanadaEast"] = "canadaeast";
	    /** Uses the {@link RegionalAuthority} for the Azure 'brazilsouth' region. */
	    RegionalAuthority["BrazilSouth"] = "brazilsouth";
	    /** Uses the {@link RegionalAuthority} for the Azure 'northeurope' region. */
	    RegionalAuthority["EuropeNorth"] = "northeurope";
	    /** Uses the {@link RegionalAuthority} for the Azure 'westeurope' region. */
	    RegionalAuthority["EuropeWest"] = "westeurope";
	    /** Uses the {@link RegionalAuthority} for the Azure 'uksouth' region. */
	    RegionalAuthority["UKSouth"] = "uksouth";
	    /** Uses the {@link RegionalAuthority} for the Azure 'ukwest' region. */
	    RegionalAuthority["UKWest"] = "ukwest";
	    /** Uses the {@link RegionalAuthority} for the Azure 'francecentral' region. */
	    RegionalAuthority["FranceCentral"] = "francecentral";
	    /** Uses the {@link RegionalAuthority} for the Azure 'francesouth' region. */
	    RegionalAuthority["FranceSouth"] = "francesouth";
	    /** Uses the {@link RegionalAuthority} for the Azure 'switzerlandnorth' region. */
	    RegionalAuthority["SwitzerlandNorth"] = "switzerlandnorth";
	    /** Uses the {@link RegionalAuthority} for the Azure 'switzerlandwest' region. */
	    RegionalAuthority["SwitzerlandWest"] = "switzerlandwest";
	    /** Uses the {@link RegionalAuthority} for the Azure 'germanynorth' region. */
	    RegionalAuthority["GermanyNorth"] = "germanynorth";
	    /** Uses the {@link RegionalAuthority} for the Azure 'germanywestcentral' region. */
	    RegionalAuthority["GermanyWestCentral"] = "germanywestcentral";
	    /** Uses the {@link RegionalAuthority} for the Azure 'norwaywest' region. */
	    RegionalAuthority["NorwayWest"] = "norwaywest";
	    /** Uses the {@link RegionalAuthority} for the Azure 'norwayeast' region. */
	    RegionalAuthority["NorwayEast"] = "norwayeast";
	    /** Uses the {@link RegionalAuthority} for the Azure 'eastasia' region. */
	    RegionalAuthority["AsiaEast"] = "eastasia";
	    /** Uses the {@link RegionalAuthority} for the Azure 'southeastasia' region. */
	    RegionalAuthority["AsiaSouthEast"] = "southeastasia";
	    /** Uses the {@link RegionalAuthority} for the Azure 'japaneast' region. */
	    RegionalAuthority["JapanEast"] = "japaneast";
	    /** Uses the {@link RegionalAuthority} for the Azure 'japanwest' region. */
	    RegionalAuthority["JapanWest"] = "japanwest";
	    /** Uses the {@link RegionalAuthority} for the Azure 'australiaeast' region. */
	    RegionalAuthority["AustraliaEast"] = "australiaeast";
	    /** Uses the {@link RegionalAuthority} for the Azure 'australiasoutheast' region. */
	    RegionalAuthority["AustraliaSouthEast"] = "australiasoutheast";
	    /** Uses the {@link RegionalAuthority} for the Azure 'australiacentral' region. */
	    RegionalAuthority["AustraliaCentral"] = "australiacentral";
	    /** Uses the {@link RegionalAuthority} for the Azure 'australiacentral2' region. */
	    RegionalAuthority["AustraliaCentral2"] = "australiacentral2";
	    /** Uses the {@link RegionalAuthority} for the Azure 'centralindia' region. */
	    RegionalAuthority["IndiaCentral"] = "centralindia";
	    /** Uses the {@link RegionalAuthority} for the Azure 'southindia' region. */
	    RegionalAuthority["IndiaSouth"] = "southindia";
	    /** Uses the {@link RegionalAuthority} for the Azure 'westindia' region. */
	    RegionalAuthority["IndiaWest"] = "westindia";
	    /** Uses the {@link RegionalAuthority} for the Azure 'koreasouth' region. */
	    RegionalAuthority["KoreaSouth"] = "koreasouth";
	    /** Uses the {@link RegionalAuthority} for the Azure 'koreacentral' region. */
	    RegionalAuthority["KoreaCentral"] = "koreacentral";
	    /** Uses the {@link RegionalAuthority} for the Azure 'uaecentral' region. */
	    RegionalAuthority["UAECentral"] = "uaecentral";
	    /** Uses the {@link RegionalAuthority} for the Azure 'uaenorth' region. */
	    RegionalAuthority["UAENorth"] = "uaenorth";
	    /** Uses the {@link RegionalAuthority} for the Azure 'southafricanorth' region. */
	    RegionalAuthority["SouthAfricaNorth"] = "southafricanorth";
	    /** Uses the {@link RegionalAuthority} for the Azure 'southafricawest' region. */
	    RegionalAuthority["SouthAfricaWest"] = "southafricawest";
	    /** Uses the {@link RegionalAuthority} for the Azure 'chinanorth' region. */
	    RegionalAuthority["ChinaNorth"] = "chinanorth";
	    /** Uses the {@link RegionalAuthority} for the Azure 'chinaeast' region. */
	    RegionalAuthority["ChinaEast"] = "chinaeast";
	    /** Uses the {@link RegionalAuthority} for the Azure 'chinanorth2' region. */
	    RegionalAuthority["ChinaNorth2"] = "chinanorth2";
	    /** Uses the {@link RegionalAuthority} for the Azure 'chinaeast2' region. */
	    RegionalAuthority["ChinaEast2"] = "chinaeast2";
	    /** Uses the {@link RegionalAuthority} for the Azure 'germanycentral' region. */
	    RegionalAuthority["GermanyCentral"] = "germanycentral";
	    /** Uses the {@link RegionalAuthority} for the Azure 'germanynortheast' region. */
	    RegionalAuthority["GermanyNorthEast"] = "germanynortheast";
	    /** Uses the {@link RegionalAuthority} for the Azure 'usgovvirginia' region. */
	    RegionalAuthority["GovernmentUSVirginia"] = "usgovvirginia";
	    /** Uses the {@link RegionalAuthority} for the Azure 'usgoviowa' region. */
	    RegionalAuthority["GovernmentUSIowa"] = "usgoviowa";
	    /** Uses the {@link RegionalAuthority} for the Azure 'usgovarizona' region. */
	    RegionalAuthority["GovernmentUSArizona"] = "usgovarizona";
	    /** Uses the {@link RegionalAuthority} for the Azure 'usgovtexas' region. */
	    RegionalAuthority["GovernmentUSTexas"] = "usgovtexas";
	    /** Uses the {@link RegionalAuthority} for the Azure 'usdodeast' region. */
	    RegionalAuthority["GovernmentUSDodEast"] = "usdodeast";
	    /** Uses the {@link RegionalAuthority} for the Azure 'usdodcentral' region. */
	    RegionalAuthority["GovernmentUSDodCentral"] = "usdodcentral";
	})(RegionalAuthority || (regionalAuthority.RegionalAuthority = RegionalAuthority = {}));
	/**
	 * Calculates the correct regional authority based on the supplied value
	 * and the AZURE_REGIONAL_AUTHORITY_NAME environment variable.
	 *
	 * Values will be returned verbatim, except for {@link RegionalAuthority.AutoDiscoverRegion}
	 * which is mapped to a value MSAL can understand.
	 *
	 * @internal
	 */
	function calculateRegionalAuthority(regionalAuthority) {
	    // Note: as of today only 3 credentials support regional authority, and the parameter
	    // is not exposed via the public API. Regional Authority is _only_ supported
	    // via the AZURE_REGIONAL_AUTHORITY_NAME env var and _only_ for: ClientSecretCredential, ClientCertificateCredential, and ClientAssertionCredential.
	    // Accepting the regionalAuthority parameter will allow us to support it in the future.
	    let azureRegion = regionalAuthority;
	    if (azureRegion === undefined &&
	        globalThis.process?.env?.AZURE_REGIONAL_AUTHORITY_NAME !== undefined) {
	        azureRegion = process.env.AZURE_REGIONAL_AUTHORITY_NAME;
	    }
	    if (azureRegion === RegionalAuthority.AutoDiscoverRegion) {
	        return "AUTO_DISCOVER";
	    }
	    return azureRegion;
	}
	
	return regionalAuthority;
}

var tenantIdUtils = {};

var processMultiTenantRequest = {};

var hasRequiredProcessMultiTenantRequest;

function requireProcessMultiTenantRequest () {
	if (hasRequiredProcessMultiTenantRequest) return processMultiTenantRequest;
	hasRequiredProcessMultiTenantRequest = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(processMultiTenantRequest, "__esModule", { value: true });
	processMultiTenantRequest.processMultiTenantRequest = processMultiTenantRequest$1;
	const errors_js_1 = requireErrors$2();
	function createConfigurationErrorMessage(tenantId) {
	    return `The current credential is not configured to acquire tokens for tenant ${tenantId}. To enable acquiring tokens for this tenant add it to the AdditionallyAllowedTenants on the credential options, or add "*" to AdditionallyAllowedTenants to allow acquiring tokens for any tenant.`;
	}
	/**
	 * Of getToken contains a tenantId, this functions allows picking this tenantId as the appropriate for authentication,
	 * unless multitenant authentication has been disabled through the AZURE_IDENTITY_DISABLE_MULTITENANTAUTH (on Node.js),
	 * or unless the original tenant Id is `adfs`.
	 * @internal
	 */
	function processMultiTenantRequest$1(tenantId, getTokenOptions, additionallyAllowedTenantIds = [], logger) {
	    let resolvedTenantId;
	    if (process.env.AZURE_IDENTITY_DISABLE_MULTITENANTAUTH) {
	        resolvedTenantId = tenantId;
	    }
	    else if (tenantId === "adfs") {
	        resolvedTenantId = tenantId;
	    }
	    else {
	        resolvedTenantId = getTokenOptions?.tenantId ?? tenantId;
	    }
	    if (tenantId &&
	        resolvedTenantId !== tenantId &&
	        !additionallyAllowedTenantIds.includes("*") &&
	        !additionallyAllowedTenantIds.some((t) => t.localeCompare(resolvedTenantId) === 0)) {
	        const message = createConfigurationErrorMessage(resolvedTenantId);
	        logger?.info(message);
	        throw new errors_js_1.CredentialUnavailableError(message);
	    }
	    return resolvedTenantId;
	}
	
	return processMultiTenantRequest;
}

var hasRequiredTenantIdUtils;

function requireTenantIdUtils () {
	if (hasRequiredTenantIdUtils) return tenantIdUtils;
	hasRequiredTenantIdUtils = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.processMultiTenantRequest = void 0;
		exports$1.checkTenantId = checkTenantId;
		exports$1.resolveTenantId = resolveTenantId;
		exports$1.resolveAdditionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds;
		const constants_js_1 = requireConstants$3();
		const logging_js_1 = requireLogging();
		var processMultiTenantRequest_js_1 = requireProcessMultiTenantRequest();
		Object.defineProperty(exports$1, "processMultiTenantRequest", { enumerable: true, get: function () { return processMultiTenantRequest_js_1.processMultiTenantRequest; } });
		/**
		 * @internal
		 */
		function checkTenantId(logger, tenantId) {
		    if (!tenantId.match(/^[0-9a-zA-Z-.]+$/)) {
		        const error = new Error("Invalid tenant id provided. You can locate your tenant id by following the instructions listed here: https://learn.microsoft.com/partner-center/find-ids-and-domain-names.");
		        logger.info((0, logging_js_1.formatError)("", error));
		        throw error;
		    }
		}
		/**
		 * @internal
		 */
		function resolveTenantId(logger, tenantId, clientId) {
		    if (tenantId) {
		        checkTenantId(logger, tenantId);
		        return tenantId;
		    }
		    if (!clientId) {
		        clientId = constants_js_1.DeveloperSignOnClientId;
		    }
		    if (clientId !== constants_js_1.DeveloperSignOnClientId) {
		        return "common";
		    }
		    return "organizations";
		}
		/**
		 * @internal
		 */
		function resolveAdditionallyAllowedTenantIds(additionallyAllowedTenants) {
		    if (!additionallyAllowedTenants || additionallyAllowedTenants.length === 0) {
		        return [];
		    }
		    if (additionallyAllowedTenants.includes("*")) {
		        return constants_js_1.ALL_TENANTS;
		    }
		    return additionallyAllowedTenants;
		}
		
	} (tenantIdUtils));
	return tenantIdUtils;
}

var hasRequiredMsalClient;

function requireMsalClient () {
	if (hasRequiredMsalClient) return msalClient;
	hasRequiredMsalClient = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(msalClient, "__esModule", { value: true });
	msalClient.generateMsalConfiguration = generateMsalConfiguration;
	msalClient.createMsalClient = createMsalClient;
	const tslib_1 = require$$0$3;
	const msal = tslib_1.__importStar(requireMsalNode());
	const logging_js_1 = requireLogging();
	const msalPlugins_js_1 = requireMsalPlugins();
	const utils_js_1 = requireUtils$3();
	const errors_js_1 = requireErrors$2();
	const identityClient_js_1 = requireIdentityClient();
	const regionalAuthority_js_1 = requireRegionalAuthority();
	const logger_1 = /*@__PURE__*/ requireCommonjs$8();
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	/**
	 * The default logger used if no logger was passed in by the credential.
	 */
	const msalLogger = (0, logging_js_1.credentialLogger)("MsalClient");
	/**
	 * Generates the configuration for MSAL (Microsoft Authentication Library).
	 *
	 * @param clientId - The client ID of the application.
	 * @param  tenantId - The tenant ID of the Azure Active Directory.
	 * @param  msalClientOptions - Optional. Additional options for creating the MSAL client.
	 * @returns  The MSAL configuration object.
	 */
	function generateMsalConfiguration(clientId, tenantId, msalClientOptions = {}) {
	    const resolvedTenant = (0, tenantIdUtils_js_1.resolveTenantId)(msalClientOptions.logger ?? msalLogger, tenantId, clientId);
	    // TODO: move and reuse getIdentityClientAuthorityHost
	    const authority = (0, utils_js_1.getAuthority)(resolvedTenant, (0, utils_js_1.getAuthorityHost)(msalClientOptions));
	    const httpClient = new identityClient_js_1.IdentityClient({
	        ...msalClientOptions.tokenCredentialOptions,
	        authorityHost: authority,
	        loggingOptions: msalClientOptions.loggingOptions,
	    });
	    const msalConfig = {
	        auth: {
	            clientId,
	            authority,
	            knownAuthorities: (0, utils_js_1.getKnownAuthorities)(resolvedTenant, authority, msalClientOptions.disableInstanceDiscovery),
	        },
	        system: {
	            networkClient: httpClient,
	            loggerOptions: {
	                loggerCallback: (0, utils_js_1.defaultLoggerCallback)(msalClientOptions.logger ?? msalLogger),
	                logLevel: (0, utils_js_1.getMSALLogLevel)((0, logger_1.getLogLevel)()),
	                piiLoggingEnabled: msalClientOptions.loggingOptions?.enableUnsafeSupportLogging,
	            },
	        },
	    };
	    return msalConfig;
	}
	/**
	 * Creates an instance of the MSAL (Microsoft Authentication Library) client.
	 *
	 * @param clientId - The client ID of the application.
	 * @param tenantId - The tenant ID of the Azure Active Directory.
	 * @param createMsalClientOptions - Optional. Additional options for creating the MSAL client.
	 * @returns An instance of the MSAL client.
	 *
	 * @public
	 */
	function createMsalClient(clientId, tenantId, createMsalClientOptions = {}) {
	    const state = {
	        msalConfig: generateMsalConfiguration(clientId, tenantId, createMsalClientOptions),
	        cachedAccount: createMsalClientOptions.authenticationRecord
	            ? (0, utils_js_1.publicToMsal)(createMsalClientOptions.authenticationRecord)
	            : null,
	        pluginConfiguration: msalPlugins_js_1.msalPlugins.generatePluginConfiguration(createMsalClientOptions),
	        logger: createMsalClientOptions.logger ?? msalLogger,
	    };
	    const publicApps = new Map();
	    async function getPublicApp(options = {}) {
	        const appKey = options.enableCae ? "CAE" : "default";
	        let publicClientApp = publicApps.get(appKey);
	        if (publicClientApp) {
	            state.logger.getToken.info("Existing PublicClientApplication found in cache, returning it.");
	            return publicClientApp;
	        }
	        // Initialize a new app and cache it
	        state.logger.getToken.info(`Creating new PublicClientApplication with CAE ${options.enableCae ? "enabled" : "disabled"}.`);
	        const cachePlugin = options.enableCae
	            ? state.pluginConfiguration.cache.cachePluginCae
	            : state.pluginConfiguration.cache.cachePlugin;
	        state.msalConfig.auth.clientCapabilities = options.enableCae ? ["cp1"] : undefined;
	        publicClientApp = new msal.PublicClientApplication({
	            ...state.msalConfig,
	            broker: { nativeBrokerPlugin: state.pluginConfiguration.broker.nativeBrokerPlugin },
	            cache: { cachePlugin: await cachePlugin },
	        });
	        publicApps.set(appKey, publicClientApp);
	        return publicClientApp;
	    }
	    const confidentialApps = new Map();
	    async function getConfidentialApp(options = {}) {
	        const appKey = options.enableCae ? "CAE" : "default";
	        let confidentialClientApp = confidentialApps.get(appKey);
	        if (confidentialClientApp) {
	            state.logger.getToken.info("Existing ConfidentialClientApplication found in cache, returning it.");
	            return confidentialClientApp;
	        }
	        // Initialize a new app and cache it
	        state.logger.getToken.info(`Creating new ConfidentialClientApplication with CAE ${options.enableCae ? "enabled" : "disabled"}.`);
	        const cachePlugin = options.enableCae
	            ? state.pluginConfiguration.cache.cachePluginCae
	            : state.pluginConfiguration.cache.cachePlugin;
	        state.msalConfig.auth.clientCapabilities = options.enableCae ? ["cp1"] : undefined;
	        confidentialClientApp = new msal.ConfidentialClientApplication({
	            ...state.msalConfig,
	            broker: { nativeBrokerPlugin: state.pluginConfiguration.broker.nativeBrokerPlugin },
	            cache: { cachePlugin: await cachePlugin },
	        });
	        confidentialApps.set(appKey, confidentialClientApp);
	        return confidentialClientApp;
	    }
	    async function getTokenSilent(app, scopes, options = {}) {
	        if (state.cachedAccount === null) {
	            state.logger.getToken.info("No cached account found in local state.");
	            throw new errors_js_1.AuthenticationRequiredError({ scopes });
	        }
	        // Keep track and reuse the claims we received across challenges
	        if (options.claims) {
	            state.cachedClaims = options.claims;
	        }
	        const silentRequest = {
	            account: state.cachedAccount,
	            scopes,
	            claims: state.cachedClaims,
	        };
	        if (state.pluginConfiguration.broker.isEnabled) {
	            silentRequest.tokenQueryParameters ||= {};
	            if (state.pluginConfiguration.broker.enableMsaPassthrough) {
	                silentRequest.tokenQueryParameters["msal_request_type"] = "consumer_passthrough";
	            }
	        }
	        if (options.proofOfPossessionOptions) {
	            silentRequest.shrNonce = options.proofOfPossessionOptions.nonce;
	            silentRequest.authenticationScheme = "pop";
	            silentRequest.resourceRequestMethod = options.proofOfPossessionOptions.resourceRequestMethod;
	            silentRequest.resourceRequestUri = options.proofOfPossessionOptions.resourceRequestUrl;
	        }
	        state.logger.getToken.info("Attempting to acquire token silently");
	        try {
	            return await app.acquireTokenSilent(silentRequest);
	        }
	        catch (err) {
	            throw (0, utils_js_1.handleMsalError)(scopes, err, options);
	        }
	    }
	    /**
	     * Builds an authority URL for the given request. The authority may be different than the one used when creating the MSAL client
	     * if the user is creating cross-tenant requests
	     */
	    function calculateRequestAuthority(options) {
	        if (options?.tenantId) {
	            return (0, utils_js_1.getAuthority)(options.tenantId, (0, utils_js_1.getAuthorityHost)(createMsalClientOptions));
	        }
	        return state.msalConfig.auth.authority;
	    }
	    /**
	     * Performs silent authentication using MSAL to acquire an access token.
	     * If silent authentication fails, falls back to interactive authentication.
	     *
	     * @param msalApp - The MSAL application instance.
	     * @param scopes - The scopes for which to acquire the access token.
	     * @param options - The options for acquiring the access token.
	     * @param onAuthenticationRequired - A callback function to handle interactive authentication when silent authentication fails.
	     * @returns A promise that resolves to an AccessToken object containing the access token and its expiration timestamp.
	     */
	    async function withSilentAuthentication(msalApp, scopes, options, onAuthenticationRequired) {
	        let response = null;
	        try {
	            response = await getTokenSilent(msalApp, scopes, options);
	        }
	        catch (e) {
	            if (e.name !== "AuthenticationRequiredError") {
	                throw e;
	            }
	            if (options.disableAutomaticAuthentication) {
	                throw new errors_js_1.AuthenticationRequiredError({
	                    scopes,
	                    getTokenOptions: options,
	                    message: "Automatic authentication has been disabled. You may call the authentication() method.",
	                });
	            }
	        }
	        // Silent authentication failed
	        if (response === null) {
	            try {
	                response = await onAuthenticationRequired();
	            }
	            catch (err) {
	                throw (0, utils_js_1.handleMsalError)(scopes, err, options);
	            }
	        }
	        // At this point we should have a token, process it
	        (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
	        state.cachedAccount = response?.account ?? null;
	        state.logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
	        return {
	            token: response.accessToken,
	            expiresOnTimestamp: response.expiresOn.getTime(),
	            refreshAfterTimestamp: response.refreshOn?.getTime(),
	            tokenType: response.tokenType,
	        };
	    }
	    async function getTokenByClientSecret(scopes, clientSecret, options = {}) {
	        state.logger.getToken.info(`Attempting to acquire token using client secret`);
	        state.msalConfig.auth.clientSecret = clientSecret;
	        const msalApp = await getConfidentialApp(options);
	        try {
	            const response = await msalApp.acquireTokenByClientCredential({
	                scopes,
	                authority: calculateRequestAuthority(options),
	                azureRegion: (0, regionalAuthority_js_1.calculateRegionalAuthority)(),
	                claims: options?.claims,
	            });
	            (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
	            state.logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
	            return {
	                token: response.accessToken,
	                expiresOnTimestamp: response.expiresOn.getTime(),
	                refreshAfterTimestamp: response.refreshOn?.getTime(),
	                tokenType: response.tokenType,
	            };
	        }
	        catch (err) {
	            throw (0, utils_js_1.handleMsalError)(scopes, err, options);
	        }
	    }
	    async function getTokenByClientAssertion(scopes, clientAssertion, options = {}) {
	        state.logger.getToken.info(`Attempting to acquire token using client assertion`);
	        state.msalConfig.auth.clientAssertion = clientAssertion;
	        const msalApp = await getConfidentialApp(options);
	        try {
	            const response = await msalApp.acquireTokenByClientCredential({
	                scopes,
	                authority: calculateRequestAuthority(options),
	                azureRegion: (0, regionalAuthority_js_1.calculateRegionalAuthority)(),
	                claims: options?.claims,
	                clientAssertion,
	            });
	            (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
	            state.logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
	            return {
	                token: response.accessToken,
	                expiresOnTimestamp: response.expiresOn.getTime(),
	                refreshAfterTimestamp: response.refreshOn?.getTime(),
	                tokenType: response.tokenType,
	            };
	        }
	        catch (err) {
	            throw (0, utils_js_1.handleMsalError)(scopes, err, options);
	        }
	    }
	    async function getTokenByClientCertificate(scopes, certificate, options = {}) {
	        state.logger.getToken.info(`Attempting to acquire token using client certificate`);
	        state.msalConfig.auth.clientCertificate = certificate;
	        const msalApp = await getConfidentialApp(options);
	        try {
	            const response = await msalApp.acquireTokenByClientCredential({
	                scopes,
	                authority: calculateRequestAuthority(options),
	                azureRegion: (0, regionalAuthority_js_1.calculateRegionalAuthority)(),
	                claims: options?.claims,
	            });
	            (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
	            state.logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
	            return {
	                token: response.accessToken,
	                expiresOnTimestamp: response.expiresOn.getTime(),
	                refreshAfterTimestamp: response.refreshOn?.getTime(),
	                tokenType: response.tokenType,
	            };
	        }
	        catch (err) {
	            throw (0, utils_js_1.handleMsalError)(scopes, err, options);
	        }
	    }
	    async function getTokenByDeviceCode(scopes, deviceCodeCallback, options = {}) {
	        state.logger.getToken.info(`Attempting to acquire token using device code`);
	        const msalApp = await getPublicApp(options);
	        return withSilentAuthentication(msalApp, scopes, options, () => {
	            const requestOptions = {
	                scopes,
	                cancel: options?.abortSignal?.aborted ?? false,
	                deviceCodeCallback,
	                authority: calculateRequestAuthority(options),
	                claims: options?.claims,
	            };
	            const deviceCodeRequest = msalApp.acquireTokenByDeviceCode(requestOptions);
	            if (options.abortSignal) {
	                options.abortSignal.addEventListener("abort", () => {
	                    requestOptions.cancel = true;
	                });
	            }
	            return deviceCodeRequest;
	        });
	    }
	    async function getTokenByUsernamePassword(scopes, username, password, options = {}) {
	        state.logger.getToken.info(`Attempting to acquire token using username and password`);
	        const msalApp = await getPublicApp(options);
	        return withSilentAuthentication(msalApp, scopes, options, () => {
	            const requestOptions = {
	                scopes,
	                username,
	                password,
	                authority: calculateRequestAuthority(options),
	                claims: options?.claims,
	            };
	            return msalApp.acquireTokenByUsernamePassword(requestOptions);
	        });
	    }
	    function getActiveAccount() {
	        if (!state.cachedAccount) {
	            return undefined;
	        }
	        return (0, utils_js_1.msalToPublic)(clientId, state.cachedAccount);
	    }
	    async function getTokenByAuthorizationCode(scopes, redirectUri, authorizationCode, clientSecret, options = {}) {
	        state.logger.getToken.info(`Attempting to acquire token using authorization code`);
	        let msalApp;
	        if (clientSecret) {
	            // If a client secret is provided, we need to use a confidential client application
	            // See https://learn.microsoft.com/entra/identity-platform/v2-oauth2-auth-code-flow#request-an-access-token-with-a-client_secret
	            state.msalConfig.auth.clientSecret = clientSecret;
	            msalApp = await getConfidentialApp(options);
	        }
	        else {
	            msalApp = await getPublicApp(options);
	        }
	        return withSilentAuthentication(msalApp, scopes, options, () => {
	            return msalApp.acquireTokenByCode({
	                scopes,
	                redirectUri,
	                code: authorizationCode,
	                authority: calculateRequestAuthority(options),
	                claims: options?.claims,
	            });
	        });
	    }
	    async function getTokenOnBehalfOf(scopes, userAssertionToken, clientCredentials, options = {}) {
	        msalLogger.getToken.info(`Attempting to acquire token on behalf of another user`);
	        if (typeof clientCredentials === "string") {
	            // Client secret
	            msalLogger.getToken.info(`Using client secret for on behalf of flow`);
	            state.msalConfig.auth.clientSecret = clientCredentials;
	        }
	        else if (typeof clientCredentials === "function") {
	            // Client Assertion
	            msalLogger.getToken.info(`Using client assertion callback for on behalf of flow`);
	            state.msalConfig.auth.clientAssertion = clientCredentials;
	        }
	        else {
	            // Client certificate
	            msalLogger.getToken.info(`Using client certificate for on behalf of flow`);
	            state.msalConfig.auth.clientCertificate = clientCredentials;
	        }
	        const msalApp = await getConfidentialApp(options);
	        try {
	            const response = await msalApp.acquireTokenOnBehalfOf({
	                scopes,
	                authority: calculateRequestAuthority(options),
	                claims: options.claims,
	                oboAssertion: userAssertionToken,
	            });
	            (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
	            msalLogger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
	            return {
	                token: response.accessToken,
	                expiresOnTimestamp: response.expiresOn.getTime(),
	                refreshAfterTimestamp: response.refreshOn?.getTime(),
	                tokenType: response.tokenType,
	            };
	        }
	        catch (err) {
	            throw (0, utils_js_1.handleMsalError)(scopes, err, options);
	        }
	    }
	    /**
	     * Creates a base interactive request configuration for MSAL interactive authentication.
	     * This is shared between interactive and brokered authentication flows.
	     */
	    function createBaseInteractiveRequest(scopes, options) {
	        return {
	            openBrowser: async (url) => {
	                const open = await import('./index-n3Oz7pe3.js');
	                await open.default(url, { newInstance: true });
	            },
	            scopes,
	            authority: calculateRequestAuthority(options),
	            claims: options?.claims,
	            loginHint: options?.loginHint,
	            errorTemplate: options?.browserCustomizationOptions?.errorMessage,
	            successTemplate: options?.browserCustomizationOptions?.successMessage,
	            prompt: options?.loginHint ? "login" : "select_account",
	        };
	    }
	    /**
	     * @internal
	     */
	    async function getBrokeredTokenInternal(scopes, useDefaultBrokerAccount, options = {}) {
	        msalLogger.verbose("Authentication will resume through the broker");
	        const app = await getPublicApp(options);
	        const interactiveRequest = createBaseInteractiveRequest(scopes, options);
	        if (state.pluginConfiguration.broker.parentWindowHandle) {
	            interactiveRequest.windowHandle = Buffer.from(state.pluginConfiguration.broker.parentWindowHandle);
	        }
	        else {
	            // this is a bug, as the pluginConfiguration handler should validate this case.
	            msalLogger.warning("Parent window handle is not specified for the broker. This may cause unexpected behavior. Please provide the parentWindowHandle.");
	        }
	        if (state.pluginConfiguration.broker.enableMsaPassthrough) {
	            (interactiveRequest.tokenQueryParameters ??= {})["msal_request_type"] =
	                "consumer_passthrough";
	        }
	        if (useDefaultBrokerAccount) {
	            interactiveRequest.prompt = "none";
	            msalLogger.verbose("Attempting broker authentication using the default broker account");
	        }
	        else {
	            msalLogger.verbose("Attempting broker authentication without the default broker account");
	        }
	        if (options.proofOfPossessionOptions) {
	            interactiveRequest.shrNonce = options.proofOfPossessionOptions.nonce;
	            interactiveRequest.authenticationScheme = "pop";
	            interactiveRequest.resourceRequestMethod =
	                options.proofOfPossessionOptions.resourceRequestMethod;
	            interactiveRequest.resourceRequestUri = options.proofOfPossessionOptions.resourceRequestUrl;
	        }
	        try {
	            return await app.acquireTokenInteractive(interactiveRequest);
	        }
	        catch (e) {
	            msalLogger.verbose(`Failed to authenticate through the broker: ${e.message}`);
	            if (options.disableAutomaticAuthentication) {
	                throw new errors_js_1.AuthenticationRequiredError({
	                    scopes,
	                    getTokenOptions: options,
	                    message: "Cannot silently authenticate with default broker account.",
	                });
	            }
	            // If we tried to use the default broker account and failed, fall back to interactive authentication
	            if (useDefaultBrokerAccount) {
	                return getBrokeredTokenInternal(scopes, false, options);
	            }
	            else {
	                throw e;
	            }
	        }
	    }
	    /**
	     * A helper function that supports brokered authentication through the MSAL's public application.
	     *
	     * When useDefaultBrokerAccount is true, the method will attempt to authenticate using the default broker account.
	     * If the default broker account is not available, the method will fall back to interactive authentication.
	     */
	    async function getBrokeredToken(scopes, useDefaultBrokerAccount, options = {}) {
	        msalLogger.getToken.info(`Attempting to acquire token using brokered authentication with useDefaultBrokerAccount: ${useDefaultBrokerAccount}`);
	        const response = await getBrokeredTokenInternal(scopes, useDefaultBrokerAccount, options);
	        (0, utils_js_1.ensureValidMsalToken)(scopes, response, options);
	        state.cachedAccount = response?.account ?? null;
	        state.logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
	        return {
	            token: response.accessToken,
	            expiresOnTimestamp: response.expiresOn.getTime(),
	            refreshAfterTimestamp: response.refreshOn?.getTime(),
	            tokenType: response.tokenType,
	        };
	    }
	    async function getTokenByInteractiveRequest(scopes, options = {}) {
	        msalLogger.getToken.info(`Attempting to acquire token interactively`);
	        const app = await getPublicApp(options);
	        return withSilentAuthentication(app, scopes, options, async () => {
	            const interactiveRequest = createBaseInteractiveRequest(scopes, options);
	            if (state.pluginConfiguration.broker.isEnabled) {
	                return getBrokeredTokenInternal(scopes, state.pluginConfiguration.broker.useDefaultBrokerAccount ?? false, options);
	            }
	            if (options.proofOfPossessionOptions) {
	                interactiveRequest.shrNonce = options.proofOfPossessionOptions.nonce;
	                interactiveRequest.authenticationScheme = "pop";
	                interactiveRequest.resourceRequestMethod =
	                    options.proofOfPossessionOptions.resourceRequestMethod;
	                interactiveRequest.resourceRequestUri = options.proofOfPossessionOptions.resourceRequestUrl;
	            }
	            return app.acquireTokenInteractive(interactiveRequest);
	        });
	    }
	    return {
	        getActiveAccount,
	        getBrokeredToken,
	        getTokenByClientSecret,
	        getTokenByClientAssertion,
	        getTokenByClientCertificate,
	        getTokenByDeviceCode,
	        getTokenByUsernamePassword,
	        getTokenByAuthorizationCode,
	        getTokenOnBehalfOf,
	        getTokenByInteractiveRequest,
	    };
	}
	
	return msalClient;
}

const require$3 = createRequire(import.meta.url);
function __require$2() { return require$3("node:fs/promises"); }

var hasRequiredClientCertificateCredential;

function requireClientCertificateCredential () {
	if (hasRequiredClientCertificateCredential) return clientCertificateCredential;
	hasRequiredClientCertificateCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(clientCertificateCredential, "__esModule", { value: true });
	clientCertificateCredential.ClientCertificateCredential = void 0;
	clientCertificateCredential.parseCertificate = parseCertificate;
	const msalClient_js_1 = requireMsalClient();
	const node_crypto_1 = __require$6();
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const logging_js_1 = requireLogging();
	const promises_1 = __require$2();
	const tracing_js_1 = requireTracing();
	const credentialName = "ClientCertificateCredential";
	const logger = (0, logging_js_1.credentialLogger)(credentialName);
	/**
	 * Enables authentication to Microsoft Entra ID using a PEM-encoded
	 * certificate that is assigned to an App Registration. More information
	 * on how to configure certificate authentication can be found here:
	 *
	 * https://learn.microsoft.com/azure/active-directory/develop/active-directory-certificate-credentials#register-your-certificate-with-azure-ad
	 *
	 */
	class ClientCertificateCredential {
	    tenantId;
	    additionallyAllowedTenantIds;
	    certificateConfiguration;
	    sendCertificateChain;
	    msalClient;
	    constructor(tenantId, clientId, certificatePathOrConfiguration, options = {}) {
	        if (!tenantId || !clientId) {
	            throw new Error(`${credentialName}: tenantId and clientId are required parameters.`);
	        }
	        this.tenantId = tenantId;
	        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
	        this.sendCertificateChain = options.sendCertificateChain;
	        this.certificateConfiguration = {
	            ...(typeof certificatePathOrConfiguration === "string"
	                ? {
	                    certificatePath: certificatePathOrConfiguration,
	                }
	                : certificatePathOrConfiguration),
	        };
	        const certificate = this.certificateConfiguration
	            .certificate;
	        const certificatePath = this.certificateConfiguration
	            .certificatePath;
	        if (!this.certificateConfiguration || !(certificate || certificatePath)) {
	            throw new Error(`${credentialName}: Provide either a PEM certificate in string form, or the path to that certificate in the filesystem. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
	        }
	        if (certificate && certificatePath) {
	            throw new Error(`${credentialName}: To avoid unexpected behaviors, providing both the contents of a PEM certificate and the path to a PEM certificate is forbidden. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
	        }
	        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, tenantId, {
	            ...options,
	            logger,
	            tokenCredentialOptions: options,
	        });
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                TokenCredential implementation might make.
	     */
	    async getToken(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${credentialName}.getToken`, options, async (newOptions) => {
	            newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
	            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
	            const certificate = await this.buildClientCertificate();
	            return this.msalClient.getTokenByClientCertificate(arrayScopes, certificate, newOptions);
	        });
	    }
	    async buildClientCertificate() {
	        const parts = await parseCertificate(this.certificateConfiguration, this.sendCertificateChain ?? false);
	        let privateKey;
	        if (this.certificateConfiguration.certificatePassword !== undefined) {
	            privateKey = (0, node_crypto_1.createPrivateKey)({
	                key: parts.certificateContents,
	                passphrase: this.certificateConfiguration.certificatePassword,
	                format: "pem",
	            })
	                .export({
	                format: "pem",
	                type: "pkcs8",
	            })
	                .toString();
	        }
	        else {
	            privateKey = parts.certificateContents;
	        }
	        return {
	            thumbprint: parts.thumbprint,
	            thumbprintSha256: parts.thumbprintSha256,
	            privateKey,
	            x5c: parts.x5c,
	        };
	    }
	}
	clientCertificateCredential.ClientCertificateCredential = ClientCertificateCredential;
	/**
	 * Parses a certificate into its relevant parts
	 *
	 * @param certificateConfiguration - The certificate contents or path to the certificate
	 * @param sendCertificateChain - true if the entire certificate chain should be sent for SNI, false otherwise
	 * @returns The parsed certificate parts and the certificate contents
	 */
	async function parseCertificate(certificateConfiguration, sendCertificateChain) {
	    const certificate = certificateConfiguration.certificate;
	    const certificatePath = certificateConfiguration
	        .certificatePath;
	    const certificateContents = certificate || (await (0, promises_1.readFile)(certificatePath, "utf8"));
	    const x5c = sendCertificateChain ? certificateContents : undefined;
	    const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/g;
	    const publicKeys = [];
	    // Match all possible certificates, in the order they are in the file. These will form the chain that is used for x5c
	    let match;
	    do {
	        match = certificatePattern.exec(certificateContents);
	        if (match) {
	            publicKeys.push(match[3]);
	        }
	    } while (match);
	    if (publicKeys.length === 0) {
	        throw new Error("The file at the specified path does not contain a PEM-encoded certificate.");
	    }
	    const thumbprint = (0, node_crypto_1.createHash)("sha1") // CodeQL [SM04514] Needed for backward compatibility reason
	        .update(Buffer.from(publicKeys[0], "base64"))
	        .digest("hex")
	        .toUpperCase();
	    const thumbprintSha256 = (0, node_crypto_1.createHash)("sha256")
	        .update(Buffer.from(publicKeys[0], "base64"))
	        .digest("hex")
	        .toUpperCase();
	    return {
	        certificateContents,
	        thumbprintSha256,
	        thumbprint,
	        x5c,
	    };
	}
	
	return clientCertificateCredential;
}

var clientSecretCredential = {};

var scopeUtils = {};

var hasRequiredScopeUtils;

function requireScopeUtils () {
	if (hasRequiredScopeUtils) return scopeUtils;
	hasRequiredScopeUtils = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(scopeUtils, "__esModule", { value: true });
	scopeUtils.ensureScopes = ensureScopes;
	scopeUtils.ensureValidScopeForDevTimeCreds = ensureValidScopeForDevTimeCreds;
	scopeUtils.getScopeResource = getScopeResource;
	const logging_js_1 = requireLogging();
	/**
	 * Ensures the scopes value is an array.
	 * @internal
	 */
	function ensureScopes(scopes) {
	    return Array.isArray(scopes) ? scopes : [scopes];
	}
	/**
	 * Throws if the received scope is not valid.
	 * @internal
	 */
	function ensureValidScopeForDevTimeCreds(scope, logger) {
	    if (!scope.match(/^[0-9a-zA-Z-_.:/]+$/)) {
	        const error = new Error("Invalid scope was specified by the user or calling client");
	        logger.getToken.info((0, logging_js_1.formatError)(scope, error));
	        throw error;
	    }
	}
	/**
	 * Returns the resource out of a scope.
	 * @internal
	 */
	function getScopeResource(scope) {
	    return scope.replace(/\/.default$/, "");
	}
	
	return scopeUtils;
}

var hasRequiredClientSecretCredential;

function requireClientSecretCredential () {
	if (hasRequiredClientSecretCredential) return clientSecretCredential;
	hasRequiredClientSecretCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(clientSecretCredential, "__esModule", { value: true });
	clientSecretCredential.ClientSecretCredential = void 0;
	const msalClient_js_1 = requireMsalClient();
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const errors_js_1 = requireErrors$2();
	const logging_js_1 = requireLogging();
	const scopeUtils_js_1 = requireScopeUtils();
	const tracing_js_1 = requireTracing();
	const logger = (0, logging_js_1.credentialLogger)("ClientSecretCredential");
	/**
	 * Enables authentication to Microsoft Entra ID using a client secret
	 * that was generated for an App Registration. More information on how
	 * to configure a client secret can be found here:
	 *
	 * https://learn.microsoft.com/entra/identity-platform/quickstart-configure-app-access-web-apis#add-credentials-to-your-web-application
	 *
	 */
	class ClientSecretCredential {
	    tenantId;
	    additionallyAllowedTenantIds;
	    msalClient;
	    clientSecret;
	    /**
	     * Creates an instance of the ClientSecretCredential with the details
	     * needed to authenticate against Microsoft Entra ID with a client
	     * secret.
	     *
	     * @param tenantId - The Microsoft Entra tenant (directory) ID.
	     * @param clientId - The client (application) ID of an App Registration in the tenant.
	     * @param clientSecret - A client secret that was generated for the App Registration.
	     * @param options - Options for configuring the client which makes the authentication request.
	     */
	    constructor(tenantId, clientId, clientSecret, options = {}) {
	        if (!tenantId) {
	            throw new errors_js_1.CredentialUnavailableError("ClientSecretCredential: tenantId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.");
	        }
	        if (!clientId) {
	            throw new errors_js_1.CredentialUnavailableError("ClientSecretCredential: clientId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.");
	        }
	        if (!clientSecret) {
	            throw new errors_js_1.CredentialUnavailableError("ClientSecretCredential: clientSecret is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.");
	        }
	        this.clientSecret = clientSecret;
	        this.tenantId = tenantId;
	        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
	        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, tenantId, {
	            ...options,
	            logger,
	            tokenCredentialOptions: options,
	        });
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                TokenCredential implementation might make.
	     */
	    async getToken(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
	            newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
	            const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
	            return this.msalClient.getTokenByClientSecret(arrayScopes, this.clientSecret, newOptions);
	        });
	    }
	}
	clientSecretCredential.ClientSecretCredential = ClientSecretCredential;
	
	return clientSecretCredential;
}

var usernamePasswordCredential = {};

var hasRequiredUsernamePasswordCredential;

function requireUsernamePasswordCredential () {
	if (hasRequiredUsernamePasswordCredential) return usernamePasswordCredential;
	hasRequiredUsernamePasswordCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(usernamePasswordCredential, "__esModule", { value: true });
	usernamePasswordCredential.UsernamePasswordCredential = void 0;
	const msalClient_js_1 = requireMsalClient();
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const errors_js_1 = requireErrors$2();
	const logging_js_1 = requireLogging();
	const scopeUtils_js_1 = requireScopeUtils();
	const tracing_js_1 = requireTracing();
	const logger = (0, logging_js_1.credentialLogger)("UsernamePasswordCredential");
	/**
	 * Enables authentication to Microsoft Entra ID with a user's
	 * username and password. This credential requires a high degree of
	 * trust so you should only use it when other, more secure credential
	 * types can't be used.
	 * @deprecated UsernamePasswordCredential is deprecated. Use a more secure credential. See https://aka.ms/azsdk/identity/mfa for details.
	 */
	class UsernamePasswordCredential {
	    tenantId;
	    additionallyAllowedTenantIds;
	    msalClient;
	    username;
	    password;
	    /**
	     * Creates an instance of the UsernamePasswordCredential with the details
	     * needed to authenticate against Microsoft Entra ID with a username
	     * and password.
	     *
	     * @param tenantId - The Microsoft Entra tenant (directory).
	     * @param clientId - The client (application) ID of an App Registration in the tenant.
	     * @param username - The user account's e-mail address (user name).
	     * @param password - The user account's account password
	     * @param options - Options for configuring the client which makes the authentication request.
	     */
	    constructor(tenantId, clientId, username, password, options = {}) {
	        if (!tenantId) {
	            throw new errors_js_1.CredentialUnavailableError("UsernamePasswordCredential: tenantId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
	        }
	        if (!clientId) {
	            throw new errors_js_1.CredentialUnavailableError("UsernamePasswordCredential: clientId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
	        }
	        if (!username) {
	            throw new errors_js_1.CredentialUnavailableError("UsernamePasswordCredential: username is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
	        }
	        if (!password) {
	            throw new errors_js_1.CredentialUnavailableError("UsernamePasswordCredential: password is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/usernamepasswordcredential/troubleshoot.");
	        }
	        this.tenantId = tenantId;
	        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
	        this.username = username;
	        this.password = password;
	        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, this.tenantId, {
	            ...options,
	            tokenCredentialOptions: options ?? {},
	        });
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * If the user provided the option `disableAutomaticAuthentication`,
	     * once the token can't be retrieved silently,
	     * this method won't attempt to request user interaction to retrieve the token.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                TokenCredential implementation might make.
	     */
	    async getToken(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
	            newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
	            const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
	            return this.msalClient.getTokenByUsernamePassword(arrayScopes, this.username, this.password, newOptions);
	        });
	    }
	}
	usernamePasswordCredential.UsernamePasswordCredential = UsernamePasswordCredential;
	
	return usernamePasswordCredential;
}

var hasRequiredEnvironmentCredential;

function requireEnvironmentCredential () {
	if (hasRequiredEnvironmentCredential) return environmentCredential;
	hasRequiredEnvironmentCredential = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.EnvironmentCredential = exports$1.AllSupportedEnvironmentVariables = void 0;
		exports$1.getSendCertificateChain = getSendCertificateChain;
		const errors_js_1 = requireErrors$2();
		const logging_js_1 = requireLogging();
		const clientCertificateCredential_js_1 = requireClientCertificateCredential();
		const clientSecretCredential_js_1 = requireClientSecretCredential();
		const usernamePasswordCredential_js_1 = requireUsernamePasswordCredential();
		const tenantIdUtils_js_1 = requireTenantIdUtils();
		const tracing_js_1 = requireTracing();
		/**
		 * Contains the list of all supported environment variable names so that an
		 * appropriate error message can be generated when no credentials can be
		 * configured.
		 *
		 * @internal
		 */
		exports$1.AllSupportedEnvironmentVariables = [
		    "AZURE_TENANT_ID",
		    "AZURE_CLIENT_ID",
		    "AZURE_CLIENT_SECRET",
		    "AZURE_CLIENT_CERTIFICATE_PATH",
		    "AZURE_CLIENT_CERTIFICATE_PASSWORD",
		    "AZURE_USERNAME",
		    "AZURE_PASSWORD",
		    "AZURE_ADDITIONALLY_ALLOWED_TENANTS",
		    "AZURE_CLIENT_SEND_CERTIFICATE_CHAIN",
		];
		function getAdditionallyAllowedTenants() {
		    const additionallyAllowedValues = process.env.AZURE_ADDITIONALLY_ALLOWED_TENANTS ?? "";
		    return additionallyAllowedValues.split(";");
		}
		const credentialName = "EnvironmentCredential";
		const logger = (0, logging_js_1.credentialLogger)(credentialName);
		function getSendCertificateChain() {
		    const sendCertificateChain = (process.env.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN ?? "").toLowerCase();
		    const result = sendCertificateChain === "true" || sendCertificateChain === "1";
		    logger.verbose(`AZURE_CLIENT_SEND_CERTIFICATE_CHAIN: ${process.env.AZURE_CLIENT_SEND_CERTIFICATE_CHAIN}; sendCertificateChain: ${result}`);
		    return result;
		}
		/**
		 * Enables authentication to Microsoft Entra ID using a client secret or certificate.
		 */
		class EnvironmentCredential {
		    _credential = undefined;
		    /**
		     * Creates an instance of the EnvironmentCredential class and decides what credential to use depending on the available environment variables.
		     *
		     * Required environment variables:
		     * - `AZURE_TENANT_ID`: The Microsoft Entra tenant (directory) ID.
		     * - `AZURE_CLIENT_ID`: The client (application) ID of an App Registration in the tenant.
		     *
		     * If setting the AZURE_TENANT_ID, then you can also set the additionally allowed tenants
		     * - `AZURE_ADDITIONALLY_ALLOWED_TENANTS`: For multi-tenant applications, specifies additional tenants for which the credential may acquire tokens with a single semicolon delimited string. Use * to allow all tenants.
		     *
		     * Environment variables used for client credential authentication:
		     * - `AZURE_CLIENT_SECRET`: A client secret that was generated for the App Registration.
		     * - `AZURE_CLIENT_CERTIFICATE_PATH`: The path to a PEM certificate to use during the authentication, instead of the client secret.
		     * - `AZURE_CLIENT_CERTIFICATE_PASSWORD`: (optional) password for the certificate file.
		     * - `AZURE_CLIENT_SEND_CERTIFICATE_CHAIN`: (optional) indicates that the certificate chain should be set in x5c header to support subject name / issuer based authentication.
		     *
		     * Username and password authentication is deprecated, since it doesn't support multifactor authentication (MFA). See https://aka.ms/azsdk/identity/mfa for more details. Users can still provide environment variables for this authentication method:
		     * - `AZURE_USERNAME`: Username to authenticate with.
		     * - `AZURE_PASSWORD`: Password to authenticate with.
		     *
		     * If the environment variables required to perform the authentication are missing, a {@link CredentialUnavailableError} will be thrown.
		     * If the authentication fails, or if there's an unknown error, an {@link AuthenticationError} will be thrown.
		     *
		     * @param options - Options for configuring the client which makes the authentication request.
		     */
		    constructor(options) {
		        // Keep track of any missing environment variables for error details
		        const assigned = (0, logging_js_1.processEnvVars)(exports$1.AllSupportedEnvironmentVariables).assigned.join(", ");
		        logger.info(`Found the following environment variables: ${assigned}`);
		        const tenantId = process.env.AZURE_TENANT_ID, clientId = process.env.AZURE_CLIENT_ID, clientSecret = process.env.AZURE_CLIENT_SECRET;
		        const additionallyAllowedTenantIds = getAdditionallyAllowedTenants();
		        const sendCertificateChain = getSendCertificateChain();
		        const newOptions = { ...options, additionallyAllowedTenantIds, sendCertificateChain };
		        if (tenantId) {
		            (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
		        }
		        if (tenantId && clientId && clientSecret) {
		            logger.info(`Invoking ClientSecretCredential with tenant ID: ${tenantId}, clientId: ${clientId} and clientSecret: [REDACTED]`);
		            this._credential = new clientSecretCredential_js_1.ClientSecretCredential(tenantId, clientId, clientSecret, newOptions);
		            return;
		        }
		        const certificatePath = process.env.AZURE_CLIENT_CERTIFICATE_PATH;
		        const certificatePassword = process.env.AZURE_CLIENT_CERTIFICATE_PASSWORD;
		        if (tenantId && clientId && certificatePath) {
		            logger.info(`Invoking ClientCertificateCredential with tenant ID: ${tenantId}, clientId: ${clientId} and certificatePath: ${certificatePath}`);
		            this._credential = new clientCertificateCredential_js_1.ClientCertificateCredential(tenantId, clientId, { certificatePath, certificatePassword }, newOptions);
		            return;
		        }
		        const username = process.env.AZURE_USERNAME;
		        const password = process.env.AZURE_PASSWORD;
		        if (tenantId && clientId && username && password) {
		            logger.info(`Invoking UsernamePasswordCredential with tenant ID: ${tenantId}, clientId: ${clientId} and username: ${username}`);
		            logger.warning("Environment is configured to use username and password authentication. This authentication method is deprecated, as it doesn't support multifactor authentication (MFA). Use a more secure credential. For more details, see https://aka.ms/azsdk/identity/mfa.");
		            this._credential = new usernamePasswordCredential_js_1.UsernamePasswordCredential(tenantId, clientId, username, password, newOptions);
		        }
		    }
		    /**
		     * Authenticates with Microsoft Entra ID and returns an access token if successful.
		     *
		     * @param scopes - The list of scopes for which the token will have access.
		     * @param options - Optional parameters. See {@link GetTokenOptions}.
		     */
		    async getToken(scopes, options = {}) {
		        return tracing_js_1.tracingClient.withSpan(`${credentialName}.getToken`, options, async (newOptions) => {
		            if (this._credential) {
		                try {
		                    const result = await this._credential.getToken(scopes, newOptions);
		                    logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
		                    return result;
		                }
		                catch (err) {
		                    const authenticationError = new errors_js_1.AuthenticationError(400, {
		                        error: `${credentialName} authentication failed. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`,
		                        error_description: err.message.toString().split("More details:").join(""),
		                    });
		                    logger.getToken.info((0, logging_js_1.formatError)(scopes, authenticationError));
		                    throw authenticationError;
		                }
		            }
		            throw new errors_js_1.CredentialUnavailableError(`${credentialName} is unavailable. No underlying credential could be used. To troubleshoot, visit https://aka.ms/azsdk/js/identity/environmentcredential/troubleshoot.`);
		        });
		    }
		}
		exports$1.EnvironmentCredential = EnvironmentCredential;
		
	} (environmentCredential));
	return environmentCredential;
}

var managedIdentityCredential = {};

var imdsRetryPolicy = {};

var hasRequiredImdsRetryPolicy;

function requireImdsRetryPolicy () {
	if (hasRequiredImdsRetryPolicy) return imdsRetryPolicy;
	hasRequiredImdsRetryPolicy = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(imdsRetryPolicy, "__esModule", { value: true });
	imdsRetryPolicy.imdsRetryPolicy = imdsRetryPolicy$1;
	const core_rest_pipeline_1 = /*@__PURE__*/ requireCommonjs$3();
	const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
	// Matches the default retry configuration in expontentialRetryStrategy.ts
	const DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;
	// For 410 responses, we need at least 70 seconds total retry duration
	// With 5 retries using exponential backoff: delays of d, 2d, 4d, 8d, 16d sum to 31d
	// Accounting for jitter (which can reduce delays by 20%), we need 31d * 0.8 >= 70
	// So we need d >= 70/24.8 = 2.82 seconds. Using 3 seconds to be safe.
	const MIN_DELAY_FOR_410_MS = 3000;
	/**
	 * An additional policy that retries on 404 and 410 errors. The default retry policy does not retry on
	 * 404s or 410s, but the IMDS endpoint can return these when the token is not yet available or when
	 * the identity is still being set up. This policy will retry on 404s and 410s with an exponential backoff.
	 * For 410 responses, it uses a minimum 3-second initial delay to ensure at least 70 seconds total duration.
	 *
	 * @param msiRetryConfig - The retry configuration for the MSI credential.
	 * @returns - The policy that will retry on 404s and 410s.
	 */
	function imdsRetryPolicy$1(msiRetryConfig) {
	    return (0, core_rest_pipeline_1.retryPolicy)([
	        {
	            name: "imdsRetryPolicy",
	            retry: ({ retryCount, response }) => {
	                if (response?.status !== 404 && response?.status !== 410) {
	                    return { skipStrategy: true };
	                }
	                // For 410 responses, use a minimum 3-second delay to ensure at least 70 seconds total retry duration
	                const initialDelayMs = response?.status === 410
	                    ? Math.max(MIN_DELAY_FOR_410_MS, msiRetryConfig.startDelayInMs)
	                    : msiRetryConfig.startDelayInMs;
	                return (0, core_util_1.calculateRetryDelay)(retryCount, {
	                    retryDelayInMs: initialDelayMs,
	                    maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL,
	                });
	            },
	        },
	    ], {
	        maxRetries: msiRetryConfig.maxRetries,
	    });
	}
	
	return imdsRetryPolicy;
}

var imdsMsi = {};

var hasRequiredImdsMsi;

function requireImdsMsi () {
	if (hasRequiredImdsMsi) return imdsMsi;
	hasRequiredImdsMsi = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(imdsMsi, "__esModule", { value: true });
	imdsMsi.imdsMsi = void 0;
	const core_rest_pipeline_1 = /*@__PURE__*/ requireCommonjs$3();
	const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
	const logging_js_1 = requireLogging();
	const utils_js_1 = requireUtils$1();
	const tracing_js_1 = requireTracing();
	const msiName = "ManagedIdentityCredential - IMDS";
	const logger = (0, logging_js_1.credentialLogger)(msiName);
	const imdsHost = "http://169.254.169.254";
	const imdsEndpointPath = "/metadata/identity/oauth2/token";
	/**
	 * Generates an invalid request options to get a response quickly from IMDS endpoint.
	 * The response indicates the availability of IMSD service; otherwise the request would time out.
	 */
	function prepareInvalidRequestOptions(scopes) {
	    const resource = (0, utils_js_1.mapScopesToResource)(scopes);
	    if (!resource) {
	        throw new Error(`${msiName}: Multiple scopes are not supported.`);
	    }
	    // Pod Identity will try to process this request even if the Metadata header is missing.
	    // We can exclude the request query to ensure no IMDS endpoint tries to process the ping request.
	    const url = new URL(imdsEndpointPath, process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST ?? imdsHost);
	    const rawHeaders = {
	        Accept: "application/json",
	        // intentionally leave out the Metadata header to invoke an error from IMDS endpoint.
	    };
	    return {
	        // intentionally not including any query
	        url: `${url}`,
	        method: "GET",
	        headers: (0, core_rest_pipeline_1.createHttpHeaders)(rawHeaders),
	    };
	}
	/**
	 * Defines how to determine whether the Azure IMDS MSI is available.
	 *
	 * Actually getting the token once we determine IMDS is available is handled by MSAL.
	 */
	imdsMsi.imdsMsi = {
	    name: "imdsMsi",
	    async isAvailable(options) {
	        const { scopes, identityClient, getTokenOptions } = options;
	        const resource = (0, utils_js_1.mapScopesToResource)(scopes);
	        if (!resource) {
	            logger.info(`${msiName}: Unavailable. Multiple scopes are not supported.`);
	            return false;
	        }
	        // if the PodIdentityEndpoint environment variable was set no need to probe the endpoint, it can be assumed to exist
	        if (process.env.AZURE_POD_IDENTITY_AUTHORITY_HOST) {
	            return true;
	        }
	        if (!identityClient) {
	            throw new Error("Missing IdentityClient");
	        }
	        const requestOptions = prepareInvalidRequestOptions(resource);
	        return tracing_js_1.tracingClient.withSpan("ManagedIdentityCredential-pingImdsEndpoint", getTokenOptions ?? {}, async (updatedOptions) => {
	            requestOptions.tracingOptions = updatedOptions.tracingOptions;
	            // Create a request with a timeout since we expect that
	            // not having a "Metadata" header should cause an error to be
	            // returned quickly from the endpoint, proving its availability.
	            const request = (0, core_rest_pipeline_1.createPipelineRequest)(requestOptions);
	            // Default to 1000 if the default of 0 is used.
	            // Negative values can still be used to disable the timeout.
	            request.timeout = updatedOptions.requestOptions?.timeout || 1000;
	            // This MSI uses the imdsEndpoint to get the token, which only uses http://
	            request.allowInsecureConnection = true;
	            let response;
	            try {
	                logger.info(`${msiName}: Pinging the Azure IMDS endpoint`);
	                response = await identityClient.sendRequest(request);
	            }
	            catch (err) {
	                // If the request failed, or Node.js was unable to establish a connection,
	                // or the host was down, we'll assume the IMDS endpoint isn't available.
	                if ((0, core_util_1.isError)(err)) {
	                    logger.verbose(`${msiName}: Caught error ${err.name}: ${err.message}`);
	                }
	                // This is a special case for Docker Desktop which responds with a 403 with a message that contains "A socket operation was attempted to an unreachable network" or "A socket operation was attempted to an unreachable host"
	                // rather than just timing out, as expected.
	                logger.info(`${msiName}: The Azure IMDS endpoint is unavailable`);
	                return false;
	            }
	            if (response.status === 403) {
	                if (response.bodyAsText?.includes("unreachable")) {
	                    logger.info(`${msiName}: The Azure IMDS endpoint is unavailable`);
	                    logger.info(`${msiName}: ${response.bodyAsText}`);
	                    return false;
	                }
	            }
	            // If we received any response, the endpoint is available
	            logger.info(`${msiName}: The Azure IMDS endpoint is available`);
	            return true;
	        });
	    },
	};
	
	return imdsMsi;
}

var tokenExchangeMsi = {};

var workloadIdentityCredential = {};

var clientAssertionCredential = {};

var hasRequiredClientAssertionCredential;

function requireClientAssertionCredential () {
	if (hasRequiredClientAssertionCredential) return clientAssertionCredential;
	hasRequiredClientAssertionCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(clientAssertionCredential, "__esModule", { value: true });
	clientAssertionCredential.ClientAssertionCredential = void 0;
	const msalClient_js_1 = requireMsalClient();
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const errors_js_1 = requireErrors$2();
	const logging_js_1 = requireLogging();
	const tracing_js_1 = requireTracing();
	const logger = (0, logging_js_1.credentialLogger)("ClientAssertionCredential");
	/**
	 * Authenticates a service principal with a JWT assertion.
	 */
	class ClientAssertionCredential {
	    msalClient;
	    tenantId;
	    additionallyAllowedTenantIds;
	    getAssertion;
	    options;
	    /**
	     * Creates an instance of the ClientAssertionCredential with the details
	     * needed to authenticate against Microsoft Entra ID with a client
	     * assertion provided by the developer through the `getAssertion` function parameter.
	     *
	     * @param tenantId - The Microsoft Entra tenant (directory) ID.
	     * @param clientId - The client (application) ID of an App Registration in the tenant.
	     * @param getAssertion - A function that retrieves the assertion for the credential to use.
	     * @param options - Options for configuring the client which makes the authentication request.
	     */
	    constructor(tenantId, clientId, getAssertion, options = {}) {
	        if (!tenantId) {
	            throw new errors_js_1.CredentialUnavailableError("ClientAssertionCredential: tenantId is a required parameter.");
	        }
	        if (!clientId) {
	            throw new errors_js_1.CredentialUnavailableError("ClientAssertionCredential: clientId is a required parameter.");
	        }
	        if (!getAssertion) {
	            throw new errors_js_1.CredentialUnavailableError("ClientAssertionCredential: clientAssertion is a required parameter.");
	        }
	        this.tenantId = tenantId;
	        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
	        this.options = options;
	        this.getAssertion = getAssertion;
	        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, tenantId, {
	            ...options,
	            logger,
	            tokenCredentialOptions: this.options,
	        });
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                TokenCredential implementation might make.
	     */
	    async getToken(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
	            newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
	            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
	            return this.msalClient.getTokenByClientAssertion(arrayScopes, this.getAssertion, newOptions);
	        });
	    }
	}
	clientAssertionCredential.ClientAssertionCredential = ClientAssertionCredential;
	
	return clientAssertionCredential;
}

var hasRequiredWorkloadIdentityCredential;

function requireWorkloadIdentityCredential () {
	if (hasRequiredWorkloadIdentityCredential) return workloadIdentityCredential;
	hasRequiredWorkloadIdentityCredential = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.WorkloadIdentityCredential = exports$1.SupportedWorkloadEnvironmentVariables = void 0;
		const logging_js_1 = requireLogging();
		const clientAssertionCredential_js_1 = requireClientAssertionCredential();
		const errors_js_1 = requireErrors$2();
		const tenantIdUtils_js_1 = requireTenantIdUtils();
		const promises_1 = __require$2();
		const credentialName = "WorkloadIdentityCredential";
		/**
		 * Contains the list of all supported environment variable names so that an
		 * appropriate error message can be generated when no credentials can be
		 * configured.
		 *
		 * @internal
		 */
		exports$1.SupportedWorkloadEnvironmentVariables = [
		    "AZURE_TENANT_ID",
		    "AZURE_CLIENT_ID",
		    "AZURE_FEDERATED_TOKEN_FILE",
		];
		const logger = (0, logging_js_1.credentialLogger)(credentialName);
		/**
		 * Workload Identity authentication is a feature in Azure that allows applications running on virtual machines (VMs)
		 * to access other Azure resources without the need for a service principal or managed identity. With Workload Identity
		 * authentication, applications authenticate themselves using their own identity, rather than using a shared service
		 * principal or managed identity. Under the hood, Workload Identity authentication uses the concept of Service Account
		 * Credentials (SACs), which are automatically created by Azure and stored securely in the VM. By using Workload
		 * Identity authentication, you can avoid the need to manage and rotate service principals or managed identities for
		 * each application on each VM. Additionally, because SACs are created automatically and managed by Azure, you don't
		 * need to worry about storing and securing sensitive credentials themselves.
		 * The WorkloadIdentityCredential supports Microsoft Entra Workload ID authentication on Azure Kubernetes and acquires
		 * a token using the SACs available in the Azure Kubernetes environment.
		 * Refer to <a href="https://learn.microsoft.com/azure/aks/workload-identity-overview">Microsoft Entra
		 * Workload ID</a> for more information.
		 */
		class WorkloadIdentityCredential {
		    client;
		    azureFederatedTokenFileContent = undefined;
		    cacheDate = undefined;
		    federatedTokenFilePath;
		    /**
		     * WorkloadIdentityCredential supports Microsoft Entra Workload ID on Kubernetes.
		     *
		     * @param options - The identity client options to use for authentication.
		     */
		    constructor(options) {
		        // Logging environment variables for error details
		        const assignedEnv = (0, logging_js_1.processEnvVars)(exports$1.SupportedWorkloadEnvironmentVariables).assigned.join(", ");
		        logger.info(`Found the following environment variables: ${assignedEnv}`);
		        const workloadIdentityCredentialOptions = options ?? {};
		        const tenantId = workloadIdentityCredentialOptions.tenantId || process.env.AZURE_TENANT_ID;
		        const clientId = workloadIdentityCredentialOptions.clientId || process.env.AZURE_CLIENT_ID;
		        this.federatedTokenFilePath =
		            workloadIdentityCredentialOptions.tokenFilePath || process.env.AZURE_FEDERATED_TOKEN_FILE;
		        if (tenantId) {
		            (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
		        }
		        if (!clientId) {
		            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. clientId is a required parameter. In DefaultAzureCredential and ManagedIdentityCredential, this can be provided as an environment variable - "AZURE_CLIENT_ID".
        See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/workloadidentitycredential/troubleshoot`);
		        }
		        if (!tenantId) {
		            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. tenantId is a required parameter. In DefaultAzureCredential and ManagedIdentityCredential, this can be provided as an environment variable - "AZURE_TENANT_ID".
        See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/workloadidentitycredential/troubleshoot`);
		        }
		        if (!this.federatedTokenFilePath) {
		            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. federatedTokenFilePath is a required parameter. In DefaultAzureCredential and ManagedIdentityCredential, this can be provided as an environment variable - "AZURE_FEDERATED_TOKEN_FILE".
        See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/workloadidentitycredential/troubleshoot`);
		        }
		        logger.info(`Invoking ClientAssertionCredential with tenant ID: ${tenantId}, clientId: ${workloadIdentityCredentialOptions.clientId} and federated token path: [REDACTED]`);
		        this.client = new clientAssertionCredential_js_1.ClientAssertionCredential(tenantId, clientId, this.readFileContents.bind(this), options);
		    }
		    /**
		     * Authenticates with Microsoft Entra ID and returns an access token if successful.
		     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
		     *
		     * @param scopes - The list of scopes for which the token will have access.
		     * @param options - The options used to configure any requests this
		     *                TokenCredential implementation might make.
		     */
		    async getToken(scopes, options) {
		        if (!this.client) {
		            const errorMessage = `${credentialName}: is unavailable. tenantId, clientId, and federatedTokenFilePath are required parameters. 
      In DefaultAzureCredential and ManagedIdentityCredential, these can be provided as environment variables - 
      "AZURE_TENANT_ID",
      "AZURE_CLIENT_ID",
      "AZURE_FEDERATED_TOKEN_FILE". See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/workloadidentitycredential/troubleshoot`;
		            logger.info(errorMessage);
		            throw new errors_js_1.CredentialUnavailableError(errorMessage);
		        }
		        logger.info("Invoking getToken() of Client Assertion Credential");
		        return this.client.getToken(scopes, options);
		    }
		    async readFileContents() {
		        // Cached assertions expire after 5 minutes
		        if (this.cacheDate !== undefined && Date.now() - this.cacheDate >= 1000 * 60 * 5) {
		            this.azureFederatedTokenFileContent = undefined;
		        }
		        if (!this.federatedTokenFilePath) {
		            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. Invalid file path provided ${this.federatedTokenFilePath}.`);
		        }
		        if (!this.azureFederatedTokenFileContent) {
		            const file = await (0, promises_1.readFile)(this.federatedTokenFilePath, "utf8");
		            const value = file.trim();
		            if (!value) {
		                throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. No content on the file ${this.federatedTokenFilePath}.`);
		            }
		            else {
		                this.azureFederatedTokenFileContent = value;
		                this.cacheDate = Date.now();
		            }
		        }
		        return this.azureFederatedTokenFileContent;
		    }
		}
		exports$1.WorkloadIdentityCredential = WorkloadIdentityCredential;
		
	} (workloadIdentityCredential));
	return workloadIdentityCredential;
}

var hasRequiredTokenExchangeMsi;

function requireTokenExchangeMsi () {
	if (hasRequiredTokenExchangeMsi) return tokenExchangeMsi;
	hasRequiredTokenExchangeMsi = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(tokenExchangeMsi, "__esModule", { value: true });
	tokenExchangeMsi.tokenExchangeMsi = void 0;
	const workloadIdentityCredential_js_1 = requireWorkloadIdentityCredential();
	const logging_js_1 = requireLogging();
	const msiName = "ManagedIdentityCredential - Token Exchange";
	const logger = (0, logging_js_1.credentialLogger)(msiName);
	/**
	 * Defines how to determine whether the token exchange MSI is available, and also how to retrieve a token from the token exchange MSI.
	 *
	 * Token exchange MSI (used by AKS) is the only MSI implementation handled entirely by Azure Identity.
	 * The rest have been migrated to MSAL.
	 */
	tokenExchangeMsi.tokenExchangeMsi = {
	    name: "tokenExchangeMsi",
	    async isAvailable(clientId) {
	        const env = process.env;
	        const result = Boolean((clientId || env.AZURE_CLIENT_ID) &&
	            env.AZURE_TENANT_ID &&
	            process.env.AZURE_FEDERATED_TOKEN_FILE);
	        if (!result) {
	            logger.info(`${msiName}: Unavailable. The environment variables needed are: AZURE_CLIENT_ID (or the client ID sent through the parameters), AZURE_TENANT_ID and AZURE_FEDERATED_TOKEN_FILE`);
	        }
	        return result;
	    },
	    async getToken(configuration, getTokenOptions = {}) {
	        const { scopes, clientId } = configuration;
	        const identityClientTokenCredentialOptions = {};
	        const workloadIdentityCredential = new workloadIdentityCredential_js_1.WorkloadIdentityCredential({
	            clientId,
	            tenantId: process.env.AZURE_TENANT_ID,
	            tokenFilePath: process.env.AZURE_FEDERATED_TOKEN_FILE,
	            ...identityClientTokenCredentialOptions,
	            disableInstanceDiscovery: true,
	        });
	        return workloadIdentityCredential.getToken(scopes, getTokenOptions);
	    },
	};
	
	return tokenExchangeMsi;
}

var hasRequiredManagedIdentityCredential;

function requireManagedIdentityCredential () {
	if (hasRequiredManagedIdentityCredential) return managedIdentityCredential;
	hasRequiredManagedIdentityCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(managedIdentityCredential, "__esModule", { value: true });
	managedIdentityCredential.ManagedIdentityCredential = void 0;
	const logger_1 = /*@__PURE__*/ requireCommonjs$8();
	const msal_node_1 = requireMsalNode();
	const identityClient_js_1 = requireIdentityClient();
	const errors_js_1 = requireErrors$2();
	const utils_js_1 = requireUtils$3();
	const imdsRetryPolicy_js_1 = requireImdsRetryPolicy();
	const logging_js_1 = requireLogging();
	const tracing_js_1 = requireTracing();
	const imdsMsi_js_1 = requireImdsMsi();
	const tokenExchangeMsi_js_1 = requireTokenExchangeMsi();
	const utils_js_2 = requireUtils$1();
	const logger = (0, logging_js_1.credentialLogger)("ManagedIdentityCredential");
	/**
	 * Attempts authentication using a managed identity available at the deployment environment.
	 * This authentication type works in Azure VMs, App Service instances, Azure Functions applications,
	 * Azure Kubernetes Services, Azure Service Fabric instances and inside of the Azure Cloud Shell.
	 *
	 * More information about configuring managed identities can be found here:
	 * https://learn.microsoft.com/azure/active-directory/managed-identities-azure-resources/overview
	 */
	class ManagedIdentityCredential {
	    managedIdentityApp;
	    identityClient;
	    clientId;
	    resourceId;
	    objectId;
	    msiRetryConfig = {
	        maxRetries: 5,
	        startDelayInMs: 800,
	        intervalIncrement: 2,
	    };
	    isAvailableIdentityClient;
	    sendProbeRequest;
	    /**
	     * @internal
	     * @hidden
	     */
	    constructor(clientIdOrOptions, options) {
	        let _options;
	        if (typeof clientIdOrOptions === "string") {
	            this.clientId = clientIdOrOptions;
	            _options = options ?? {};
	        }
	        else {
	            this.clientId = clientIdOrOptions?.clientId;
	            _options = clientIdOrOptions ?? {};
	        }
	        this.resourceId = _options?.resourceId;
	        this.objectId = _options?.objectId;
	        this.sendProbeRequest =
	            _options?.sendProbeRequest ?? false;
	        // For JavaScript users.
	        const providedIds = [
	            { key: "clientId", value: this.clientId },
	            { key: "resourceId", value: this.resourceId },
	            { key: "objectId", value: this.objectId },
	        ].filter((id) => id.value);
	        if (providedIds.length > 1) {
	            throw new Error(`ManagedIdentityCredential: only one of 'clientId', 'resourceId', or 'objectId' can be provided. Received values: ${JSON.stringify({ clientId: this.clientId, resourceId: this.resourceId, objectId: this.objectId })}`);
	        }
	        // ManagedIdentity uses http for local requests
	        _options.allowInsecureConnection = true;
	        if (_options.retryOptions?.maxRetries !== undefined) {
	            this.msiRetryConfig.maxRetries = _options.retryOptions.maxRetries;
	        }
	        this.identityClient = new identityClient_js_1.IdentityClient({
	            ..._options,
	            additionalPolicies: [{ policy: (0, imdsRetryPolicy_js_1.imdsRetryPolicy)(this.msiRetryConfig), position: "perCall" }],
	        });
	        this.managedIdentityApp = new msal_node_1.ManagedIdentityApplication({
	            managedIdentityIdParams: {
	                userAssignedClientId: this.clientId,
	                userAssignedResourceId: this.resourceId,
	                userAssignedObjectId: this.objectId,
	            },
	            system: {
	                disableInternalRetries: true,
	                networkClient: this.identityClient,
	                loggerOptions: {
	                    logLevel: (0, utils_js_1.getMSALLogLevel)((0, logger_1.getLogLevel)()),
	                    piiLoggingEnabled: _options.loggingOptions?.enableUnsafeSupportLogging,
	                    loggerCallback: (0, utils_js_1.defaultLoggerCallback)(logger),
	                },
	            },
	        });
	        this.isAvailableIdentityClient = new identityClient_js_1.IdentityClient({
	            ..._options,
	            retryOptions: {
	                maxRetries: 0,
	            },
	        });
	        const managedIdentitySource = this.managedIdentityApp.getManagedIdentitySource();
	        // CloudShell MSI will ignore any user-assigned identity passed as parameters. To avoid confusion, we prevent this from happening as early as possible.
	        if (managedIdentitySource === "CloudShell") {
	            if (this.clientId || this.resourceId || this.objectId) {
	                logger.warning(`CloudShell MSI detected with user-provided IDs - throwing. Received values: ${JSON.stringify({
	                    clientId: this.clientId,
	                    resourceId: this.resourceId,
	                    objectId: this.objectId,
	                })}.`);
	                throw new errors_js_1.CredentialUnavailableError("ManagedIdentityCredential: Specifying a user-assigned managed identity is not supported for CloudShell at runtime. When using Managed Identity in CloudShell, omit the clientId, resourceId, and objectId parameters.");
	            }
	        }
	        // ServiceFabric does not support specifying user-assigned managed identity by client ID or resource ID. The managed identity selected is based on the resource configuration.
	        if (managedIdentitySource === "ServiceFabric") {
	            if (this.clientId || this.resourceId || this.objectId) {
	                logger.warning(`Service Fabric detected with user-provided IDs - throwing. Received values: ${JSON.stringify({
	                    clientId: this.clientId,
	                    resourceId: this.resourceId,
	                    objectId: this.objectId,
	                })}.`);
	                throw new errors_js_1.CredentialUnavailableError(`ManagedIdentityCredential: ${utils_js_2.serviceFabricErrorMessage}`);
	            }
	        }
	        logger.info(`Using ${managedIdentitySource} managed identity.`);
	        // Check if either clientId, resourceId or objectId was provided and log the value used
	        if (providedIds.length === 1) {
	            const { key, value } = providedIds[0];
	            logger.info(`${managedIdentitySource} with ${key}: ${value}`);
	        }
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     * If an unexpected error occurs, an {@link AuthenticationError} will be thrown with the details of the failure.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                TokenCredential implementation might make.
	     */
	    async getToken(scopes, options = {}) {
	        logger.getToken.info("Using the MSAL provider for Managed Identity.");
	        const resource = (0, utils_js_2.mapScopesToResource)(scopes);
	        if (!resource) {
	            throw new errors_js_1.CredentialUnavailableError(`ManagedIdentityCredential: Multiple scopes are not supported. Scopes: ${JSON.stringify(scopes)}`);
	        }
	        return tracing_js_1.tracingClient.withSpan("ManagedIdentityCredential.getToken", options, async () => {
	            try {
	                const isTokenExchangeMsi = await tokenExchangeMsi_js_1.tokenExchangeMsi.isAvailable(this.clientId);
	                // Most scenarios are handled by MSAL except for two:
	                // AKS pod identity - MSAL does not implement the token exchange flow.
	                // IMDS Endpoint probing - MSAL does not do any probing before trying to get a token.
	                // As a DefaultAzureCredential optimization we probe the IMDS endpoint with a short timeout and no retries before actually trying to get a token
	                // We will continue to implement these features in the Identity library.
	                const identitySource = this.managedIdentityApp.getManagedIdentitySource();
	                const isImdsMsi = identitySource === "DefaultToImds" || identitySource === "Imds"; // Neither actually checks that IMDS endpoint is available, just that it's the source the MSAL _would_ try to use.
	                logger.getToken.info(`MSAL Identity source: ${identitySource}`);
	                if (isTokenExchangeMsi) {
	                    // In the AKS scenario we will use the existing tokenExchangeMsi indefinitely.
	                    logger.getToken.info("Using the token exchange managed identity.");
	                    const result = await tokenExchangeMsi_js_1.tokenExchangeMsi.getToken({
	                        scopes,
	                        clientId: this.clientId,
	                        identityClient: this.identityClient,
	                        retryConfig: this.msiRetryConfig,
	                        resourceId: this.resourceId,
	                    });
	                    if (result === null) {
	                        throw new errors_js_1.CredentialUnavailableError("Attempted to use the token exchange managed identity, but received a null response.");
	                    }
	                    return result;
	                }
	                else if (isImdsMsi && this.sendProbeRequest) {
	                    // In the IMDS scenario we will probe the IMDS endpoint to ensure it's available before trying to get a token.
	                    // If the IMDS endpoint is not available and this is the source that MSAL will use, we will fail-fast with an error that tells DAC to move to the next credential.
	                    logger.getToken.info("Using the IMDS endpoint to probe for availability.");
	                    const isAvailable = await imdsMsi_js_1.imdsMsi.isAvailable({
	                        scopes,
	                        clientId: this.clientId,
	                        getTokenOptions: options,
	                        identityClient: this.isAvailableIdentityClient,
	                        resourceId: this.resourceId,
	                    });
	                    if (!isAvailable) {
	                        throw new errors_js_1.CredentialUnavailableError(`Attempted to use the IMDS endpoint, but it is not available.`);
	                    }
	                }
	                // If we got this far, it means:
	                // - This is not a tokenExchangeMsi,
	                // - We already probed for IMDS endpoint availability and failed-fast if it's unreachable,
	                // or we skip probing because the credential is set in DAC.
	                // We can proceed normally by calling MSAL for a token.
	                logger.getToken.info("Calling into MSAL for managed identity token.");
	                const token = await this.managedIdentityApp.acquireToken({
	                    resource,
	                });
	                this.ensureValidMsalToken(scopes, token, options);
	                logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
	                return {
	                    expiresOnTimestamp: token.expiresOn.getTime(),
	                    token: token.accessToken,
	                    refreshAfterTimestamp: token.refreshOn?.getTime(),
	                    tokenType: "Bearer",
	                };
	            }
	            catch (err) {
	                logger.getToken.error((0, logging_js_1.formatError)(scopes, err));
	                // AuthenticationRequiredError described as Error to enforce authentication after trying to retrieve a token silently.
	                // TODO: why would this _ever_ happen considering we're not trying the silent request in this flow?
	                if (err.name === "AuthenticationRequiredError") {
	                    throw err;
	                }
	                if (isNetworkError(err)) {
	                    throw new errors_js_1.CredentialUnavailableError(`ManagedIdentityCredential: Network unreachable. Message: ${err.message}`, { cause: err });
	                }
	                throw new errors_js_1.CredentialUnavailableError(`ManagedIdentityCredential: Authentication failed. Message ${err.message}`, { cause: err });
	            }
	        });
	    }
	    /**
	     * Ensures the validity of the MSAL token
	     */
	    ensureValidMsalToken(scopes, msalToken, getTokenOptions) {
	        const createError = (message) => {
	            logger.getToken.info(message);
	            return new errors_js_1.AuthenticationRequiredError({
	                scopes: Array.isArray(scopes) ? scopes : [scopes],
	                getTokenOptions,
	                message,
	            });
	        };
	        if (!msalToken) {
	            throw createError("No response.");
	        }
	        if (!msalToken.expiresOn) {
	            throw createError(`Response had no "expiresOn" property.`);
	        }
	        if (!msalToken.accessToken) {
	            throw createError(`Response had no "accessToken" property.`);
	        }
	    }
	}
	managedIdentityCredential.ManagedIdentityCredential = ManagedIdentityCredential;
	function isNetworkError(err) {
	    // MSAL error
	    if (err.errorCode === "network_error") {
	        return true;
	    }
	    // Probe errors
	    if (err.code === "ENETUNREACH" || err.code === "EHOSTUNREACH") {
	        return true;
	    }
	    // This is a special case for Docker Desktop which responds with a 403 with a message that contains "A socket operation was attempted to an unreachable network" or "A socket operation was attempted to an unreachable host"
	    // rather than just timing out, as expected.
	    if (err.statusCode === 403 || err.code === 403) {
	        if (err.message.includes("unreachable")) {
	            return true;
	        }
	    }
	    return false;
	}
	
	return managedIdentityCredential;
}

var azureDeveloperCliCredential = {};

var hasRequiredAzureDeveloperCliCredential;

function requireAzureDeveloperCliCredential () {
	if (hasRequiredAzureDeveloperCliCredential) return azureDeveloperCliCredential;
	hasRequiredAzureDeveloperCliCredential = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.AzureDeveloperCliCredential = exports$1.developerCliCredentialInternals = exports$1.azureDeveloperCliPublicErrorMessages = void 0;
		const tslib_1 = require$$0$3;
		const logging_js_1 = requireLogging();
		const errors_js_1 = requireErrors$2();
		const child_process_1 = tslib_1.__importDefault(require$$3$1);
		const tenantIdUtils_js_1 = requireTenantIdUtils();
		const tracing_js_1 = requireTracing();
		const scopeUtils_js_1 = requireScopeUtils();
		const logger = (0, logging_js_1.credentialLogger)("AzureDeveloperCliCredential");
		/**
		 * Messages to use when throwing in this credential.
		 * @internal
		 */
		exports$1.azureDeveloperCliPublicErrorMessages = {
		    notInstalled: "Azure Developer CLI couldn't be found. To mitigate this issue, see the troubleshooting guidelines at https://aka.ms/azsdk/js/identity/azdevclicredential/troubleshoot.",
		    login: "Please run 'azd auth login' from a command prompt to authenticate before using this credential. For more information, see the troubleshooting guidelines at https://aka.ms/azsdk/js/identity/azdevclicredential/troubleshoot.",
		    unknown: "Unknown error while trying to retrieve the access token",
		    claim: "This credential doesn't support claims challenges. To authenticate with the required claims, please run the following command:",
		};
		/**
		 * Mockable reference to the Developer CLI credential cliCredentialFunctions
		 * @internal
		 */
		exports$1.developerCliCredentialInternals = {
		    /**
		     * @internal
		     */
		    getSafeWorkingDir() {
		        if (process.platform === "win32") {
		            let systemRoot = process.env.SystemRoot || process.env["SYSTEMROOT"];
		            if (!systemRoot) {
		                logger.getToken.warning("The SystemRoot environment variable is not set. This may cause issues when using the Azure Developer CLI credential.");
		                systemRoot = "C:\\Windows";
		            }
		            return systemRoot;
		        }
		        else {
		            return "/bin";
		        }
		    },
		    /**
		     * Gets the access token from Azure Developer CLI
		     * @param scopes - The scopes to use when getting the token
		     * @internal
		     */
		    async getAzdAccessToken(scopes, tenantId, timeout, claims) {
		        let tenantSection = [];
		        if (tenantId) {
		            tenantSection = ["--tenant-id", tenantId];
		        }
		        let claimsSections = [];
		        if (claims) {
		            const encodedClaims = btoa(claims);
		            claimsSections = ["--claims", encodedClaims];
		        }
		        return new Promise((resolve, reject) => {
		            try {
		                const args = [
		                    "auth",
		                    "token",
		                    "--output",
		                    "json",
		                    "--no-prompt",
		                    ...scopes.reduce((previous, current) => previous.concat("--scope", current), []),
		                    ...tenantSection,
		                    ...claimsSections,
		                ];
		                const command = ["azd", ...args].join(" ");
		                child_process_1.default.exec(command, {
		                    cwd: exports$1.developerCliCredentialInternals.getSafeWorkingDir(),
		                    timeout,
		                }, (error, stdout, stderr) => {
		                    resolve({ stdout, stderr, error });
		                });
		            }
		            catch (err) {
		                reject(err);
		            }
		        });
		    },
		};
		/**
		 * Azure Developer CLI is a command-line interface tool that allows developers to create, manage, and deploy
		 * resources in Azure. It's built on top of the Azure CLI and provides additional functionality specific
		 * to Azure developers. It allows users to authenticate as a user and/or a service principal against
		 * <a href="https://learn.microsoft.com/entra/fundamentals/">Microsoft Entra ID</a>. The
		 * AzureDeveloperCliCredential authenticates in a development environment and acquires a token on behalf of
		 * the logged-in user or service principal in the Azure Developer CLI. It acts as the Azure Developer CLI logged in user or
		 * service principal and executes an Azure CLI command underneath to authenticate the application against
		 * Microsoft Entra ID.
		 *
		 * <h2> Configure AzureDeveloperCliCredential </h2>
		 *
		 * To use this credential, the developer needs to authenticate locally in Azure Developer CLI using one of the
		 * commands below:
		 *
		 * <ol>
		 *     <li>Run "azd auth login" in Azure Developer CLI to authenticate interactively as a user.</li>
		 *     <li>Run "azd auth login --client-id clientID --client-secret clientSecret
		 *     --tenant-id tenantID" to authenticate as a service principal.</li>
		 * </ol>
		 *
		 * You may need to repeat this process after a certain time period, depending on the refresh token validity in your
		 * organization. Generally, the refresh token validity period is a few weeks to a few months.
		 * AzureDeveloperCliCredential will prompt you to sign in again.
		 */
		class AzureDeveloperCliCredential {
		    tenantId;
		    additionallyAllowedTenantIds;
		    timeout;
		    /**
		     * Creates an instance of the {@link AzureDeveloperCliCredential}.
		     *
		     * To use this credential, ensure that you have already logged
		     * in via the 'azd' tool using the command "azd auth login" from the commandline.
		     *
		     * @param options - Options, to optionally allow multi-tenant requests.
		     */
		    constructor(options) {
		        if (options?.tenantId) {
		            (0, tenantIdUtils_js_1.checkTenantId)(logger, options?.tenantId);
		            this.tenantId = options?.tenantId;
		        }
		        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
		        this.timeout = options?.processTimeoutInMs;
		    }
		    /**
		     * Authenticates with Microsoft Entra ID and returns an access token if successful.
		     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
		     *
		     * @param scopes - The list of scopes for which the token will have access.
		     * @param options - The options used to configure any requests this
		     *                TokenCredential implementation might make.
		     */
		    async getToken(scopes, options = {}) {
		        const tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, options, this.additionallyAllowedTenantIds);
		        if (tenantId) {
		            (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
		        }
		        let scopeList;
		        if (typeof scopes === "string") {
		            scopeList = [scopes];
		        }
		        else {
		            scopeList = scopes;
		        }
		        logger.getToken.info(`Using the scopes ${scopes}`);
		        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
		            try {
		                scopeList.forEach((scope) => {
		                    (0, scopeUtils_js_1.ensureValidScopeForDevTimeCreds)(scope, logger);
		                });
		                const obj = await exports$1.developerCliCredentialInternals.getAzdAccessToken(scopeList, tenantId, this.timeout, options.claims);
		                const isMFARequiredError = obj.stderr?.match("must use multi-factor authentication") ||
		                    obj.stderr?.match("reauthentication required");
		                const isNotLoggedInError = obj.stderr?.match("not logged in, run `azd login` to login") ||
		                    obj.stderr?.match("not logged in, run `azd auth login` to login");
		                const isNotInstallError = obj.stderr?.match("azd:(.*)not found") ||
		                    obj.stderr?.startsWith("'azd' is not recognized");
		                if (isNotInstallError || (obj.error && obj.error.code === "ENOENT")) {
		                    const error = new errors_js_1.CredentialUnavailableError(exports$1.azureDeveloperCliPublicErrorMessages.notInstalled);
		                    logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
		                    throw error;
		                }
		                if (isNotLoggedInError) {
		                    const error = new errors_js_1.CredentialUnavailableError(exports$1.azureDeveloperCliPublicErrorMessages.login);
		                    logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
		                    throw error;
		                }
		                if (isMFARequiredError) {
		                    const scope = scopeList
		                        .reduce((previous, current) => previous.concat("--scope", current), [])
		                        .join(" ");
		                    const loginCmd = `azd auth login ${scope}`;
		                    const error = new errors_js_1.CredentialUnavailableError(`${exports$1.azureDeveloperCliPublicErrorMessages.claim} ${loginCmd}`);
		                    logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
		                    throw error;
		                }
		                try {
		                    const resp = JSON.parse(obj.stdout);
		                    logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
		                    return {
		                        token: resp.token,
		                        expiresOnTimestamp: new Date(resp.expiresOn).getTime(),
		                        tokenType: "Bearer",
		                    };
		                }
		                catch (e) {
		                    if (obj.stderr) {
		                        throw new errors_js_1.CredentialUnavailableError(obj.stderr);
		                    }
		                    throw e;
		                }
		            }
		            catch (err) {
		                const error = err.name === "CredentialUnavailableError"
		                    ? err
		                    : new errors_js_1.CredentialUnavailableError(err.message || exports$1.azureDeveloperCliPublicErrorMessages.unknown);
		                logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
		                throw error;
		            }
		        });
		    }
		}
		exports$1.AzureDeveloperCliCredential = AzureDeveloperCliCredential;
		
	} (azureDeveloperCliCredential));
	return azureDeveloperCliCredential;
}

var azureCliCredential = {};

var subscriptionUtils = {};

var hasRequiredSubscriptionUtils;

function requireSubscriptionUtils () {
	if (hasRequiredSubscriptionUtils) return subscriptionUtils;
	hasRequiredSubscriptionUtils = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(subscriptionUtils, "__esModule", { value: true });
	subscriptionUtils.checkSubscription = checkSubscription;
	const logging_js_1 = requireLogging();
	/**
	 * @internal
	 */
	function checkSubscription(logger, subscription) {
	    if (!subscription.match(/^[0-9a-zA-Z-._ ]+$/)) {
	        const error = new Error(`Subscription '${subscription}' contains invalid characters. If this is the name of a subscription, use ` +
	            `its ID instead. You can locate your subscription by following the instructions listed here: ` +
	            `https://learn.microsoft.com/azure/azure-portal/get-subscription-tenant-id`);
	        logger.info((0, logging_js_1.formatError)("", error));
	        throw error;
	    }
	}
	
	return subscriptionUtils;
}

var hasRequiredAzureCliCredential;

function requireAzureCliCredential () {
	if (hasRequiredAzureCliCredential) return azureCliCredential;
	hasRequiredAzureCliCredential = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.AzureCliCredential = exports$1.cliCredentialInternals = exports$1.azureCliPublicErrorMessages = void 0;
		const tslib_1 = require$$0$3;
		const tenantIdUtils_js_1 = requireTenantIdUtils();
		const logging_js_1 = requireLogging();
		const scopeUtils_js_1 = requireScopeUtils();
		const errors_js_1 = requireErrors$2();
		const child_process_1 = tslib_1.__importDefault(require$$3$1);
		const tracing_js_1 = requireTracing();
		const subscriptionUtils_js_1 = requireSubscriptionUtils();
		const logger = (0, logging_js_1.credentialLogger)("AzureCliCredential");
		/**
		 * Messages to use when throwing in this credential.
		 * @internal
		 */
		exports$1.azureCliPublicErrorMessages = {
		    claim: "This credential doesn't support claims challenges. To authenticate with the required claims, please run the following command:",
		    notInstalled: "Azure CLI could not be found. Please visit https://aka.ms/azure-cli for installation instructions and then, once installed, authenticate to your Azure account using 'az login'.",
		    login: "Please run 'az login' from a command prompt to authenticate before using this credential.",
		    unknown: "Unknown error while trying to retrieve the access token",
		    unexpectedResponse: 'Unexpected response from Azure CLI when getting token. Expected "expiresOn" to be a RFC3339 date string. Got:',
		};
		/**
		 * Mockable reference to the CLI credential cliCredentialFunctions
		 * @internal
		 */
		exports$1.cliCredentialInternals = {
		    /**
		     * @internal
		     */
		    getSafeWorkingDir() {
		        if (process.platform === "win32") {
		            let systemRoot = process.env.SystemRoot || process.env["SYSTEMROOT"];
		            if (!systemRoot) {
		                logger.getToken.warning("The SystemRoot environment variable is not set. This may cause issues when using the Azure CLI credential.");
		                systemRoot = "C:\\Windows";
		            }
		            return systemRoot;
		        }
		        else {
		            return "/bin";
		        }
		    },
		    /**
		     * Gets the access token from Azure CLI
		     * @param resource - The resource to use when getting the token
		     * @internal
		     */
		    async getAzureCliAccessToken(resource, tenantId, subscription, timeout) {
		        let tenantSection = [];
		        let subscriptionSection = [];
		        if (tenantId) {
		            tenantSection = ["--tenant", tenantId];
		        }
		        if (subscription) {
		            // Add quotes around the subscription to handle subscriptions with spaces
		            subscriptionSection = ["--subscription", `"${subscription}"`];
		        }
		        return new Promise((resolve, reject) => {
		            try {
		                const args = [
		                    "account",
		                    "get-access-token",
		                    "--output",
		                    "json",
		                    "--resource",
		                    resource,
		                    ...tenantSection,
		                    ...subscriptionSection,
		                ];
		                const command = ["az", ...args].join(" ");
		                child_process_1.default.exec(command, { cwd: exports$1.cliCredentialInternals.getSafeWorkingDir(), timeout }, (error, stdout, stderr) => {
		                    resolve({ stdout: stdout, stderr: stderr, error });
		                });
		            }
		            catch (err) {
		                reject(err);
		            }
		        });
		    },
		};
		/**
		 * This credential will use the currently logged-in user login information
		 * via the Azure CLI ('az') commandline tool.
		 * To do so, it will read the user access token and expire time
		 * with Azure CLI command "az account get-access-token".
		 */
		class AzureCliCredential {
		    tenantId;
		    additionallyAllowedTenantIds;
		    timeout;
		    subscription;
		    /**
		     * Creates an instance of the {@link AzureCliCredential}.
		     *
		     * To use this credential, ensure that you have already logged
		     * in via the 'az' tool using the command "az login" from the commandline.
		     *
		     * @param options - Options, to optionally allow multi-tenant requests.
		     */
		    constructor(options) {
		        if (options?.tenantId) {
		            (0, tenantIdUtils_js_1.checkTenantId)(logger, options?.tenantId);
		            this.tenantId = options?.tenantId;
		        }
		        if (options?.subscription) {
		            (0, subscriptionUtils_js_1.checkSubscription)(logger, options?.subscription);
		            this.subscription = options?.subscription;
		        }
		        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
		        this.timeout = options?.processTimeoutInMs;
		    }
		    /**
		     * Authenticates with Microsoft Entra ID and returns an access token if successful.
		     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
		     *
		     * @param scopes - The list of scopes for which the token will have access.
		     * @param options - The options used to configure any requests this
		     *                TokenCredential implementation might make.
		     */
		    async getToken(scopes, options = {}) {
		        const scope = typeof scopes === "string" ? scopes : scopes[0];
		        const claimsValue = options.claims;
		        if (claimsValue && claimsValue.trim()) {
		            const encodedClaims = btoa(claimsValue);
		            let loginCmd = `az login --claims-challenge ${encodedClaims} --scope ${scope}`;
		            const tenantIdFromOptions = options.tenantId;
		            if (tenantIdFromOptions) {
		                loginCmd += ` --tenant ${tenantIdFromOptions}`;
		            }
		            const error = new errors_js_1.CredentialUnavailableError(`${exports$1.azureCliPublicErrorMessages.claim} ${loginCmd}`);
		            logger.getToken.info((0, logging_js_1.formatError)(scope, error));
		            throw error;
		        }
		        const tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, options, this.additionallyAllowedTenantIds);
		        if (tenantId) {
		            (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
		        }
		        if (this.subscription) {
		            (0, subscriptionUtils_js_1.checkSubscription)(logger, this.subscription);
		        }
		        logger.getToken.info(`Using the scope ${scope}`);
		        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
		            try {
		                (0, scopeUtils_js_1.ensureValidScopeForDevTimeCreds)(scope, logger);
		                const resource = (0, scopeUtils_js_1.getScopeResource)(scope);
		                const obj = await exports$1.cliCredentialInternals.getAzureCliAccessToken(resource, tenantId, this.subscription, this.timeout);
		                const specificScope = obj.stderr?.match("(.*)az login --scope(.*)");
		                const isLoginError = obj.stderr?.match("(.*)az login(.*)") && !specificScope;
		                const isNotInstallError = obj.stderr?.match("az:(.*)not found") || obj.stderr?.startsWith("'az' is not recognized");
		                if (isNotInstallError) {
		                    const error = new errors_js_1.CredentialUnavailableError(exports$1.azureCliPublicErrorMessages.notInstalled);
		                    logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
		                    throw error;
		                }
		                if (isLoginError) {
		                    const error = new errors_js_1.CredentialUnavailableError(exports$1.azureCliPublicErrorMessages.login);
		                    logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
		                    throw error;
		                }
		                try {
		                    const responseData = obj.stdout;
		                    const response = this.parseRawResponse(responseData);
		                    logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
		                    return response;
		                }
		                catch (e) {
		                    if (obj.stderr) {
		                        throw new errors_js_1.CredentialUnavailableError(obj.stderr);
		                    }
		                    throw e;
		                }
		            }
		            catch (err) {
		                const error = err.name === "CredentialUnavailableError"
		                    ? err
		                    : new errors_js_1.CredentialUnavailableError(err.message || exports$1.azureCliPublicErrorMessages.unknown);
		                logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
		                throw error;
		            }
		        });
		    }
		    /**
		     * Parses the raw JSON response from the Azure CLI into a usable AccessToken object
		     *
		     * @param rawResponse - The raw JSON response from the Azure CLI
		     * @returns An access token with the expiry time parsed from the raw response
		     *
		     * The expiryTime of the credential's access token, in milliseconds, is calculated as follows:
		     *
		     * When available, expires_on (introduced in Azure CLI v2.54.0) will be preferred. Otherwise falls back to expiresOn.
		     */
		    parseRawResponse(rawResponse) {
		        const response = JSON.parse(rawResponse);
		        const token = response.accessToken;
		        // if available, expires_on will be a number representing seconds since epoch.
		        // ensure it's a number or NaN
		        let expiresOnTimestamp = Number.parseInt(response.expires_on, 10) * 1000;
		        if (!isNaN(expiresOnTimestamp)) {
		            logger.getToken.info("expires_on is available and is valid, using it");
		            return {
		                token,
		                expiresOnTimestamp,
		                tokenType: "Bearer",
		            };
		        }
		        // fallback to the older expiresOn - an RFC3339 date string
		        expiresOnTimestamp = new Date(response.expiresOn).getTime();
		        // ensure expiresOn is well-formatted
		        if (isNaN(expiresOnTimestamp)) {
		            throw new errors_js_1.CredentialUnavailableError(`${exports$1.azureCliPublicErrorMessages.unexpectedResponse} "${response.expiresOn}"`);
		        }
		        return {
		            token,
		            expiresOnTimestamp,
		            tokenType: "Bearer",
		        };
		    }
		}
		exports$1.AzureCliCredential = AzureCliCredential;
		
	} (azureCliCredential));
	return azureCliCredential;
}

var azurePowerShellCredential = {};

var processUtils = {};

const require$2 = createRequire(import.meta.url);
function __require$1() { return require$2("node:child_process"); }

var hasRequiredProcessUtils;

function requireProcessUtils () {
	if (hasRequiredProcessUtils) return processUtils;
	hasRequiredProcessUtils = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(processUtils, "__esModule", { value: true });
	processUtils.processUtils = void 0;
	const tslib_1 = require$$0$3;
	const node_child_process_1 = tslib_1.__importDefault(__require$1());
	/**
	 * Easy to mock childProcess utils.
	 * @internal
	 */
	processUtils.processUtils = {
	    /**
	     * Promisifying childProcess.execFile
	     * @internal
	     */
	    execFile(file, params, options) {
	        return new Promise((resolve, reject) => {
	            node_child_process_1.default.execFile(file, params, options, (error, stdout, stderr) => {
	                if (Buffer.isBuffer(stdout)) {
	                    stdout = stdout.toString("utf8");
	                }
	                if (Buffer.isBuffer(stderr)) {
	                    stderr = stderr.toString("utf8");
	                }
	                if (stderr || error) {
	                    reject(stderr ? new Error(stderr) : error);
	                }
	                else {
	                    resolve(stdout);
	                }
	            });
	        });
	    },
	};
	
	return processUtils;
}

var hasRequiredAzurePowerShellCredential;

function requireAzurePowerShellCredential () {
	if (hasRequiredAzurePowerShellCredential) return azurePowerShellCredential;
	hasRequiredAzurePowerShellCredential = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.AzurePowerShellCredential = exports$1.commandStack = exports$1.powerShellPublicErrorMessages = exports$1.powerShellErrors = void 0;
		exports$1.formatCommand = formatCommand;
		exports$1.parseJsonToken = parseJsonToken;
		const tenantIdUtils_js_1 = requireTenantIdUtils();
		const logging_js_1 = requireLogging();
		const scopeUtils_js_1 = requireScopeUtils();
		const errors_js_1 = requireErrors$2();
		const processUtils_js_1 = requireProcessUtils();
		const tracing_js_1 = requireTracing();
		const logger = (0, logging_js_1.credentialLogger)("AzurePowerShellCredential");
		const isWindows = process.platform === "win32";
		/**
		 * Returns a platform-appropriate command name by appending ".exe" on Windows.
		 *
		 * @internal
		 */
		function formatCommand(commandName) {
		    if (isWindows) {
		        return `${commandName}.exe`;
		    }
		    else {
		        return commandName;
		    }
		}
		/**
		 * Receives a list of commands to run, executes them, then returns the outputs.
		 * If anything fails, an error is thrown.
		 * @internal
		 */
		async function runCommands(commands, timeout) {
		    const results = [];
		    for (const command of commands) {
		        const [file, ...parameters] = command;
		        const result = (await processUtils_js_1.processUtils.execFile(file, parameters, {
		            encoding: "utf8",
		            timeout,
		        }));
		        results.push(result);
		    }
		    return results;
		}
		/**
		 * Known PowerShell errors
		 * @internal
		 */
		exports$1.powerShellErrors = {
		    login: "Run Connect-AzAccount to login",
		    installed: "The specified module 'Az.Accounts' with version '2.2.0' was not loaded because no valid module file was found in any module directory",
		};
		/**
		 * Messages to use when throwing in this credential.
		 * @internal
		 */
		exports$1.powerShellPublicErrorMessages = {
		    login: "Please run 'Connect-AzAccount' from PowerShell to authenticate before using this credential.",
		    installed: `The 'Az.Account' module >= 2.2.0 is not installed. Install the Azure Az PowerShell module with: "Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force".`,
		    claim: "This credential doesn't support claims challenges. To authenticate with the required claims, please run the following command:",
		    troubleshoot: `To troubleshoot, visit https://aka.ms/azsdk/js/identity/powershellcredential/troubleshoot.`,
		};
		// PowerShell Azure User not logged in error check.
		const isLoginError = (err) => err.message.match(`(.*)${exports$1.powerShellErrors.login}(.*)`);
		// Az Module not Installed in Azure PowerShell check.
		const isNotInstalledError = (err) => err.message.match(exports$1.powerShellErrors.installed);
		/**
		 * The PowerShell commands to be tried, in order.
		 *
		 * @internal
		 */
		exports$1.commandStack = [formatCommand("pwsh")];
		if (isWindows) {
		    exports$1.commandStack.push(formatCommand("powershell"));
		}
		/**
		 * This credential will use the currently logged-in user information from the
		 * Azure PowerShell module. To do so, it will read the user access token and
		 * expire time with Azure PowerShell command `Get-AzAccessToken -ResourceUrl {ResourceScope}`
		 */
		class AzurePowerShellCredential {
		    tenantId;
		    additionallyAllowedTenantIds;
		    timeout;
		    /**
		     * Creates an instance of the {@link AzurePowerShellCredential}.
		     *
		     * To use this credential:
		     * - Install the Azure Az PowerShell module with:
		     *   `Install-Module -Name Az -Scope CurrentUser -Repository PSGallery -Force`.
		     * - You have already logged in to Azure PowerShell using the command
		     * `Connect-AzAccount` from the command line.
		     *
		     * @param options - Options, to optionally allow multi-tenant requests.
		     */
		    constructor(options) {
		        if (options?.tenantId) {
		            (0, tenantIdUtils_js_1.checkTenantId)(logger, options?.tenantId);
		            this.tenantId = options?.tenantId;
		        }
		        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
		        this.timeout = options?.processTimeoutInMs;
		    }
		    /**
		     * Gets the access token from Azure PowerShell
		     * @param resource - The resource to use when getting the token
		     */
		    async getAzurePowerShellAccessToken(resource, tenantId, timeout) {
		        // Clone the stack to avoid mutating it while iterating
		        for (const powerShellCommand of [...exports$1.commandStack]) {
		            try {
		                await runCommands([[powerShellCommand, "/?"]], timeout);
		            }
		            catch (e) {
		                // Remove this credential from the original stack so that we don't try it again.
		                exports$1.commandStack.shift();
		                continue;
		            }
		            const results = await runCommands([
		                [
		                    powerShellCommand,
		                    "-NoProfile",
		                    "-NonInteractive",
		                    "-Command",
		                    `
          $tenantId = "${tenantId ?? ""}"
          $m = Import-Module Az.Accounts -MinimumVersion 2.2.0 -PassThru
          $useSecureString = $m.Version -ge [version]'2.17.0' -and $m.Version -lt [version]'5.0.0'

          $params = @{
            ResourceUrl = "${resource}"
          }

          if ($tenantId.Length -gt 0) {
            $params["TenantId"] = $tenantId
          }

          if ($useSecureString) {
            $params["AsSecureString"] = $true
          }

          $token = Get-AzAccessToken @params

          $result = New-Object -TypeName PSObject
          $result | Add-Member -MemberType NoteProperty -Name ExpiresOn -Value $token.ExpiresOn

          if ($token.Token -is [System.Security.SecureString]) {
            if ($PSVersionTable.PSVersion.Major -lt 7) {
              $ssPtr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($token.Token)
              try {
                $result | Add-Member -MemberType NoteProperty -Name Token -Value ([System.Runtime.InteropServices.Marshal]::PtrToStringBSTR($ssPtr))
              }
              finally {
                [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($ssPtr)
              }
            }
            else {
              $result | Add-Member -MemberType NoteProperty -Name Token -Value ($token.Token | ConvertFrom-SecureString -AsPlainText)
            }
          }
          else {
            $result | Add-Member -MemberType NoteProperty -Name Token -Value $token.Token
          }

          Write-Output (ConvertTo-Json $result)
          `,
		                ],
		            ]);
		            const result = results[0];
		            return parseJsonToken(result);
		        }
		        throw new Error(`Unable to execute PowerShell. Ensure that it is installed in your system`);
		    }
		    /**
		     * Authenticates with Microsoft Entra ID and returns an access token if successful.
		     * If the authentication cannot be performed through PowerShell, a {@link CredentialUnavailableError} will be thrown.
		     *
		     * @param scopes - The list of scopes for which the token will have access.
		     * @param options - The options used to configure any requests this TokenCredential implementation might make.
		     */
		    async getToken(scopes, options = {}) {
		        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async () => {
		            const scope = typeof scopes === "string" ? scopes : scopes[0];
		            const claimsValue = options.claims;
		            if (claimsValue && claimsValue.trim()) {
		                const encodedClaims = btoa(claimsValue);
		                let loginCmd = `Connect-AzAccount -ClaimsChallenge ${encodedClaims}`;
		                const tenantIdFromOptions = options.tenantId;
		                if (tenantIdFromOptions) {
		                    loginCmd += ` -Tenant ${tenantIdFromOptions}`;
		                }
		                const error = new errors_js_1.CredentialUnavailableError(`${exports$1.powerShellPublicErrorMessages.claim} ${loginCmd}`);
		                logger.getToken.info((0, logging_js_1.formatError)(scope, error));
		                throw error;
		            }
		            const tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, options, this.additionallyAllowedTenantIds);
		            if (tenantId) {
		                (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
		            }
		            try {
		                (0, scopeUtils_js_1.ensureValidScopeForDevTimeCreds)(scope, logger);
		                logger.getToken.info(`Using the scope ${scope}`);
		                const resource = (0, scopeUtils_js_1.getScopeResource)(scope);
		                const response = await this.getAzurePowerShellAccessToken(resource, tenantId, this.timeout);
		                logger.getToken.info((0, logging_js_1.formatSuccess)(scopes));
		                return {
		                    token: response.Token,
		                    expiresOnTimestamp: new Date(response.ExpiresOn).getTime(),
		                    tokenType: "Bearer",
		                };
		            }
		            catch (err) {
		                if (isNotInstalledError(err)) {
		                    const error = new errors_js_1.CredentialUnavailableError(exports$1.powerShellPublicErrorMessages.installed);
		                    logger.getToken.info((0, logging_js_1.formatError)(scope, error));
		                    throw error;
		                }
		                else if (isLoginError(err)) {
		                    const error = new errors_js_1.CredentialUnavailableError(exports$1.powerShellPublicErrorMessages.login);
		                    logger.getToken.info((0, logging_js_1.formatError)(scope, error));
		                    throw error;
		                }
		                const error = new errors_js_1.CredentialUnavailableError(`${err}. ${exports$1.powerShellPublicErrorMessages.troubleshoot}`);
		                logger.getToken.info((0, logging_js_1.formatError)(scope, error));
		                throw error;
		            }
		        });
		    }
		}
		exports$1.AzurePowerShellCredential = AzurePowerShellCredential;
		/**
		 *
		 * @internal
		 */
		async function parseJsonToken(result) {
		    const jsonRegex = /{[^{}]*}/g;
		    const matches = result.match(jsonRegex);
		    let resultWithoutToken = result;
		    if (matches) {
		        try {
		            for (const item of matches) {
		                try {
		                    const jsonContent = JSON.parse(item);
		                    if (jsonContent?.Token) {
		                        resultWithoutToken = resultWithoutToken.replace(item, "");
		                        if (resultWithoutToken) {
		                            logger.getToken.warning(resultWithoutToken);
		                        }
		                        return jsonContent;
		                    }
		                }
		                catch (e) {
		                    continue;
		                }
		            }
		        }
		        catch (e) {
		            throw new Error(`Unable to parse the output of PowerShell. Received output: ${result}`);
		        }
		    }
		    throw new Error(`No access token found in the output. Received output: ${result}`);
		}
		
	} (azurePowerShellCredential));
	return azurePowerShellCredential;
}

var visualStudioCodeCredential = {};

var hasRequiredVisualStudioCodeCredential;

function requireVisualStudioCodeCredential () {
	if (hasRequiredVisualStudioCodeCredential) return visualStudioCodeCredential;
	hasRequiredVisualStudioCodeCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(visualStudioCodeCredential, "__esModule", { value: true });
	visualStudioCodeCredential.VisualStudioCodeCredential = void 0;
	const logging_js_1 = requireLogging();
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const errors_js_1 = requireErrors$2();
	const tenantIdUtils_js_2 = requireTenantIdUtils();
	const msalClient_js_1 = requireMsalClient();
	const scopeUtils_js_1 = requireScopeUtils();
	const msalPlugins_js_1 = requireMsalPlugins();
	const utils_js_1 = requireUtils$3();
	const promises_1 = __require$2();
	const CommonTenantId = "common";
	const VSCodeClientId = "aebc6443-996d-45c2-90f0-388ff96faa56";
	const logger = (0, logging_js_1.credentialLogger)("VisualStudioCodeCredential");
	// Map of unsupported Tenant IDs and the errors we will be throwing.
	const unsupportedTenantIds = {
	    adfs: "The VisualStudioCodeCredential does not support authentication with ADFS tenants.",
	};
	function checkUnsupportedTenant(tenantId) {
	    // If the Tenant ID isn't supported, we throw.
	    const unsupportedTenantError = unsupportedTenantIds[tenantId];
	    if (unsupportedTenantError) {
	        throw new errors_js_1.CredentialUnavailableError(unsupportedTenantError);
	    }
	}
	/**
	 * Connects to Azure using the user account signed in through the Azure Resources extension in Visual Studio Code.
	 * Once the user has logged in via the extension, this credential can share the same refresh token
	 * that is cached by the extension.
	 */
	class VisualStudioCodeCredential {
	    tenantId;
	    additionallyAllowedTenantIds;
	    msalClient;
	    options;
	    /**
	     * Creates an instance of VisualStudioCodeCredential to use for automatically authenticating via VSCode.
	     *
	     * **Note**: `VisualStudioCodeCredential` is provided by a plugin package:
	     * `@azure/identity-vscode`. If this package is not installed, then authentication using
	     * `VisualStudioCodeCredential` will not be available.
	     *
	     * @param options - Options for configuring the client which makes the authentication request.
	     */
	    constructor(options) {
	        this.options = options || {};
	        if (options && options.tenantId) {
	            (0, tenantIdUtils_js_2.checkTenantId)(logger, options.tenantId);
	            this.tenantId = options.tenantId;
	        }
	        else {
	            this.tenantId = CommonTenantId;
	        }
	        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
	        checkUnsupportedTenant(this.tenantId);
	    }
	    /**
	     * Runs preparations for any further getToken request:
	     *   - Validates that the plugin is available.
	     *   - Loads the authentication record from VSCode if available.
	     *   - Creates the MSAL client with the loaded plugin and authentication record.
	     */
	    async prepare(scopes) {
	        const tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, this.options, this.additionallyAllowedTenantIds, logger) || this.tenantId;
	        if (!(0, msalPlugins_js_1.hasVSCodePlugin)() || !msalPlugins_js_1.vsCodeAuthRecordPath) {
	            throw new errors_js_1.CredentialUnavailableError("Visual Studio Code Authentication is not available." +
	                " Ensure you have have Azure Resources Extension installed in VS Code," +
	                " signed into Azure via VS Code, installed the @azure/identity-vscode package," +
	                " and properly configured the extension.");
	        }
	        // Load the authentication record directly from the path
	        const authenticationRecord = await this.loadAuthRecord(msalPlugins_js_1.vsCodeAuthRecordPath, scopes);
	        this.msalClient = (0, msalClient_js_1.createMsalClient)(VSCodeClientId, tenantId, {
	            ...this.options,
	            isVSCodeCredential: true,
	            brokerOptions: {
	                enabled: true,
	                parentWindowHandle: new Uint8Array(0),
	                useDefaultBrokerAccount: true,
	            },
	            authenticationRecord,
	        });
	    }
	    /**
	     * The promise of the single preparation that will be executed at the first getToken request for an instance of this class.
	     */
	    preparePromise;
	    /**
	     * Runs preparations for any further getToken, but only once.
	     */
	    prepareOnce(scopes) {
	        if (!this.preparePromise) {
	            this.preparePromise = this.prepare(scopes);
	        }
	        return this.preparePromise;
	    }
	    /**
	     * Returns the token found by searching VSCode's authentication cache or
	     * returns null if no token could be found.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                `TokenCredential` implementation might make.
	     */
	    async getToken(scopes, options) {
	        // Load the plugin and authentication record only once
	        const scopeArray = (0, scopeUtils_js_1.ensureScopes)(scopes);
	        await this.prepareOnce(scopeArray);
	        if (!this.msalClient) {
	            throw new errors_js_1.CredentialUnavailableError("Visual Studio Code Authentication failed to initialize." +
	                " Ensure you have have Azure Resources Extension installed in VS Code," +
	                " signed into Azure via VS Code, installed the @azure/identity-vscode package," +
	                " and properly configured the extension.");
	        }
	        // Disable automatic authentication to ensure that the user is not prompted interactively if no token is available
	        return this.msalClient.getTokenByInteractiveRequest(scopeArray, {
	            ...options,
	            disableAutomaticAuthentication: true,
	        });
	    }
	    /**
	     * Loads the authentication record from the specified path.
	     * @param authRecordPath - The path to the authentication record file.
	     * @param scopes - The list of scopes for which the token will have access.
	     * @returns The authentication record or undefined if loading fails.
	     */
	    async loadAuthRecord(authRecordPath, scopes) {
	        try {
	            const authRecordContent = await (0, promises_1.readFile)(authRecordPath, { encoding: "utf8" });
	            return (0, utils_js_1.deserializeAuthenticationRecord)(authRecordContent);
	        }
	        catch (error) {
	            logger.getToken.info((0, logging_js_1.formatError)(scopes, error));
	            throw new errors_js_1.CredentialUnavailableError("Cannot load authentication record in Visual Studio Code." +
	                " Ensure you have have Azure Resources Extension installed in VS Code," +
	                " signed into Azure via VS Code, installed the @azure/identity-vscode package," +
	                " and properly configured the extension.");
	        }
	    }
	}
	visualStudioCodeCredential.VisualStudioCodeCredential = VisualStudioCodeCredential;
	
	return visualStudioCodeCredential;
}

var brokerCredential = {};

var hasRequiredBrokerCredential;

function requireBrokerCredential () {
	if (hasRequiredBrokerCredential) return brokerCredential;
	hasRequiredBrokerCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(brokerCredential, "__esModule", { value: true });
	brokerCredential.BrokerCredential = void 0;
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const logging_js_1 = requireLogging();
	const scopeUtils_js_1 = requireScopeUtils();
	const tracing_js_1 = requireTracing();
	const msalClient_js_1 = requireMsalClient();
	const constants_js_1 = requireConstants$3();
	const errors_js_1 = requireErrors$2();
	const logger = (0, logging_js_1.credentialLogger)("BrokerCredential");
	/**
	 * Enables authentication to Microsoft Entra ID using WAM (Web Account Manager) broker.
	 * This credential uses the default account logged into the OS via a broker.
	 */
	class BrokerCredential {
	    brokerMsalClient;
	    brokerTenantId;
	    brokerAdditionallyAllowedTenantIds;
	    /**
	     * Creates an instance of BrokerCredential with the required broker options.
	     *
	     * This credential uses WAM (Web Account Manager) for authentication, which provides
	     * better security and user experience on Windows platforms.
	     *
	     * @param options - Options for configuring the broker credential, including required broker options.
	     */
	    constructor(options) {
	        this.brokerTenantId = (0, tenantIdUtils_js_1.resolveTenantId)(logger, options.tenantId);
	        this.brokerAdditionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
	        const msalClientOptions = {
	            ...options,
	            tokenCredentialOptions: options,
	            logger,
	            brokerOptions: {
	                enabled: true,
	                parentWindowHandle: new Uint8Array(0),
	                useDefaultBrokerAccount: true,
	            },
	        };
	        this.brokerMsalClient = (0, msalClient_js_1.createMsalClient)(constants_js_1.DeveloperSignOnClientId, this.brokerTenantId, msalClientOptions);
	    }
	    /**
	     * Authenticates with Microsoft Entra ID using WAM broker and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * This method extends the base getToken method to support silentAuthenticationOnly option
	     * when using broker authentication.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure the token request, including silentAuthenticationOnly option.
	     */
	    async getToken(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
	            newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.brokerTenantId, newOptions, this.brokerAdditionallyAllowedTenantIds, logger);
	            const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
	            try {
	                return this.brokerMsalClient.getBrokeredToken(arrayScopes, true, {
	                    ...newOptions,
	                    disableAutomaticAuthentication: true,
	                });
	            }
	            catch (e) {
	                logger.getToken.info((0, logging_js_1.formatError)(arrayScopes, e));
	                throw new errors_js_1.CredentialUnavailableError("Failed to acquire token using broker authentication", { cause: e });
	            }
	        });
	    }
	}
	brokerCredential.BrokerCredential = BrokerCredential;
	
	return brokerCredential;
}

var hasRequiredDefaultAzureCredentialFunctions;

function requireDefaultAzureCredentialFunctions () {
	if (hasRequiredDefaultAzureCredentialFunctions) return defaultAzureCredentialFunctions;
	hasRequiredDefaultAzureCredentialFunctions = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(defaultAzureCredentialFunctions, "__esModule", { value: true });
	defaultAzureCredentialFunctions.createDefaultBrokerCredential = createDefaultBrokerCredential;
	defaultAzureCredentialFunctions.createDefaultVisualStudioCodeCredential = createDefaultVisualStudioCodeCredential;
	defaultAzureCredentialFunctions.createDefaultManagedIdentityCredential = createDefaultManagedIdentityCredential;
	defaultAzureCredentialFunctions.createDefaultWorkloadIdentityCredential = createDefaultWorkloadIdentityCredential;
	defaultAzureCredentialFunctions.createDefaultAzureDeveloperCliCredential = createDefaultAzureDeveloperCliCredential;
	defaultAzureCredentialFunctions.createDefaultAzureCliCredential = createDefaultAzureCliCredential;
	defaultAzureCredentialFunctions.createDefaultAzurePowershellCredential = createDefaultAzurePowershellCredential;
	defaultAzureCredentialFunctions.createDefaultEnvironmentCredential = createDefaultEnvironmentCredential;
	const environmentCredential_js_1 = requireEnvironmentCredential();
	const index_js_1 = requireManagedIdentityCredential();
	const workloadIdentityCredential_js_1 = requireWorkloadIdentityCredential();
	const azureDeveloperCliCredential_js_1 = requireAzureDeveloperCliCredential();
	const azureCliCredential_js_1 = requireAzureCliCredential();
	const azurePowerShellCredential_js_1 = requireAzurePowerShellCredential();
	const visualStudioCodeCredential_js_1 = requireVisualStudioCodeCredential();
	const brokerCredential_js_1 = requireBrokerCredential();
	/**
	 * Creates a {@link BrokerCredential} instance with the provided options.
	 * This credential uses the Windows Authentication Manager (WAM) broker for authentication.
	 * It will only attempt to authenticate silently using the default broker account
	 *
	 * @param options - Options for configuring the credential.
	 *
	 * @internal
	 */
	function createDefaultBrokerCredential(options = {}) {
	    return new brokerCredential_js_1.BrokerCredential(options);
	}
	/**
	 * Creates a {@link VisualStudioCodeCredential} from the provided options.
	 * @param options - Options to configure the credential.
	 *
	 * @internal
	 */
	function createDefaultVisualStudioCodeCredential(options = {}) {
	    return new visualStudioCodeCredential_js_1.VisualStudioCodeCredential(options);
	}
	/**
	 * Creates a {@link ManagedIdentityCredential} from the provided options.
	 * @param options - Options to configure the credential.
	 *
	 * @internal
	 */
	function createDefaultManagedIdentityCredential(options = {}) {
	    options.retryOptions ??= {
	        maxRetries: 5,
	        retryDelayInMs: 800,
	    };
	    // ManagedIdentityCredential inside DAC chain should send a probe request by default.
	    // This is different from standalone ManagedIdentityCredential behavior
	    // or when AZURE_TOKEN_CREDENTIALS is set to only ManagedIdentityCredential.
	    options.sendProbeRequest ??= true;
	    const managedIdentityClientId = options?.managedIdentityClientId ??
	        process.env.AZURE_CLIENT_ID;
	    const workloadIdentityClientId = options?.workloadIdentityClientId ??
	        managedIdentityClientId;
	    const managedResourceId = options
	        ?.managedIdentityResourceId;
	    const workloadFile = process.env.AZURE_FEDERATED_TOKEN_FILE;
	    const tenantId = options?.tenantId ?? process.env.AZURE_TENANT_ID;
	    if (managedResourceId) {
	        const managedIdentityResourceIdOptions = {
	            ...options,
	            resourceId: managedResourceId,
	        };
	        return new index_js_1.ManagedIdentityCredential(managedIdentityResourceIdOptions);
	    }
	    if (workloadFile && workloadIdentityClientId) {
	        const workloadIdentityCredentialOptions = {
	            ...options,
	            tenantId: tenantId,
	        };
	        return new index_js_1.ManagedIdentityCredential(workloadIdentityClientId, workloadIdentityCredentialOptions);
	    }
	    if (managedIdentityClientId) {
	        const managedIdentityClientOptions = {
	            ...options,
	            clientId: managedIdentityClientId,
	        };
	        return new index_js_1.ManagedIdentityCredential(managedIdentityClientOptions);
	    }
	    // We may be able to return a UnavailableCredential here, but that may be a breaking change
	    return new index_js_1.ManagedIdentityCredential(options);
	}
	/**
	 * Creates a {@link WorkloadIdentityCredential} from the provided options.
	 * @param options - Options to configure the credential.
	 *
	 * @internal
	 */
	function createDefaultWorkloadIdentityCredential(options) {
	    const managedIdentityClientId = options?.managedIdentityClientId ??
	        process.env.AZURE_CLIENT_ID;
	    const workloadIdentityClientId = options?.workloadIdentityClientId ??
	        managedIdentityClientId;
	    const workloadFile = process.env.AZURE_FEDERATED_TOKEN_FILE;
	    const tenantId = options?.tenantId ?? process.env.AZURE_TENANT_ID;
	    if (workloadFile && workloadIdentityClientId) {
	        const workloadIdentityCredentialOptions = {
	            ...options,
	            tenantId,
	            clientId: workloadIdentityClientId,
	            tokenFilePath: workloadFile,
	        };
	        return new workloadIdentityCredential_js_1.WorkloadIdentityCredential(workloadIdentityCredentialOptions);
	    }
	    if (tenantId) {
	        const workloadIdentityClientTenantOptions = {
	            ...options,
	            tenantId,
	        };
	        return new workloadIdentityCredential_js_1.WorkloadIdentityCredential(workloadIdentityClientTenantOptions);
	    }
	    // We may be able to return a UnavailableCredential here, but that may be a breaking change
	    return new workloadIdentityCredential_js_1.WorkloadIdentityCredential(options);
	}
	/**
	 * Creates a {@link AzureDeveloperCliCredential} from the provided options.
	 * @param options - Options to configure the credential.
	 *
	 * @internal
	 */
	function createDefaultAzureDeveloperCliCredential(options = {}) {
	    return new azureDeveloperCliCredential_js_1.AzureDeveloperCliCredential(options);
	}
	/**
	 * Creates a {@link AzureCliCredential} from the provided options.
	 * @param options - Options to configure the credential.
	 *
	 * @internal
	 */
	function createDefaultAzureCliCredential(options = {}) {
	    return new azureCliCredential_js_1.AzureCliCredential(options);
	}
	/**
	 * Creates a {@link AzurePowerShellCredential} from the provided options.
	 * @param options - Options to configure the credential.
	 *
	 * @internal
	 */
	function createDefaultAzurePowershellCredential(options = {}) {
	    return new azurePowerShellCredential_js_1.AzurePowerShellCredential(options);
	}
	/**
	 * Creates an {@link EnvironmentCredential} from the provided options.
	 * @param options - Options to configure the credential.
	 *
	 * @internal
	 */
	function createDefaultEnvironmentCredential(options = {}) {
	    return new environmentCredential_js_1.EnvironmentCredential(options);
	}
	
	return defaultAzureCredentialFunctions;
}

var hasRequiredDefaultAzureCredential;

function requireDefaultAzureCredential () {
	if (hasRequiredDefaultAzureCredential) return defaultAzureCredential;
	hasRequiredDefaultAzureCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(defaultAzureCredential, "__esModule", { value: true });
	defaultAzureCredential.DefaultAzureCredential = defaultAzureCredential.UnavailableDefaultCredential = void 0;
	const chainedTokenCredential_js_1 = requireChainedTokenCredential();
	const logging_js_1 = requireLogging();
	const defaultAzureCredentialFunctions_js_1 = requireDefaultAzureCredentialFunctions();
	const logger = (0, logging_js_1.credentialLogger)("DefaultAzureCredential");
	/**
	 * A no-op credential that logs the reason it was skipped if getToken is called.
	 * @internal
	 */
	class UnavailableDefaultCredential {
	    credentialUnavailableErrorMessage;
	    credentialName;
	    constructor(credentialName, message) {
	        this.credentialName = credentialName;
	        this.credentialUnavailableErrorMessage = message;
	    }
	    getToken() {
	        logger.getToken.info(`Skipping ${this.credentialName}, reason: ${this.credentialUnavailableErrorMessage}`);
	        return Promise.resolve(null);
	    }
	}
	defaultAzureCredential.UnavailableDefaultCredential = UnavailableDefaultCredential;
	/**
	 * Provides a default {@link ChainedTokenCredential} configuration that works for most
	 * applications that use Azure SDK client libraries. For more information, see
	 * [DefaultAzureCredential overview](https://aka.ms/azsdk/js/identity/credential-chains#use-defaultazurecredential-for-flexibility).
	 *
	 * The following credential types will be tried, in order:
	 *
	 * - {@link EnvironmentCredential}
	 * - {@link WorkloadIdentityCredential}
	 * - {@link ManagedIdentityCredential}
	 * - {@link VisualStudioCodeCredential}
	 * - {@link AzureCliCredential}
	 * - {@link AzurePowerShellCredential}
	 * - {@link AzureDeveloperCliCredential}
	 * - BrokerCredential (a broker-enabled credential that requires \@azure/identity-broker is installed)
	 *
	 * Consult the documentation of these credential types for more information
	 * on how they attempt authentication.
	 *
	 * The following example demonstrates how to use the `requiredEnvVars` option to ensure that certain environment variables are set before the `DefaultAzureCredential` is instantiated.
	 * If any of the specified environment variables are missing or empty, an error will be thrown, preventing the application from continuing execution without the necessary configuration.
	 * It also demonstrates how to set the `AZURE_TOKEN_CREDENTIALS` environment variable to control which credentials are included in the chain.
	 
	 * ```ts snippet:defaultazurecredential_requiredEnvVars
	 * import { DefaultAzureCredential } from "@azure/identity";
	 *
	 * const credential = new DefaultAzureCredential({
	 *   requiredEnvVars: [
	 *     "AZURE_CLIENT_ID",
	 *     "AZURE_TENANT_ID",
	 *     "AZURE_CLIENT_SECRET",
	 *     "AZURE_TOKEN_CREDENTIALS",
	 *   ],
	 * });
	 * ```
	 */
	class DefaultAzureCredential extends chainedTokenCredential_js_1.ChainedTokenCredential {
	    constructor(options) {
	        validateRequiredEnvVars(options);
	        // If AZURE_TOKEN_CREDENTIALS is not set, use the default credential chain.
	        const azureTokenCredentials = process.env.AZURE_TOKEN_CREDENTIALS
	            ? process.env.AZURE_TOKEN_CREDENTIALS.trim().toLowerCase()
	            : undefined;
	        const devCredentialFunctions = [
	            defaultAzureCredentialFunctions_js_1.createDefaultVisualStudioCodeCredential,
	            defaultAzureCredentialFunctions_js_1.createDefaultAzureCliCredential,
	            defaultAzureCredentialFunctions_js_1.createDefaultAzurePowershellCredential,
	            defaultAzureCredentialFunctions_js_1.createDefaultAzureDeveloperCliCredential,
	            defaultAzureCredentialFunctions_js_1.createDefaultBrokerCredential,
	        ];
	        const prodCredentialFunctions = [
	            defaultAzureCredentialFunctions_js_1.createDefaultEnvironmentCredential,
	            defaultAzureCredentialFunctions_js_1.createDefaultWorkloadIdentityCredential,
	            defaultAzureCredentialFunctions_js_1.createDefaultManagedIdentityCredential,
	        ];
	        let credentialFunctions = [];
	        const validCredentialNames = "EnvironmentCredential, WorkloadIdentityCredential, ManagedIdentityCredential, VisualStudioCodeCredential, AzureCliCredential, AzurePowerShellCredential, AzureDeveloperCliCredential";
	        // If AZURE_TOKEN_CREDENTIALS is set, use it to determine which credentials to use.
	        // The value of AZURE_TOKEN_CREDENTIALS should be either "dev" or "prod" or any one of these credentials - {validCredentialNames}.
	        if (azureTokenCredentials) {
	            switch (azureTokenCredentials) {
	                case "dev":
	                    credentialFunctions = devCredentialFunctions;
	                    break;
	                case "prod":
	                    credentialFunctions = prodCredentialFunctions;
	                    break;
	                case "environmentcredential":
	                    credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultEnvironmentCredential];
	                    break;
	                case "workloadidentitycredential":
	                    credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultWorkloadIdentityCredential];
	                    break;
	                case "managedidentitycredential":
	                    // Setting `sendProbeRequest` to false to ensure ManagedIdentityCredential behavior
	                    // is consistent when used standalone in DAC chain or used directly.
	                    credentialFunctions = [
	                        () => (0, defaultAzureCredentialFunctions_js_1.createDefaultManagedIdentityCredential)({ sendProbeRequest: false }),
	                    ];
	                    break;
	                case "visualstudiocodecredential":
	                    credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultVisualStudioCodeCredential];
	                    break;
	                case "azureclicredential":
	                    credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultAzureCliCredential];
	                    break;
	                case "azurepowershellcredential":
	                    credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultAzurePowershellCredential];
	                    break;
	                case "azuredeveloperclicredential":
	                    credentialFunctions = [defaultAzureCredentialFunctions_js_1.createDefaultAzureDeveloperCliCredential];
	                    break;
	                default: {
	                    // If AZURE_TOKEN_CREDENTIALS is set to an unsupported value, throw an error.
	                    // This will prevent the creation of the DefaultAzureCredential.
	                    const errorMessage = `Invalid value for AZURE_TOKEN_CREDENTIALS = ${process.env.AZURE_TOKEN_CREDENTIALS}. Valid values are 'prod' or 'dev' or any of these credentials - ${validCredentialNames}.`;
	                    logger.warning(errorMessage);
	                    throw new Error(errorMessage);
	                }
	            }
	        }
	        else {
	            // If AZURE_TOKEN_CREDENTIALS is not set, use the default credential chain.
	            credentialFunctions = [...prodCredentialFunctions, ...devCredentialFunctions];
	        }
	        // Errors from individual credentials should not be thrown in the DefaultAzureCredential constructor, instead throwing on getToken() which is handled by ChainedTokenCredential.
	        // When adding new credentials to the default chain, consider:
	        // 1. Making the constructor parameters required and explicit
	        // 2. Validating any required parameters in the factory function
	        // 3. Returning a UnavailableDefaultCredential from the factory function if a credential is unavailable for any reason
	        const credentials = credentialFunctions.map((createCredentialFn) => {
	            try {
	                return createCredentialFn(options ?? {});
	            }
	            catch (err) {
	                logger.warning(`Skipped ${createCredentialFn.name} because of an error creating the credential: ${err}`);
	                return new UnavailableDefaultCredential(createCredentialFn.name, err.message);
	            }
	        });
	        super(...credentials);
	    }
	}
	defaultAzureCredential.DefaultAzureCredential = DefaultAzureCredential;
	/**
	 * This function checks that all environment variables in `options.requiredEnvVars` are set and non-empty.
	 * If any are missing or empty, it throws an error.
	 */
	function validateRequiredEnvVars(options) {
	    if (options?.requiredEnvVars) {
	        const requiredVars = Array.isArray(options.requiredEnvVars)
	            ? options.requiredEnvVars
	            : [options.requiredEnvVars];
	        const missing = requiredVars.filter((envVar) => !process.env[envVar]);
	        if (missing.length > 0) {
	            const errorMessage = `Required environment ${missing.length === 1 ? "variable" : "variables"} '${missing.join(", ")}' for DefaultAzureCredential ${missing.length === 1 ? "is" : "are"} not set or empty.`;
	            logger.warning(errorMessage);
	            throw new Error(errorMessage);
	        }
	    }
	}
	
	return defaultAzureCredential;
}

var interactiveBrowserCredential = {};

var hasRequiredInteractiveBrowserCredential;

function requireInteractiveBrowserCredential () {
	if (hasRequiredInteractiveBrowserCredential) return interactiveBrowserCredential;
	hasRequiredInteractiveBrowserCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(interactiveBrowserCredential, "__esModule", { value: true });
	interactiveBrowserCredential.InteractiveBrowserCredential = void 0;
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const logging_js_1 = requireLogging();
	const scopeUtils_js_1 = requireScopeUtils();
	const tracing_js_1 = requireTracing();
	const msalClient_js_1 = requireMsalClient();
	const constants_js_1 = requireConstants$3();
	const logger = (0, logging_js_1.credentialLogger)("InteractiveBrowserCredential");
	/**
	 * Enables authentication to Microsoft Entra ID inside of the web browser
	 * using the interactive login flow.
	 */
	class InteractiveBrowserCredential {
	    tenantId;
	    additionallyAllowedTenantIds;
	    msalClient;
	    disableAutomaticAuthentication;
	    browserCustomizationOptions;
	    loginHint;
	    /**
	     * Creates an instance of InteractiveBrowserCredential with the details needed.
	     *
	     * This credential uses the [Authorization Code Flow](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-auth-code-flow).
	     * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.
	     * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.
	     *
	     * For Node.js, if a `clientId` is provided, the Microsoft Entra application will need to be configured to have a "Mobile and desktop applications" redirect endpoint.
	     * Follow our guide on [setting up Redirect URIs for Desktop apps that calls to web APIs](https://learn.microsoft.com/entra/identity-platform/scenario-desktop-app-registration#redirect-uris).
	     *
	     * @param options - Options for configuring the client which makes the authentication requests.
	     */
	    constructor(options) {
	        this.tenantId = (0, tenantIdUtils_js_1.resolveTenantId)(logger, options.tenantId, options.clientId);
	        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
	        const msalClientOptions = {
	            ...options,
	            tokenCredentialOptions: options,
	            logger,
	        };
	        const ibcNodeOptions = options;
	        this.browserCustomizationOptions = ibcNodeOptions.browserCustomizationOptions;
	        this.loginHint = ibcNodeOptions.loginHint;
	        if (ibcNodeOptions?.brokerOptions?.enabled) {
	            if (!ibcNodeOptions?.brokerOptions?.parentWindowHandle) {
	                throw new Error("In order to do WAM authentication, `parentWindowHandle` under `brokerOptions` is a required parameter");
	            }
	            else {
	                msalClientOptions.brokerOptions = {
	                    enabled: true,
	                    parentWindowHandle: ibcNodeOptions.brokerOptions.parentWindowHandle,
	                    legacyEnableMsaPassthrough: ibcNodeOptions.brokerOptions?.legacyEnableMsaPassthrough,
	                    useDefaultBrokerAccount: ibcNodeOptions.brokerOptions?.useDefaultBrokerAccount,
	                };
	            }
	        }
	        this.msalClient = (0, msalClient_js_1.createMsalClient)(options.clientId ?? constants_js_1.DeveloperSignOnClientId, this.tenantId, msalClientOptions);
	        this.disableAutomaticAuthentication = options?.disableAutomaticAuthentication;
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * If the user provided the option `disableAutomaticAuthentication`,
	     * once the token can't be retrieved silently,
	     * this method won't attempt to request user interaction to retrieve the token.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                TokenCredential implementation might make.
	     */
	    async getToken(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
	            newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
	            const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
	            return this.msalClient.getTokenByInteractiveRequest(arrayScopes, {
	                ...newOptions,
	                disableAutomaticAuthentication: this.disableAutomaticAuthentication,
	                browserCustomizationOptions: this.browserCustomizationOptions,
	                loginHint: this.loginHint,
	            });
	        });
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * If the token can't be retrieved silently, this method will always generate a challenge for the user.
	     *
	     * On Node.js, this credential has [Proof Key for Code Exchange (PKCE)](https://datatracker.ietf.org/doc/html/rfc7636) enabled by default.
	     * PKCE is a security feature that mitigates authentication code interception attacks.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                  TokenCredential implementation might make.
	     */
	    async authenticate(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
	            const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
	            await this.msalClient.getTokenByInteractiveRequest(arrayScopes, {
	                ...newOptions,
	                disableAutomaticAuthentication: false, // this method should always allow user interaction
	                browserCustomizationOptions: this.browserCustomizationOptions,
	                loginHint: this.loginHint,
	            });
	            return this.msalClient.getActiveAccount();
	        });
	    }
	}
	interactiveBrowserCredential.InteractiveBrowserCredential = InteractiveBrowserCredential;
	
	return interactiveBrowserCredential;
}

var deviceCodeCredential = {};

var hasRequiredDeviceCodeCredential;

function requireDeviceCodeCredential () {
	if (hasRequiredDeviceCodeCredential) return deviceCodeCredential;
	hasRequiredDeviceCodeCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(deviceCodeCredential, "__esModule", { value: true });
	deviceCodeCredential.DeviceCodeCredential = void 0;
	deviceCodeCredential.defaultDeviceCodePromptCallback = defaultDeviceCodePromptCallback;
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const logging_js_1 = requireLogging();
	const scopeUtils_js_1 = requireScopeUtils();
	const tracing_js_1 = requireTracing();
	const msalClient_js_1 = requireMsalClient();
	const constants_js_1 = requireConstants$3();
	const logger = (0, logging_js_1.credentialLogger)("DeviceCodeCredential");
	/**
	 * Method that logs the user code from the DeviceCodeCredential.
	 * @param deviceCodeInfo - The device code.
	 */
	function defaultDeviceCodePromptCallback(deviceCodeInfo) {
	    console.log(deviceCodeInfo.message);
	}
	/**
	 * Enables authentication to Microsoft Entra ID using a device code
	 * that the user can enter into https://microsoft.com/devicelogin.
	 */
	class DeviceCodeCredential {
	    tenantId;
	    additionallyAllowedTenantIds;
	    disableAutomaticAuthentication;
	    msalClient;
	    userPromptCallback;
	    /**
	     * Creates an instance of DeviceCodeCredential with the details needed
	     * to initiate the device code authorization flow with Microsoft Entra ID.
	     *
	     * A message will be logged, giving users a code that they can use to authenticate once they go to https://microsoft.com/devicelogin
	     *
	     * Developers can configure how this message is shown by passing a custom `userPromptCallback`:
	     *
	     * ```ts snippet:device_code_credential_example
	     * import { DeviceCodeCredential } from "@azure/identity";
	     *
	     * const credential = new DeviceCodeCredential({
	     *   tenantId: process.env.AZURE_TENANT_ID,
	     *   clientId: process.env.AZURE_CLIENT_ID,
	     *   userPromptCallback: (info) => {
	     *     console.log("CUSTOMIZED PROMPT CALLBACK", info.message);
	     *   },
	     * });
	     * ```
	     *
	     * @param options - Options for configuring the client which makes the authentication requests.
	     */
	    constructor(options) {
	        this.tenantId = options?.tenantId;
	        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
	        const clientId = options?.clientId ?? constants_js_1.DeveloperSignOnClientId;
	        const tenantId = (0, tenantIdUtils_js_1.resolveTenantId)(logger, options?.tenantId, clientId);
	        this.userPromptCallback = options?.userPromptCallback ?? defaultDeviceCodePromptCallback;
	        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, tenantId, {
	            ...options,
	            logger,
	            tokenCredentialOptions: options || {},
	        });
	        this.disableAutomaticAuthentication = options?.disableAutomaticAuthentication;
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * If the user provided the option `disableAutomaticAuthentication`,
	     * once the token can't be retrieved silently,
	     * this method won't attempt to request user interaction to retrieve the token.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                TokenCredential implementation might make.
	     */
	    async getToken(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
	            newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
	            const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
	            return this.msalClient.getTokenByDeviceCode(arrayScopes, this.userPromptCallback, {
	                ...newOptions,
	                disableAutomaticAuthentication: this.disableAutomaticAuthentication,
	            });
	        });
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * If the token can't be retrieved silently, this method will always generate a challenge for the user.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                  TokenCredential implementation might make.
	     */
	    async authenticate(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {
	            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];
	            await this.msalClient.getTokenByDeviceCode(arrayScopes, this.userPromptCallback, {
	                ...newOptions,
	                disableAutomaticAuthentication: false, // this method should always allow user interaction
	            });
	            return this.msalClient.getActiveAccount();
	        });
	    }
	}
	deviceCodeCredential.DeviceCodeCredential = DeviceCodeCredential;
	
	return deviceCodeCredential;
}

var azurePipelinesCredential = {};

var hasRequiredAzurePipelinesCredential;

function requireAzurePipelinesCredential () {
	if (hasRequiredAzurePipelinesCredential) return azurePipelinesCredential;
	hasRequiredAzurePipelinesCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(azurePipelinesCredential, "__esModule", { value: true });
	azurePipelinesCredential.AzurePipelinesCredential = void 0;
	azurePipelinesCredential.handleOidcResponse = handleOidcResponse;
	const errors_js_1 = requireErrors$2();
	const core_rest_pipeline_1 = /*@__PURE__*/ requireCommonjs$3();
	const clientAssertionCredential_js_1 = requireClientAssertionCredential();
	const identityClient_js_1 = requireIdentityClient();
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const logging_js_1 = requireLogging();
	const credentialName = "AzurePipelinesCredential";
	const logger = (0, logging_js_1.credentialLogger)(credentialName);
	const OIDC_API_VERSION = "7.1";
	/**
	 * This credential is designed to be used in Azure Pipelines with service connections
	 * as a setup for workload identity federation.
	 */
	class AzurePipelinesCredential {
	    clientAssertionCredential;
	    identityClient;
	    /**
	     * AzurePipelinesCredential supports Federated Identity on Azure Pipelines through Service Connections.
	     * @param tenantId - tenantId associated with the service connection
	     * @param clientId - clientId associated with the service connection
	     * @param serviceConnectionId - Unique ID for the service connection, as found in the querystring's resourceId key
	     * @param systemAccessToken - The pipeline's <see href="https://learn.microsoft.com/azure/devops/pipelines/build/variables?view=azure-devops%26tabs=yaml#systemaccesstoken">System.AccessToken</see> value.
	     * @param options - The identity client options to use for authentication.
	     */
	    constructor(tenantId, clientId, serviceConnectionId, systemAccessToken, options = {}) {
	        if (!clientId) {
	            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. clientId is a required parameter.`);
	        }
	        if (!tenantId) {
	            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. tenantId is a required parameter.`);
	        }
	        if (!serviceConnectionId) {
	            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. serviceConnectionId is a required parameter.`);
	        }
	        if (!systemAccessToken) {
	            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. systemAccessToken is a required parameter.`);
	        }
	        // Allow these headers to be logged for troubleshooting by AzurePipelines.
	        options.loggingOptions = {
	            ...options?.loggingOptions,
	            additionalAllowedHeaderNames: [
	                ...(options.loggingOptions?.additionalAllowedHeaderNames ?? []),
	                "x-vss-e2eid",
	                "x-msedge-ref",
	            ],
	        };
	        this.identityClient = new identityClient_js_1.IdentityClient(options);
	        (0, tenantIdUtils_js_1.checkTenantId)(logger, tenantId);
	        logger.info(`Invoking AzurePipelinesCredential with tenant ID: ${tenantId}, client ID: ${clientId}, and service connection ID: ${serviceConnectionId}`);
	        if (!process.env.SYSTEM_OIDCREQUESTURI) {
	            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: is unavailable. Ensure that you're running this task in an Azure Pipeline, so that following missing system variable(s) can be defined- "SYSTEM_OIDCREQUESTURI"`);
	        }
	        const oidcRequestUrl = `${process.env.SYSTEM_OIDCREQUESTURI}?api-version=${OIDC_API_VERSION}&serviceConnectionId=${serviceConnectionId}`;
	        logger.info(`Invoking ClientAssertionCredential with tenant ID: ${tenantId}, client ID: ${clientId} and service connection ID: ${serviceConnectionId}`);
	        this.clientAssertionCredential = new clientAssertionCredential_js_1.ClientAssertionCredential(tenantId, clientId, this.requestOidcToken.bind(this, oidcRequestUrl, systemAccessToken), options);
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} or {@link AuthenticationError} will be thrown with the details of the failure.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                TokenCredential implementation might make.
	     */
	    async getToken(scopes, options) {
	        if (!this.clientAssertionCredential) {
	            const errorMessage = `${credentialName}: is unavailable. To use Federation Identity in Azure Pipelines, the following parameters are required - 
      tenantId,
      clientId,
      serviceConnectionId,
      systemAccessToken,
      "SYSTEM_OIDCREQUESTURI".      
      See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`;
	            logger.error(errorMessage);
	            throw new errors_js_1.CredentialUnavailableError(errorMessage);
	        }
	        logger.info("Invoking getToken() of Client Assertion Credential");
	        return this.clientAssertionCredential.getToken(scopes, options);
	    }
	    /**
	     *
	     * @param oidcRequestUrl - oidc request url
	     * @param systemAccessToken - system access token
	     * @returns OIDC token from Azure Pipelines
	     */
	    async requestOidcToken(oidcRequestUrl, systemAccessToken) {
	        logger.info("Requesting OIDC token from Azure Pipelines...");
	        logger.info(oidcRequestUrl);
	        const request = (0, core_rest_pipeline_1.createPipelineRequest)({
	            url: oidcRequestUrl,
	            method: "POST",
	            headers: (0, core_rest_pipeline_1.createHttpHeaders)({
	                "Content-Type": "application/json",
	                Authorization: `Bearer ${systemAccessToken}`,
	                // Prevents the service from responding with a redirect HTTP status code (useful for automation).
	                "X-TFS-FedAuthRedirect": "Suppress",
	            }),
	        });
	        const response = await this.identityClient.sendRequest(request);
	        return handleOidcResponse(response);
	    }
	}
	azurePipelinesCredential.AzurePipelinesCredential = AzurePipelinesCredential;
	function handleOidcResponse(response) {
	    // OIDC token is present in `bodyAsText` field
	    const text = response.bodyAsText;
	    if (!text) {
	        logger.error(`${credentialName}: Authentication Failed. Received null token from OIDC request. Response status- ${response.status}. Complete response - ${JSON.stringify(response)}`);
	        throw new errors_js_1.AuthenticationError(response.status, {
	            error: `${credentialName}: Authentication Failed. Received null token from OIDC request.`,
	            error_description: `${JSON.stringify(response)}. See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`,
	        });
	    }
	    try {
	        const result = JSON.parse(text);
	        if (result?.oidcToken) {
	            return result.oidcToken;
	        }
	        else {
	            const errorMessage = `${credentialName}: Authentication Failed. oidcToken field not detected in the response.`;
	            let errorDescription = ``;
	            if (response.status !== 200) {
	                errorDescription = `Response body = ${text}. Response Headers ["x-vss-e2eid"] = ${response.headers.get("x-vss-e2eid")} and ["x-msedge-ref"] = ${response.headers.get("x-msedge-ref")}. See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`;
	            }
	            logger.error(errorMessage);
	            logger.error(errorDescription);
	            throw new errors_js_1.AuthenticationError(response.status, {
	                error: errorMessage,
	                error_description: errorDescription,
	            });
	        }
	    }
	    catch (e) {
	        const errorDetails = `${credentialName}: Authentication Failed. oidcToken field not detected in the response.`;
	        logger.error(`Response from service = ${text}, Response Headers ["x-vss-e2eid"] = ${response.headers.get("x-vss-e2eid")} 
      and ["x-msedge-ref"] = ${response.headers.get("x-msedge-ref")}, error message = ${e.message}`);
	        logger.error(errorDetails);
	        throw new errors_js_1.AuthenticationError(response.status, {
	            error: errorDetails,
	            error_description: `Response = ${text}. Response headers ["x-vss-e2eid"] = ${response.headers.get("x-vss-e2eid")} and ["x-msedge-ref"] =  ${response.headers.get("x-msedge-ref")}. See the troubleshooting guide for more information: https://aka.ms/azsdk/js/identity/azurepipelinescredential/troubleshoot`,
	        });
	    }
	}
	
	return azurePipelinesCredential;
}

var authorizationCodeCredential = {};

var hasRequiredAuthorizationCodeCredential;

function requireAuthorizationCodeCredential () {
	if (hasRequiredAuthorizationCodeCredential) return authorizationCodeCredential;
	hasRequiredAuthorizationCodeCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(authorizationCodeCredential, "__esModule", { value: true });
	authorizationCodeCredential.AuthorizationCodeCredential = void 0;
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const tenantIdUtils_js_2 = requireTenantIdUtils();
	const logging_js_1 = requireLogging();
	const scopeUtils_js_1 = requireScopeUtils();
	const tracing_js_1 = requireTracing();
	const msalClient_js_1 = requireMsalClient();
	const logger = (0, logging_js_1.credentialLogger)("AuthorizationCodeCredential");
	/**
	 * Enables authentication to Microsoft Entra ID using an authorization code
	 * that was obtained through the authorization code flow, described in more detail
	 * in the Microsoft Entra ID documentation:
	 *
	 * https://learn.microsoft.com/entra/identity-platform/v2-oauth2-auth-code-flow
	 */
	class AuthorizationCodeCredential {
	    msalClient;
	    disableAutomaticAuthentication;
	    authorizationCode;
	    redirectUri;
	    tenantId;
	    additionallyAllowedTenantIds;
	    clientSecret;
	    /**
	     * @hidden
	     * @internal
	     */
	    constructor(tenantId, clientId, clientSecretOrAuthorizationCode, authorizationCodeOrRedirectUri, redirectUriOrOptions, options) {
	        (0, tenantIdUtils_js_2.checkTenantId)(logger, tenantId);
	        this.clientSecret = clientSecretOrAuthorizationCode;
	        if (typeof redirectUriOrOptions === "string") {
	            // the clientId+clientSecret constructor
	            this.authorizationCode = authorizationCodeOrRedirectUri;
	            this.redirectUri = redirectUriOrOptions;
	            // in this case, options are good as they come
	        }
	        else {
	            // clientId only
	            this.authorizationCode = clientSecretOrAuthorizationCode;
	            this.redirectUri = authorizationCodeOrRedirectUri;
	            this.clientSecret = undefined;
	            options = redirectUriOrOptions;
	        }
	        // TODO: Validate tenant if provided
	        this.tenantId = tenantId;
	        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(options?.additionallyAllowedTenants);
	        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, tenantId, {
	            ...options,
	            logger,
	            tokenCredentialOptions: options ?? {},
	        });
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure any requests this
	     *                TokenCredential implementation might make.
	     */
	    async getToken(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {
	            const tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds);
	            newOptions.tenantId = tenantId;
	            const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
	            return this.msalClient.getTokenByAuthorizationCode(arrayScopes, this.redirectUri, this.authorizationCode, this.clientSecret, {
	                ...newOptions,
	                disableAutomaticAuthentication: this.disableAutomaticAuthentication,
	            });
	        });
	    }
	}
	authorizationCodeCredential.AuthorizationCodeCredential = AuthorizationCodeCredential;
	
	return authorizationCodeCredential;
}

var onBehalfOfCredential = {};

var hasRequiredOnBehalfOfCredential;

function requireOnBehalfOfCredential () {
	if (hasRequiredOnBehalfOfCredential) return onBehalfOfCredential;
	hasRequiredOnBehalfOfCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(onBehalfOfCredential, "__esModule", { value: true });
	onBehalfOfCredential.OnBehalfOfCredential = void 0;
	const msalClient_js_1 = requireMsalClient();
	const logging_js_1 = requireLogging();
	const tenantIdUtils_js_1 = requireTenantIdUtils();
	const errors_js_1 = requireErrors$2();
	const node_crypto_1 = __require$6();
	const scopeUtils_js_1 = requireScopeUtils();
	const promises_1 = __require$2();
	const tracing_js_1 = requireTracing();
	const credentialName = "OnBehalfOfCredential";
	const logger = (0, logging_js_1.credentialLogger)(credentialName);
	/**
	 * Enables authentication to Microsoft Entra ID using the [On Behalf Of flow](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow).
	 */
	class OnBehalfOfCredential {
	    tenantId;
	    additionallyAllowedTenantIds;
	    msalClient;
	    sendCertificateChain;
	    certificatePath;
	    clientSecret;
	    userAssertionToken;
	    clientAssertion;
	    constructor(options) {
	        const { clientSecret } = options;
	        const { certificatePath, sendCertificateChain } = options;
	        const { getAssertion } = options;
	        const { tenantId, clientId, userAssertionToken, additionallyAllowedTenants: additionallyAllowedTenantIds, } = options;
	        if (!tenantId) {
	            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: tenantId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
	        }
	        if (!clientId) {
	            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: clientId is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
	        }
	        if (!clientSecret && !certificatePath && !getAssertion) {
	            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: You must provide one of clientSecret, certificatePath, or a getAssertion callback but none were provided. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
	        }
	        if (!userAssertionToken) {
	            throw new errors_js_1.CredentialUnavailableError(`${credentialName}: userAssertionToken is a required parameter. To troubleshoot, visit https://aka.ms/azsdk/js/identity/serviceprincipalauthentication/troubleshoot.`);
	        }
	        this.certificatePath = certificatePath;
	        this.clientSecret = clientSecret;
	        this.userAssertionToken = userAssertionToken;
	        this.sendCertificateChain = sendCertificateChain;
	        this.clientAssertion = getAssertion;
	        this.tenantId = tenantId;
	        this.additionallyAllowedTenantIds = (0, tenantIdUtils_js_1.resolveAdditionallyAllowedTenantIds)(additionallyAllowedTenantIds);
	        this.msalClient = (0, msalClient_js_1.createMsalClient)(clientId, this.tenantId, {
	            ...options,
	            logger,
	            tokenCredentialOptions: options,
	        });
	    }
	    /**
	     * Authenticates with Microsoft Entra ID and returns an access token if successful.
	     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.
	     *
	     * @param scopes - The list of scopes for which the token will have access.
	     * @param options - The options used to configure the underlying network requests.
	     */
	    async getToken(scopes, options = {}) {
	        return tracing_js_1.tracingClient.withSpan(`${credentialName}.getToken`, options, async (newOptions) => {
	            newOptions.tenantId = (0, tenantIdUtils_js_1.processMultiTenantRequest)(this.tenantId, newOptions, this.additionallyAllowedTenantIds, logger);
	            const arrayScopes = (0, scopeUtils_js_1.ensureScopes)(scopes);
	            if (this.certificatePath) {
	                const clientCertificate = await this.buildClientCertificate(this.certificatePath);
	                return this.msalClient.getTokenOnBehalfOf(arrayScopes, this.userAssertionToken, clientCertificate, newOptions);
	            }
	            else if (this.clientSecret) {
	                return this.msalClient.getTokenOnBehalfOf(arrayScopes, this.userAssertionToken, this.clientSecret, options);
	            }
	            else if (this.clientAssertion) {
	                return this.msalClient.getTokenOnBehalfOf(arrayScopes, this.userAssertionToken, this.clientAssertion, options);
	            }
	            else {
	                // this is an invalid scenario and is a bug, as the constructor should have thrown an error if neither clientSecret nor certificatePath nor clientAssertion were provided
	                throw new Error("Expected either clientSecret or certificatePath or clientAssertion to be defined.");
	            }
	        });
	    }
	    async buildClientCertificate(certificatePath) {
	        try {
	            const parts = await this.parseCertificate({ certificatePath }, this.sendCertificateChain);
	            return {
	                thumbprint: parts.thumbprint,
	                thumbprintSha256: parts.thumbprintSha256,
	                privateKey: parts.certificateContents,
	                x5c: parts.x5c,
	            };
	        }
	        catch (error) {
	            logger.info((0, logging_js_1.formatError)("", error));
	            throw error;
	        }
	    }
	    async parseCertificate(configuration, sendCertificateChain) {
	        const certificatePath = configuration.certificatePath;
	        const certificateContents = await (0, promises_1.readFile)(certificatePath, "utf8");
	        const x5c = sendCertificateChain ? certificateContents : undefined;
	        const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/g;
	        const publicKeys = [];
	        // Match all possible certificates, in the order they are in the file. These will form the chain that is used for x5c
	        let match;
	        do {
	            match = certificatePattern.exec(certificateContents);
	            if (match) {
	                publicKeys.push(match[3]);
	            }
	        } while (match);
	        if (publicKeys.length === 0) {
	            throw new Error("The file at the specified path does not contain a PEM-encoded certificate.");
	        }
	        const thumbprint = (0, node_crypto_1.createHash)("sha1") // CodeQL [SM04514] Needed for backward compatibility reason
	            .update(Buffer.from(publicKeys[0], "base64"))
	            .digest("hex")
	            .toUpperCase();
	        const thumbprintSha256 = (0, node_crypto_1.createHash)("sha256")
	            .update(Buffer.from(publicKeys[0], "base64"))
	            .digest("hex")
	            .toUpperCase();
	        return {
	            certificateContents,
	            thumbprintSha256,
	            thumbprint,
	            x5c,
	        };
	    }
	}
	onBehalfOfCredential.OnBehalfOfCredential = OnBehalfOfCredential;
	
	return onBehalfOfCredential;
}

var tokenProvider = {};

var hasRequiredTokenProvider;

function requireTokenProvider () {
	if (hasRequiredTokenProvider) return tokenProvider;
	hasRequiredTokenProvider = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(tokenProvider, "__esModule", { value: true });
	tokenProvider.getBearerTokenProvider = getBearerTokenProvider;
	const core_rest_pipeline_1 = /*@__PURE__*/ requireCommonjs$3();
	/**
	 * Returns a callback that provides a bearer token.
	 * For example, the bearer token can be used to authenticate a request as follows:
	 * ```ts snippet:token_provider_example
	 * import { DefaultAzureCredential, getBearerTokenProvider } from "@azure/identity";
	 * import { createPipelineRequest } from "@azure/core-rest-pipeline";
	 *
	 * const credential = new DefaultAzureCredential();
	 * const scope = "https://cognitiveservices.azure.com/.default";
	 * const getAccessToken = getBearerTokenProvider(credential, scope);
	 * const token = await getAccessToken();
	 *
	 * // usage
	 * const request = createPipelineRequest({ url: "https://example.com" });
	 * request.headers.set("Authorization", `Bearer ${token}`);
	 * ```
	 *
	 * @param credential - The credential used to authenticate the request.
	 * @param scopes - The scopes required for the bearer token.
	 * @param options - Options to configure the token provider.
	 * @returns a callback that provides a bearer token.
	 */
	function getBearerTokenProvider(credential, scopes, options) {
	    const { abortSignal, tracingOptions } = options || {};
	    const pipeline = (0, core_rest_pipeline_1.createEmptyPipeline)();
	    pipeline.addPolicy((0, core_rest_pipeline_1.bearerTokenAuthenticationPolicy)({ credential, scopes }));
	    async function getRefreshedToken() {
	        // Create a pipeline with just the bearer token policy
	        // and run a dummy request through it to get the token
	        const res = await pipeline.sendRequest({
	            sendRequest: (request) => Promise.resolve({
	                request,
	                status: 200,
	                headers: request.headers,
	            }),
	        }, (0, core_rest_pipeline_1.createPipelineRequest)({
	            url: "https://example.com",
	            abortSignal,
	            tracingOptions,
	        }));
	        const accessToken = res.headers.get("authorization")?.split(" ")[1];
	        if (!accessToken) {
	            throw new Error("Failed to get access token");
	        }
	        return accessToken;
	    }
	    return getRefreshedToken;
	}
	
	return tokenProvider;
}

var hasRequiredCommonjs$1;

function requireCommonjs$1 () {
	if (hasRequiredCommonjs$1) return commonjs$8;
	hasRequiredCommonjs$1 = 1;
	(function (exports$1) {
		// Copyright (c) Microsoft Corporation.
		// Licensed under the MIT License.
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.getBearerTokenProvider = exports$1.AzureAuthorityHosts = exports$1.logger = exports$1.WorkloadIdentityCredential = exports$1.OnBehalfOfCredential = exports$1.VisualStudioCodeCredential = exports$1.UsernamePasswordCredential = exports$1.AzurePowerShellCredential = exports$1.AuthorizationCodeCredential = exports$1.AzurePipelinesCredential = exports$1.DeviceCodeCredential = exports$1.ManagedIdentityCredential = exports$1.InteractiveBrowserCredential = exports$1.AzureDeveloperCliCredential = exports$1.AzureCliCredential = exports$1.ClientAssertionCredential = exports$1.ClientCertificateCredential = exports$1.EnvironmentCredential = exports$1.DefaultAzureCredential = exports$1.ClientSecretCredential = exports$1.ChainedTokenCredential = exports$1.deserializeAuthenticationRecord = exports$1.serializeAuthenticationRecord = exports$1.AuthenticationRequiredError = exports$1.CredentialUnavailableErrorName = exports$1.CredentialUnavailableError = exports$1.AggregateAuthenticationErrorName = exports$1.AuthenticationErrorName = exports$1.AggregateAuthenticationError = exports$1.AuthenticationError = void 0;
		exports$1.getDefaultAzureCredential = getDefaultAzureCredential;
		const tslib_1 = require$$0$3;
		tslib_1.__exportStar(requireConsumer(), exports$1);
		const defaultAzureCredential_js_1 = requireDefaultAzureCredential();
		var errors_js_1 = requireErrors$2();
		Object.defineProperty(exports$1, "AuthenticationError", { enumerable: true, get: function () { return errors_js_1.AuthenticationError; } });
		Object.defineProperty(exports$1, "AggregateAuthenticationError", { enumerable: true, get: function () { return errors_js_1.AggregateAuthenticationError; } });
		Object.defineProperty(exports$1, "AuthenticationErrorName", { enumerable: true, get: function () { return errors_js_1.AuthenticationErrorName; } });
		Object.defineProperty(exports$1, "AggregateAuthenticationErrorName", { enumerable: true, get: function () { return errors_js_1.AggregateAuthenticationErrorName; } });
		Object.defineProperty(exports$1, "CredentialUnavailableError", { enumerable: true, get: function () { return errors_js_1.CredentialUnavailableError; } });
		Object.defineProperty(exports$1, "CredentialUnavailableErrorName", { enumerable: true, get: function () { return errors_js_1.CredentialUnavailableErrorName; } });
		Object.defineProperty(exports$1, "AuthenticationRequiredError", { enumerable: true, get: function () { return errors_js_1.AuthenticationRequiredError; } });
		var utils_js_1 = requireUtils$3();
		Object.defineProperty(exports$1, "serializeAuthenticationRecord", { enumerable: true, get: function () { return utils_js_1.serializeAuthenticationRecord; } });
		Object.defineProperty(exports$1, "deserializeAuthenticationRecord", { enumerable: true, get: function () { return utils_js_1.deserializeAuthenticationRecord; } });
		var chainedTokenCredential_js_1 = requireChainedTokenCredential();
		Object.defineProperty(exports$1, "ChainedTokenCredential", { enumerable: true, get: function () { return chainedTokenCredential_js_1.ChainedTokenCredential; } });
		var clientSecretCredential_js_1 = requireClientSecretCredential();
		Object.defineProperty(exports$1, "ClientSecretCredential", { enumerable: true, get: function () { return clientSecretCredential_js_1.ClientSecretCredential; } });
		var defaultAzureCredential_js_2 = requireDefaultAzureCredential();
		Object.defineProperty(exports$1, "DefaultAzureCredential", { enumerable: true, get: function () { return defaultAzureCredential_js_2.DefaultAzureCredential; } });
		var environmentCredential_js_1 = requireEnvironmentCredential();
		Object.defineProperty(exports$1, "EnvironmentCredential", { enumerable: true, get: function () { return environmentCredential_js_1.EnvironmentCredential; } });
		var clientCertificateCredential_js_1 = requireClientCertificateCredential();
		Object.defineProperty(exports$1, "ClientCertificateCredential", { enumerable: true, get: function () { return clientCertificateCredential_js_1.ClientCertificateCredential; } });
		var clientAssertionCredential_js_1 = requireClientAssertionCredential();
		Object.defineProperty(exports$1, "ClientAssertionCredential", { enumerable: true, get: function () { return clientAssertionCredential_js_1.ClientAssertionCredential; } });
		var azureCliCredential_js_1 = requireAzureCliCredential();
		Object.defineProperty(exports$1, "AzureCliCredential", { enumerable: true, get: function () { return azureCliCredential_js_1.AzureCliCredential; } });
		var azureDeveloperCliCredential_js_1 = requireAzureDeveloperCliCredential();
		Object.defineProperty(exports$1, "AzureDeveloperCliCredential", { enumerable: true, get: function () { return azureDeveloperCliCredential_js_1.AzureDeveloperCliCredential; } });
		var interactiveBrowserCredential_js_1 = requireInteractiveBrowserCredential();
		Object.defineProperty(exports$1, "InteractiveBrowserCredential", { enumerable: true, get: function () { return interactiveBrowserCredential_js_1.InteractiveBrowserCredential; } });
		var index_js_1 = requireManagedIdentityCredential();
		Object.defineProperty(exports$1, "ManagedIdentityCredential", { enumerable: true, get: function () { return index_js_1.ManagedIdentityCredential; } });
		var deviceCodeCredential_js_1 = requireDeviceCodeCredential();
		Object.defineProperty(exports$1, "DeviceCodeCredential", { enumerable: true, get: function () { return deviceCodeCredential_js_1.DeviceCodeCredential; } });
		var azurePipelinesCredential_js_1 = requireAzurePipelinesCredential();
		Object.defineProperty(exports$1, "AzurePipelinesCredential", { enumerable: true, get: function () { return azurePipelinesCredential_js_1.AzurePipelinesCredential; } });
		var authorizationCodeCredential_js_1 = requireAuthorizationCodeCredential();
		Object.defineProperty(exports$1, "AuthorizationCodeCredential", { enumerable: true, get: function () { return authorizationCodeCredential_js_1.AuthorizationCodeCredential; } });
		var azurePowerShellCredential_js_1 = requireAzurePowerShellCredential();
		Object.defineProperty(exports$1, "AzurePowerShellCredential", { enumerable: true, get: function () { return azurePowerShellCredential_js_1.AzurePowerShellCredential; } });
		var usernamePasswordCredential_js_1 = requireUsernamePasswordCredential();
		Object.defineProperty(exports$1, "UsernamePasswordCredential", { enumerable: true, get: function () { return usernamePasswordCredential_js_1.UsernamePasswordCredential; } });
		var visualStudioCodeCredential_js_1 = requireVisualStudioCodeCredential();
		Object.defineProperty(exports$1, "VisualStudioCodeCredential", { enumerable: true, get: function () { return visualStudioCodeCredential_js_1.VisualStudioCodeCredential; } });
		var onBehalfOfCredential_js_1 = requireOnBehalfOfCredential();
		Object.defineProperty(exports$1, "OnBehalfOfCredential", { enumerable: true, get: function () { return onBehalfOfCredential_js_1.OnBehalfOfCredential; } });
		var workloadIdentityCredential_js_1 = requireWorkloadIdentityCredential();
		Object.defineProperty(exports$1, "WorkloadIdentityCredential", { enumerable: true, get: function () { return workloadIdentityCredential_js_1.WorkloadIdentityCredential; } });
		var logging_js_1 = requireLogging();
		Object.defineProperty(exports$1, "logger", { enumerable: true, get: function () { return logging_js_1.logger; } });
		var constants_js_1 = requireConstants$3();
		Object.defineProperty(exports$1, "AzureAuthorityHosts", { enumerable: true, get: function () { return constants_js_1.AzureAuthorityHosts; } });
		/**
		 * Returns a new instance of the {@link DefaultAzureCredential}.
		 */
		function getDefaultAzureCredential() {
		    return new defaultAzureCredential_js_1.DefaultAzureCredential();
		}
		var tokenProvider_js_1 = requireTokenProvider();
		Object.defineProperty(exports$1, "getBearerTokenProvider", { enumerable: true, get: function () { return tokenProvider_js_1.getBearerTokenProvider; } });
		
	} (commonjs$8));
	return commonjs$8;
}

var commonjs = {};

var azureKeyCredential = {};

var hasRequiredAzureKeyCredential;

function requireAzureKeyCredential () {
	if (hasRequiredAzureKeyCredential) return azureKeyCredential;
	hasRequiredAzureKeyCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(azureKeyCredential, "__esModule", { value: true });
	azureKeyCredential.AzureKeyCredential = void 0;
	/**
	 * A static-key-based credential that supports updating
	 * the underlying key value.
	 */
	class AzureKeyCredential {
	    _key;
	    /**
	     * The value of the key to be used in authentication
	     */
	    get key() {
	        return this._key;
	    }
	    /**
	     * Create an instance of an AzureKeyCredential for use
	     * with a service client.
	     *
	     * @param key - The initial value of the key to use in authentication
	     */
	    constructor(key) {
	        if (!key) {
	            throw new Error("key must be a non-empty string");
	        }
	        this._key = key;
	    }
	    /**
	     * Change the value of the key.
	     *
	     * Updates will take effect upon the next request after
	     * updating the key value.
	     *
	     * @param newKey - The new key value to be used
	     */
	    update(newKey) {
	        this._key = newKey;
	    }
	}
	azureKeyCredential.AzureKeyCredential = AzureKeyCredential;
	
	return azureKeyCredential;
}

var keyCredential = {};

var hasRequiredKeyCredential;

function requireKeyCredential () {
	if (hasRequiredKeyCredential) return keyCredential;
	hasRequiredKeyCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(keyCredential, "__esModule", { value: true });
	keyCredential.isKeyCredential = isKeyCredential;
	const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
	/**
	 * Tests an object to determine whether it implements KeyCredential.
	 *
	 * @param credential - The assumed KeyCredential to be tested.
	 */
	function isKeyCredential(credential) {
	    return (0, core_util_1.isObjectWithProperties)(credential, ["key"]) && typeof credential.key === "string";
	}
	
	return keyCredential;
}

var azureNamedKeyCredential = {};

var hasRequiredAzureNamedKeyCredential;

function requireAzureNamedKeyCredential () {
	if (hasRequiredAzureNamedKeyCredential) return azureNamedKeyCredential;
	hasRequiredAzureNamedKeyCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(azureNamedKeyCredential, "__esModule", { value: true });
	azureNamedKeyCredential.AzureNamedKeyCredential = void 0;
	azureNamedKeyCredential.isNamedKeyCredential = isNamedKeyCredential;
	const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
	/**
	 * A static name/key-based credential that supports updating
	 * the underlying name and key values.
	 */
	class AzureNamedKeyCredential {
	    _key;
	    _name;
	    /**
	     * The value of the key to be used in authentication.
	     */
	    get key() {
	        return this._key;
	    }
	    /**
	     * The value of the name to be used in authentication.
	     */
	    get name() {
	        return this._name;
	    }
	    /**
	     * Create an instance of an AzureNamedKeyCredential for use
	     * with a service client.
	     *
	     * @param name - The initial value of the name to use in authentication.
	     * @param key - The initial value of the key to use in authentication.
	     */
	    constructor(name, key) {
	        if (!name || !key) {
	            throw new TypeError("name and key must be non-empty strings");
	        }
	        this._name = name;
	        this._key = key;
	    }
	    /**
	     * Change the value of the key.
	     *
	     * Updates will take effect upon the next request after
	     * updating the key value.
	     *
	     * @param newName - The new name value to be used.
	     * @param newKey - The new key value to be used.
	     */
	    update(newName, newKey) {
	        if (!newName || !newKey) {
	            throw new TypeError("newName and newKey must be non-empty strings");
	        }
	        this._name = newName;
	        this._key = newKey;
	    }
	}
	azureNamedKeyCredential.AzureNamedKeyCredential = AzureNamedKeyCredential;
	/**
	 * Tests an object to determine whether it implements NamedKeyCredential.
	 *
	 * @param credential - The assumed NamedKeyCredential to be tested.
	 */
	function isNamedKeyCredential(credential) {
	    return ((0, core_util_1.isObjectWithProperties)(credential, ["name", "key"]) &&
	        typeof credential.key === "string" &&
	        typeof credential.name === "string");
	}
	
	return azureNamedKeyCredential;
}

var azureSASCredential = {};

var hasRequiredAzureSASCredential;

function requireAzureSASCredential () {
	if (hasRequiredAzureSASCredential) return azureSASCredential;
	hasRequiredAzureSASCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(azureSASCredential, "__esModule", { value: true });
	azureSASCredential.AzureSASCredential = void 0;
	azureSASCredential.isSASCredential = isSASCredential;
	const core_util_1 = /*@__PURE__*/ requireCommonjs$5();
	/**
	 * A static-signature-based credential that supports updating
	 * the underlying signature value.
	 */
	class AzureSASCredential {
	    _signature;
	    /**
	     * The value of the shared access signature to be used in authentication
	     */
	    get signature() {
	        return this._signature;
	    }
	    /**
	     * Create an instance of an AzureSASCredential for use
	     * with a service client.
	     *
	     * @param signature - The initial value of the shared access signature to use in authentication
	     */
	    constructor(signature) {
	        if (!signature) {
	            throw new Error("shared access signature must be a non-empty string");
	        }
	        this._signature = signature;
	    }
	    /**
	     * Change the value of the signature.
	     *
	     * Updates will take effect upon the next request after
	     * updating the signature value.
	     *
	     * @param newSignature - The new shared access signature value to be used
	     */
	    update(newSignature) {
	        if (!newSignature) {
	            throw new Error("shared access signature must be a non-empty string");
	        }
	        this._signature = newSignature;
	    }
	}
	azureSASCredential.AzureSASCredential = AzureSASCredential;
	/**
	 * Tests an object to determine whether it implements SASCredential.
	 *
	 * @param credential - The assumed SASCredential to be tested.
	 */
	function isSASCredential(credential) {
	    return ((0, core_util_1.isObjectWithProperties)(credential, ["signature"]) && typeof credential.signature === "string");
	}
	
	return azureSASCredential;
}

var tokenCredential = {};

var hasRequiredTokenCredential;

function requireTokenCredential () {
	if (hasRequiredTokenCredential) return tokenCredential;
	hasRequiredTokenCredential = 1;
	// Copyright (c) Microsoft Corporation.
	// Licensed under the MIT License.
	Object.defineProperty(tokenCredential, "__esModule", { value: true });
	tokenCredential.isBearerToken = isBearerToken;
	tokenCredential.isPopToken = isPopToken;
	tokenCredential.isTokenCredential = isTokenCredential;
	/**
	 * @internal
	 * @param accessToken - Access token
	 * @returns Whether a token is bearer type or not
	 */
	function isBearerToken(accessToken) {
	    return !accessToken.tokenType || accessToken.tokenType === "Bearer";
	}
	/**
	 * @internal
	 * @param accessToken - Access token
	 * @returns Whether a token is Pop token or not
	 */
	function isPopToken(accessToken) {
	    return accessToken.tokenType === "pop";
	}
	/**
	 * Tests an object to determine whether it implements TokenCredential.
	 *
	 * @param credential - The assumed TokenCredential to be tested.
	 */
	function isTokenCredential(credential) {
	    // Check for an object with a 'getToken' function and possibly with
	    // a 'signRequest' function.  We do this check to make sure that
	    // a ServiceClientCredentials implementor (like TokenClientCredentials
	    // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
	    // it doesn't actually implement TokenCredential also.
	    const castCredential = credential;
	    return (castCredential &&
	        typeof castCredential.getToken === "function" &&
	        (castCredential.signRequest === undefined || castCredential.getToken.length > 0));
	}
	
	return tokenCredential;
}

var hasRequiredCommonjs;

function requireCommonjs () {
	if (hasRequiredCommonjs) return commonjs;
	hasRequiredCommonjs = 1;
	(function (exports$1) {
		Object.defineProperty(exports$1, "__esModule", { value: true });
		exports$1.isTokenCredential = exports$1.isSASCredential = exports$1.AzureSASCredential = exports$1.isNamedKeyCredential = exports$1.AzureNamedKeyCredential = exports$1.isKeyCredential = exports$1.AzureKeyCredential = void 0;
		var azureKeyCredential_js_1 = requireAzureKeyCredential();
		Object.defineProperty(exports$1, "AzureKeyCredential", { enumerable: true, get: function () { return azureKeyCredential_js_1.AzureKeyCredential; } });
		var keyCredential_js_1 = requireKeyCredential();
		Object.defineProperty(exports$1, "isKeyCredential", { enumerable: true, get: function () { return keyCredential_js_1.isKeyCredential; } });
		var azureNamedKeyCredential_js_1 = requireAzureNamedKeyCredential();
		Object.defineProperty(exports$1, "AzureNamedKeyCredential", { enumerable: true, get: function () { return azureNamedKeyCredential_js_1.AzureNamedKeyCredential; } });
		Object.defineProperty(exports$1, "isNamedKeyCredential", { enumerable: true, get: function () { return azureNamedKeyCredential_js_1.isNamedKeyCredential; } });
		var azureSASCredential_js_1 = requireAzureSASCredential();
		Object.defineProperty(exports$1, "AzureSASCredential", { enumerable: true, get: function () { return azureSASCredential_js_1.AzureSASCredential; } });
		Object.defineProperty(exports$1, "isSASCredential", { enumerable: true, get: function () { return azureSASCredential_js_1.isSASCredential; } });
		var tokenCredential_js_1 = requireTokenCredential();
		Object.defineProperty(exports$1, "isTokenCredential", { enumerable: true, get: function () { return tokenCredential_js_1.isTokenCredential; } });
		
	} (commonjs));
	return commonjs;
}

var debug$1 = {exports: {}};

var hasRequiredDebug;

function requireDebug () {
	if (hasRequiredDebug) return debug$1.exports;
	hasRequiredDebug = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _events = require$$0$5;
		var util = _interopRequireWildcard(require$$5$1);
		function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
		function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
		class Debug extends _events.EventEmitter {
		  /*
		    @options    Which debug details should be sent.
		                data    - dump of packet data
		                payload - details of decoded payload
		  */
		  constructor({
		    data = false,
		    payload = false,
		    packet = false,
		    token = false
		  } = {}) {
		    super();
		    this.options = {
		      data,
		      payload,
		      packet,
		      token
		    };
		    this.indent = '  ';
		  }
		  packet(direction, packet) {
		    if (this.haveListeners() && this.options.packet) {
		      this.log('');
		      this.log(direction);
		      this.log(packet.headerToString(this.indent));
		    }
		  }
		  data(packet) {
		    if (this.haveListeners() && this.options.data) {
		      this.log(packet.dataToString(this.indent));
		    }
		  }
		  payload(generatePayloadText) {
		    if (this.haveListeners() && this.options.payload) {
		      this.log(generatePayloadText());
		    }
		  }
		  token(token) {
		    if (this.haveListeners() && this.options.token) {
		      this.log(util.inspect(token, {
		        showHidden: false,
		        depth: 5,
		        colors: true
		      }));
		    }
		  }
		  haveListeners() {
		    return this.listeners('debug').length > 0;
		  }
		  log(text) {
		    this.emit('debug', text);
		  }
		}
		exports$1.default = Debug;
		module.exports = Debug;
		
	} (debug$1, debug$1.exports));
	return debug$1.exports;
}

var instanceLookup = {};

var abortError = {};

var hasRequiredAbortError;

function requireAbortError () {
	if (hasRequiredAbortError) return abortError;
	hasRequiredAbortError = 1;

	Object.defineProperty(abortError, "__esModule", {
	  value: true
	});
	abortError.default = void 0;
	class AbortError extends Error {
	  constructor() {
	    super('The operation was aborted');
	    this.code = 'ABORT_ERR';
	    this.name = 'AbortError';
	  }
	}
	abortError.default = AbortError;
	
	return abortError;
}

var sender = {};

const require$1 = createRequire(import.meta.url);
function __require() { return require$1("node:url"); }

var hasRequiredSender;

function requireSender () {
	if (hasRequiredSender) return sender;
	hasRequiredSender = 1;

	Object.defineProperty(sender, "__esModule", {
	  value: true
	});
	sender.sendInParallel = sendInParallel;
	sender.sendMessage = sendMessage;
	var _dgram = _interopRequireDefault(require$$0$a);
	var _net = _interopRequireDefault(require$$0$9);
	var _nodeUrl = _interopRequireDefault(__require());
	var _abortError = _interopRequireDefault(requireAbortError());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	async function sendInParallel(addresses, port, request, signal) {
	  if (signal.aborted) {
	    throw new _abortError.default();
	  }
	  return await new Promise((resolve, reject) => {
	    const sockets = [];
	    let errorCount = 0;
	    const onError = err => {
	      errorCount++;
	      if (errorCount === addresses.length) {
	        signal.removeEventListener('abort', onAbort);
	        clearSockets();
	        reject(err);
	      }
	    };
	    const onMessage = message => {
	      signal.removeEventListener('abort', onAbort);
	      clearSockets();
	      resolve(message);
	    };
	    const onAbort = () => {
	      clearSockets();
	      reject(new _abortError.default());
	    };
	    const clearSockets = () => {
	      for (const socket of sockets) {
	        socket.removeListener('error', onError);
	        socket.removeListener('message', onMessage);
	        socket.close();
	      }
	    };
	    signal.addEventListener('abort', onAbort, {
	      once: true
	    });
	    for (let j = 0; j < addresses.length; j++) {
	      const udpType = addresses[j].family === 6 ? 'udp6' : 'udp4';
	      const socket = _dgram.default.createSocket(udpType);
	      sockets.push(socket);
	      socket.on('error', onError);
	      socket.on('message', onMessage);
	      socket.send(request, 0, request.length, port, addresses[j].address);
	    }
	  });
	}
	async function sendMessage(host, port, lookup, signal, request) {
	  if (signal.aborted) {
	    throw new _abortError.default();
	  }
	  let addresses;
	  if (_net.default.isIP(host)) {
	    addresses = [{
	      address: host,
	      family: _net.default.isIPv6(host) ? 6 : 4
	    }];
	  } else {
	    addresses = await new Promise((resolve, reject) => {
	      const onAbort = () => {
	        reject(new _abortError.default());
	      };
	      const domainInASCII = _nodeUrl.default.domainToASCII(host);
	      lookup(domainInASCII === '' ? host : domainInASCII, {
	        all: true
	      }, (err, addresses) => {
	        signal.removeEventListener('abort', onAbort);
	        err ? reject(err) : resolve(addresses);
	      });
	    });
	  }
	  return await sendInParallel(addresses, port, request, signal);
	}
	
	return sender;
}

var withTimeout = {};

var timeoutError = {};

var hasRequiredTimeoutError;

function requireTimeoutError () {
	if (hasRequiredTimeoutError) return timeoutError;
	hasRequiredTimeoutError = 1;

	Object.defineProperty(timeoutError, "__esModule", {
	  value: true
	});
	timeoutError.default = void 0;
	class TimeoutError extends Error {
	  constructor() {
	    super('The operation was aborted due to timeout');
	    this.code = 'TIMEOUT_ERR';
	    this.name = 'TimeoutError';
	  }
	}
	timeoutError.default = TimeoutError;
	
	return timeoutError;
}

var hasRequiredWithTimeout;

function requireWithTimeout () {
	if (hasRequiredWithTimeout) return withTimeout;
	hasRequiredWithTimeout = 1;

	Object.defineProperty(withTimeout, "__esModule", {
	  value: true
	});
	withTimeout.withTimeout = withTimeout$1;
	var _timeoutError = _interopRequireDefault(requireTimeoutError());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	/**
	 * Run the function `func` with an `AbortSignal` that will automatically abort after the time specified
	 * by `timeout` or when the given `signal` is aborted.
	 *
	 * On timeout, the `timeoutSignal` will be aborted and a `TimeoutError` will be thrown.
	 */
	async function withTimeout$1(timeout, func, signal) {
	  const timeoutController = new AbortController();
	  const abortCurrentAttempt = () => {
	    timeoutController.abort();
	  };
	  const timer = setTimeout(abortCurrentAttempt, timeout);
	  signal?.addEventListener('abort', abortCurrentAttempt, {
	    once: true
	  });
	  try {
	    return await func(timeoutController.signal);
	  } catch (err) {
	    if (err instanceof Error && err.name === 'AbortError' && !(signal && signal.aborted)) {
	      throw new _timeoutError.default();
	    }
	    throw err;
	  } finally {
	    signal?.removeEventListener('abort', abortCurrentAttempt);
	    clearTimeout(timer);
	  }
	}
	
	return withTimeout;
}

var hasRequiredInstanceLookup;

function requireInstanceLookup () {
	if (hasRequiredInstanceLookup) return instanceLookup;
	hasRequiredInstanceLookup = 1;

	Object.defineProperty(instanceLookup, "__esModule", {
	  value: true
	});
	instanceLookup.instanceLookup = instanceLookup$1;
	instanceLookup.parseBrowserResponse = parseBrowserResponse;
	var _dns = _interopRequireDefault(require$$0$b);
	var _abortError = _interopRequireDefault(requireAbortError());
	var _sender = requireSender();
	var _withTimeout = requireWithTimeout();
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	const SQL_SERVER_BROWSER_PORT = 1434;
	const TIMEOUT = 2 * 1000;
	const RETRIES = 3;
	// There are three bytes at the start of the response, whose purpose is unknown.
	const MYSTERY_HEADER_LENGTH = 3;
	// Most of the functionality has been determined from from jTDS's MSSqlServerInfo class.
	async function instanceLookup$1(options) {
	  const server = options.server;
	  if (typeof server !== 'string') {
	    throw new TypeError('Invalid arguments: "server" must be a string');
	  }
	  const instanceName = options.instanceName;
	  if (typeof instanceName !== 'string') {
	    throw new TypeError('Invalid arguments: "instanceName" must be a string');
	  }
	  const timeout = options.timeout === undefined ? TIMEOUT : options.timeout;
	  if (typeof timeout !== 'number') {
	    throw new TypeError('Invalid arguments: "timeout" must be a number');
	  }
	  const retries = options.retries === undefined ? RETRIES : options.retries;
	  if (typeof retries !== 'number') {
	    throw new TypeError('Invalid arguments: "retries" must be a number');
	  }
	  if (options.lookup !== undefined && typeof options.lookup !== 'function') {
	    throw new TypeError('Invalid arguments: "lookup" must be a function');
	  }
	  const lookup = options.lookup ?? _dns.default.lookup;
	  if (options.port !== undefined && typeof options.port !== 'number') {
	    throw new TypeError('Invalid arguments: "port" must be a number');
	  }
	  const port = options.port ?? SQL_SERVER_BROWSER_PORT;
	  const signal = options.signal;
	  if (signal.aborted) {
	    throw new _abortError.default();
	  }
	  let response;
	  for (let i = 0; i <= retries; i++) {
	    try {
	      response = await (0, _withTimeout.withTimeout)(timeout, async signal => {
	        const request = Buffer.from([0x02]);
	        return await (0, _sender.sendMessage)(options.server, port, lookup, signal, request);
	      }, signal);
	    } catch (err) {
	      // If the current attempt timed out, continue with the next
	      if (!signal.aborted && err instanceof Error && err.name === 'TimeoutError') {
	        continue;
	      }
	      throw err;
	    }
	  }
	  if (!response) {
	    throw new Error('Failed to get response from SQL Server Browser on ' + server);
	  }
	  const message = response.toString('ascii', MYSTERY_HEADER_LENGTH);
	  const foundPort = parseBrowserResponse(message, instanceName);
	  if (!foundPort) {
	    throw new Error('Port for ' + instanceName + ' not found in ' + options.server);
	  }
	  return foundPort;
	}
	function parseBrowserResponse(response, instanceName) {
	  let getPort;
	  const instances = response.split(';;');
	  for (let i = 0, len = instances.length; i < len; i++) {
	    const instance = instances[i];
	    const parts = instance.split(';');
	    for (let p = 0, partsLen = parts.length; p < partsLen; p += 2) {
	      const name = parts[p];
	      const value = parts[p + 1];
	      if (name === 'tcp' && getPort) {
	        const port = parseInt(value, 10);
	        return port;
	      }
	      if (name === 'InstanceName') {
	        if (value.toUpperCase() === instanceName.toUpperCase()) {
	          getPort = true;
	        } else {
	          getPort = false;
	        }
	      }
	    }
	  }
	}
	
	return instanceLookup;
}

var transientErrorLookup = {};

var hasRequiredTransientErrorLookup;

function requireTransientErrorLookup () {
	if (hasRequiredTransientErrorLookup) return transientErrorLookup;
	hasRequiredTransientErrorLookup = 1;

	Object.defineProperty(transientErrorLookup, "__esModule", {
	  value: true
	});
	transientErrorLookup.TransientErrorLookup = void 0;
	// This simple piece of code is factored out into a separate class to make it
	// easy to stub it out in tests. It's hard, if not impossible, to cause a
	// transient error on demand in tests.
	class TransientErrorLookup {
	  isTransientError(error) {
	    // This list of transient errors comes from Microsoft implementation of SqlClient:
	    //  - https://github.com/dotnet/corefx/blob/master/src/System.Data.SqlClient/src/System/Data/SqlClient/SqlInternalConnectionTds.cs#L115
	    const transientErrors = [4060, 10928, 10929, 40197, 40501, 40613];
	    return transientErrors.indexOf(error) !== -1;
	  }
	}
	transientErrorLookup.TransientErrorLookup = TransientErrorLookup;
	
	return transientErrorLookup;
}

var packet = {};

var sprintf = {};

/* global window, exports, define */

var hasRequiredSprintf;

function requireSprintf () {
	if (hasRequiredSprintf) return sprintf;
	hasRequiredSprintf = 1;
	(function (exports$1) {
		!function() {

		    var re = {
		        not_type: /[^T]/,
		        not_primitive: /[^v]/,
		        number: /[diefg]/,
		        numeric_arg: /[bcdiefguxX]/,
		        json: /[j]/,
		        text: /^[^\x25]+/,
		        modulo: /^\x25{2}/,
		        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
		        key: /^([a-z_][a-z_\d]*)/i,
		        key_access: /^\.([a-z_][a-z_\d]*)/i,
		        index_access: /^\[(\d+)\]/,
		        sign: /^[+-]/
		    };

		    function sprintf(key) {
		        // `arguments` is not an array, but should be fine for this call
		        return sprintf_format(sprintf_parse(key), arguments)
		    }

		    function vsprintf(fmt, argv) {
		        return sprintf.apply(null, [fmt].concat(argv || []))
		    }

		    function sprintf_format(parse_tree, argv) {
		        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign;
		        for (i = 0; i < tree_length; i++) {
		            if (typeof parse_tree[i] === 'string') {
		                output += parse_tree[i];
		            }
		            else if (typeof parse_tree[i] === 'object') {
		                ph = parse_tree[i]; // convenience purposes only
		                if (ph.keys) { // keyword argument
		                    arg = argv[cursor];
		                    for (k = 0; k < ph.keys.length; k++) {
		                        if (arg == undefined) {
		                            throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k-1]))
		                        }
		                        arg = arg[ph.keys[k]];
		                    }
		                }
		                else if (ph.param_no) { // positional argument (explicit)
		                    arg = argv[ph.param_no];
		                }
		                else { // positional argument (implicit)
		                    arg = argv[cursor++];
		                }

		                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
		                    arg = arg();
		                }

		                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {
		                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))
		                }

		                if (re.number.test(ph.type)) {
		                    is_positive = arg >= 0;
		                }

		                switch (ph.type) {
		                    case 'b':
		                        arg = parseInt(arg, 10).toString(2);
		                        break
		                    case 'c':
		                        arg = String.fromCharCode(parseInt(arg, 10));
		                        break
		                    case 'd':
		                    case 'i':
		                        arg = parseInt(arg, 10);
		                        break
		                    case 'j':
		                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
		                        break
		                    case 'e':
		                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
		                        break
		                    case 'f':
		                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
		                        break
		                    case 'g':
		                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
		                        break
		                    case 'o':
		                        arg = (parseInt(arg, 10) >>> 0).toString(8);
		                        break
		                    case 's':
		                        arg = String(arg);
		                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
		                        break
		                    case 't':
		                        arg = String(!!arg);
		                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
		                        break
		                    case 'T':
		                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
		                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
		                        break
		                    case 'u':
		                        arg = parseInt(arg, 10) >>> 0;
		                        break
		                    case 'v':
		                        arg = arg.valueOf();
		                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg);
		                        break
		                    case 'x':
		                        arg = (parseInt(arg, 10) >>> 0).toString(16);
		                        break
		                    case 'X':
		                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
		                        break
		                }
		                if (re.json.test(ph.type)) {
		                    output += arg;
		                }
		                else {
		                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
		                        sign = is_positive ? '+' : '-';
		                        arg = arg.toString().replace(re.sign, '');
		                    }
		                    else {
		                        sign = '';
		                    }
		                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
		                    pad_length = ph.width - (sign + arg).length;
		                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : '';
		                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg);
		                }
		            }
		        }
		        return output
		    }

		    var sprintf_cache = Object.create(null);

		    function sprintf_parse(fmt) {
		        if (sprintf_cache[fmt]) {
		            return sprintf_cache[fmt]
		        }

		        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
		        while (_fmt) {
		            if ((match = re.text.exec(_fmt)) !== null) {
		                parse_tree.push(match[0]);
		            }
		            else if ((match = re.modulo.exec(_fmt)) !== null) {
		                parse_tree.push('%');
		            }
		            else if ((match = re.placeholder.exec(_fmt)) !== null) {
		                if (match[2]) {
		                    arg_names |= 1;
		                    var field_list = [], replacement_field = match[2], field_match = [];
		                    if ((field_match = re.key.exec(replacement_field)) !== null) {
		                        field_list.push(field_match[1]);
		                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
		                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
		                                field_list.push(field_match[1]);
		                            }
		                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
		                                field_list.push(field_match[1]);
		                            }
		                            else {
		                                throw new SyntaxError('[sprintf] failed to parse named argument key')
		                            }
		                        }
		                    }
		                    else {
		                        throw new SyntaxError('[sprintf] failed to parse named argument key')
		                    }
		                    match[2] = field_list;
		                }
		                else {
		                    arg_names |= 2;
		                }
		                if (arg_names === 3) {
		                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
		                }

		                parse_tree.push(
		                    {
		                        placeholder: match[0],
		                        param_no:    match[1],
		                        keys:        match[2],
		                        sign:        match[3],
		                        pad_char:    match[4],
		                        align:       match[5],
		                        width:       match[6],
		                        precision:   match[7],
		                        type:        match[8]
		                    }
		                );
		            }
		            else {
		                throw new SyntaxError('[sprintf] unexpected placeholder')
		            }
		            _fmt = _fmt.substring(match[0].length);
		        }
		        return sprintf_cache[fmt] = parse_tree
		    }

		    /**
		     * export to either browser or node.js
		     */
		    /* eslint-disable quote-props */
		    {
		        exports$1['sprintf'] = sprintf;
		        exports$1['vsprintf'] = vsprintf;
		    }
		    if (typeof window !== 'undefined') {
		        window['sprintf'] = sprintf;
		        window['vsprintf'] = vsprintf;
		    }
		    /* eslint-enable quote-props */
		}(); // eslint-disable-line 
	} (sprintf));
	return sprintf;
}

var hasRequiredPacket;

function requirePacket () {
	if (hasRequiredPacket) return packet;
	hasRequiredPacket = 1;

	Object.defineProperty(packet, "__esModule", {
	  value: true
	});
	packet.TYPE = packet.Packet = packet.OFFSET = packet.HEADER_LENGTH = void 0;
	packet.isPacketComplete = isPacketComplete;
	packet.packetLength = packetLength;
	var _sprintfJs = requireSprintf();
	const HEADER_LENGTH = packet.HEADER_LENGTH = 8;
	const TYPE = packet.TYPE = {
	  SQL_BATCH: 0x01,
	  RPC_REQUEST: 0x03,
	  TABULAR_RESULT: 0x04,
	  ATTENTION: 0x06,
	  BULK_LOAD: 0x07,
	  TRANSACTION_MANAGER: 0x0E,
	  LOGIN7: 0x10,
	  NTLMAUTH_PKT: 0x11,
	  PRELOGIN: 0x12,
	  FEDAUTH_TOKEN: 0x08
	};
	const typeByValue = {};
	for (const name in TYPE) {
	  typeByValue[TYPE[name]] = name;
	}
	const STATUS = {
	  NORMAL: 0x00,
	  EOM: 0x01,
	  IGNORE: 0x02,
	  RESETCONNECTION: 0x08,
	  RESETCONNECTIONSKIPTRAN: 0x10
	};
	const OFFSET = packet.OFFSET = {
	  Type: 0,
	  Status: 1,
	  Length: 2,
	  SPID: 4,
	  PacketID: 6,
	  Window: 7
	};
	const DEFAULT_SPID = 0;
	const DEFAULT_PACKETID = 1;
	const DEFAULT_WINDOW = 0;
	const NL = '\n';
	class Packet {
	  constructor(typeOrBuffer) {
	    if (typeOrBuffer instanceof Buffer) {
	      this.buffer = typeOrBuffer;
	    } else {
	      const type = typeOrBuffer;
	      this.buffer = Buffer.alloc(HEADER_LENGTH, 0);
	      this.buffer.writeUInt8(type, OFFSET.Type);
	      this.buffer.writeUInt8(STATUS.NORMAL, OFFSET.Status);
	      this.buffer.writeUInt16BE(DEFAULT_SPID, OFFSET.SPID);
	      this.buffer.writeUInt8(DEFAULT_PACKETID, OFFSET.PacketID);
	      this.buffer.writeUInt8(DEFAULT_WINDOW, OFFSET.Window);
	      this.setLength();
	    }
	  }
	  setLength() {
	    this.buffer.writeUInt16BE(this.buffer.length, OFFSET.Length);
	  }
	  length() {
	    return this.buffer.readUInt16BE(OFFSET.Length);
	  }
	  resetConnection(reset) {
	    let status = this.buffer.readUInt8(OFFSET.Status);
	    if (reset) {
	      status |= STATUS.RESETCONNECTION;
	    } else {
	      status &= 0xFF - STATUS.RESETCONNECTION;
	    }
	    this.buffer.writeUInt8(status, OFFSET.Status);
	  }
	  last(last) {
	    let status = this.buffer.readUInt8(OFFSET.Status);
	    if (arguments.length > 0) {
	      if (last) {
	        status |= STATUS.EOM;
	      } else {
	        status &= 0xFF - STATUS.EOM;
	      }
	      this.buffer.writeUInt8(status, OFFSET.Status);
	    }
	    return this.isLast();
	  }
	  ignore(last) {
	    let status = this.buffer.readUInt8(OFFSET.Status);
	    if (last) {
	      status |= STATUS.IGNORE;
	    } else {
	      status &= 0xFF - STATUS.IGNORE;
	    }
	    this.buffer.writeUInt8(status, OFFSET.Status);
	  }
	  isLast() {
	    return !!(this.buffer.readUInt8(OFFSET.Status) & STATUS.EOM);
	  }
	  packetId(packetId) {
	    if (packetId) {
	      this.buffer.writeUInt8(packetId % 256, OFFSET.PacketID);
	    }
	    return this.buffer.readUInt8(OFFSET.PacketID);
	  }
	  addData(data) {
	    this.buffer = Buffer.concat([this.buffer, data]);
	    this.setLength();
	    return this;
	  }
	  data() {
	    return this.buffer.slice(HEADER_LENGTH);
	  }
	  type() {
	    return this.buffer.readUInt8(OFFSET.Type);
	  }
	  statusAsString() {
	    const status = this.buffer.readUInt8(OFFSET.Status);
	    const statuses = [];
	    for (const name in STATUS) {
	      const value = STATUS[name];
	      if (status & value) {
	        statuses.push(name);
	      } else {
	        statuses.push(undefined);
	      }
	    }
	    return statuses.join(' ').trim();
	  }
	  headerToString(indent = '') {
	    const text = (0, _sprintfJs.sprintf)('type:0x%02X(%s), status:0x%02X(%s), length:0x%04X, spid:0x%04X, packetId:0x%02X, window:0x%02X', this.buffer.readUInt8(OFFSET.Type), typeByValue[this.buffer.readUInt8(OFFSET.Type)], this.buffer.readUInt8(OFFSET.Status), this.statusAsString(), this.buffer.readUInt16BE(OFFSET.Length), this.buffer.readUInt16BE(OFFSET.SPID), this.buffer.readUInt8(OFFSET.PacketID), this.buffer.readUInt8(OFFSET.Window));
	    return indent + text;
	  }
	  dataToString(indent = '') {
	    const BYTES_PER_GROUP = 0x04;
	    const CHARS_PER_GROUP = 0x08;
	    const BYTES_PER_LINE = 0x20;
	    const data = this.data();
	    let dataDump = '';
	    let chars = '';
	    for (let offset = 0; offset < data.length; offset++) {
	      if (offset % BYTES_PER_LINE === 0) {
	        dataDump += indent;
	        dataDump += (0, _sprintfJs.sprintf)('%04X  ', offset);
	      }
	      if (data[offset] < 0x20 || data[offset] > 0x7E) {
	        chars += '.';
	        if ((offset + 1) % CHARS_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
	          chars += ' ';
	        }
	      } else {
	        chars += String.fromCharCode(data[offset]);
	      }
	      if (data[offset] != null) {
	        dataDump += (0, _sprintfJs.sprintf)('%02X', data[offset]);
	      }
	      if ((offset + 1) % BYTES_PER_GROUP === 0 && !((offset + 1) % BYTES_PER_LINE === 0)) {
	        dataDump += ' ';
	      }
	      if ((offset + 1) % BYTES_PER_LINE === 0) {
	        dataDump += '  ' + chars;
	        chars = '';
	        if (offset < data.length - 1) {
	          dataDump += NL;
	        }
	      }
	    }
	    if (chars.length) {
	      dataDump += '  ' + chars;
	    }
	    return dataDump;
	  }
	  toString(indent = '') {
	    return this.headerToString(indent) + '\n' + this.dataToString(indent + indent);
	  }
	  payloadString() {
	    return '';
	  }
	}
	packet.Packet = Packet;
	function isPacketComplete(potentialPacketBuffer) {
	  if (potentialPacketBuffer.length < HEADER_LENGTH) {
	    return false;
	  } else {
	    return potentialPacketBuffer.length >= potentialPacketBuffer.readUInt16BE(OFFSET.Length);
	  }
	}
	function packetLength(potentialPacketBuffer) {
	  return potentialPacketBuffer.readUInt16BE(OFFSET.Length);
	}
	
	return packet;
}

var preloginPayload = {exports: {}};

var hasRequiredPreloginPayload;

function requirePreloginPayload () {
	if (hasRequiredPreloginPayload) return preloginPayload.exports;
	hasRequiredPreloginPayload = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _sprintfJs = requireSprintf();
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const optionBufferSize = 20;
		const TOKEN = {
		  VERSION: 0x00,
		  ENCRYPTION: 0x01,
		  INSTOPT: 0x02,
		  THREADID: 0x03,
		  MARS: 0x04,
		  FEDAUTHREQUIRED: 0x06,
		  TERMINATOR: 0xFF
		};
		const ENCRYPT = {
		  OFF: 0x00,
		  ON: 0x01,
		  NOT_SUP: 0x02,
		  REQ: 0x03
		};
		const encryptByValue = {};
		for (const name in ENCRYPT) {
		  const value = ENCRYPT[name];
		  encryptByValue[value] = name;
		}
		const MARS = {
		  OFF: 0x00,
		  ON: 0x01
		};
		const marsByValue = {};
		for (const name in MARS) {
		  const value = MARS[name];
		  marsByValue[value] = name;
		}
		/*
		  s2.2.6.4
		 */
		class PreloginPayload {
		  constructor(bufferOrOptions = {
		    encrypt: false,
		    version: {
		      major: 0,
		      minor: 0,
		      build: 0,
		      subbuild: 0
		    }
		  }) {
		    if (bufferOrOptions instanceof Buffer) {
		      this.data = bufferOrOptions;
		      this.options = {
		        encrypt: false,
		        version: {
		          major: 0,
		          minor: 0,
		          build: 0,
		          subbuild: 0
		        }
		      };
		    } else {
		      this.options = bufferOrOptions;
		      this.createOptions();
		    }
		    this.extractOptions();
		  }
		  createOptions() {
		    const options = [this.createVersionOption(), this.createEncryptionOption(), this.createInstanceOption(), this.createThreadIdOption(), this.createMarsOption(), this.createFedAuthOption()];
		    let length = 0;
		    for (let i = 0, len = options.length; i < len; i++) {
		      const option = options[i];
		      length += 5 + option.data.length;
		    }
		    length++; // terminator
		    this.data = Buffer.alloc(length, 0);
		    let optionOffset = 0;
		    let optionDataOffset = 5 * options.length + 1;
		    for (let j = 0, len = options.length; j < len; j++) {
		      const option = options[j];
		      this.data.writeUInt8(option.token, optionOffset + 0);
		      this.data.writeUInt16BE(optionDataOffset, optionOffset + 1);
		      this.data.writeUInt16BE(option.data.length, optionOffset + 3);
		      optionOffset += 5;
		      option.data.copy(this.data, optionDataOffset);
		      optionDataOffset += option.data.length;
		    }
		    this.data.writeUInt8(TOKEN.TERMINATOR, optionOffset);
		  }
		  createVersionOption() {
		    const buffer = new _writableTrackingBuffer.default(optionBufferSize);
		    buffer.writeUInt8(this.options.version.major);
		    buffer.writeUInt8(this.options.version.minor);
		    buffer.writeUInt16BE(this.options.version.build);
		    buffer.writeUInt16BE(this.options.version.subbuild);
		    return {
		      token: TOKEN.VERSION,
		      data: buffer.data
		    };
		  }
		  createEncryptionOption() {
		    const buffer = new _writableTrackingBuffer.default(optionBufferSize);
		    if (this.options.encrypt) {
		      buffer.writeUInt8(ENCRYPT.ON);
		    } else {
		      buffer.writeUInt8(ENCRYPT.NOT_SUP);
		    }
		    return {
		      token: TOKEN.ENCRYPTION,
		      data: buffer.data
		    };
		  }
		  createInstanceOption() {
		    const buffer = new _writableTrackingBuffer.default(optionBufferSize);
		    buffer.writeUInt8(0x00);
		    return {
		      token: TOKEN.INSTOPT,
		      data: buffer.data
		    };
		  }
		  createThreadIdOption() {
		    const buffer = new _writableTrackingBuffer.default(optionBufferSize);
		    buffer.writeUInt32BE(0x00);
		    return {
		      token: TOKEN.THREADID,
		      data: buffer.data
		    };
		  }
		  createMarsOption() {
		    const buffer = new _writableTrackingBuffer.default(optionBufferSize);
		    buffer.writeUInt8(MARS.OFF);
		    return {
		      token: TOKEN.MARS,
		      data: buffer.data
		    };
		  }
		  createFedAuthOption() {
		    const buffer = new _writableTrackingBuffer.default(optionBufferSize);
		    buffer.writeUInt8(0x01);
		    return {
		      token: TOKEN.FEDAUTHREQUIRED,
		      data: buffer.data
		    };
		  }
		  extractOptions() {
		    let offset = 0;
		    while (this.data[offset] !== TOKEN.TERMINATOR) {
		      let dataOffset = this.data.readUInt16BE(offset + 1);
		      const dataLength = this.data.readUInt16BE(offset + 3);
		      switch (this.data[offset]) {
		        case TOKEN.VERSION:
		          this.extractVersion(dataOffset);
		          break;
		        case TOKEN.ENCRYPTION:
		          this.extractEncryption(dataOffset);
		          break;
		        case TOKEN.INSTOPT:
		          this.extractInstance(dataOffset);
		          break;
		        case TOKEN.THREADID:
		          if (dataLength > 0) {
		            this.extractThreadId(dataOffset);
		          }
		          break;
		        case TOKEN.MARS:
		          this.extractMars(dataOffset);
		          break;
		        case TOKEN.FEDAUTHREQUIRED:
		          this.extractFedAuth(dataOffset);
		          break;
		      }
		      offset += 5;
		      dataOffset += dataLength;
		    }
		  }
		  extractVersion(offset) {
		    this.version = {
		      major: this.data.readUInt8(offset + 0),
		      minor: this.data.readUInt8(offset + 1),
		      build: this.data.readUInt16BE(offset + 2),
		      subbuild: this.data.readUInt16BE(offset + 4)
		    };
		  }
		  extractEncryption(offset) {
		    this.encryption = this.data.readUInt8(offset);
		    this.encryptionString = encryptByValue[this.encryption];
		  }
		  extractInstance(offset) {
		    this.instance = this.data.readUInt8(offset);
		  }
		  extractThreadId(offset) {
		    this.threadId = this.data.readUInt32BE(offset);
		  }
		  extractMars(offset) {
		    this.mars = this.data.readUInt8(offset);
		    this.marsString = marsByValue[this.mars];
		  }
		  extractFedAuth(offset) {
		    this.fedAuthRequired = this.data.readUInt8(offset);
		  }
		  toString(indent = '') {
		    return indent + 'PreLogin - ' + (0, _sprintfJs.sprintf)('version:%d.%d.%d.%d, encryption:0x%02X(%s), instopt:0x%02X, threadId:0x%08X, mars:0x%02X(%s)', this.version.major, this.version.minor, this.version.build, this.version.subbuild, this.encryption ? this.encryption : 0, this.encryptionString ? this.encryptionString : '', this.instance ? this.instance : 0, this.threadId ? this.threadId : 0, this.mars ? this.mars : 0, this.marsString ? this.marsString : '');
		  }
		}
		exports$1.default = PreloginPayload;
		module.exports = PreloginPayload;
		
	} (preloginPayload, preloginPayload.exports));
	return preloginPayload.exports;
}

var login7Payload = {exports: {}};

var tdsVersions = {};

var hasRequiredTdsVersions;

function requireTdsVersions () {
	if (hasRequiredTdsVersions) return tdsVersions;
	hasRequiredTdsVersions = 1;

	Object.defineProperty(tdsVersions, "__esModule", {
	  value: true
	});
	tdsVersions.versionsByValue = tdsVersions.versions = void 0;
	const versions = tdsVersions.versions = {
	  '7_1': 0x71000001,
	  '7_2': 0x72090002,
	  '7_3_A': 0x730A0003,
	  '7_3_B': 0x730B0003,
	  '7_4': 0x74000004,
	  '8_0': 0x08000000
	};
	const versionsByValue = tdsVersions.versionsByValue = {};
	for (const name in versions) {
	  versionsByValue[versions[name]] = name;
	}
	
	return tdsVersions;
}

var hasRequiredLogin7Payload;

function requireLogin7Payload () {
	if (hasRequiredLogin7Payload) return login7Payload.exports;
	hasRequiredLogin7Payload = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _sprintfJs = requireSprintf();
		var _tdsVersions = requireTdsVersions();
		const FLAGS_1 = {
		  ENDIAN_LITTLE: 0x00,
		  CHARSET_ASCII: 0x00,
		  FLOAT_IEEE_754: 0x00,
		  BCP_DUMPLOAD_OFF: 0x10,
		  USE_DB_OFF: 0x20,
		  INIT_DB_WARN: 0x00,
		  INIT_DB_FATAL: 0x40,
		  SET_LANG_WARN_ON: 0x80
		};
		const FLAGS_2 = {
		  INIT_LANG_WARN: 0x00,
		  ODBC_OFF: 0x00,
		  USER_NORMAL: 0x00,
		  INTEGRATED_SECURITY_OFF: 0x00,
		  INTEGRATED_SECURITY_ON: 0x80
		};
		const TYPE_FLAGS = {
		  SQL_DFLT: 0x00,
		  OLEDB_OFF: 0x00,
		  READ_WRITE_INTENT: 0x00,
		  READ_ONLY_INTENT: 0x20
		};
		const FLAGS_3 = {
		  CHANGE_PASSWORD_NO: 0x00,
		  UNKNOWN_COLLATION_HANDLING: 0x08,
		  EXTENSION_USED: 0x10
		};
		const FEDAUTH_OPTIONS = {
		  FEATURE_ID: 0x02,
		  LIBRARY_SECURITYTOKEN: 0x01,
		  LIBRARY_ADAL: 0x02,
		  FEDAUTH_YES_ECHO: 0x01,
		  FEDAUTH_NO_ECHO: 0x00,
		  ADAL_WORKFLOW_USER_PASS: 0x01};
		const FEATURE_EXT_TERMINATOR = 0xFF;
		/*
		  s2.2.6.3
		 */
		class Login7Payload {
		  constructor({
		    tdsVersion,
		    packetSize,
		    clientProgVer,
		    clientPid,
		    connectionId,
		    clientTimeZone,
		    clientLcid
		  }) {
		    this.tdsVersion = tdsVersion;
		    this.packetSize = packetSize;
		    this.clientProgVer = clientProgVer;
		    this.clientPid = clientPid;
		    this.connectionId = connectionId;
		    this.clientTimeZone = clientTimeZone;
		    this.clientLcid = clientLcid;
		    this.readOnlyIntent = false;
		    this.initDbFatal = false;
		    this.fedAuth = undefined;
		    this.userName = undefined;
		    this.password = undefined;
		    this.serverName = undefined;
		    this.appName = undefined;
		    this.hostname = undefined;
		    this.libraryName = undefined;
		    this.language = undefined;
		    this.database = undefined;
		    this.clientId = undefined;
		    this.sspi = undefined;
		    this.attachDbFile = undefined;
		    this.changePassword = undefined;
		  }
		  toBuffer() {
		    const fixedData = Buffer.alloc(94);
		    const buffers = [fixedData];
		    let offset = 0;
		    let dataOffset = fixedData.length;

		    // Length: 4-byte
		    offset = fixedData.writeUInt32LE(0, offset);

		    // TDSVersion: 4-byte
		    offset = fixedData.writeUInt32LE(this.tdsVersion, offset);

		    // PacketSize: 4-byte
		    offset = fixedData.writeUInt32LE(this.packetSize, offset);

		    // ClientProgVer: 4-byte
		    offset = fixedData.writeUInt32LE(this.clientProgVer, offset);

		    // ClientPID: 4-byte
		    offset = fixedData.writeUInt32LE(this.clientPid, offset);

		    // ConnectionID: 4-byte
		    offset = fixedData.writeUInt32LE(this.connectionId, offset);

		    // OptionFlags1: 1-byte
		    offset = fixedData.writeUInt8(this.buildOptionFlags1(), offset);

		    // OptionFlags2: 1-byte
		    offset = fixedData.writeUInt8(this.buildOptionFlags2(), offset);

		    // TypeFlags: 1-byte
		    offset = fixedData.writeUInt8(this.buildTypeFlags(), offset);

		    // OptionFlags3: 1-byte
		    offset = fixedData.writeUInt8(this.buildOptionFlags3(), offset);

		    // ClientTimZone: 4-byte
		    offset = fixedData.writeInt32LE(this.clientTimeZone, offset);

		    // ClientLCID: 4-byte
		    offset = fixedData.writeUInt32LE(this.clientLcid, offset);

		    // ibHostName: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cchHostName: 2-byte
		    if (this.hostname) {
		      const buffer = Buffer.from(this.hostname, 'ucs2');
		      offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
		      dataOffset += buffer.length;
		      buffers.push(buffer);
		    } else {
		      offset = fixedData.writeUInt16LE(dataOffset, offset);
		    }

		    // ibUserName: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cchUserName: 2-byte
		    if (this.userName) {
		      const buffer = Buffer.from(this.userName, 'ucs2');
		      offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
		      dataOffset += buffer.length;
		      buffers.push(buffer);
		    } else {
		      offset = fixedData.writeUInt16LE(0, offset);
		    }

		    // ibPassword: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cchPassword: 2-byte
		    if (this.password) {
		      const buffer = Buffer.from(this.password, 'ucs2');
		      offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
		      dataOffset += buffer.length;
		      buffers.push(this.scramblePassword(buffer));
		    } else {
		      offset = fixedData.writeUInt16LE(0, offset);
		    }

		    // ibAppName: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cchAppName: 2-byte
		    if (this.appName) {
		      const buffer = Buffer.from(this.appName, 'ucs2');
		      offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
		      dataOffset += buffer.length;
		      buffers.push(buffer);
		    } else {
		      offset = fixedData.writeUInt16LE(0, offset);
		    }

		    // ibServerName: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cchServerName: 2-byte
		    if (this.serverName) {
		      const buffer = Buffer.from(this.serverName, 'ucs2');
		      offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
		      dataOffset += buffer.length;
		      buffers.push(buffer);
		    } else {
		      offset = fixedData.writeUInt16LE(0, offset);
		    }

		    // (ibUnused / ibExtension): 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // (cchUnused / cbExtension): 2-byte
		    const extensions = this.buildFeatureExt();
		    offset = fixedData.writeUInt16LE(4, offset);
		    const extensionOffset = Buffer.alloc(4);
		    extensionOffset.writeUInt32LE(dataOffset += 4, 0);
		    dataOffset += extensions.length;
		    buffers.push(extensionOffset, extensions);

		    // ibCltIntName: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cchCltIntName: 2-byte
		    if (this.libraryName) {
		      const buffer = Buffer.from(this.libraryName, 'ucs2');
		      offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
		      dataOffset += buffer.length;
		      buffers.push(buffer);
		    } else {
		      offset = fixedData.writeUInt16LE(0, offset);
		    }

		    // ibLanguage: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cchLanguage: 2-byte
		    if (this.language) {
		      const buffer = Buffer.from(this.language, 'ucs2');
		      offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
		      dataOffset += buffer.length;
		      buffers.push(buffer);
		    } else {
		      offset = fixedData.writeUInt16LE(0, offset);
		    }

		    // ibDatabase: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cchDatabase: 2-byte
		    if (this.database) {
		      const buffer = Buffer.from(this.database, 'ucs2');
		      offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
		      dataOffset += buffer.length;
		      buffers.push(buffer);
		    } else {
		      offset = fixedData.writeUInt16LE(0, offset);
		    }

		    // ClientID: 6-byte
		    if (this.clientId) {
		      this.clientId.copy(fixedData, offset, 0, 6);
		    }
		    offset += 6;

		    // ibSSPI: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cbSSPI: 2-byte
		    if (this.sspi) {
		      if (this.sspi.length > 65535) {
		        offset = fixedData.writeUInt16LE(65535, offset);
		      } else {
		        offset = fixedData.writeUInt16LE(this.sspi.length, offset);
		      }
		      buffers.push(this.sspi);
		    } else {
		      offset = fixedData.writeUInt16LE(0, offset);
		    }

		    // ibAtchDBFile: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cchAtchDBFile: 2-byte
		    if (this.attachDbFile) {
		      const buffer = Buffer.from(this.attachDbFile, 'ucs2');
		      offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
		      dataOffset += buffer.length;
		      buffers.push(buffer);
		    } else {
		      offset = fixedData.writeUInt16LE(0, offset);
		    }

		    // ibChangePassword: 2-byte
		    offset = fixedData.writeUInt16LE(dataOffset, offset);

		    // cchChangePassword: 2-byte
		    if (this.changePassword) {
		      const buffer = Buffer.from(this.changePassword, 'ucs2');
		      offset = fixedData.writeUInt16LE(buffer.length / 2, offset);
		      dataOffset += buffer.length;
		      buffers.push(buffer);
		    } else {
		      offset = fixedData.writeUInt16LE(0, offset);
		    }

		    // cbSSPILong: 4-byte
		    if (this.sspi && this.sspi.length > 65535) {
		      fixedData.writeUInt32LE(this.sspi.length, offset);
		    } else {
		      fixedData.writeUInt32LE(0, offset);
		    }
		    const data = Buffer.concat(buffers);
		    data.writeUInt32LE(data.length, 0);
		    return data;
		  }
		  buildOptionFlags1() {
		    let flags1 = FLAGS_1.ENDIAN_LITTLE | FLAGS_1.CHARSET_ASCII | FLAGS_1.FLOAT_IEEE_754 | FLAGS_1.BCP_DUMPLOAD_OFF | FLAGS_1.USE_DB_OFF | FLAGS_1.SET_LANG_WARN_ON;
		    if (this.initDbFatal) {
		      flags1 |= FLAGS_1.INIT_DB_FATAL;
		    } else {
		      flags1 |= FLAGS_1.INIT_DB_WARN;
		    }
		    return flags1;
		  }
		  buildFeatureExt() {
		    const buffers = [];
		    const fedAuth = this.fedAuth;
		    if (fedAuth) {
		      switch (fedAuth.type) {
		        case 'ADAL':
		          const buffer = Buffer.alloc(7);
		          buffer.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, 0);
		          buffer.writeUInt32LE(2, 1);
		          buffer.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_ADAL << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), 5);
		          buffer.writeUInt8(fedAuth.workflow === 'integrated' ? 0x02 : FEDAUTH_OPTIONS.ADAL_WORKFLOW_USER_PASS, 6);
		          buffers.push(buffer);
		          break;
		        case 'SECURITYTOKEN':
		          const token = Buffer.from(fedAuth.fedAuthToken, 'ucs2');
		          const buf = Buffer.alloc(10);
		          let offset = 0;
		          offset = buf.writeUInt8(FEDAUTH_OPTIONS.FEATURE_ID, offset);
		          offset = buf.writeUInt32LE(token.length + 4 + 1, offset);
		          offset = buf.writeUInt8(FEDAUTH_OPTIONS.LIBRARY_SECURITYTOKEN << 1 | (fedAuth.echo ? FEDAUTH_OPTIONS.FEDAUTH_YES_ECHO : FEDAUTH_OPTIONS.FEDAUTH_NO_ECHO), offset);
		          buf.writeInt32LE(token.length, offset);
		          buffers.push(buf);
		          buffers.push(token);
		          break;
		      }
		    }
		    if (this.tdsVersion >= _tdsVersions.versions['7_4']) {
		      // Signal UTF-8 support: Value 0x0A, bit 0 must be set to 1. Added in TDS 7.4.
		      const UTF8_SUPPORT_FEATURE_ID = 0x0a;
		      const UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8 = 0x01;
		      const buf = Buffer.alloc(6);
		      buf.writeUInt8(UTF8_SUPPORT_FEATURE_ID, 0);
		      buf.writeUInt32LE(1, 1);
		      buf.writeUInt8(UTF8_SUPPORT_CLIENT_SUPPORTS_UTF8, 5);
		      buffers.push(buf);
		    }
		    buffers.push(Buffer.from([FEATURE_EXT_TERMINATOR]));
		    return Buffer.concat(buffers);
		  }
		  buildOptionFlags2() {
		    let flags2 = FLAGS_2.INIT_LANG_WARN | FLAGS_2.ODBC_OFF | FLAGS_2.USER_NORMAL;
		    if (this.sspi) {
		      flags2 |= FLAGS_2.INTEGRATED_SECURITY_ON;
		    } else {
		      flags2 |= FLAGS_2.INTEGRATED_SECURITY_OFF;
		    }
		    return flags2;
		  }
		  buildTypeFlags() {
		    let typeFlags = TYPE_FLAGS.SQL_DFLT | TYPE_FLAGS.OLEDB_OFF;
		    if (this.readOnlyIntent) {
		      typeFlags |= TYPE_FLAGS.READ_ONLY_INTENT;
		    } else {
		      typeFlags |= TYPE_FLAGS.READ_WRITE_INTENT;
		    }
		    return typeFlags;
		  }
		  buildOptionFlags3() {
		    return FLAGS_3.CHANGE_PASSWORD_NO | FLAGS_3.UNKNOWN_COLLATION_HANDLING | FLAGS_3.EXTENSION_USED;
		  }
		  scramblePassword(password) {
		    for (let b = 0, len = password.length; b < len; b++) {
		      let byte = password[b];
		      const lowNibble = byte & 0x0f;
		      const highNibble = byte >> 4;
		      byte = lowNibble << 4 | highNibble;
		      byte = byte ^ 0xa5;
		      password[b] = byte;
		    }
		    return password;
		  }
		  toString(indent = '') {
		    return indent + 'Login7 - ' + (0, _sprintfJs.sprintf)('TDS:0x%08X, PacketSize:0x%08X, ClientProgVer:0x%08X, ClientPID:0x%08X, ConnectionID:0x%08X', this.tdsVersion, this.packetSize, this.clientProgVer, this.clientPid, this.connectionId) + '\n' + indent + '         ' + (0, _sprintfJs.sprintf)('Flags1:0x%02X, Flags2:0x%02X, TypeFlags:0x%02X, Flags3:0x%02X, ClientTimezone:%d, ClientLCID:0x%08X', this.buildOptionFlags1(), this.buildOptionFlags2(), this.buildTypeFlags(), this.buildOptionFlags3(), this.clientTimeZone, this.clientLcid) + '\n' + indent + '         ' + (0, _sprintfJs.sprintf)("Hostname:'%s', Username:'%s', Password:'%s', AppName:'%s', ServerName:'%s', LibraryName:'%s'", this.hostname, this.userName, this.password, this.appName, this.serverName, this.libraryName) + '\n' + indent + '         ' + (0, _sprintfJs.sprintf)("Language:'%s', Database:'%s', SSPI:'%s', AttachDbFile:'%s', ChangePassword:'%s'", this.language, this.database, this.sspi, this.attachDbFile, this.changePassword);
		  }
		}
		exports$1.default = Login7Payload;
		module.exports = Login7Payload;
		
	} (login7Payload, login7Payload.exports));
	return login7Payload.exports;
}

var ntlmPayload = {exports: {}};

var md4 = {exports: {}};

/**
 * [js-md4]{@link https://github.com/emn178/js-md4}
 *
 * @namespace md4
 * @version 0.3.2
 * @author Yi-Cyuan Chen [emn178@gmail.com]
 * @copyright Yi-Cyuan Chen 2015-2027
 * @license MIT
 */

var hasRequiredMd4;

function requireMd4 () {
	if (hasRequiredMd4) return md4.exports;
	hasRequiredMd4 = 1;
	(function (module) {
		/*jslint bitwise: true */
		(function () {

		  var root = typeof window === 'object' ? window : {};
		  var NODE_JS = !root.JS_MD4_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
		  if (NODE_JS) {
		    root = commonjsGlobal;
		  }
		  var COMMON_JS = !root.JS_MD4_NO_COMMON_JS && 'object' === 'object' && module.exports;
		  var ARRAY_BUFFER = !root.JS_MD4_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
		  var HEX_CHARS = '0123456789abcdef'.split('');
		  var EXTRA = [128, 32768, 8388608, -2147483648];
		  var SHIFT = [0, 8, 16, 24];
		  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer'];

		  var blocks = [], buffer8;
		  if (ARRAY_BUFFER) {
		    var buffer = new ArrayBuffer(68);
		    buffer8 = new Uint8Array(buffer);
		    blocks = new Uint32Array(buffer);
		  }

		  /**
		   * @method hex
		   * @memberof md4
		   * @description Output hash as hex string
		   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
		   * @returns {String} Hex string
		   * @example
		   * md4.hex('The quick brown fox jumps over the lazy dog');
		   * // equal to
		   * md4('The quick brown fox jumps over the lazy dog');
		   */
		  /**
		   * @method digest
		   * @memberof md4
		   * @description Output hash as bytes array
		   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
		   * @returns {Array} Bytes array
		   * @example
		   * md4.digest('The quick brown fox jumps over the lazy dog');
		   */
		  /**
		   * @method array
		   * @memberof md4
		   * @description Output hash as bytes array
		   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
		   * @returns {Array} Bytes array
		   * @example
		   * md4.array('The quick brown fox jumps over the lazy dog');
		   */
		  /**
		   * @method buffer
		   * @memberof md4
		   * @description Output hash as ArrayBuffer
		   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
		   * @returns {ArrayBuffer} ArrayBuffer
		   * @example
		   * md4.buffer('The quick brown fox jumps over the lazy dog');
		   */
		  var createOutputMethod = function (outputType) {
		    return function(message) {
		      return new Md4(true).update(message)[outputType]();
		    }
		  };

		  /**
		   * @method create
		   * @memberof md4
		   * @description Create Md4 object
		   * @returns {Md4} MD4 object.
		   * @example
		   * var hash = md4.create();
		   */
		  /**
		   * @method update
		   * @memberof md4
		   * @description Create and update Md4 object
		   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
		   * @returns {Md4} MD4 object.
		   * @example
		   * var hash = md4.update('The quick brown fox jumps over the lazy dog');
		   * // equal to
		   * var hash = md4.create();
		   * hash.update('The quick brown fox jumps over the lazy dog');
		   */
		  var createMethod = function () {
		    var method = createOutputMethod('hex');
		    if (NODE_JS) {
		      method = nodeWrap(method);
		    }
		    method.create = function () {
		      return new Md4();
		    };
		    method.update = function (message) {
		      return method.create().update(message);
		    };
		    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
		      var type = OUTPUT_TYPES[i];
		      method[type] = createOutputMethod(type);
		    }
		    return method;
		  };

		  var nodeWrap = function (method) {
		    var crypto = crypto$1;
		    var Buffer = require$$0$7.Buffer;
		    var nodeMethod = function (message) {
		      if (typeof message === 'string') {
		        return crypto.createHash('md4').update(message, 'utf8').digest('hex');
		      } else if (ARRAY_BUFFER && message instanceof ArrayBuffer) {
		        message = new Uint8Array(message);
		      } else if (message.length === undefined) {
		        return method(message);
		      }
		      return crypto.createHash('md4').update(new Buffer(message)).digest('hex');
		    };
		    return nodeMethod;
		  };

		  /**
		   * Md4 class
		   * @class Md4
		   * @description This is internal class.
		   * @see {@link md4.create}
		   */
		  function Md4(sharedMemory) {
		    if (sharedMemory) {
		      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =
		      blocks[4] = blocks[5] = blocks[6] = blocks[7] =
		      blocks[8] = blocks[9] = blocks[10] = blocks[11] =
		      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
		      this.blocks = blocks;
		      this.buffer8 = buffer8;
		    } else {
		      if (ARRAY_BUFFER) {
		        var buffer = new ArrayBuffer(68);
		        this.buffer8 = new Uint8Array(buffer);
		        this.blocks = new Uint32Array(buffer);
		      } else {
		        this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		      }
		    }
		    this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = 0;
		    this.finalized = this.hashed = false;
		    this.first = true;
		  }

		  /**
		   * @method update
		   * @memberof Md4
		   * @instance
		   * @description Update hash
		   * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
		   * @returns {Md4} MD4 object.
		   * @see {@link md4.update}
		   */
		  Md4.prototype.update = function (message) {
		    if (this.finalized) {
		      return;
		    }
		    var notString = typeof message !== 'string';
		    if (notString && ARRAY_BUFFER && message instanceof ArrayBuffer) {
		      message = new Uint8Array(message);
		    }
		    var code, index = 0, i, length = message.length || 0, blocks = this.blocks;
		    var buffer8 = this.buffer8;

		    while (index < length) {
		      if (this.hashed) {
		        this.hashed = false;
		        blocks[0] = blocks[16];
		        blocks[16] = blocks[1] = blocks[2] = blocks[3] =
		        blocks[4] = blocks[5] = blocks[6] = blocks[7] =
		        blocks[8] = blocks[9] = blocks[10] = blocks[11] =
		        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
		      }

		      if (notString) {
		        if (ARRAY_BUFFER) {
		          for (i = this.start; index < length && i < 64; ++index) {
		            buffer8[i++] = message[index];
		          }
		        } else {
		          for (i = this.start; index < length && i < 64; ++index) {
		            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
		          }
		        }
		      } else {
		        if (ARRAY_BUFFER) {
		          for (i = this.start; index < length && i < 64; ++index) {
		            code = message.charCodeAt(index);
		            if (code < 0x80) {
		              buffer8[i++] = code;
		            } else if (code < 0x800) {
		              buffer8[i++] = 0xc0 | (code >> 6);
		              buffer8[i++] = 0x80 | (code & 0x3f);
		            } else if (code < 0xd800 || code >= 0xe000) {
		              buffer8[i++] = 0xe0 | (code >> 12);
		              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);
		              buffer8[i++] = 0x80 | (code & 0x3f);
		            } else {
		              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
		              buffer8[i++] = 0xf0 | (code >> 18);
		              buffer8[i++] = 0x80 | ((code >> 12) & 0x3f);
		              buffer8[i++] = 0x80 | ((code >> 6) & 0x3f);
		              buffer8[i++] = 0x80 | (code & 0x3f);
		            }
		          }
		        } else {
		          for (i = this.start; index < length && i < 64; ++index) {
		            code = message.charCodeAt(index);
		            if (code < 0x80) {
		              blocks[i >> 2] |= code << SHIFT[i++ & 3];
		            } else if (code < 0x800) {
		              blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
		              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
		            } else if (code < 0xd800 || code >= 0xe000) {
		              blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
		              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
		              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
		            } else {
		              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
		              blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
		              blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
		              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
		              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
		            }
		          }
		        }
		      }
		      this.lastByteIndex = i;
		      this.bytes += i - this.start;
		      if (i >= 64) {
		        this.start = i - 64;
		        this.hash();
		        this.hashed = true;
		      } else {
		        this.start = i;
		      }
		    }
		    return this;
		  };

		  Md4.prototype.finalize = function () {
		    if (this.finalized) {
		      return;
		    }
		    this.finalized = true;
		    var blocks = this.blocks, i = this.lastByteIndex;
		    blocks[i >> 2] |= EXTRA[i & 3];
		    if (i >= 56) {
		      if (!this.hashed) {
		        this.hash();
		      }
		      blocks[0] = blocks[16];
		      blocks[16] = blocks[1] = blocks[2] = blocks[3] =
		      blocks[4] = blocks[5] = blocks[6] = blocks[7] =
		      blocks[8] = blocks[9] = blocks[10] = blocks[11] =
		      blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
		    }
		    blocks[14] = this.bytes << 3;
		    this.hash();
		  };

		  Md4.prototype.hash = function () {
		    var a, b, c, d, ab, bc, cd, da, blocks = this.blocks;

		    if (this.first) {
		      a = blocks[0] - 1;
		      a = (a << 3) | (a >>> 29);
		      d = ((a & 0xefcdab89) | (~a & 0x98badcfe)) + blocks[1] + 271733878;
		      d = (d << 7) | (d >>> 25);
		      c = ((d & a) | (~d & 0xefcdab89)) + blocks[2] - 1732584194;
		      c = (c << 11) | (c >>> 21);
		      b = ((c & d) | (~c & a)) + blocks[3] - 271733879;
		      b = (b << 19) | (b >>> 13);
		    } else {
		      a = this.h0;
		      b = this.h1;
		      c = this.h2;
		      d = this.h3;
		      a += ((b & c) | (~b & d)) + blocks[0];
		      a = (a << 3) | (a >>> 29);
		      d += ((a & b) | (~a & c)) + blocks[1];
		      d = (d << 7) | (d >>> 25);
		      c += ((d & a) | (~d & b)) + blocks[2];
		      c = (c << 11) | (c >>> 21);
		      b += ((c & d) | (~c & a)) + blocks[3];
		      b = (b << 19) | (b >>> 13);
		    }
		    a += ((b & c) | (~b & d)) + blocks[4];
		    a = (a << 3) | (a >>> 29);
		    d += ((a & b) | (~a & c)) + blocks[5];
		    d = (d << 7) | (d >>> 25);
		    c += ((d & a) | (~d & b)) + blocks[6];
		    c = (c << 11) | (c >>> 21);
		    b += ((c & d) | (~c & a)) + blocks[7];
		    b = (b << 19) | (b >>> 13);
		    a += ((b & c) | (~b & d)) + blocks[8];
		    a = (a << 3) | (a >>> 29);
		    d += ((a & b) | (~a & c)) + blocks[9];
		    d = (d << 7) | (d >>> 25);
		    c += ((d & a) | (~d & b)) + blocks[10];
		    c = (c << 11) | (c >>> 21);
		    b += ((c & d) | (~c & a)) + blocks[11];
		    b = (b << 19) | (b >>> 13);
		    a += ((b & c) | (~b & d)) + blocks[12];
		    a = (a << 3) | (a >>> 29);
		    d += ((a & b) | (~a & c)) + blocks[13];
		    d = (d << 7) | (d >>> 25);
		    c += ((d & a) | (~d & b)) + blocks[14];
		    c = (c << 11) | (c >>> 21);
		    b += ((c & d) | (~c & a)) + blocks[15];
		    b = (b << 19) | (b >>> 13);

		    bc = b & c;
		    a += (bc | (b & d) | (c & d)) + blocks[0] + 1518500249;
		    a = (a << 3) | (a >>> 29);
		    ab = a & b;
		    d += (ab | (a & c) | bc) + blocks[4] + 1518500249;
		    d = (d << 5) | (d >>> 27);
		    da = d & a;
		    c += (da | (d & b) | ab) + blocks[8] + 1518500249;
		    c = (c << 9) | (c >>> 23);
		    cd = c & d;
		    b += (cd | (c & a) | da) + blocks[12] + 1518500249;
		    b = (b << 13) | (b >>> 19);
		    bc = b & c;
		    a += (bc | (b & d) | cd) + blocks[1] + 1518500249;
		    a = (a << 3) | (a >>> 29);
		    ab = a & b;
		    d += (ab | (a & c) | bc) + blocks[5] + 1518500249;
		    d = (d << 5) | (d >>> 27);
		    da = d & a;
		    c += (da | (d & b) | ab) + blocks[9] + 1518500249;
		    c = (c << 9) | (c >>> 23);
		    cd = c & d;
		    b += (cd | (c & a) | da) + blocks[13] + 1518500249;
		    b = (b << 13) | (b >>> 19);
		    bc = b & c;
		    a += (bc | (b & d) | cd) + blocks[2] + 1518500249;
		    a = (a << 3) | (a >>> 29);
		    ab = a & b;
		    d += (ab | (a & c) | bc) + blocks[6] + 1518500249;
		    d = (d << 5) | (d >>> 27);
		    da = d & a;
		    c += (da | (d & b) | ab) + blocks[10] + 1518500249;
		    c = (c << 9) | (c >>> 23);
		    cd = c & d;
		    b += (cd | (c & a) | da) + blocks[14] + 1518500249;
		    b = (b << 13) | (b >>> 19);
		    bc = b & c;
		    a += (bc | (b & d) | cd) + blocks[3] + 1518500249;
		    a = (a << 3) | (a >>> 29);
		    ab = a & b;
		    d += (ab | (a & c) | bc) + blocks[7] + 1518500249;
		    d = (d << 5) | (d >>> 27);
		    da = d & a;
		    c += (da | (d & b) | ab) + blocks[11] + 1518500249;
		    c = (c << 9) | (c >>> 23);
		    b += ((c & d) | (c & a) | da) + blocks[15] + 1518500249;
		    b = (b << 13) | (b >>> 19);

		    bc = b ^ c;
		    a += (bc ^ d) + blocks[0] + 1859775393;
		    a = (a << 3) | (a >>> 29);
		    d += (bc ^ a) + blocks[8] + 1859775393;
		    d = (d << 9) | (d >>> 23);
		    da = d ^ a;
		    c += (da ^ b) + blocks[4] + 1859775393;
		    c = (c << 11) | (c >>> 21);
		    b += (da ^ c) + blocks[12] + 1859775393;
		    b = (b << 15) | (b >>> 17);
		    bc = b ^ c;
		    a += (bc ^ d) + blocks[2] + 1859775393;
		    a = (a << 3) | (a >>> 29);
		    d += (bc ^ a) + blocks[10] + 1859775393;
		    d = (d << 9) | (d >>> 23);
		    da = d ^ a;
		    c += (da ^ b) + blocks[6] + 1859775393;
		    c = (c << 11) | (c >>> 21);
		    b += (da ^ c) + blocks[14] + 1859775393;
		    b = (b << 15) | (b >>> 17);
		    bc = b ^ c;
		    a += (bc ^ d) + blocks[1] + 1859775393;
		    a = (a << 3) | (a >>> 29);
		    d += (bc ^ a) + blocks[9] + 1859775393;
		    d = (d << 9) | (d >>> 23);
		    da = d ^ a;
		    c += (da ^ b) + blocks[5] + 1859775393;
		    c = (c << 11) | (c >>> 21);
		    b += (da ^ c) + blocks[13] + 1859775393;
		    b = (b << 15) | (b >>> 17);
		    bc = b ^ c;
		    a += (bc ^ d) + blocks[3] + 1859775393;
		    a = (a << 3) | (a >>> 29);
		    d += (bc ^ a) + blocks[11] + 1859775393;
		    d = (d << 9) | (d >>> 23);
		    da = d ^ a;
		    c += (da ^ b) + blocks[7] + 1859775393;
		    c = (c << 11) | (c >>> 21);
		    b += (da ^ c) + blocks[15] + 1859775393;
		    b = (b << 15) | (b >>> 17);

		    if (this.first) {
		      this.h0 = a + 1732584193 << 0;
		      this.h1 = b - 271733879 << 0;
		      this.h2 = c - 1732584194 << 0;
		      this.h3 = d + 271733878 << 0;
		      this.first = false;
		    } else {
		      this.h0 = this.h0 + a << 0;
		      this.h1 = this.h1 + b << 0;
		      this.h2 = this.h2 + c << 0;
		      this.h3 = this.h3 + d << 0;
		    }
		  };

		  /**
		   * @method hex
		   * @memberof Md4
		   * @instance
		   * @description Output hash as hex string
		   * @returns {String} Hex string
		   * @see {@link md4.hex}
		   * @example
		   * hash.hex();
		   */
		  Md4.prototype.hex = function () {
		    this.finalize();

		    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;

		    return HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +
		      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +
		      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +
		      HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +
		      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +
		      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +
		      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +
		      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +
		      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +
		      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +
		      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +
		      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +
		      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +
		      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +
		      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +
		      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F];
		  };

		  /**
		   * @method toString
		   * @memberof Md4
		   * @instance
		   * @description Output hash as hex string
		   * @returns {String} Hex string
		   * @see {@link md4.hex}
		   * @example
		   * hash.toString();
		   */
		  Md4.prototype.toString = Md4.prototype.hex;

		  /**
		   * @method digest
		   * @memberof Md4
		   * @instance
		   * @description Output hash as bytes array
		   * @returns {Array} Bytes array
		   * @see {@link md4.digest}
		   * @example
		   * hash.digest();
		   */
		  Md4.prototype.digest = function() {
		    this.finalize();

		    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
		    return [
		      h0 & 0xFF, (h0 >> 8) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 24) & 0xFF,
		      h1 & 0xFF, (h1 >> 8) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 24) & 0xFF,
		      h2 & 0xFF, (h2 >> 8) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 24) & 0xFF,
		      h3 & 0xFF, (h3 >> 8) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 24) & 0xFF
		    ];
		  };

		  /**
		   * @method array
		   * @memberof Md4
		   * @instance
		   * @description Output hash as bytes array
		   * @returns {Array} Bytes array
		   * @see {@link md4.array}
		   * @example
		   * hash.array();
		   */
		  Md4.prototype.array = Md4.prototype.digest;

		  /**
		   * @method arrayBuffer
		   * @memberof Md4
		   * @instance
		   * @description Output hash as ArrayBuffer
		   * @returns {ArrayBuffer} ArrayBuffer
		   * @see {@link md4.arrayBuffer}
		   * @example
		   * hash.arrayBuffer();
		   */
		  Md4.prototype.arrayBuffer = function() {
		    this.finalize();

		    var buffer = new ArrayBuffer(16);
		    var blocks = new Uint32Array(buffer);
		    blocks[0] = this.h0;
		    blocks[1] = this.h1;
		    blocks[2] = this.h2;
		    blocks[3] = this.h3;
		    return buffer;
		  };

		  /**
		   * @method buffer
		   * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
		   * @memberof Md4
		   * @instance
		   * @description Output hash as ArrayBuffer
		   * @returns {ArrayBuffer} ArrayBuffer
		   * @see {@link md4.buffer}
		   * @example
		   * hash.buffer();
		   */
		  Md4.prototype.buffer = Md4.prototype.arrayBuffer;

		  var exports$1 = createMethod();

		  if (COMMON_JS) {
		    module.exports = exports$1;
		  } else {
		    /**
		     * @method md4
		     * @description MD4 hash function, export to global in browsers.
		     * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
		     * @returns {String} md4 hashes
		     * @example
		     * md4(''); // 31d6cfe0d16ae931b73c59d7e0c089c0
		     * md4('The quick brown fox jumps over the lazy dog'); // 1bee69a46ba811185c194762abaeae90
		     * md4('The quick brown fox jumps over the lazy dog.'); // 2812c6c7136898c51f6f6739ad08750e
		     *
		     * // It also supports UTF-8 encoding
		     * md4(''); // 223088bf7bd45a16436b15360c5fc5a0
		     *
		     * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`
		     * md4([]); // 31d6cfe0d16ae931b73c59d7e0c089c0
		     * md4(new Uint8Array([])); // 31d6cfe0d16ae931b73c59d7e0c089c0
		     */
		    root.md4 = exports$1;
		  }
		})(); 
	} (md4));
	return md4.exports;
}

var hasRequiredNtlmPayload;

function requireNtlmPayload () {
	if (hasRequiredNtlmPayload) return ntlmPayload.exports;
	hasRequiredNtlmPayload = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		var crypto = _interopRequireWildcard(crypto$1);
		var _jsMd = _interopRequireDefault(requireMd4());
		function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
		function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		class NTLMResponsePayload {
		  constructor(loginData) {
		    this.data = this.createResponse(loginData);
		  }
		  toString(indent = '') {
		    return indent + 'NTLM Auth';
		  }
		  createResponse(challenge) {
		    const client_nonce = this.createClientNonce();
		    const lmv2len = 24;
		    const ntlmv2len = 16;
		    const domain = challenge.domain;
		    const username = challenge.userName;
		    const password = challenge.password;
		    const ntlmData = challenge.ntlmpacket;
		    const server_data = ntlmData.target;
		    const server_nonce = ntlmData.nonce;
		    const bufferLength = 64 + domain.length * 2 + username.length * 2 + lmv2len + ntlmv2len + 8 + 8 + 8 + 4 + server_data.length + 4;
		    const data = new _writableTrackingBuffer.default(bufferLength);
		    data.position = 0;
		    data.writeString('NTLMSSP\u0000', 'utf8');
		    data.writeUInt32LE(0x03);
		    const baseIdx = 64;
		    const dnIdx = baseIdx;
		    const unIdx = dnIdx + domain.length * 2;
		    const l2Idx = unIdx + username.length * 2;
		    const ntIdx = l2Idx + lmv2len;
		    data.writeUInt16LE(lmv2len);
		    data.writeUInt16LE(lmv2len);
		    data.writeUInt32LE(l2Idx);
		    data.writeUInt16LE(ntlmv2len);
		    data.writeUInt16LE(ntlmv2len);
		    data.writeUInt32LE(ntIdx);
		    data.writeUInt16LE(domain.length * 2);
		    data.writeUInt16LE(domain.length * 2);
		    data.writeUInt32LE(dnIdx);
		    data.writeUInt16LE(username.length * 2);
		    data.writeUInt16LE(username.length * 2);
		    data.writeUInt32LE(unIdx);
		    data.writeUInt16LE(0);
		    data.writeUInt16LE(0);
		    data.writeUInt32LE(baseIdx);
		    data.writeUInt16LE(0);
		    data.writeUInt16LE(0);
		    data.writeUInt32LE(baseIdx);
		    data.writeUInt16LE(0x8201);
		    data.writeUInt16LE(0x08);
		    data.writeString(domain, 'ucs2');
		    data.writeString(username, 'ucs2');
		    const lmv2Data = this.lmv2Response(domain, username, password, server_nonce, client_nonce);
		    data.copyFrom(lmv2Data);
		    const genTime = new Date().getTime();
		    const ntlmDataBuffer = this.ntlmv2Response(domain, username, password, server_nonce, server_data, client_nonce, genTime);
		    data.copyFrom(ntlmDataBuffer);
		    data.writeUInt32LE(0x0101);
		    data.writeUInt32LE(0x0000);
		    const timestamp = this.createTimestamp(genTime);
		    data.copyFrom(timestamp);
		    data.copyFrom(client_nonce);
		    data.writeUInt32LE(0x0000);
		    data.copyFrom(server_data);
		    data.writeUInt32LE(0x0000);
		    return data.data;
		  }
		  createClientNonce() {
		    const client_nonce = Buffer.alloc(8, 0);
		    let nidx = 0;
		    while (nidx < 8) {
		      client_nonce.writeUInt8(Math.ceil(Math.random() * 255), nidx);
		      nidx++;
		    }
		    return client_nonce;
		  }
		  ntlmv2Response(domain, user, password, serverNonce, targetInfo, clientNonce, mytime) {
		    const timestamp = this.createTimestamp(mytime);
		    const hash = this.ntv2Hash(domain, user, password);
		    const dataLength = 40 + targetInfo.length;
		    const data = Buffer.alloc(dataLength, 0);
		    serverNonce.copy(data, 0, 0, 8);
		    data.writeUInt32LE(0x101, 8);
		    data.writeUInt32LE(0x0, 12);
		    timestamp.copy(data, 16, 0, 8);
		    clientNonce.copy(data, 24, 0, 8);
		    data.writeUInt32LE(0x0, 32);
		    targetInfo.copy(data, 36, 0, targetInfo.length);
		    data.writeUInt32LE(0x0, 36 + targetInfo.length);
		    return this.hmacMD5(data, hash);
		  }
		  createTimestamp(time) {
		    const tenthsOfAMicrosecond = (BigInt(time) + BigInt(11644473600)) * BigInt(10000000);
		    const lo = Number(tenthsOfAMicrosecond & BigInt(0xffffffff));
		    const hi = Number(tenthsOfAMicrosecond >> BigInt(32) & BigInt(0xffffffff));
		    const result = Buffer.alloc(8);
		    result.writeUInt32LE(lo, 0);
		    result.writeUInt32LE(hi, 4);
		    return result;
		  }
		  lmv2Response(domain, user, password, serverNonce, clientNonce) {
		    const hash = this.ntv2Hash(domain, user, password);
		    const data = Buffer.alloc(serverNonce.length + clientNonce.length, 0);
		    serverNonce.copy(data);
		    clientNonce.copy(data, serverNonce.length, 0, clientNonce.length);
		    const newhash = this.hmacMD5(data, hash);
		    const response = Buffer.alloc(newhash.length + clientNonce.length, 0);
		    newhash.copy(response);
		    clientNonce.copy(response, newhash.length, 0, clientNonce.length);
		    return response;
		  }
		  ntv2Hash(domain, user, password) {
		    const hash = this.ntHash(password);
		    const identity = Buffer.from(user.toUpperCase() + domain.toUpperCase(), 'ucs2');
		    return this.hmacMD5(identity, hash);
		  }
		  ntHash(text) {
		    const unicodeString = Buffer.from(text, 'ucs2');
		    return Buffer.from(_jsMd.default.arrayBuffer(unicodeString));
		  }
		  hmacMD5(data, key) {
		    return crypto.createHmac('MD5', key).update(data).digest();
		  }
		}
		exports$1.default = NTLMResponsePayload;
		module.exports = NTLMResponsePayload;
		
	} (ntlmPayload, ntlmPayload.exports));
	return ntlmPayload.exports;
}

var request$1 = {exports: {}};

var errors$1 = {};

var hasRequiredErrors$1;

function requireErrors$1 () {
	if (hasRequiredErrors$1) return errors$1;
	hasRequiredErrors$1 = 1;

	Object.defineProperty(errors$1, "__esModule", {
	  value: true
	});
	errors$1.RequestError = errors$1.InputError = errors$1.ConnectionError = void 0;
	class ConnectionError extends Error {
	  constructor(message, code, options) {
	    super(message, options);
	    this.code = code;
	  }
	}
	errors$1.ConnectionError = ConnectionError;
	class RequestError extends Error {
	  constructor(message, code, options) {
	    super(message, options);
	    this.code = code;
	  }
	}
	errors$1.RequestError = RequestError;
	class InputError extends TypeError {}
	errors$1.InputError = InputError;
	
	return errors$1;
}

var types = {};

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;

	Object.defineProperty(types, "__esModule", {
	  value: true
	});
	types.SQLServerStatementColumnEncryptionSetting = types.SQLServerEncryptionType = types.DescribeParameterEncryptionResultSet2 = types.DescribeParameterEncryptionResultSet1 = void 0;
	// This code is based on the `mssql-jdbc` library published under the conditions of MIT license.
	// Copyright (c) 2019 Microsoft Corporation
	types.SQLServerEncryptionType = /*#__PURE__*/function (SQLServerEncryptionType) {
	  SQLServerEncryptionType[SQLServerEncryptionType["Deterministic"] = 1] = "Deterministic";
	  SQLServerEncryptionType[SQLServerEncryptionType["Randomized"] = 2] = "Randomized";
	  SQLServerEncryptionType[SQLServerEncryptionType["PlainText"] = 0] = "PlainText";
	  return SQLServerEncryptionType;
	}({});
	// Fields in the first resultset of "sp_describe_parameter_encryption"
	// We expect the server to return the fields in the resultset in the same order as mentioned below.
	// If the server changes the below order, then transparent parameter encryption will break.
	types.DescribeParameterEncryptionResultSet1 = /*#__PURE__*/function (DescribeParameterEncryptionResultSet1) {
	  DescribeParameterEncryptionResultSet1[DescribeParameterEncryptionResultSet1["KeyOrdinal"] = 0] = "KeyOrdinal";
	  DescribeParameterEncryptionResultSet1[DescribeParameterEncryptionResultSet1["DbId"] = 1] = "DbId";
	  DescribeParameterEncryptionResultSet1[DescribeParameterEncryptionResultSet1["KeyId"] = 2] = "KeyId";
	  DescribeParameterEncryptionResultSet1[DescribeParameterEncryptionResultSet1["KeyVersion"] = 3] = "KeyVersion";
	  DescribeParameterEncryptionResultSet1[DescribeParameterEncryptionResultSet1["KeyMdVersion"] = 4] = "KeyMdVersion";
	  DescribeParameterEncryptionResultSet1[DescribeParameterEncryptionResultSet1["EncryptedKey"] = 5] = "EncryptedKey";
	  DescribeParameterEncryptionResultSet1[DescribeParameterEncryptionResultSet1["ProviderName"] = 6] = "ProviderName";
	  DescribeParameterEncryptionResultSet1[DescribeParameterEncryptionResultSet1["KeyPath"] = 7] = "KeyPath";
	  DescribeParameterEncryptionResultSet1[DescribeParameterEncryptionResultSet1["KeyEncryptionAlgorithm"] = 8] = "KeyEncryptionAlgorithm";
	  return DescribeParameterEncryptionResultSet1;
	}({}); // Fields in the second resultset of "sp_describe_parameter_encryption"
	// We expect the server to return the fields in the resultset in the same order as mentioned below.
	// If the server changes the below order, then transparent parameter encryption will break.
	types.DescribeParameterEncryptionResultSet2 = /*#__PURE__*/function (DescribeParameterEncryptionResultSet2) {
	  DescribeParameterEncryptionResultSet2[DescribeParameterEncryptionResultSet2["ParameterOrdinal"] = 0] = "ParameterOrdinal";
	  DescribeParameterEncryptionResultSet2[DescribeParameterEncryptionResultSet2["ParameterName"] = 1] = "ParameterName";
	  DescribeParameterEncryptionResultSet2[DescribeParameterEncryptionResultSet2["ColumnEncryptionAlgorithm"] = 2] = "ColumnEncryptionAlgorithm";
	  DescribeParameterEncryptionResultSet2[DescribeParameterEncryptionResultSet2["ColumnEncrytionType"] = 3] = "ColumnEncrytionType";
	  DescribeParameterEncryptionResultSet2[DescribeParameterEncryptionResultSet2["ColumnEncryptionKeyOrdinal"] = 4] = "ColumnEncryptionKeyOrdinal";
	  DescribeParameterEncryptionResultSet2[DescribeParameterEncryptionResultSet2["NormalizationRuleVersion"] = 5] = "NormalizationRuleVersion";
	  return DescribeParameterEncryptionResultSet2;
	}({});
	types.SQLServerStatementColumnEncryptionSetting = /*#__PURE__*/function (SQLServerStatementColumnEncryptionSetting) {
	  SQLServerStatementColumnEncryptionSetting[SQLServerStatementColumnEncryptionSetting["UseConnectionSetting"] = 0] = "UseConnectionSetting";
	  SQLServerStatementColumnEncryptionSetting[SQLServerStatementColumnEncryptionSetting["Enabled"] = 1] = "Enabled";
	  SQLServerStatementColumnEncryptionSetting[SQLServerStatementColumnEncryptionSetting["ResultSetOnly"] = 2] = "ResultSetOnly";
	  SQLServerStatementColumnEncryptionSetting[SQLServerStatementColumnEncryptionSetting["Disabled"] = 3] = "Disabled";
	  return SQLServerStatementColumnEncryptionSetting;
	}({});
	
	return types;
}

var hasRequiredRequest$1;

function requireRequest$1 () {
	if (hasRequiredRequest$1) return request$1.exports;
	hasRequiredRequest$1 = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _events = require$$0$5;
		var _errors = requireErrors$1();
		var _types = requireTypes();
		/**
		 * The callback is called when the request has completed, either successfully or with an error.
		 * If an error occurs during execution of the statement(s), then `err` will describe the error.
		 *
		 * As only one request at a time may be executed on a connection, another request should not
		 * be initiated until this callback is called.
		 *
		 * This callback is called before `requestCompleted` is emitted.
		 */

		/**
		 * ```js
		 * const { Request } = require('tedious');
		 * const request = new Request("select 42, 'hello world'", (err, rowCount) {
		 *   // Request completion callback...
		 * });
		 * connection.execSql(request);
		 * ```
		 */
		class Request extends _events.EventEmitter {
		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * This event, describing result set columns, will be emitted before row
		   * events are emitted. This event may be emitted multiple times when more
		   * than one recordset is produced by the statement.
		   *
		   * An array like object, where the columns can be accessed either by index
		   * or name. Columns with a name that is an integer are not accessible by name,
		   * as it would be interpreted as an array index.
		   */

		  /**
		   * The request has been prepared and can be used in subsequent calls to execute and unprepare.
		   */

		  /**
		   * The request encountered an error and has not been prepared.
		   */

		  /**
		   * A row resulting from execution of the SQL statement.
		   */

		  /**
		   * All rows from a result set have been provided (through `row` events).
		   *
		   * This token is used to indicate the completion of a SQL statement.
		   * As multiple SQL statements can be sent to the server in a single SQL batch, multiple `done` can be generated.
		   * An `done` event is emitted for each SQL statement in the SQL batch except variable declarations.
		   * For execution of SQL statements within stored procedures, `doneProc` and `doneInProc` events are used in place of `done`.
		   *
		   * If you are using [[Connection.execSql]] then SQL server may treat the multiple calls with the same query as a stored procedure.
		   * When this occurs, the `doneProc` and `doneInProc` events may be emitted instead. You must handle both events to ensure complete coverage.
		   */

		  /**
		   * `request.on('doneInProc', function (rowCount, more, rows) { });`
		   *
		   * Indicates the completion status of a SQL statement within a stored procedure. All rows from a statement
		   * in a stored procedure have been provided (through `row` events).
		   *
		   * This event may also occur when executing multiple calls with the same query using [[execSql]].
		   */

		  /**
		   * Indicates the completion status of a stored procedure. This is also generated for stored procedures
		   * executed through SQL statements.\
		   * This event may also occur when executing multiple calls with the same query using [[execSql]].
		   */

		  /**
		   * A value for an output parameter (that was added to the request with [[addOutputParameter]]).
		   * See also `Using Parameters`.
		   */

		  /**
		   * This event gives the columns by which data is ordered, if `ORDER BY` clause is executed in SQL Server.
		   */

		  on(event, listener) {
		    return super.on(event, listener);
		  }

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  emit(event, ...args) {
		    return super.emit(event, ...args);
		  }

		  /**
		   * @param sqlTextOrProcedure
		   *   The SQL statement to be executed
		   *
		   * @param callback
		   *   The callback to execute once the request has been fully completed.
		   */
		  constructor(sqlTextOrProcedure, callback, options) {
		    super();
		    this.sqlTextOrProcedure = sqlTextOrProcedure;
		    this.parameters = [];
		    this.parametersByName = {};
		    this.preparing = false;
		    this.handle = undefined;
		    this.canceled = false;
		    this.paused = false;
		    this.error = undefined;
		    this.connection = undefined;
		    this.timeout = undefined;
		    this.userCallback = callback;
		    this.statementColumnEncryptionSetting = options && options.statementColumnEncryptionSetting || _types.SQLServerStatementColumnEncryptionSetting.UseConnectionSetting;
		    this.cryptoMetadataLoaded = false;
		    this.callback = function (err, rowCount, rows) {
		      if (this.preparing) {
		        this.preparing = false;
		        if (err) {
		          this.emit('error', err);
		        } else {
		          this.emit('prepared');
		        }
		      } else {
		        this.userCallback(err, rowCount, rows);
		        this.emit('requestCompleted');
		      }
		    };
		  }

		  /**
		   * @param name
		   *   The parameter name. This should correspond to a parameter in the SQL,
		   *   or a parameter that a called procedure expects. The name should not start with `@`.
		   *
		   * @param type
		   *   One of the supported data types.
		   *
		   * @param value
		   *   The value that the parameter is to be given. The Javascript type of the
		   *   argument should match that documented for data types.
		   *
		   * @param options
		   *   Additional type options. Optional.
		   */
		  // TODO: `type` must be a valid TDS value type
		  addParameter(name, type, value, options) {
		    const {
		      output = false,
		      length,
		      precision,
		      scale
		    } = options ?? {};
		    const parameter = {
		      type: type,
		      name: name,
		      value: value,
		      output: output,
		      length: length,
		      precision: precision,
		      scale: scale
		    };
		    this.parameters.push(parameter);
		    this.parametersByName[name] = parameter;
		  }

		  /**
		   * @param name
		   *   The parameter name. This should correspond to a parameter in the SQL,
		   *   or a parameter that a called procedure expects.
		   *
		   * @param type
		   *   One of the supported data types.
		   *
		   * @param value
		   *   The value that the parameter is to be given. The Javascript type of the
		   *   argument should match that documented for data types
		   *
		   * @param options
		   *   Additional type options. Optional.
		   */
		  addOutputParameter(name, type, value, options) {
		    this.addParameter(name, type, value, {
		      ...options,
		      output: true
		    });
		  }

		  /**
		   * @private
		   */
		  makeParamsParameter(parameters) {
		    let paramsParameter = '';
		    for (let i = 0, len = parameters.length; i < len; i++) {
		      const parameter = parameters[i];
		      if (paramsParameter.length > 0) {
		        paramsParameter += ', ';
		      }
		      paramsParameter += '@' + parameter.name + ' ';
		      paramsParameter += parameter.type.declaration(parameter);
		      if (parameter.output) {
		        paramsParameter += ' OUTPUT';
		      }
		    }
		    return paramsParameter;
		  }

		  /**
		   * @private
		   */
		  validateParameters(collation) {
		    for (let i = 0, len = this.parameters.length; i < len; i++) {
		      const parameter = this.parameters[i];
		      try {
		        parameter.value = parameter.type.validate(parameter.value, collation);
		      } catch (error) {
		        throw new _errors.RequestError('Validation failed for parameter \'' + parameter.name + '\'. ' + error.message, 'EPARAM', {
		          cause: error
		        });
		      }
		    }
		  }

		  /**
		   * Temporarily suspends the flow of data from the database. No more `row` events will be emitted until [[resume] is called.
		   * If this request is already in a paused state, calling [[pause]] has no effect.
		   */
		  pause() {
		    if (this.paused) {
		      return;
		    }
		    this.emit('pause');
		    this.paused = true;
		  }

		  /**
		   * Resumes the flow of data from the database.
		   * If this request is not in a paused state, calling [[resume]] has no effect.
		   */
		  resume() {
		    if (!this.paused) {
		      return;
		    }
		    this.paused = false;
		    this.emit('resume');
		  }

		  /**
		   * Cancels a request while waiting for a server response.
		   */
		  cancel() {
		    if (this.canceled) {
		      return;
		    }
		    this.canceled = true;
		    this.emit('cancel');
		  }

		  /**
		   * Sets a timeout for this request.
		   *
		   * @param timeout
		   *   The number of milliseconds before the request is considered failed,
		   *   or `0` for no timeout. When no timeout is set for the request,
		   *   the [[ConnectionOptions.requestTimeout]] of the [[Connection]] is used.
		   */
		  setTimeout(timeout) {
		    this.timeout = timeout;
		  }
		}
		exports$1.default = Request;
		module.exports = Request;
		
	} (request$1, request$1.exports));
	return request$1.exports;
}

var rpcrequestPayload = {exports: {}};

var allHeaders = {};

var hasRequiredAllHeaders;

function requireAllHeaders () {
	if (hasRequiredAllHeaders) return allHeaders;
	hasRequiredAllHeaders = 1;

	Object.defineProperty(allHeaders, "__esModule", {
	  value: true
	});
	allHeaders.writeToTrackingBuffer = writeToTrackingBuffer;
	const TYPE = {
	  TXN_DESCRIPTOR: 2};
	const TXNDESCRIPTOR_HEADER_DATA_LEN = 4 + 8;
	const TXNDESCRIPTOR_HEADER_LEN = 4 + 2 + TXNDESCRIPTOR_HEADER_DATA_LEN;
	function writeToTrackingBuffer(buffer, txnDescriptor, outstandingRequestCount) {
	  buffer.writeUInt32LE(0);
	  buffer.writeUInt32LE(TXNDESCRIPTOR_HEADER_LEN);
	  buffer.writeUInt16LE(TYPE.TXN_DESCRIPTOR);
	  buffer.writeBuffer(txnDescriptor);
	  buffer.writeUInt32LE(outstandingRequestCount);
	  const data = buffer.data;
	  data.writeUInt32LE(data.length, 0);
	  return buffer;
	}
	
	return allHeaders;
}

var hasRequiredRpcrequestPayload;

function requireRpcrequestPayload () {
	if (hasRequiredRpcrequestPayload) return rpcrequestPayload.exports;
	hasRequiredRpcrequestPayload = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		var _allHeaders = requireAllHeaders();
		var _errors = requireErrors$1();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		// const OPTION = {
		//   WITH_RECOMPILE: 0x01,
		//   NO_METADATA: 0x02,
		//   REUSE_METADATA: 0x04
		// };

		const STATUS = {
		  BY_REF_VALUE: 0x01};

		/*
		  s2.2.6.5
		 */
		class RpcRequestPayload {
		  constructor(procedure, parameters, txnDescriptor, options, collation) {
		    this.procedure = procedure;
		    this.parameters = parameters;
		    this.options = options;
		    this.txnDescriptor = txnDescriptor;
		    this.collation = collation;
		  }
		  [Symbol.iterator]() {
		    return this.generateData();
		  }
		  *generateData() {
		    const buffer = new _writableTrackingBuffer.default(500);
		    if (this.options.tdsVersion >= '7_2') {
		      const outstandingRequestCount = 1;
		      (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
		    }
		    if (typeof this.procedure === 'string') {
		      buffer.writeUsVarchar(this.procedure);
		    } else {
		      buffer.writeUShort(0xFFFF);
		      buffer.writeUShort(this.procedure);
		    }
		    const optionFlags = 0;
		    buffer.writeUInt16LE(optionFlags);
		    yield buffer.data;
		    const parametersLength = this.parameters.length;
		    for (let i = 0; i < parametersLength; i++) {
		      yield* this.generateParameterData(this.parameters[i]);
		    }
		  }
		  toString(indent = '') {
		    return indent + ('RPC Request - ' + this.procedure);
		  }
		  *generateParameterData(parameter) {
		    const buffer = new _writableTrackingBuffer.default(1 + 2 + Buffer.byteLength(parameter.name, 'ucs-2') + 1);
		    if (parameter.name) {
		      buffer.writeBVarchar('@' + parameter.name);
		    } else {
		      buffer.writeBVarchar('');
		    }
		    let statusFlags = 0;
		    if (parameter.output) {
		      statusFlags |= STATUS.BY_REF_VALUE;
		    }
		    buffer.writeUInt8(statusFlags);
		    yield buffer.data;
		    const param = {
		      value: parameter.value
		    };
		    const type = parameter.type;
		    if ((type.id & 0x30) === 0x20) {
		      if (parameter.length) {
		        param.length = parameter.length;
		      } else if (type.resolveLength) {
		        param.length = type.resolveLength(parameter);
		      }
		    }
		    if (parameter.precision) {
		      param.precision = parameter.precision;
		    } else if (type.resolvePrecision) {
		      param.precision = type.resolvePrecision(parameter);
		    }
		    if (parameter.scale) {
		      param.scale = parameter.scale;
		    } else if (type.resolveScale) {
		      param.scale = type.resolveScale(parameter);
		    }
		    if (this.collation) {
		      param.collation = this.collation;
		    }
		    yield type.generateTypeInfo(param, this.options);
		    yield type.generateParameterLength(param, this.options);
		    try {
		      yield* type.generateParameterData(param, this.options);
		    } catch (error) {
		      throw new _errors.InputError(`Input parameter '${parameter.name}' could not be validated`, {
		        cause: error
		      });
		    }
		  }
		}
		exports$1.default = RpcRequestPayload;
		module.exports = RpcRequestPayload;
		
	} (rpcrequestPayload, rpcrequestPayload.exports));
	return rpcrequestPayload.exports;
}

var sqlbatchPayload = {exports: {}};

var hasRequiredSqlbatchPayload;

function requireSqlbatchPayload () {
	if (hasRequiredSqlbatchPayload) return sqlbatchPayload.exports;
	hasRequiredSqlbatchPayload = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		var _allHeaders = requireAllHeaders();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/*
		  s2.2.6.6
		 */
		class SqlBatchPayload {
		  constructor(sqlText, txnDescriptor, options) {
		    this.sqlText = sqlText;
		    this.txnDescriptor = txnDescriptor;
		    this.options = options;
		  }
		  *[Symbol.iterator]() {
		    if (this.options.tdsVersion >= '7_2') {
		      const buffer = new _writableTrackingBuffer.default(18, 'ucs2');
		      const outstandingRequestCount = 1;
		      (0, _allHeaders.writeToTrackingBuffer)(buffer, this.txnDescriptor, outstandingRequestCount);
		      yield buffer.data;
		    }
		    yield Buffer.from(this.sqlText, 'ucs2');
		  }
		  toString(indent = '') {
		    return indent + ('SQL Batch - ' + this.sqlText);
		  }
		}
		exports$1.default = SqlBatchPayload;
		module.exports = SqlBatchPayload;
		
	} (sqlbatchPayload, sqlbatchPayload.exports));
	return sqlbatchPayload.exports;
}

var messageIo = {exports: {}};

var nativeDuplexpair;
var hasRequiredNativeDuplexpair;

function requireNativeDuplexpair () {
	if (hasRequiredNativeDuplexpair) return nativeDuplexpair;
	hasRequiredNativeDuplexpair = 1;
	const Duplex = require$$0$6.Duplex;

	const kCallback = Symbol('Callback');
	const kOtherSide = Symbol('Other');

	class DuplexSocket extends Duplex {
	  constructor(options) {
	    super(options);
	    this[kCallback] = null;
	    this[kOtherSide] = null;
	  }

	  _read() {
	    const callback = this[kCallback];
	    if (callback) {
	      this[kCallback] = null;
	      callback();
	    }
	  }

	  _write(chunk, encoding, callback) {
	    this[kOtherSide][kCallback] = callback;
	    this[kOtherSide].push(chunk);
	  }

	  _final(callback) {
	    this[kOtherSide].on('end', callback);
	    this[kOtherSide].push(null);
	  }
	}

	class DuplexPair {
	  constructor(options) {
	    this.socket1 = new DuplexSocket(options);
	    this.socket2 = new DuplexSocket(options);
	    this.socket1[kOtherSide] = this.socket2;
	    this.socket2[kOtherSide] = this.socket1;
	  }
	}

	nativeDuplexpair = DuplexPair;
	return nativeDuplexpair;
}

var message = {exports: {}};

var hasRequiredMessage;

function requireMessage () {
	if (hasRequiredMessage) return message.exports;
	hasRequiredMessage = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _stream = require$$0$6;
		class Message extends _stream.PassThrough {
		  constructor({
		    type,
		    resetConnection = false
		  }) {
		    super();
		    this.type = type;
		    this.resetConnection = resetConnection;
		    this.ignore = false;
		  }
		}
		exports$1.default = Message;
		module.exports = Message;
		
	} (message, message.exports));
	return message.exports;
}

var incomingMessageStream = {exports: {}};

var bl = {exports: {}};

var ours = {exports: {}};

var stream = {exports: {}};

var primordials;
var hasRequiredPrimordials;

function requirePrimordials () {
	if (hasRequiredPrimordials) return primordials;
	hasRequiredPrimordials = 1;

	/*
	  This file is a reduced and adapted version of the main lib/internal/per_context/primordials.js file defined at

	  https://github.com/nodejs/node/blob/main/lib/internal/per_context/primordials.js

	  Don't try to replace with the original file and keep it up to date with the upstream file.
	*/

	// This is a simplified version of AggregateError
	class AggregateError extends Error {
	  constructor(errors) {
	    if (!Array.isArray(errors)) {
	      throw new TypeError(`Expected input to be an Array, got ${typeof errors}`)
	    }
	    let message = '';
	    for (let i = 0; i < errors.length; i++) {
	      message += `    ${errors[i].stack}\n`;
	    }
	    super(message);
	    this.name = 'AggregateError';
	    this.errors = errors;
	  }
	}
	primordials = {
	  AggregateError,
	  ArrayIsArray(self) {
	    return Array.isArray(self)
	  },
	  ArrayPrototypeIncludes(self, el) {
	    return self.includes(el)
	  },
	  ArrayPrototypeIndexOf(self, el) {
	    return self.indexOf(el)
	  },
	  ArrayPrototypeJoin(self, sep) {
	    return self.join(sep)
	  },
	  ArrayPrototypeMap(self, fn) {
	    return self.map(fn)
	  },
	  ArrayPrototypePop(self, el) {
	    return self.pop(el)
	  },
	  ArrayPrototypePush(self, el) {
	    return self.push(el)
	  },
	  ArrayPrototypeSlice(self, start, end) {
	    return self.slice(start, end)
	  },
	  Error,
	  FunctionPrototypeCall(fn, thisArgs, ...args) {
	    return fn.call(thisArgs, ...args)
	  },
	  FunctionPrototypeSymbolHasInstance(self, instance) {
	    return Function.prototype[Symbol.hasInstance].call(self, instance)
	  },
	  MathFloor: Math.floor,
	  Number,
	  NumberIsInteger: Number.isInteger,
	  NumberIsNaN: Number.isNaN,
	  NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
	  NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
	  NumberParseInt: Number.parseInt,
	  ObjectDefineProperties(self, props) {
	    return Object.defineProperties(self, props)
	  },
	  ObjectDefineProperty(self, name, prop) {
	    return Object.defineProperty(self, name, prop)
	  },
	  ObjectGetOwnPropertyDescriptor(self, name) {
	    return Object.getOwnPropertyDescriptor(self, name)
	  },
	  ObjectKeys(obj) {
	    return Object.keys(obj)
	  },
	  ObjectSetPrototypeOf(target, proto) {
	    return Object.setPrototypeOf(target, proto)
	  },
	  Promise,
	  PromisePrototypeCatch(self, fn) {
	    return self.catch(fn)
	  },
	  PromisePrototypeThen(self, thenFn, catchFn) {
	    return self.then(thenFn, catchFn)
	  },
	  PromiseReject(err) {
	    return Promise.reject(err)
	  },
	  PromiseResolve(val) {
	    return Promise.resolve(val)
	  },
	  ReflectApply: Reflect.apply,
	  RegExpPrototypeTest(self, value) {
	    return self.test(value)
	  },
	  SafeSet: Set,
	  String,
	  StringPrototypeSlice(self, start, end) {
	    return self.slice(start, end)
	  },
	  StringPrototypeToLowerCase(self) {
	    return self.toLowerCase()
	  },
	  StringPrototypeToUpperCase(self) {
	    return self.toUpperCase()
	  },
	  StringPrototypeTrim(self) {
	    return self.trim()
	  },
	  Symbol,
	  SymbolFor: Symbol.for,
	  SymbolAsyncIterator: Symbol.asyncIterator,
	  SymbolHasInstance: Symbol.hasInstance,
	  SymbolIterator: Symbol.iterator,
	  SymbolDispose: Symbol.dispose || Symbol('Symbol.dispose'),
	  SymbolAsyncDispose: Symbol.asyncDispose || Symbol('Symbol.asyncDispose'),
	  TypedArrayPrototypeSet(self, buf, len) {
	    return self.set(buf, len)
	  },
	  Boolean,
	  Uint8Array
	};
	return primordials;
}

var util = {exports: {}};

var inspect;
var hasRequiredInspect;

function requireInspect () {
	if (hasRequiredInspect) return inspect;
	hasRequiredInspect = 1;

	/*
	  This file is a reduced and adapted version of the main lib/internal/util/inspect.js file defined at

	  https://github.com/nodejs/node/blob/main/lib/internal/util/inspect.js

	  Don't try to replace with the original file and keep it up to date with the upstream file.
	*/
	inspect = {
	  format(format, ...args) {
	    // Simplified version of https://nodejs.org/api/util.html#utilformatformat-args
	    return format.replace(/%([sdifj])/g, function (...[_unused, type]) {
	      const replacement = args.shift();
	      if (type === 'f') {
	        return replacement.toFixed(6)
	      } else if (type === 'j') {
	        return JSON.stringify(replacement)
	      } else if (type === 's' && typeof replacement === 'object') {
	        const ctor = replacement.constructor !== Object ? replacement.constructor.name : '';
	        return `${ctor} {}`.trim()
	      } else {
	        return replacement.toString()
	      }
	    })
	  },
	  inspect(value) {
	    // Vastly simplified version of https://nodejs.org/api/util.html#utilinspectobject-options
	    switch (typeof value) {
	      case 'string':
	        if (value.includes("'")) {
	          if (!value.includes('"')) {
	            return `"${value}"`
	          } else if (!value.includes('`') && !value.includes('${')) {
	            return `\`${value}\``
	          }
	        }
	        return `'${value}'`
	      case 'number':
	        if (isNaN(value)) {
	          return 'NaN'
	        } else if (Object.is(value, -0)) {
	          return String(value)
	        }
	        return value
	      case 'bigint':
	        return `${String(value)}n`
	      case 'boolean':
	      case 'undefined':
	        return String(value)
	      case 'object':
	        return '{}'
	    }
	  }
	};
	return inspect;
}

var errors;
var hasRequiredErrors;

function requireErrors () {
	if (hasRequiredErrors) return errors;
	hasRequiredErrors = 1;

	const { format, inspect } = requireInspect();
	const { AggregateError: CustomAggregateError } = requirePrimordials();

	/*
	  This file is a reduced and adapted version of the main lib/internal/errors.js file defined at

	  https://github.com/nodejs/node/blob/main/lib/internal/errors.js

	  Don't try to replace with the original file and keep it up to date (starting from E(...) definitions)
	  with the upstream file.
	*/

	const AggregateError = globalThis.AggregateError || CustomAggregateError;
	const kIsNodeError = Symbol('kIsNodeError');
	const kTypes = [
	  'string',
	  'function',
	  'number',
	  'object',
	  // Accept 'Function' and 'Object' as alternative to the lower cased version.
	  'Function',
	  'Object',
	  'boolean',
	  'bigint',
	  'symbol'
	];
	const classRegExp = /^([A-Z][a-z0-9]*)+$/;
	const nodeInternalPrefix = '__node_internal_';
	const codes = {};
	function assert(value, message) {
	  if (!value) {
	    throw new codes.ERR_INTERNAL_ASSERTION(message)
	  }
	}

	// Only use this for integers! Decimal numbers do not work with this function.
	function addNumericalSeparator(val) {
	  let res = '';
	  let i = val.length;
	  const start = val[0] === '-' ? 1 : 0;
	  for (; i >= start + 4; i -= 3) {
	    res = `_${val.slice(i - 3, i)}${res}`;
	  }
	  return `${val.slice(0, i)}${res}`
	}
	function getMessage(key, msg, args) {
	  if (typeof msg === 'function') {
	    assert(
	      msg.length <= args.length,
	      // Default options do not count.
	      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
	    );
	    return msg(...args)
	  }
	  const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
	  assert(
	    expectedLength === args.length,
	    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
	  );
	  if (args.length === 0) {
	    return msg
	  }
	  return format(msg, ...args)
	}
	function E(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }
	  class NodeError extends Base {
	    constructor(...args) {
	      super(getMessage(code, message, args));
	    }
	    toString() {
	      return `${this.name} [${code}]: ${this.message}`
	    }
	  }
	  Object.defineProperties(NodeError.prototype, {
	    name: {
	      value: Base.name,
	      writable: true,
	      enumerable: false,
	      configurable: true
	    },
	    toString: {
	      value() {
	        return `${this.name} [${code}]: ${this.message}`
	      },
	      writable: true,
	      enumerable: false,
	      configurable: true
	    }
	  });
	  NodeError.prototype.code = code;
	  NodeError.prototype[kIsNodeError] = true;
	  codes[code] = NodeError;
	}
	function hideStackFrames(fn) {
	  // We rename the functions that will be hidden to cut off the stacktrace
	  // at the outermost one
	  const hidden = nodeInternalPrefix + fn.name;
	  Object.defineProperty(fn, 'name', {
	    value: hidden
	  });
	  return fn
	}
	function aggregateTwoErrors(innerError, outerError) {
	  if (innerError && outerError && innerError !== outerError) {
	    if (Array.isArray(outerError.errors)) {
	      // If `outerError` is already an `AggregateError`.
	      outerError.errors.push(innerError);
	      return outerError
	    }
	    const err = new AggregateError([outerError, innerError], outerError.message);
	    err.code = outerError.code;
	    return err
	  }
	  return innerError || outerError
	}
	class AbortError extends Error {
	  constructor(message = 'The operation was aborted', options = undefined) {
	    if (options !== undefined && typeof options !== 'object') {
	      throw new codes.ERR_INVALID_ARG_TYPE('options', 'Object', options)
	    }
	    super(message, options);
	    this.code = 'ABORT_ERR';
	    this.name = 'AbortError';
	  }
	}
	E('ERR_ASSERTION', '%s', Error);
	E(
	  'ERR_INVALID_ARG_TYPE',
	  (name, expected, actual) => {
	    assert(typeof name === 'string', "'name' must be a string");
	    if (!Array.isArray(expected)) {
	      expected = [expected];
	    }
	    let msg = 'The ';
	    if (name.endsWith(' argument')) {
	      // For cases like 'first argument'
	      msg += `${name} `;
	    } else {
	      msg += `"${name}" ${name.includes('.') ? 'property' : 'argument'} `;
	    }
	    msg += 'must be ';
	    const types = [];
	    const instances = [];
	    const other = [];
	    for (const value of expected) {
	      assert(typeof value === 'string', 'All expected entries have to be of type string');
	      if (kTypes.includes(value)) {
	        types.push(value.toLowerCase());
	      } else if (classRegExp.test(value)) {
	        instances.push(value);
	      } else {
	        assert(value !== 'object', 'The value "object" should be written as "Object"');
	        other.push(value);
	      }
	    }

	    // Special handle `object` in case other instances are allowed to outline
	    // the differences between each other.
	    if (instances.length > 0) {
	      const pos = types.indexOf('object');
	      if (pos !== -1) {
	        types.splice(types, pos, 1);
	        instances.push('Object');
	      }
	    }
	    if (types.length > 0) {
	      switch (types.length) {
	        case 1:
	          msg += `of type ${types[0]}`;
	          break
	        case 2:
	          msg += `one of type ${types[0]} or ${types[1]}`;
	          break
	        default: {
	          const last = types.pop();
	          msg += `one of type ${types.join(', ')}, or ${last}`;
	        }
	      }
	      if (instances.length > 0 || other.length > 0) {
	        msg += ' or ';
	      }
	    }
	    if (instances.length > 0) {
	      switch (instances.length) {
	        case 1:
	          msg += `an instance of ${instances[0]}`;
	          break
	        case 2:
	          msg += `an instance of ${instances[0]} or ${instances[1]}`;
	          break
	        default: {
	          const last = instances.pop();
	          msg += `an instance of ${instances.join(', ')}, or ${last}`;
	        }
	      }
	      if (other.length > 0) {
	        msg += ' or ';
	      }
	    }
	    switch (other.length) {
	      case 0:
	        break
	      case 1:
	        if (other[0].toLowerCase() !== other[0]) {
	          msg += 'an ';
	        }
	        msg += `${other[0]}`;
	        break
	      case 2:
	        msg += `one of ${other[0]} or ${other[1]}`;
	        break
	      default: {
	        const last = other.pop();
	        msg += `one of ${other.join(', ')}, or ${last}`;
	      }
	    }
	    if (actual == null) {
	      msg += `. Received ${actual}`;
	    } else if (typeof actual === 'function' && actual.name) {
	      msg += `. Received function ${actual.name}`;
	    } else if (typeof actual === 'object') {
	      var _actual$constructor;
	      if (
	        (_actual$constructor = actual.constructor) !== null &&
	        _actual$constructor !== undefined &&
	        _actual$constructor.name
	      ) {
	        msg += `. Received an instance of ${actual.constructor.name}`;
	      } else {
	        const inspected = inspect(actual, {
	          depth: -1
	        });
	        msg += `. Received ${inspected}`;
	      }
	    } else {
	      let inspected = inspect(actual, {
	        colors: false
	      });
	      if (inspected.length > 25) {
	        inspected = `${inspected.slice(0, 25)}...`;
	      }
	      msg += `. Received type ${typeof actual} (${inspected})`;
	    }
	    return msg
	  },
	  TypeError
	);
	E(
	  'ERR_INVALID_ARG_VALUE',
	  (name, value, reason = 'is invalid') => {
	    let inspected = inspect(value);
	    if (inspected.length > 128) {
	      inspected = inspected.slice(0, 128) + '...';
	    }
	    const type = name.includes('.') ? 'property' : 'argument';
	    return `The ${type} '${name}' ${reason}. Received ${inspected}`
	  },
	  TypeError
	);
	E(
	  'ERR_INVALID_RETURN_VALUE',
	  (input, name, value) => {
	    var _value$constructor;
	    const type =
	      value !== null &&
	      value !== undefined &&
	      (_value$constructor = value.constructor) !== null &&
	      _value$constructor !== undefined &&
	      _value$constructor.name
	        ? `instance of ${value.constructor.name}`
	        : `type ${typeof value}`;
	    return `Expected ${input} to be returned from the "${name}"` + ` function but got ${type}.`
	  },
	  TypeError
	);
	E(
	  'ERR_MISSING_ARGS',
	  (...args) => {
	    assert(args.length > 0, 'At least one arg needs to be specified');
	    let msg;
	    const len = args.length;
	    args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(' or ');
	    switch (len) {
	      case 1:
	        msg += `The ${args[0]} argument`;
	        break
	      case 2:
	        msg += `The ${args[0]} and ${args[1]} arguments`;
	        break
	      default:
	        {
	          const last = args.pop();
	          msg += `The ${args.join(', ')}, and ${last} arguments`;
	        }
	        break
	    }
	    return `${msg} must be specified`
	  },
	  TypeError
	);
	E(
	  'ERR_OUT_OF_RANGE',
	  (str, range, input) => {
	    assert(range, 'Missing "range" argument');
	    let received;
	    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
	      received = addNumericalSeparator(String(input));
	    } else if (typeof input === 'bigint') {
	      received = String(input);
	      const limit = BigInt(2) ** BigInt(32);
	      if (input > limit || input < -limit) {
	        received = addNumericalSeparator(received);
	      }
	      received += 'n';
	    } else {
	      received = inspect(input);
	    }
	    return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`
	  },
	  RangeError
	);
	E('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times', Error);
	E('ERR_METHOD_NOT_IMPLEMENTED', 'The %s method is not implemented', Error);
	E('ERR_STREAM_ALREADY_FINISHED', 'Cannot call %s after a stream was finished', Error);
	E('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable', Error);
	E('ERR_STREAM_DESTROYED', 'Cannot call %s after a stream was destroyed', Error);
	E('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	E('ERR_STREAM_PREMATURE_CLOSE', 'Premature close', Error);
	E('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF', Error);
	E('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event', Error);
	E('ERR_STREAM_WRITE_AFTER_END', 'write after end', Error);
	E('ERR_UNKNOWN_ENCODING', 'Unknown encoding: %s', TypeError);
	errors = {
	  AbortError,
	  aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
	  hideStackFrames,
	  codes
	};
	return errors;
}

/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
/**
 * @typedef {object} PrivateData
 * @property {EventTarget} eventTarget The event target.
 * @property {{type:string}} event The original event object.
 * @property {number} eventPhase The current event phase.
 * @property {EventTarget|null} currentTarget The current event target.
 * @property {boolean} canceled The flag to prevent default.
 * @property {boolean} stopped The flag to stop propagation.
 * @property {boolean} immediateStopped The flag to stop propagation immediately.
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event} event The event object to get private data.
 * @returns {PrivateData} The private data of the event.
 * @private
 */
function pd(event) {
    const retv = privateData.get(event);
    console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
    );
    return retv
}

/**
 * https://dom.spec.whatwg.org/#set-the-canceled-flag
 * @param data {PrivateData} private data.
 */
function setCancelFlag(data) {
    if (data.passiveListener != null) {
        if (
            typeof console !== "undefined" &&
            typeof console.error === "function"
        ) {
            console.error(
                "Unable to preventDefault inside passive event listener invocation.",
                data.passiveListener
            );
        }
        return
    }
    if (!data.event.cancelable) {
        return
    }

    data.canceled = true;
    if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
    }
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Event|{type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) {
    privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
    });

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });

    // Define accessors
    const keys = Object.keys(event);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
    }
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
    /**
     * The type of this event.
     * @type {string}
     */
    get type() {
        return pd(this).event.type
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get target() {
        return pd(this).eventTarget
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get currentTarget() {
        return pd(this).currentTarget
    },

    /**
     * @returns {EventTarget[]} The composed path of this event.
     */
    composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
            return []
        }
        return [currentTarget]
    },

    /**
     * Constant of NONE.
     * @type {number}
     */
    get NONE() {
        return 0
    },

    /**
     * Constant of CAPTURING_PHASE.
     * @type {number}
     */
    get CAPTURING_PHASE() {
        return 1
    },

    /**
     * Constant of AT_TARGET.
     * @type {number}
     */
    get AT_TARGET() {
        return 2
    },

    /**
     * Constant of BUBBLING_PHASE.
     * @type {number}
     */
    get BUBBLING_PHASE() {
        return 3
    },

    /**
     * The target of this event.
     * @type {number}
     */
    get eventPhase() {
        return pd(this).eventPhase
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopPropagation() {
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
            data.event.stopPropagation();
        }
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopImmediatePropagation() {
        const data = pd(this);

        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
            data.event.stopImmediatePropagation();
        }
    },

    /**
     * The flag to be bubbling.
     * @type {boolean}
     */
    get bubbles() {
        return Boolean(pd(this).event.bubbles)
    },

    /**
     * The flag to be cancelable.
     * @type {boolean}
     */
    get cancelable() {
        return Boolean(pd(this).event.cancelable)
    },

    /**
     * Cancel this event.
     * @returns {void}
     */
    preventDefault() {
        setCancelFlag(pd(this));
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     */
    get defaultPrevented() {
        return pd(this).canceled
    },

    /**
     * The flag to be composed.
     * @type {boolean}
     */
    get composed() {
        return Boolean(pd(this).event.composed)
    },

    /**
     * The unix time of this event.
     * @type {number}
     */
    get timeStamp() {
        return pd(this).timeStamp
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     * @deprecated
     */
    get srcElement() {
        return pd(this).eventTarget
    },

    /**
     * The flag to stop event bubbling.
     * @type {boolean}
     * @deprecated
     */
    get cancelBubble() {
        return pd(this).stopped
    },
    set cancelBubble(value) {
        if (!value) {
            return
        }
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
            data.event.cancelBubble = true;
        }
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     * @deprecated
     */
    get returnValue() {
        return !pd(this).canceled
    },
    set returnValue(value) {
        if (!value) {
            setCancelFlag(pd(this));
        }
    },

    /**
     * Initialize this event object. But do nothing under event dispatching.
     * @param {string} type The event type.
     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
     * @param {boolean} [cancelable=false] The flag to be possible to cancel.
     * @deprecated
     */
    initEvent() {
        // Do nothing.
    },
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", {
    value: Event,
    configurable: true,
    writable: true,
});

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
    return {
        get() {
            return pd(this).event[key]
        },
        set(value) {
            pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Get the property descriptor to call a given method property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
    return {
        value() {
            const event = pd(this).event;
            return event[key].apply(event, arguments)
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define new wrapper class.
 * @param {Function} BaseEvent The base wrapper class.
 * @param {Object} proto The prototype of the original event.
 * @returns {Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
        return BaseEvent
    }

    /** CustomEvent */
    function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
    }

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true },
    });

    // Define accessors.
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = typeof descriptor.value === "function";
            Object.defineProperty(
                CustomEvent.prototype,
                key,
                isFunc
                    ? defineCallDescriptor(key)
                    : defineRedirectDescriptor(key)
            );
        }
    }

    return CustomEvent
}

/**
 * Get the wrapper class of a given prototype.
 * @param {Object} proto The prototype of the original event to get its wrapper.
 * @returns {Function} The wrapper class.
 * @private
 */
function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
        return Event
    }

    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
    }
    return wrapper
}

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Object} event The event to wrap.
 * @returns {Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event)
}

/**
 * Get the immediateStopped flag of a given event.
 * @param {Event} event The event to get.
 * @returns {boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
    return pd(event).immediateStopped
}

/**
 * Set the current event phase of a given event.
 * @param {Event} event The event to set current target.
 * @param {number} eventPhase New event phase.
 * @returns {void}
 * @private
 */
function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param {Event} event The event to set current target.
 * @param {EventTarget|null} currentTarget New current target.
 * @returns {void}
 * @private
 */
function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param {Event} event The event to set current target.
 * @param {Function|null} passiveListener New passive listener.
 * @returns {void}
 * @private
 */
function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
}

/**
 * @typedef {object} ListenerNode
 * @property {Function} listener
 * @property {1|2|3} listenerType
 * @property {boolean} passive
 * @property {boolean} once
 * @property {ListenerNode|null} next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an object.
 */
function isObject(x) {
    return x !== null && typeof x === "object" //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param {EventTarget} eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
        throw new TypeError(
            "'this' is expected an EventTarget object, but got another value."
        )
    }
    return listeners
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string} eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener
                }
                node = node.next;
            }
            return null
        },

        set(listener) {
            if (typeof listener !== "function" && !isObject(listener)) {
                listener = null; // eslint-disable-line no-param-reassign
            }
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    // Remove old value.
                    if (prev !== null) {
                        prev.next = node.next;
                    } else if (node.next !== null) {
                        listeners.set(eventName, node.next);
                    } else {
                        listeners.delete(eventName);
                    }
                } else {
                    prev = node;
                }

                node = node.next;
            }

            // Add new value.
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
                };
                if (prev === null) {
                    listeners.set(eventName, newNode);
                } else {
                    prev.next = newNode;
                }
            }
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string} eventName The event name to define.
 * @returns {void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
    );
}

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]} eventNames Event names for event attributes.
 * @returns {EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
    /** CustomEventTarget */
    function CustomEventTarget() {
        EventTarget.call(this);
    }

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
            value: CustomEventTarget,
            configurable: true,
            writable: true,
        },
    });

    for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }

    return CustomEventTarget
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {}
 *     class B extends EventTarget("message") {}
 *     class C extends EventTarget("message", "error") {}
 *     class D extends EventTarget(["message", "error"]) {}
 */
function EventTarget() {
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0])
    }
    if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
            types[i] = arguments[i];
        }
        return defineCustomEventTarget(types)
    }
    throw new TypeError("Cannot call a class as a function")
    /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
    /**
     * Add a given listener to this event target.
     * @param {string} eventName The event name to add.
     * @param {Function} listener The listener to add.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {void}
     */
    addEventListener(eventName, listener, options) {
        if (listener == null) {
            return
        }
        if (typeof listener !== "function" && !isObject(listener)) {
            throw new TypeError("'listener' should be a function or an object.")
        }

        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
            listener,
            listenerType,
            passive: optionsIsObj && Boolean(options.passive),
            once: optionsIsObj && Boolean(options.once),
            next: null,
        };

        // Set it as the first node if the first node is null.
        let node = listeners.get(eventName);
        if (node === undefined) {
            listeners.set(eventName, newNode);
            return
        }

        // Traverse to the tail while checking duplication..
        let prev = null;
        while (node != null) {
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) {
                // Should ignore duplication.
                return
            }
            prev = node;
            node = node.next;
        }

        // Add it.
        prev.next = newNode;
    },

    /**
     * Remove a given listener from this event target.
     * @param {string} eventName The event name to remove.
     * @param {Function} listener The listener to remove.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {void}
     */
    removeEventListener(eventName, listener, options) {
        if (listener == null) {
            return
        }

        const listeners = getListeners(this);
        const capture = isObject(options)
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;

        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) {
                if (prev !== null) {
                    prev.next = node.next;
                } else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                } else {
                    listeners.delete(eventName);
                }
                return
            }

            prev = node;
            node = node.next;
        }
    },

    /**
     * Dispatch a given event.
     * @param {Event|{type:string}} event The event to dispatch.
     * @returns {boolean} `false` if canceled.
     */
    dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
            throw new TypeError('"event.type" should be a string.')
        }

        // If listeners aren't registered, terminate.
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
            return true
        }

        // Since we cannot rewrite several properties, so wrap object.
        const wrappedEvent = wrapEvent(this, event);

        // This doesn't process capturing phase and bubbling phase.
        // This isn't participating in a tree.
        let prev = null;
        while (node != null) {
            // Remove this listener if it's once
            if (node.once) {
                if (prev !== null) {
                    prev.next = node.next;
                } else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                } else {
                    listeners.delete(eventName);
                }
            } else {
                prev = node;
            }

            // Call this listener
            setPassiveListener(
                wrappedEvent,
                node.passive ? node.listener : null
            );
            if (typeof node.listener === "function") {
                try {
                    node.listener.call(this, wrappedEvent);
                } catch (err) {
                    if (
                        typeof console !== "undefined" &&
                        typeof console.error === "function"
                    ) {
                        console.error(err);
                    }
                }
            } else if (
                node.listenerType !== ATTRIBUTE &&
                typeof node.listener.handleEvent === "function"
            ) {
                node.listener.handleEvent(wrappedEvent);
            }

            // Break if `event.stopImmediatePropagation` was called.
            if (isStopped(wrappedEvent)) {
                break
            }

            node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented
    },
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true,
});

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (
    typeof window !== "undefined" &&
    typeof window.EventTarget !== "undefined"
) {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */

/**
 * The signal class.
 * @see https://dom.spec.whatwg.org/#abortsignal
 */
let AbortSignal$1 = class AbortSignal extends EventTarget {
    /**
     * AbortSignal cannot be constructed directly.
     */
    constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
    }
    /**
     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
     */
    get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
    }
};
defineEventAttribute(AbortSignal$1.prototype, "abort");
/**
 * Create an AbortSignal object.
 */
function createAbortSignal() {
    const signal = Object.create(AbortSignal$1.prototype);
    EventTarget.call(signal);
    abortedFlags.set(signal, false);
    return signal;
}
/**
 * Abort a given signal.
 */
function abortSignal(signal) {
    if (abortedFlags.get(signal) !== false) {
        return;
    }
    abortedFlags.set(signal, true);
    signal.dispatchEvent({ type: "abort" });
}
/**
 * Aborted flag for each instances.
 */
const abortedFlags = new WeakMap();
// Properties should be enumerable.
Object.defineProperties(AbortSignal$1.prototype, {
    aborted: { enumerable: true },
});
// `toString()` should return `"[object AbortSignal]"`
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortSignal$1.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal",
    });
}

/**
 * The AbortController.
 * @see https://dom.spec.whatwg.org/#abortcontroller
 */
let AbortController$1 = class AbortController {
    /**
     * Initialize this controller.
     */
    constructor() {
        signals.set(this, createAbortSignal());
    }
    /**
     * Returns the `AbortSignal` object associated with this object.
     */
    get signal() {
        return getSignal(this);
    }
    /**
     * Abort and signal to any observers that the associated activity is to be aborted.
     */
    abort() {
        abortSignal(getSignal(this));
    }
};
/**
 * Associated signals.
 */
const signals = new WeakMap();
/**
 * Get the associated signal of a given controller.
 */
function getSignal(controller) {
    const signal = signals.get(controller);
    if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
    }
    return signal;
}
// Properties should be enumerable.
Object.defineProperties(AbortController$1.prototype, {
    signal: { enumerable: true },
    abort: { enumerable: true },
});
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortController$1.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController",
    });
}

var abortController = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AbortController: AbortController$1,
  AbortSignal: AbortSignal$1,
  default: AbortController$1
});

var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(abortController);

var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util.exports;
	hasRequiredUtil = 1;
	(function (module) {

		const bufferModule = require$$0$7;
		const { format, inspect } = requireInspect();
		const {
		  codes: { ERR_INVALID_ARG_TYPE }
		} = requireErrors();
		const { kResistStopPropagation, AggregateError, SymbolDispose } = requirePrimordials();
		const AbortSignal = globalThis.AbortSignal || require$$0$2.AbortSignal;
		const AbortController = globalThis.AbortController || require$$0$2.AbortController;
		const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;
		const Blob = globalThis.Blob || bufferModule.Blob;
		/* eslint-disable indent */
		const isBlob =
		  typeof Blob !== 'undefined'
		    ? function isBlob(b) {
		        // eslint-disable-next-line indent
		        return b instanceof Blob
		      }
		    : function isBlob(b) {
		        return false
		      };
		/* eslint-enable indent */

		const validateAbortSignal = (signal, name) => {
		  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {
		    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
		  }
		};
		const validateFunction = (value, name) => {
		  if (typeof value !== 'function') {
		    throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
		  }
		};
		module.exports = {
		  AggregateError,
		  kEmptyObject: Object.freeze({}),
		  once(callback) {
		    let called = false;
		    return function (...args) {
		      if (called) {
		        return
		      }
		      called = true;
		      callback.apply(this, args);
		    }
		  },
		  createDeferredPromise: function () {
		    let resolve;
		    let reject;

		    // eslint-disable-next-line promise/param-names
		    const promise = new Promise((res, rej) => {
		      resolve = res;
		      reject = rej;
		    });
		    return {
		      promise,
		      resolve,
		      reject
		    }
		  },
		  promisify(fn) {
		    return new Promise((resolve, reject) => {
		      fn((err, ...args) => {
		        if (err) {
		          return reject(err)
		        }
		        return resolve(...args)
		      });
		    })
		  },
		  debuglog() {
		    return function () {}
		  },
		  format,
		  inspect,
		  types: {
		    isAsyncFunction(fn) {
		      return fn instanceof AsyncFunction
		    },
		    isArrayBufferView(arr) {
		      return ArrayBuffer.isView(arr)
		    }
		  },
		  isBlob,
		  deprecate(fn, message) {
		    return fn
		  },
		  addAbortListener:
		    require$$0$5.addAbortListener ||
		    function addAbortListener(signal, listener) {
		      if (signal === undefined) {
		        throw new ERR_INVALID_ARG_TYPE('signal', 'AbortSignal', signal)
		      }
		      validateAbortSignal(signal, 'signal');
		      validateFunction(listener, 'listener');
		      let removeEventListener;
		      if (signal.aborted) {
		        queueMicrotask(() => listener());
		      } else {
		        signal.addEventListener('abort', listener, {
		          __proto__: null,
		          once: true,
		          [kResistStopPropagation]: true
		        });
		        removeEventListener = () => {
		          signal.removeEventListener('abort', listener);
		        };
		      }
		      return {
		        __proto__: null,
		        [SymbolDispose]() {
		          var _removeEventListener
		          ;(_removeEventListener = removeEventListener) === null || _removeEventListener === undefined
		            ? undefined
		            : _removeEventListener();
		        }
		      }
		    },
		  AbortSignalAny:
		    AbortSignal.any ||
		    function AbortSignalAny(signals) {
		      // Fast path if there is only one signal.
		      if (signals.length === 1) {
		        return signals[0]
		      }
		      const ac = new AbortController();
		      const abort = () => ac.abort();
		      signals.forEach((signal) => {
		        validateAbortSignal(signal, 'signals');
		        signal.addEventListener('abort', abort, {
		          once: true
		        });
		      });
		      ac.signal.addEventListener(
		        'abort',
		        () => {
		          signals.forEach((signal) => signal.removeEventListener('abort', abort));
		        },
		        {
		          once: true
		        }
		      );
		      return ac.signal
		    }
		};
		module.exports.promisify.custom = Symbol.for('nodejs.util.promisify.custom'); 
	} (util));
	return util.exports;
}

var operators = {};

/* eslint jsdoc/require-jsdoc: "error" */

var validators;
var hasRequiredValidators;

function requireValidators () {
	if (hasRequiredValidators) return validators;
	hasRequiredValidators = 1;

	const {
	  ArrayIsArray,
	  ArrayPrototypeIncludes,
	  ArrayPrototypeJoin,
	  ArrayPrototypeMap,
	  NumberIsInteger,
	  NumberIsNaN,
	  NumberMAX_SAFE_INTEGER,
	  NumberMIN_SAFE_INTEGER,
	  NumberParseInt,
	  ObjectPrototypeHasOwnProperty,
	  RegExpPrototypeExec,
	  String,
	  StringPrototypeToUpperCase,
	  StringPrototypeTrim
	} = requirePrimordials();
	const {
	  hideStackFrames,
	  codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
	} = requireErrors();
	const { normalizeEncoding } = requireUtil();
	const { isAsyncFunction, isArrayBufferView } = requireUtil().types;
	const signals = {};

	/**
	 * @param {*} value
	 * @returns {boolean}
	 */
	function isInt32(value) {
	  return value === (value | 0)
	}

	/**
	 * @param {*} value
	 * @returns {boolean}
	 */
	function isUint32(value) {
	  return value === value >>> 0
	}
	const octalReg = /^[0-7]+$/;
	const modeDesc = 'must be a 32-bit unsigned integer or an octal string';

	/**
	 * Parse and validate values that will be converted into mode_t (the S_*
	 * constants). Only valid numbers and octal strings are allowed. They could be
	 * converted to 32-bit unsigned integers or non-negative signed integers in the
	 * C++ land, but any value higher than 0o777 will result in platform-specific
	 * behaviors.
	 * @param {*} value Values to be validated
	 * @param {string} name Name of the argument
	 * @param {number} [def] If specified, will be returned for invalid values
	 * @returns {number}
	 */
	function parseFileMode(value, name, def) {
	  if (typeof value === 'undefined') {
	    value = def;
	  }
	  if (typeof value === 'string') {
	    if (RegExpPrototypeExec(octalReg, value) === null) {
	      throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc)
	    }
	    value = NumberParseInt(value, 8);
	  }
	  validateUint32(value, name);
	  return value
	}

	/**
	 * @callback validateInteger
	 * @param {*} value
	 * @param {string} name
	 * @param {number} [min]
	 * @param {number} [max]
	 * @returns {asserts value is number}
	 */

	/** @type {validateInteger} */
	const validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
	  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
	  if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
	  if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
	});

	/**
	 * @callback validateInt32
	 * @param {*} value
	 * @param {string} name
	 * @param {number} [min]
	 * @param {number} [max]
	 * @returns {asserts value is number}
	 */

	/** @type {validateInt32} */
	const validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
	  // The defaults for min and max correspond to the limits of 32-bit integers.
	  if (typeof value !== 'number') {
	    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
	  }
	  if (!NumberIsInteger(value)) {
	    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
	  }
	  if (value < min || value > max) {
	    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
	  }
	});

	/**
	 * @callback validateUint32
	 * @param {*} value
	 * @param {string} name
	 * @param {number|boolean} [positive=false]
	 * @returns {asserts value is number}
	 */

	/** @type {validateUint32} */
	const validateUint32 = hideStackFrames((value, name, positive = false) => {
	  if (typeof value !== 'number') {
	    throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
	  }
	  if (!NumberIsInteger(value)) {
	    throw new ERR_OUT_OF_RANGE(name, 'an integer', value)
	  }
	  const min = positive ? 1 : 0;
	  // 2 ** 32 === 4294967296
	  const max = 4294967295;
	  if (value < min || value > max) {
	    throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value)
	  }
	});

	/**
	 * @callback validateString
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is string}
	 */

	/** @type {validateString} */
	function validateString(value, name) {
	  if (typeof value !== 'string') throw new ERR_INVALID_ARG_TYPE(name, 'string', value)
	}

	/**
	 * @callback validateNumber
	 * @param {*} value
	 * @param {string} name
	 * @param {number} [min]
	 * @param {number} [max]
	 * @returns {asserts value is number}
	 */

	/** @type {validateNumber} */
	function validateNumber(value, name, min = undefined, max) {
	  if (typeof value !== 'number') throw new ERR_INVALID_ARG_TYPE(name, 'number', value)
	  if (
	    (min != null && value < min) ||
	    (max != null && value > max) ||
	    ((min != null || max != null) && NumberIsNaN(value))
	  ) {
	    throw new ERR_OUT_OF_RANGE(
	      name,
	      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`,
	      value
	    )
	  }
	}

	/**
	 * @callback validateOneOf
	 * @template T
	 * @param {T} value
	 * @param {string} name
	 * @param {T[]} oneOf
	 */

	/** @type {validateOneOf} */
	const validateOneOf = hideStackFrames((value, name, oneOf) => {
	  if (!ArrayPrototypeIncludes(oneOf, value)) {
	    const allowed = ArrayPrototypeJoin(
	      ArrayPrototypeMap(oneOf, (v) => (typeof v === 'string' ? `'${v}'` : String(v))),
	      ', '
	    );
	    const reason = 'must be one of: ' + allowed;
	    throw new ERR_INVALID_ARG_VALUE(name, value, reason)
	  }
	});

	/**
	 * @callback validateBoolean
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is boolean}
	 */

	/** @type {validateBoolean} */
	function validateBoolean(value, name) {
	  if (typeof value !== 'boolean') throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value)
	}

	/**
	 * @param {any} options
	 * @param {string} key
	 * @param {boolean} defaultValue
	 * @returns {boolean}
	 */
	function getOwnPropertyValueOrDefault(options, key, defaultValue) {
	  return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key]
	}

	/**
	 * @callback validateObject
	 * @param {*} value
	 * @param {string} name
	 * @param {{
	 *   allowArray?: boolean,
	 *   allowFunction?: boolean,
	 *   nullable?: boolean
	 * }} [options]
	 */

	/** @type {validateObject} */
	const validateObject = hideStackFrames((value, name, options = null) => {
	  const allowArray = getOwnPropertyValueOrDefault(options, 'allowArray', false);
	  const allowFunction = getOwnPropertyValueOrDefault(options, 'allowFunction', false);
	  const nullable = getOwnPropertyValueOrDefault(options, 'nullable', false);
	  if (
	    (!nullable && value === null) ||
	    (!allowArray && ArrayIsArray(value)) ||
	    (typeof value !== 'object' && (!allowFunction || typeof value !== 'function'))
	  ) {
	    throw new ERR_INVALID_ARG_TYPE(name, 'Object', value)
	  }
	});

	/**
	 * @callback validateDictionary - We are using the Web IDL Standard definition
	 *                                of "dictionary" here, which means any value
	 *                                whose Type is either Undefined, Null, or
	 *                                Object (which includes functions).
	 * @param {*} value
	 * @param {string} name
	 * @see https://webidl.spec.whatwg.org/#es-dictionary
	 * @see https://tc39.es/ecma262/#table-typeof-operator-results
	 */

	/** @type {validateDictionary} */
	const validateDictionary = hideStackFrames((value, name) => {
	  if (value != null && typeof value !== 'object' && typeof value !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE(name, 'a dictionary', value)
	  }
	});

	/**
	 * @callback validateArray
	 * @param {*} value
	 * @param {string} name
	 * @param {number} [minLength]
	 * @returns {asserts value is any[]}
	 */

	/** @type {validateArray} */
	const validateArray = hideStackFrames((value, name, minLength = 0) => {
	  if (!ArrayIsArray(value)) {
	    throw new ERR_INVALID_ARG_TYPE(name, 'Array', value)
	  }
	  if (value.length < minLength) {
	    const reason = `must be longer than ${minLength}`;
	    throw new ERR_INVALID_ARG_VALUE(name, value, reason)
	  }
	});

	/**
	 * @callback validateStringArray
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is string[]}
	 */

	/** @type {validateStringArray} */
	function validateStringArray(value, name) {
	  validateArray(value, name);
	  for (let i = 0; i < value.length; i++) {
	    validateString(value[i], `${name}[${i}]`);
	  }
	}

	/**
	 * @callback validateBooleanArray
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is boolean[]}
	 */

	/** @type {validateBooleanArray} */
	function validateBooleanArray(value, name) {
	  validateArray(value, name);
	  for (let i = 0; i < value.length; i++) {
	    validateBoolean(value[i], `${name}[${i}]`);
	  }
	}

	/**
	 * @callback validateAbortSignalArray
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is AbortSignal[]}
	 */

	/** @type {validateAbortSignalArray} */
	function validateAbortSignalArray(value, name) {
	  validateArray(value, name);
	  for (let i = 0; i < value.length; i++) {
	    const signal = value[i];
	    const indexedName = `${name}[${i}]`;
	    if (signal == null) {
	      throw new ERR_INVALID_ARG_TYPE(indexedName, 'AbortSignal', signal)
	    }
	    validateAbortSignal(signal, indexedName);
	  }
	}

	/**
	 * @param {*} signal
	 * @param {string} [name='signal']
	 * @returns {asserts signal is keyof signals}
	 */
	function validateSignalName(signal, name = 'signal') {
	  validateString(signal, name);
	  if (signals[signal] === undefined) {
	    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {
	      throw new ERR_UNKNOWN_SIGNAL(signal + ' (signals must use all capital letters)')
	    }
	    throw new ERR_UNKNOWN_SIGNAL(signal)
	  }
	}

	/**
	 * @callback validateBuffer
	 * @param {*} buffer
	 * @param {string} [name='buffer']
	 * @returns {asserts buffer is ArrayBufferView}
	 */

	/** @type {validateBuffer} */
	const validateBuffer = hideStackFrames((buffer, name = 'buffer') => {
	  if (!isArrayBufferView(buffer)) {
	    throw new ERR_INVALID_ARG_TYPE(name, ['Buffer', 'TypedArray', 'DataView'], buffer)
	  }
	});

	/**
	 * @param {string} data
	 * @param {string} encoding
	 */
	function validateEncoding(data, encoding) {
	  const normalizedEncoding = normalizeEncoding(encoding);
	  const length = data.length;
	  if (normalizedEncoding === 'hex' && length % 2 !== 0) {
	    throw new ERR_INVALID_ARG_VALUE('encoding', encoding, `is invalid for data of length ${length}`)
	  }
	}

	/**
	 * Check that the port number is not NaN when coerced to a number,
	 * is an integer and that it falls within the legal range of port numbers.
	 * @param {*} port
	 * @param {string} [name='Port']
	 * @param {boolean} [allowZero=true]
	 * @returns {number}
	 */
	function validatePort(port, name = 'Port', allowZero = true) {
	  if (
	    (typeof port !== 'number' && typeof port !== 'string') ||
	    (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||
	    +port !== +port >>> 0 ||
	    port > 0xffff ||
	    (port === 0 && !allowZero)
	  ) {
	    throw new ERR_SOCKET_BAD_PORT(name, port, allowZero)
	  }
	  return port | 0
	}

	/**
	 * @callback validateAbortSignal
	 * @param {*} signal
	 * @param {string} name
	 */

	/** @type {validateAbortSignal} */
	const validateAbortSignal = hideStackFrames((signal, name) => {
	  if (signal !== undefined && (signal === null || typeof signal !== 'object' || !('aborted' in signal))) {
	    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
	  }
	});

	/**
	 * @callback validateFunction
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is Function}
	 */

	/** @type {validateFunction} */
	const validateFunction = hideStackFrames((value, name) => {
	  if (typeof value !== 'function') throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
	});

	/**
	 * @callback validatePlainFunction
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is Function}
	 */

	/** @type {validatePlainFunction} */
	const validatePlainFunction = hideStackFrames((value, name) => {
	  if (typeof value !== 'function' || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, 'Function', value)
	});

	/**
	 * @callback validateUndefined
	 * @param {*} value
	 * @param {string} name
	 * @returns {asserts value is undefined}
	 */

	/** @type {validateUndefined} */
	const validateUndefined = hideStackFrames((value, name) => {
	  if (value !== undefined) throw new ERR_INVALID_ARG_TYPE(name, 'undefined', value)
	});

	/**
	 * @template T
	 * @param {T} value
	 * @param {string} name
	 * @param {T[]} union
	 */
	function validateUnion(value, name, union) {
	  if (!ArrayPrototypeIncludes(union, value)) {
	    throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, '|')}')`, value)
	  }
	}

	/*
	  The rules for the Link header field are described here:
	  https://www.rfc-editor.org/rfc/rfc8288.html#section-3

	  This regex validates any string surrounded by angle brackets
	  (not necessarily a valid URI reference) followed by zero or more
	  link-params separated by semicolons.
	*/
	const linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;

	/**
	 * @param {any} value
	 * @param {string} name
	 */
	function validateLinkHeaderFormat(value, name) {
	  if (typeof value === 'undefined' || !RegExpPrototypeExec(linkValueRegExp, value)) {
	    throw new ERR_INVALID_ARG_VALUE(
	      name,
	      value,
	      'must be an array or string of format "</styles.css>; rel=preload; as=style"'
	    )
	  }
	}

	/**
	 * @param {any} hints
	 * @return {string}
	 */
	function validateLinkHeaderValue(hints) {
	  if (typeof hints === 'string') {
	    validateLinkHeaderFormat(hints, 'hints');
	    return hints
	  } else if (ArrayIsArray(hints)) {
	    const hintsLength = hints.length;
	    let result = '';
	    if (hintsLength === 0) {
	      return result
	    }
	    for (let i = 0; i < hintsLength; i++) {
	      const link = hints[i];
	      validateLinkHeaderFormat(link, 'hints');
	      result += link;
	      if (i !== hintsLength - 1) {
	        result += ', ';
	      }
	    }
	    return result
	  }
	  throw new ERR_INVALID_ARG_VALUE(
	    'hints',
	    hints,
	    'must be an array or string of format "</styles.css>; rel=preload; as=style"'
	  )
	}
	validators = {
	  isInt32,
	  isUint32,
	  parseFileMode,
	  validateArray,
	  validateStringArray,
	  validateBooleanArray,
	  validateAbortSignalArray,
	  validateBoolean,
	  validateBuffer,
	  validateDictionary,
	  validateEncoding,
	  validateFunction,
	  validateInt32,
	  validateInteger,
	  validateNumber,
	  validateObject,
	  validateOneOf,
	  validatePlainFunction,
	  validatePort,
	  validateSignalName,
	  validateString,
	  validateUint32,
	  validateUndefined,
	  validateUnion,
	  validateAbortSignal,
	  validateLinkHeaderValue
	};
	return validators;
}

var endOfStream = {exports: {}};

var process$1;
var hasRequiredProcess;

function requireProcess () {
	if (hasRequiredProcess) return process$1;
	hasRequiredProcess = 1;
	// for now just expose the builtin process global from node.js
	process$1 = commonjsGlobal.process;
	return process$1;
}

var utils;
var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;

	const { SymbolAsyncIterator, SymbolIterator, SymbolFor } = requirePrimordials();

	// We need to use SymbolFor to make these globally available
	// for interopt with readable-stream, i.e. readable-stream
	// and node core needs to be able to read/write private state
	// from each other for proper interoperability.
	const kIsDestroyed = SymbolFor('nodejs.stream.destroyed');
	const kIsErrored = SymbolFor('nodejs.stream.errored');
	const kIsReadable = SymbolFor('nodejs.stream.readable');
	const kIsWritable = SymbolFor('nodejs.stream.writable');
	const kIsDisturbed = SymbolFor('nodejs.stream.disturbed');
	const kIsClosedPromise = SymbolFor('nodejs.webstream.isClosedPromise');
	const kControllerErrorFunction = SymbolFor('nodejs.webstream.controllerErrorFunction');
	function isReadableNodeStream(obj, strict = false) {
	  var _obj$_readableState;
	  return !!(
	    (
	      obj &&
	      typeof obj.pipe === 'function' &&
	      typeof obj.on === 'function' &&
	      (!strict || (typeof obj.pause === 'function' && typeof obj.resume === 'function')) &&
	      (!obj._writableState ||
	        ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === undefined
	          ? undefined
	          : _obj$_readableState.readable) !== false) &&
	      // Duplex
	      (!obj._writableState || obj._readableState)
	    ) // Writable has .pipe.
	  )
	}
	function isWritableNodeStream(obj) {
	  var _obj$_writableState;
	  return !!(
	    (
	      obj &&
	      typeof obj.write === 'function' &&
	      typeof obj.on === 'function' &&
	      (!obj._readableState ||
	        ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === undefined
	          ? undefined
	          : _obj$_writableState.writable) !== false)
	    ) // Duplex
	  )
	}
	function isDuplexNodeStream(obj) {
	  return !!(
	    obj &&
	    typeof obj.pipe === 'function' &&
	    obj._readableState &&
	    typeof obj.on === 'function' &&
	    typeof obj.write === 'function'
	  )
	}
	function isNodeStream(obj) {
	  return (
	    obj &&
	    (obj._readableState ||
	      obj._writableState ||
	      (typeof obj.write === 'function' && typeof obj.on === 'function') ||
	      (typeof obj.pipe === 'function' && typeof obj.on === 'function'))
	  )
	}
	function isReadableStream(obj) {
	  return !!(
	    obj &&
	    !isNodeStream(obj) &&
	    typeof obj.pipeThrough === 'function' &&
	    typeof obj.getReader === 'function' &&
	    typeof obj.cancel === 'function'
	  )
	}
	function isWritableStream(obj) {
	  return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === 'function' && typeof obj.abort === 'function')
	}
	function isTransformStream(obj) {
	  return !!(obj && !isNodeStream(obj) && typeof obj.readable === 'object' && typeof obj.writable === 'object')
	}
	function isWebStream(obj) {
	  return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj)
	}
	function isIterable(obj, isAsync) {
	  if (obj == null) return false
	  if (isAsync === true) return typeof obj[SymbolAsyncIterator] === 'function'
	  if (isAsync === false) return typeof obj[SymbolIterator] === 'function'
	  return typeof obj[SymbolAsyncIterator] === 'function' || typeof obj[SymbolIterator] === 'function'
	}
	function isDestroyed(stream) {
	  if (!isNodeStream(stream)) return null
	  const wState = stream._writableState;
	  const rState = stream._readableState;
	  const state = wState || rState;
	  return !!(stream.destroyed || stream[kIsDestroyed] || (state !== null && state !== undefined && state.destroyed))
	}

	// Have been end():d.
	function isWritableEnded(stream) {
	  if (!isWritableNodeStream(stream)) return null
	  if (stream.writableEnded === true) return true
	  const wState = stream._writableState;
	  if (wState !== null && wState !== undefined && wState.errored) return false
	  if (typeof (wState === null || wState === undefined ? undefined : wState.ended) !== 'boolean') return null
	  return wState.ended
	}

	// Have emitted 'finish'.
	function isWritableFinished(stream, strict) {
	  if (!isWritableNodeStream(stream)) return null
	  if (stream.writableFinished === true) return true
	  const wState = stream._writableState;
	  if (wState !== null && wState !== undefined && wState.errored) return false
	  if (typeof (wState === null || wState === undefined ? undefined : wState.finished) !== 'boolean') return null
	  return !!(wState.finished || (strict === false && wState.ended === true && wState.length === 0))
	}

	// Have been push(null):d.
	function isReadableEnded(stream) {
	  if (!isReadableNodeStream(stream)) return null
	  if (stream.readableEnded === true) return true
	  const rState = stream._readableState;
	  if (!rState || rState.errored) return false
	  if (typeof (rState === null || rState === undefined ? undefined : rState.ended) !== 'boolean') return null
	  return rState.ended
	}

	// Have emitted 'end'.
	function isReadableFinished(stream, strict) {
	  if (!isReadableNodeStream(stream)) return null
	  const rState = stream._readableState;
	  if (rState !== null && rState !== undefined && rState.errored) return false
	  if (typeof (rState === null || rState === undefined ? undefined : rState.endEmitted) !== 'boolean') return null
	  return !!(rState.endEmitted || (strict === false && rState.ended === true && rState.length === 0))
	}
	function isReadable(stream) {
	  if (stream && stream[kIsReadable] != null) return stream[kIsReadable]
	  if (typeof (stream === null || stream === undefined ? undefined : stream.readable) !== 'boolean') return null
	  if (isDestroyed(stream)) return false
	  return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream)
	}
	function isWritable(stream) {
	  if (stream && stream[kIsWritable] != null) return stream[kIsWritable]
	  if (typeof (stream === null || stream === undefined ? undefined : stream.writable) !== 'boolean') return null
	  if (isDestroyed(stream)) return false
	  return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream)
	}
	function isFinished(stream, opts) {
	  if (!isNodeStream(stream)) {
	    return null
	  }
	  if (isDestroyed(stream)) {
	    return true
	  }
	  if ((opts === null || opts === undefined ? undefined : opts.readable) !== false && isReadable(stream)) {
	    return false
	  }
	  if ((opts === null || opts === undefined ? undefined : opts.writable) !== false && isWritable(stream)) {
	    return false
	  }
	  return true
	}
	function isWritableErrored(stream) {
	  var _stream$_writableStat, _stream$_writableStat2;
	  if (!isNodeStream(stream)) {
	    return null
	  }
	  if (stream.writableErrored) {
	    return stream.writableErrored
	  }
	  return (_stream$_writableStat =
	    (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === undefined
	      ? undefined
	      : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== undefined
	    ? _stream$_writableStat
	    : null
	}
	function isReadableErrored(stream) {
	  var _stream$_readableStat, _stream$_readableStat2;
	  if (!isNodeStream(stream)) {
	    return null
	  }
	  if (stream.readableErrored) {
	    return stream.readableErrored
	  }
	  return (_stream$_readableStat =
	    (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === undefined
	      ? undefined
	      : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== undefined
	    ? _stream$_readableStat
	    : null
	}
	function isClosed(stream) {
	  if (!isNodeStream(stream)) {
	    return null
	  }
	  if (typeof stream.closed === 'boolean') {
	    return stream.closed
	  }
	  const wState = stream._writableState;
	  const rState = stream._readableState;
	  if (
	    typeof (wState === null || wState === undefined ? undefined : wState.closed) === 'boolean' ||
	    typeof (rState === null || rState === undefined ? undefined : rState.closed) === 'boolean'
	  ) {
	    return (
	      (wState === null || wState === undefined ? undefined : wState.closed) ||
	      (rState === null || rState === undefined ? undefined : rState.closed)
	    )
	  }
	  if (typeof stream._closed === 'boolean' && isOutgoingMessage(stream)) {
	    return stream._closed
	  }
	  return null
	}
	function isOutgoingMessage(stream) {
	  return (
	    typeof stream._closed === 'boolean' &&
	    typeof stream._defaultKeepAlive === 'boolean' &&
	    typeof stream._removedConnection === 'boolean' &&
	    typeof stream._removedContLen === 'boolean'
	  )
	}
	function isServerResponse(stream) {
	  return typeof stream._sent100 === 'boolean' && isOutgoingMessage(stream)
	}
	function isServerRequest(stream) {
	  var _stream$req;
	  return (
	    typeof stream._consuming === 'boolean' &&
	    typeof stream._dumped === 'boolean' &&
	    ((_stream$req = stream.req) === null || _stream$req === undefined ? undefined : _stream$req.upgradeOrConnect) ===
	      undefined
	  )
	}
	function willEmitClose(stream) {
	  if (!isNodeStream(stream)) return null
	  const wState = stream._writableState;
	  const rState = stream._readableState;
	  const state = wState || rState;
	  return (
	    (!state && isServerResponse(stream)) || !!(state && state.autoDestroy && state.emitClose && state.closed === false)
	  )
	}
	function isDisturbed(stream) {
	  var _stream$kIsDisturbed;
	  return !!(
	    stream &&
	    ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== undefined
	      ? _stream$kIsDisturbed
	      : stream.readableDidRead || stream.readableAborted)
	  )
	}
	function isErrored(stream) {
	  var _ref,
	    _ref2,
	    _ref3,
	    _ref4,
	    _ref5,
	    _stream$kIsErrored,
	    _stream$_readableStat3,
	    _stream$_writableStat3,
	    _stream$_readableStat4,
	    _stream$_writableStat4;
	  return !!(
	    stream &&
	    ((_ref =
	      (_ref2 =
	        (_ref3 =
	          (_ref4 =
	            (_ref5 =
	              (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== undefined
	                ? _stream$kIsErrored
	                : stream.readableErrored) !== null && _ref5 !== undefined
	              ? _ref5
	              : stream.writableErrored) !== null && _ref4 !== undefined
	            ? _ref4
	            : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === undefined
	            ? undefined
	            : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== undefined
	          ? _ref3
	          : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === undefined
	          ? undefined
	          : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== undefined
	        ? _ref2
	        : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === undefined
	        ? undefined
	        : _stream$_readableStat4.errored) !== null && _ref !== undefined
	      ? _ref
	      : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === undefined
	      ? undefined
	      : _stream$_writableStat4.errored)
	  )
	}
	utils = {
	  isDestroyed,
	  kIsDestroyed,
	  isDisturbed,
	  kIsDisturbed,
	  isErrored,
	  kIsErrored,
	  isReadable,
	  kIsReadable,
	  kIsClosedPromise,
	  kControllerErrorFunction,
	  kIsWritable,
	  isClosed,
	  isDuplexNodeStream,
	  isFinished,
	  isIterable,
	  isReadableNodeStream,
	  isReadableStream,
	  isReadableEnded,
	  isReadableFinished,
	  isReadableErrored,
	  isNodeStream,
	  isWebStream,
	  isWritable,
	  isWritableNodeStream,
	  isWritableStream,
	  isWritableEnded,
	  isWritableFinished,
	  isWritableErrored,
	  isServerRequest,
	  isServerResponse,
	  willEmitClose,
	  isTransformStream
	};
	return utils;
}

var hasRequiredEndOfStream;

function requireEndOfStream () {
	if (hasRequiredEndOfStream) return endOfStream.exports;
	hasRequiredEndOfStream = 1;

	/* replacement start */

	const process = requireProcess();

	/* replacement end */

	const { AbortError, codes } = requireErrors();
	const { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
	const { kEmptyObject, once } = requireUtil();
	const { validateAbortSignal, validateFunction, validateObject, validateBoolean } = requireValidators();
	const { Promise, PromisePrototypeThen, SymbolDispose } = requirePrimordials();
	const {
	  isClosed,
	  isReadable,
	  isReadableNodeStream,
	  isReadableStream,
	  isReadableFinished,
	  isReadableErrored,
	  isWritable,
	  isWritableNodeStream,
	  isWritableStream,
	  isWritableFinished,
	  isWritableErrored,
	  isNodeStream,
	  willEmitClose: _willEmitClose,
	  kIsClosedPromise
	} = requireUtils();
	let addAbortListener;
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function'
	}
	const nop = () => {};
	function eos(stream, options, callback) {
	  var _options$readable, _options$writable;
	  if (arguments.length === 2) {
	    callback = options;
	    options = kEmptyObject;
	  } else if (options == null) {
	    options = kEmptyObject;
	  } else {
	    validateObject(options, 'options');
	  }
	  validateFunction(callback, 'callback');
	  validateAbortSignal(options.signal, 'options.signal');
	  callback = once(callback);
	  if (isReadableStream(stream) || isWritableStream(stream)) {
	    return eosWeb(stream, options, callback)
	  }
	  if (!isNodeStream(stream)) {
	    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)
	  }
	  const readable =
	    (_options$readable = options.readable) !== null && _options$readable !== undefined
	      ? _options$readable
	      : isReadableNodeStream(stream);
	  const writable =
	    (_options$writable = options.writable) !== null && _options$writable !== undefined
	      ? _options$writable
	      : isWritableNodeStream(stream);
	  const wState = stream._writableState;
	  const rState = stream._readableState;
	  const onlegacyfinish = () => {
	    if (!stream.writable) {
	      onfinish();
	    }
	  };

	  // TODO (ronag): Improve soft detection to include core modules and
	  // common ecosystem modules that do properly emit 'close' but fail
	  // this generic check.
	  let willEmitClose =
	    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
	  let writableFinished = isWritableFinished(stream, false);
	  const onfinish = () => {
	    writableFinished = true;
	    // Stream should not be destroyed here. If it is that
	    // means that user space is doing something differently and
	    // we cannot trust willEmitClose.
	    if (stream.destroyed) {
	      willEmitClose = false;
	    }
	    if (willEmitClose && (!stream.readable || readable)) {
	      return
	    }
	    if (!readable || readableFinished) {
	      callback.call(stream);
	    }
	  };
	  let readableFinished = isReadableFinished(stream, false);
	  const onend = () => {
	    readableFinished = true;
	    // Stream should not be destroyed here. If it is that
	    // means that user space is doing something differently and
	    // we cannot trust willEmitClose.
	    if (stream.destroyed) {
	      willEmitClose = false;
	    }
	    if (willEmitClose && (!stream.writable || writable)) {
	      return
	    }
	    if (!writable || writableFinished) {
	      callback.call(stream);
	    }
	  };
	  const onerror = (err) => {
	    callback.call(stream, err);
	  };
	  let closed = isClosed(stream);
	  const onclose = () => {
	    closed = true;
	    const errored = isWritableErrored(stream) || isReadableErrored(stream);
	    if (errored && typeof errored !== 'boolean') {
	      return callback.call(stream, errored)
	    }
	    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
	      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
	    }
	    if (writable && !writableFinished) {
	      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())
	    }
	    callback.call(stream);
	  };
	  const onclosed = () => {
	    closed = true;
	    const errored = isWritableErrored(stream) || isReadableErrored(stream);
	    if (errored && typeof errored !== 'boolean') {
	      return callback.call(stream, errored)
	    }
	    callback.call(stream);
	  };
	  const onrequest = () => {
	    stream.req.on('finish', onfinish);
	  };
	  if (isRequest(stream)) {
	    stream.on('complete', onfinish);
	    if (!willEmitClose) {
	      stream.on('abort', onclose);
	    }
	    if (stream.req) {
	      onrequest();
	    } else {
	      stream.on('request', onrequest);
	    }
	  } else if (writable && !wState) {
	    // legacy streams
	    stream.on('end', onlegacyfinish);
	    stream.on('close', onlegacyfinish);
	  }

	  // Not all streams will emit 'close' after 'aborted'.
	  if (!willEmitClose && typeof stream.aborted === 'boolean') {
	    stream.on('aborted', onclose);
	  }
	  stream.on('end', onend);
	  stream.on('finish', onfinish);
	  if (options.error !== false) {
	    stream.on('error', onerror);
	  }
	  stream.on('close', onclose);
	  if (closed) {
	    process.nextTick(onclose);
	  } else if (
	    (wState !== null && wState !== undefined && wState.errorEmitted) ||
	    (rState !== null && rState !== undefined && rState.errorEmitted)
	  ) {
	    if (!willEmitClose) {
	      process.nextTick(onclosed);
	    }
	  } else if (
	    !readable &&
	    (!willEmitClose || isReadable(stream)) &&
	    (writableFinished || isWritable(stream) === false)
	  ) {
	    process.nextTick(onclosed);
	  } else if (
	    !writable &&
	    (!willEmitClose || isWritable(stream)) &&
	    (readableFinished || isReadable(stream) === false)
	  ) {
	    process.nextTick(onclosed);
	  } else if (rState && stream.req && stream.aborted) {
	    process.nextTick(onclosed);
	  }
	  const cleanup = () => {
	    callback = nop;
	    stream.removeListener('aborted', onclose);
	    stream.removeListener('complete', onfinish);
	    stream.removeListener('abort', onclose);
	    stream.removeListener('request', onrequest);
	    if (stream.req) stream.req.removeListener('finish', onfinish);
	    stream.removeListener('end', onlegacyfinish);
	    stream.removeListener('close', onlegacyfinish);
	    stream.removeListener('finish', onfinish);
	    stream.removeListener('end', onend);
	    stream.removeListener('error', onerror);
	    stream.removeListener('close', onclose);
	  };
	  if (options.signal && !closed) {
	    const abort = () => {
	      // Keep it because cleanup removes it.
	      const endCallback = callback;
	      cleanup();
	      endCallback.call(
	        stream,
	        new AbortError(undefined, {
	          cause: options.signal.reason
	        })
	      );
	    };
	    if (options.signal.aborted) {
	      process.nextTick(abort);
	    } else {
	      addAbortListener = addAbortListener || requireUtil().addAbortListener;
	      const disposable = addAbortListener(options.signal, abort);
	      const originalCallback = callback;
	      callback = once((...args) => {
	        disposable[SymbolDispose]();
	        originalCallback.apply(stream, args);
	      });
	    }
	  }
	  return cleanup
	}
	function eosWeb(stream, options, callback) {
	  let isAborted = false;
	  let abort = nop;
	  if (options.signal) {
	    abort = () => {
	      isAborted = true;
	      callback.call(
	        stream,
	        new AbortError(undefined, {
	          cause: options.signal.reason
	        })
	      );
	    };
	    if (options.signal.aborted) {
	      process.nextTick(abort);
	    } else {
	      addAbortListener = addAbortListener || requireUtil().addAbortListener;
	      const disposable = addAbortListener(options.signal, abort);
	      const originalCallback = callback;
	      callback = once((...args) => {
	        disposable[SymbolDispose]();
	        originalCallback.apply(stream, args);
	      });
	    }
	  }
	  const resolverFn = (...args) => {
	    if (!isAborted) {
	      process.nextTick(() => callback.apply(stream, args));
	    }
	  };
	  PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
	  return nop
	}
	function finished(stream, opts) {
	  var _opts;
	  let autoCleanup = false;
	  if (opts === null) {
	    opts = kEmptyObject;
	  }
	  if ((_opts = opts) !== null && _opts !== undefined && _opts.cleanup) {
	    validateBoolean(opts.cleanup, 'cleanup');
	    autoCleanup = opts.cleanup;
	  }
	  return new Promise((resolve, reject) => {
	    const cleanup = eos(stream, opts, (err) => {
	      if (autoCleanup) {
	        cleanup();
	      }
	      if (err) {
	        reject(err);
	      } else {
	        resolve();
	      }
	    });
	  })
	}
	endOfStream.exports = eos;
	endOfStream.exports.finished = finished;
	return endOfStream.exports;
}

var destroy_1;
var hasRequiredDestroy;

function requireDestroy () {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;

	/* replacement start */

	const process = requireProcess();

	/* replacement end */

	const {
	  aggregateTwoErrors,
	  codes: { ERR_MULTIPLE_CALLBACK },
	  AbortError
	} = requireErrors();
	const { Symbol } = requirePrimordials();
	const { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = requireUtils();
	const kDestroy = Symbol('kDestroy');
	const kConstruct = Symbol('kConstruct');
	function checkError(err, w, r) {
	  if (err) {
	    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
	    err.stack; // eslint-disable-line no-unused-expressions

	    if (w && !w.errored) {
	      w.errored = err;
	    }
	    if (r && !r.errored) {
	      r.errored = err;
	    }
	  }
	}

	// Backwards compat. cb() is undocumented and unused in core but
	// unfortunately might be used by modules.
	function destroy(err, cb) {
	  const r = this._readableState;
	  const w = this._writableState;
	  // With duplex streams we use the writable side for state.
	  const s = w || r;
	  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {
	    if (typeof cb === 'function') {
	      cb();
	    }
	    return this
	  }

	  // We set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks
	  checkError(err, w, r);
	  if (w) {
	    w.destroyed = true;
	  }
	  if (r) {
	    r.destroyed = true;
	  }

	  // If still constructing then defer calling _destroy.
	  if (!s.constructed) {
	    this.once(kDestroy, function (er) {
	      _destroy(this, aggregateTwoErrors(er, err), cb);
	    });
	  } else {
	    _destroy(this, err, cb);
	  }
	  return this
	}
	function _destroy(self, err, cb) {
	  let called = false;
	  function onDestroy(err) {
	    if (called) {
	      return
	    }
	    called = true;
	    const r = self._readableState;
	    const w = self._writableState;
	    checkError(err, w, r);
	    if (w) {
	      w.closed = true;
	    }
	    if (r) {
	      r.closed = true;
	    }
	    if (typeof cb === 'function') {
	      cb(err);
	    }
	    if (err) {
	      process.nextTick(emitErrorCloseNT, self, err);
	    } else {
	      process.nextTick(emitCloseNT, self);
	    }
	  }
	  try {
	    self._destroy(err || null, onDestroy);
	  } catch (err) {
	    onDestroy(err);
	  }
	}
	function emitErrorCloseNT(self, err) {
	  emitErrorNT(self, err);
	  emitCloseNT(self);
	}
	function emitCloseNT(self) {
	  const r = self._readableState;
	  const w = self._writableState;
	  if (w) {
	    w.closeEmitted = true;
	  }
	  if (r) {
	    r.closeEmitted = true;
	  }
	  if ((w !== null && w !== undefined && w.emitClose) || (r !== null && r !== undefined && r.emitClose)) {
	    self.emit('close');
	  }
	}
	function emitErrorNT(self, err) {
	  const r = self._readableState;
	  const w = self._writableState;
	  if ((w !== null && w !== undefined && w.errorEmitted) || (r !== null && r !== undefined && r.errorEmitted)) {
	    return
	  }
	  if (w) {
	    w.errorEmitted = true;
	  }
	  if (r) {
	    r.errorEmitted = true;
	  }
	  self.emit('error', err);
	}
	function undestroy() {
	  const r = this._readableState;
	  const w = this._writableState;
	  if (r) {
	    r.constructed = true;
	    r.closed = false;
	    r.closeEmitted = false;
	    r.destroyed = false;
	    r.errored = null;
	    r.errorEmitted = false;
	    r.reading = false;
	    r.ended = r.readable === false;
	    r.endEmitted = r.readable === false;
	  }
	  if (w) {
	    w.constructed = true;
	    w.destroyed = false;
	    w.closed = false;
	    w.closeEmitted = false;
	    w.errored = null;
	    w.errorEmitted = false;
	    w.finalCalled = false;
	    w.prefinished = false;
	    w.ended = w.writable === false;
	    w.ending = w.writable === false;
	    w.finished = w.writable === false;
	  }
	}
	function errorOrDestroy(stream, err, sync) {
	  // We have tests that rely on errors being emitted
	  // in the same tick, so changing this is semver major.
	  // For now when you opt-in to autoDestroy we allow
	  // the error to be emitted nextTick. In a future
	  // semver major update we should change the default to this.

	  const r = stream._readableState;
	  const w = stream._writableState;
	  if ((w !== null && w !== undefined && w.destroyed) || (r !== null && r !== undefined && r.destroyed)) {
	    return this
	  }
	  if ((r !== null && r !== undefined && r.autoDestroy) || (w !== null && w !== undefined && w.autoDestroy))
	    stream.destroy(err);
	  else if (err) {
	    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
	    err.stack; // eslint-disable-line no-unused-expressions

	    if (w && !w.errored) {
	      w.errored = err;
	    }
	    if (r && !r.errored) {
	      r.errored = err;
	    }
	    if (sync) {
	      process.nextTick(emitErrorNT, stream, err);
	    } else {
	      emitErrorNT(stream, err);
	    }
	  }
	}
	function construct(stream, cb) {
	  if (typeof stream._construct !== 'function') {
	    return
	  }
	  const r = stream._readableState;
	  const w = stream._writableState;
	  if (r) {
	    r.constructed = false;
	  }
	  if (w) {
	    w.constructed = false;
	  }
	  stream.once(kConstruct, cb);
	  if (stream.listenerCount(kConstruct) > 1) {
	    // Duplex
	    return
	  }
	  process.nextTick(constructNT, stream);
	}
	function constructNT(stream) {
	  let called = false;
	  function onConstruct(err) {
	    if (called) {
	      errorOrDestroy(stream, err !== null && err !== undefined ? err : new ERR_MULTIPLE_CALLBACK());
	      return
	    }
	    called = true;
	    const r = stream._readableState;
	    const w = stream._writableState;
	    const s = w || r;
	    if (r) {
	      r.constructed = true;
	    }
	    if (w) {
	      w.constructed = true;
	    }
	    if (s.destroyed) {
	      stream.emit(kDestroy, err);
	    } else if (err) {
	      errorOrDestroy(stream, err, true);
	    } else {
	      process.nextTick(emitConstructNT, stream);
	    }
	  }
	  try {
	    stream._construct((err) => {
	      process.nextTick(onConstruct, err);
	    });
	  } catch (err) {
	    process.nextTick(onConstruct, err);
	  }
	}
	function emitConstructNT(stream) {
	  stream.emit(kConstruct);
	}
	function isRequest(stream) {
	  return (stream === null || stream === undefined ? undefined : stream.setHeader) && typeof stream.abort === 'function'
	}
	function emitCloseLegacy(stream) {
	  stream.emit('close');
	}
	function emitErrorCloseLegacy(stream, err) {
	  stream.emit('error', err);
	  process.nextTick(emitCloseLegacy, stream);
	}

	// Normalize destroy for legacy.
	function destroyer(stream, err) {
	  if (!stream || isDestroyed(stream)) {
	    return
	  }
	  if (!err && !isFinished(stream)) {
	    err = new AbortError();
	  }

	  // TODO: Remove isRequest branches.
	  if (isServerRequest(stream)) {
	    stream.socket = null;
	    stream.destroy(err);
	  } else if (isRequest(stream)) {
	    stream.abort();
	  } else if (isRequest(stream.req)) {
	    stream.req.abort();
	  } else if (typeof stream.destroy === 'function') {
	    stream.destroy(err);
	  } else if (typeof stream.close === 'function') {
	    // TODO: Don't lose err?
	    stream.close();
	  } else if (err) {
	    process.nextTick(emitErrorCloseLegacy, stream, err);
	  } else {
	    process.nextTick(emitCloseLegacy, stream);
	  }
	  if (!stream.destroyed) {
	    stream[kIsDestroyed] = true;
	  }
	}
	destroy_1 = {
	  construct,
	  destroyer,
	  destroy,
	  undestroy,
	  errorOrDestroy
	};
	return destroy_1;
}

var legacy;
var hasRequiredLegacy;

function requireLegacy () {
	if (hasRequiredLegacy) return legacy;
	hasRequiredLegacy = 1;

	const { ArrayIsArray, ObjectSetPrototypeOf } = requirePrimordials();
	const { EventEmitter: EE } = require$$0$5;
	function Stream(opts) {
	  EE.call(this, opts);
	}
	ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
	ObjectSetPrototypeOf(Stream, EE);
	Stream.prototype.pipe = function (dest, options) {
	  const source = this;
	  function ondata(chunk) {
	    if (dest.writable && dest.write(chunk) === false && source.pause) {
	      source.pause();
	    }
	  }
	  source.on('data', ondata);
	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }
	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }
	  let didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return
	    didOnEnd = true;
	    dest.end();
	  }
	  function onclose() {
	    if (didOnEnd) return
	    didOnEnd = true;
	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // Don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      this.emit('error', er);
	    }
	  }
	  prependListener(source, 'error', onerror);
	  prependListener(dest, 'error', onerror);

	  // Remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);
	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);
	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);
	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);
	    dest.removeListener('close', cleanup);
	  }
	  source.on('end', cleanup);
	  source.on('close', cleanup);
	  dest.on('close', cleanup);
	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest
	};
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn)

	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
	  else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
	  else emitter._events[event] = [fn, emitter._events[event]];
	}
	legacy = {
	  Stream,
	  prependListener
	};
	return legacy;
}

var addAbortSignal = {exports: {}};

var hasRequiredAddAbortSignal;

function requireAddAbortSignal () {
	if (hasRequiredAddAbortSignal) return addAbortSignal.exports;
	hasRequiredAddAbortSignal = 1;
	(function (module) {

		const { SymbolDispose } = requirePrimordials();
		const { AbortError, codes } = requireErrors();
		const { isNodeStream, isWebStream, kControllerErrorFunction } = requireUtils();
		const eos = requireEndOfStream();
		const { ERR_INVALID_ARG_TYPE } = codes;
		let addAbortListener;

		// This method is inlined here for readable-stream
		// It also does not allow for signal to not exist on the stream
		// https://github.com/nodejs/node/pull/36061#discussion_r533718029
		const validateAbortSignal = (signal, name) => {
		  if (typeof signal !== 'object' || !('aborted' in signal)) {
		    throw new ERR_INVALID_ARG_TYPE(name, 'AbortSignal', signal)
		  }
		};
		module.exports.addAbortSignal = function addAbortSignal(signal, stream) {
		  validateAbortSignal(signal, 'signal');
		  if (!isNodeStream(stream) && !isWebStream(stream)) {
		    throw new ERR_INVALID_ARG_TYPE('stream', ['ReadableStream', 'WritableStream', 'Stream'], stream)
		  }
		  return module.exports.addAbortSignalNoValidate(signal, stream)
		};
		module.exports.addAbortSignalNoValidate = function (signal, stream) {
		  if (typeof signal !== 'object' || !('aborted' in signal)) {
		    return stream
		  }
		  const onAbort = isNodeStream(stream)
		    ? () => {
		        stream.destroy(
		          new AbortError(undefined, {
		            cause: signal.reason
		          })
		        );
		      }
		    : () => {
		        stream[kControllerErrorFunction](
		          new AbortError(undefined, {
		            cause: signal.reason
		          })
		        );
		      };
		  if (signal.aborted) {
		    onAbort();
		  } else {
		    addAbortListener = addAbortListener || requireUtil().addAbortListener;
		    const disposable = addAbortListener(signal, onAbort);
		    eos(stream, disposable[SymbolDispose]);
		  }
		  return stream
		}; 
	} (addAbortSignal));
	return addAbortSignal.exports;
}

var buffer_list;
var hasRequiredBuffer_list;

function requireBuffer_list () {
	if (hasRequiredBuffer_list) return buffer_list;
	hasRequiredBuffer_list = 1;

	const { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = requirePrimordials();
	const { Buffer } = require$$0$7;
	const { inspect } = requireUtil();
	buffer_list = class BufferList {
	  constructor() {
	    this.head = null;
	    this.tail = null;
	    this.length = 0;
	  }
	  push(v) {
	    const entry = {
	      data: v,
	      next: null
	    };
	    if (this.length > 0) this.tail.next = entry;
	    else this.head = entry;
	    this.tail = entry;
	    ++this.length;
	  }
	  unshift(v) {
	    const entry = {
	      data: v,
	      next: this.head
	    };
	    if (this.length === 0) this.tail = entry;
	    this.head = entry;
	    ++this.length;
	  }
	  shift() {
	    if (this.length === 0) return
	    const ret = this.head.data;
	    if (this.length === 1) this.head = this.tail = null;
	    else this.head = this.head.next;
	    --this.length;
	    return ret
	  }
	  clear() {
	    this.head = this.tail = null;
	    this.length = 0;
	  }
	  join(s) {
	    if (this.length === 0) return ''
	    let p = this.head;
	    let ret = '' + p.data;
	    while ((p = p.next) !== null) ret += s + p.data;
	    return ret
	  }
	  concat(n) {
	    if (this.length === 0) return Buffer.alloc(0)
	    const ret = Buffer.allocUnsafe(n >>> 0);
	    let p = this.head;
	    let i = 0;
	    while (p) {
	      TypedArrayPrototypeSet(ret, p.data, i);
	      i += p.data.length;
	      p = p.next;
	    }
	    return ret
	  }

	  // Consumes a specified amount of bytes or characters from the buffered data.
	  consume(n, hasStrings) {
	    const data = this.head.data;
	    if (n < data.length) {
	      // `slice` is the same for buffers and strings.
	      const slice = data.slice(0, n);
	      this.head.data = data.slice(n);
	      return slice
	    }
	    if (n === data.length) {
	      // First chunk is a perfect match.
	      return this.shift()
	    }
	    // Result spans more than one buffer.
	    return hasStrings ? this._getString(n) : this._getBuffer(n)
	  }
	  first() {
	    return this.head.data
	  }
	  *[SymbolIterator]() {
	    for (let p = this.head; p; p = p.next) {
	      yield p.data;
	    }
	  }

	  // Consumes a specified amount of characters from the buffered data.
	  _getString(n) {
	    let ret = '';
	    let p = this.head;
	    let c = 0;
	    do {
	      const str = p.data;
	      if (n > str.length) {
	        ret += str;
	        n -= str.length;
	      } else {
	        if (n === str.length) {
	          ret += str;
	          ++c;
	          if (p.next) this.head = p.next;
	          else this.head = this.tail = null;
	        } else {
	          ret += StringPrototypeSlice(str, 0, n);
	          this.head = p;
	          p.data = StringPrototypeSlice(str, n);
	        }
	        break
	      }
	      ++c;
	    } while ((p = p.next) !== null)
	    this.length -= c;
	    return ret
	  }

	  // Consumes a specified amount of bytes from the buffered data.
	  _getBuffer(n) {
	    const ret = Buffer.allocUnsafe(n);
	    const retLen = n;
	    let p = this.head;
	    let c = 0;
	    do {
	      const buf = p.data;
	      if (n > buf.length) {
	        TypedArrayPrototypeSet(ret, buf, retLen - n);
	        n -= buf.length;
	      } else {
	        if (n === buf.length) {
	          TypedArrayPrototypeSet(ret, buf, retLen - n);
	          ++c;
	          if (p.next) this.head = p.next;
	          else this.head = this.tail = null;
	        } else {
	          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);
	          this.head = p;
	          p.data = buf.slice(n);
	        }
	        break
	      }
	      ++c;
	    } while ((p = p.next) !== null)
	    this.length -= c;
	    return ret
	  }

	  // Make sure the linked list only shows the minimal necessary information.
	  [Symbol.for('nodejs.util.inspect.custom')](_, options) {
	    return inspect(this, {
	      ...options,
	      // Only inspect one level.
	      depth: 0,
	      // It should not recurse.
	      customInspect: false
	    })
	  }
	};
	return buffer_list;
}

var state;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state;
	hasRequiredState = 1;

	const { MathFloor, NumberIsInteger } = requirePrimordials();
	const { validateInteger } = requireValidators();
	const { ERR_INVALID_ARG_VALUE } = requireErrors().codes;
	let defaultHighWaterMarkBytes = 16 * 1024;
	let defaultHighWaterMarkObjectMode = 16;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null
	}
	function getDefaultHighWaterMark(objectMode) {
	  return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes
	}
	function setDefaultHighWaterMark(objectMode, value) {
	  validateInteger(value, 'value', 0);
	  if (objectMode) {
	    defaultHighWaterMarkObjectMode = value;
	  } else {
	    defaultHighWaterMarkBytes = value;
	  }
	}
	function getHighWaterMark(state, options, duplexKey, isDuplex) {
	  const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
	  if (hwm != null) {
	    if (!NumberIsInteger(hwm) || hwm < 0) {
	      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';
	      throw new ERR_INVALID_ARG_VALUE(name, hwm)
	    }
	    return MathFloor(hwm)
	  }

	  // Default value
	  return getDefaultHighWaterMark(state.objectMode)
	}
	state = {
	  getHighWaterMark,
	  getDefaultHighWaterMark,
	  setDefaultHighWaterMark
	};
	return state;
}

var string_decoder = {};

var hasRequiredString_decoder;

function requireString_decoder () {
	if (hasRequiredString_decoder) return string_decoder;
	hasRequiredString_decoder = 1;

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	/*</replacement>*/

	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	string_decoder.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}
	return string_decoder;
}

var from_1;
var hasRequiredFrom;

function requireFrom () {
	if (hasRequiredFrom) return from_1;
	hasRequiredFrom = 1;

	/* replacement start */

	const process = requireProcess();

	/* replacement end */

	const { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = requirePrimordials();
	const { Buffer } = require$$0$7;
	const { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = requireErrors().codes;
	function from(Readable, iterable, opts) {
	  let iterator;
	  if (typeof iterable === 'string' || iterable instanceof Buffer) {
	    return new Readable({
	      objectMode: true,
	      ...opts,
	      read() {
	        this.push(iterable);
	        this.push(null);
	      }
	    })
	  }
	  let isAsync;
	  if (iterable && iterable[SymbolAsyncIterator]) {
	    isAsync = true;
	    iterator = iterable[SymbolAsyncIterator]();
	  } else if (iterable && iterable[SymbolIterator]) {
	    isAsync = false;
	    iterator = iterable[SymbolIterator]();
	  } else {
	    throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable)
	  }
	  const readable = new Readable({
	    objectMode: true,
	    highWaterMark: 1,
	    // TODO(ronag): What options should be allowed?
	    ...opts
	  });

	  // Flag to protect against _read
	  // being called before last iteration completion.
	  let reading = false;
	  readable._read = function () {
	    if (!reading) {
	      reading = true;
	      next();
	    }
	  };
	  readable._destroy = function (error, cb) {
	    PromisePrototypeThen(
	      close(error),
	      () => process.nextTick(cb, error),
	      // nextTick is here in case cb throws
	      (e) => process.nextTick(cb, e || error)
	    );
	  };
	  async function close(error) {
	    const hadError = error !== undefined && error !== null;
	    const hasThrow = typeof iterator.throw === 'function';
	    if (hadError && hasThrow) {
	      const { value, done } = await iterator.throw(error);
	      await value;
	      if (done) {
	        return
	      }
	    }
	    if (typeof iterator.return === 'function') {
	      const { value } = await iterator.return();
	      await value;
	    }
	  }
	  async function next() {
	    for (;;) {
	      try {
	        const { value, done } = isAsync ? await iterator.next() : iterator.next();
	        if (done) {
	          readable.push(null);
	        } else {
	          const res = value && typeof value.then === 'function' ? await value : value;
	          if (res === null) {
	            reading = false;
	            throw new ERR_STREAM_NULL_VALUES()
	          } else if (readable.push(res)) {
	            continue
	          } else {
	            reading = false;
	          }
	        }
	      } catch (err) {
	        readable.destroy(err);
	      }
	      break
	    }
	  }
	  return readable
	}
	from_1 = from;
	return from_1;
}

var readable;
var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable;
	hasRequiredReadable = 1;

	/* replacement start */

	const process = requireProcess();

	/* replacement end */

	const {
	  ArrayPrototypeIndexOf,
	  NumberIsInteger,
	  NumberIsNaN,
	  NumberParseInt,
	  ObjectDefineProperties,
	  ObjectKeys,
	  ObjectSetPrototypeOf,
	  Promise,
	  SafeSet,
	  SymbolAsyncDispose,
	  SymbolAsyncIterator,
	  Symbol
	} = requirePrimordials();
	readable = Readable;
	Readable.ReadableState = ReadableState;
	const { EventEmitter: EE } = require$$0$5;
	const { Stream, prependListener } = requireLegacy();
	const { Buffer } = require$$0$7;
	const { addAbortSignal } = requireAddAbortSignal();
	const eos = requireEndOfStream();
	let debug = requireUtil().debuglog('stream', (fn) => {
	  debug = fn;
	});
	const BufferList = requireBuffer_list();
	const destroyImpl = requireDestroy();
	const { getHighWaterMark, getDefaultHighWaterMark } = requireState();
	const {
	  aggregateTwoErrors,
	  codes: {
	    ERR_INVALID_ARG_TYPE,
	    ERR_METHOD_NOT_IMPLEMENTED,
	    ERR_OUT_OF_RANGE,
	    ERR_STREAM_PUSH_AFTER_EOF,
	    ERR_STREAM_UNSHIFT_AFTER_END_EVENT
	  },
	  AbortError
	} = requireErrors();
	const { validateObject } = requireValidators();
	const kPaused = Symbol('kPaused');
	const { StringDecoder } = requireString_decoder();
	const from = requireFrom();
	ObjectSetPrototypeOf(Readable.prototype, Stream.prototype);
	ObjectSetPrototypeOf(Readable, Stream);
	const nop = () => {};
	const { errorOrDestroy } = destroyImpl;
	const kObjectMode = 1 << 0;
	const kEnded = 1 << 1;
	const kEndEmitted = 1 << 2;
	const kReading = 1 << 3;
	const kConstructed = 1 << 4;
	const kSync = 1 << 5;
	const kNeedReadable = 1 << 6;
	const kEmittedReadable = 1 << 7;
	const kReadableListening = 1 << 8;
	const kResumeScheduled = 1 << 9;
	const kErrorEmitted = 1 << 10;
	const kEmitClose = 1 << 11;
	const kAutoDestroy = 1 << 12;
	const kDestroyed = 1 << 13;
	const kClosed = 1 << 14;
	const kCloseEmitted = 1 << 15;
	const kMultiAwaitDrain = 1 << 16;
	const kReadingMore = 1 << 17;
	const kDataEmitted = 1 << 18;

	// TODO(benjamingr) it is likely slower to do it this way than with free functions
	function makeBitMapDescriptor(bit) {
	  return {
	    enumerable: false,
	    get() {
	      return (this.state & bit) !== 0
	    },
	    set(value) {
	      if (value) this.state |= bit;
	      else this.state &= ~bit;
	    }
	  }
	}
	ObjectDefineProperties(ReadableState.prototype, {
	  objectMode: makeBitMapDescriptor(kObjectMode),
	  ended: makeBitMapDescriptor(kEnded),
	  endEmitted: makeBitMapDescriptor(kEndEmitted),
	  reading: makeBitMapDescriptor(kReading),
	  // Stream is still being constructed and cannot be
	  // destroyed until construction finished or failed.
	  // Async construction is opt in, therefore we start as
	  // constructed.
	  constructed: makeBitMapDescriptor(kConstructed),
	  // A flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  sync: makeBitMapDescriptor(kSync),
	  // Whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  needReadable: makeBitMapDescriptor(kNeedReadable),
	  emittedReadable: makeBitMapDescriptor(kEmittedReadable),
	  readableListening: makeBitMapDescriptor(kReadableListening),
	  resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
	  // True if the error was already emitted and should not be thrown again.
	  errorEmitted: makeBitMapDescriptor(kErrorEmitted),
	  emitClose: makeBitMapDescriptor(kEmitClose),
	  autoDestroy: makeBitMapDescriptor(kAutoDestroy),
	  // Has it been destroyed.
	  destroyed: makeBitMapDescriptor(kDestroyed),
	  // Indicates whether the stream has finished destroying.
	  closed: makeBitMapDescriptor(kClosed),
	  // True if close has been emitted or would have been emitted
	  // depending on emitClose.
	  closeEmitted: makeBitMapDescriptor(kCloseEmitted),
	  multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
	  // If true, a maybeReadMore has been scheduled.
	  readingMore: makeBitMapDescriptor(kReadingMore),
	  dataEmitted: makeBitMapDescriptor(kDataEmitted)
	});
	function ReadableState(options, stream, isDuplex) {
	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof requireDuplex();

	  // Bit map field to store ReadableState more effciently with 1 bit per field
	  // instead of a V8 slot per field.
	  this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
	  // Object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away.
	  if (options && options.objectMode) this.state |= kObjectMode;
	  if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;

	  // The point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  this.highWaterMark = options
	    ? getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex)
	    : getDefaultHighWaterMark(false);

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift().
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = [];
	  this.flowing = null;
	  this[kPaused] = null;

	  // Should close be emitted on destroy. Defaults to true.
	  if (options && options.emitClose === false) this.state &= ~kEmitClose;

	  // Should .destroy() be called after 'end' (and potentially 'finish').
	  if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;

	  // Indicates whether the stream has errored. When true no further
	  // _read calls, 'data' or 'readable' events should occur. This is needed
	  // since when autoDestroy is disabled we need a way to tell whether the
	  // stream has failed.
	  this.errored = null;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';

	  // Ref the piped dest which we need a drain event on it
	  // type: null | Writable | Set<Writable>.
	  this.awaitDrainWriters = null;
	  this.decoder = null;
	  this.encoding = null;
	  if (options && options.encoding) {
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {
	  if (!(this instanceof Readable)) return new Readable(options)

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the ReadableState constructor, at least with V8 6.5.
	  const isDuplex = this instanceof requireDuplex();
	  this._readableState = new ReadableState(options, this, isDuplex);
	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.construct === 'function') this._construct = options.construct;
	    if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
	  }
	  Stream.call(this, options);
	  destroyImpl.construct(this, () => {
	    if (this._readableState.needReadable) {
	      maybeReadMore(this, this._readableState);
	    }
	  });
	}
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  cb(err);
	};
	Readable.prototype[EE.captureRejectionSymbol] = function (err) {
	  this.destroy(err);
	};
	Readable.prototype[SymbolAsyncDispose] = function () {
	  let error;
	  if (!this.destroyed) {
	    error = this.readableEnded ? null : new AbortError();
	    this.destroy(error);
	  }
	  return new Promise((resolve, reject) => eos(this, (err) => (err && err !== error ? reject(err) : resolve(null))))
	};

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  return readableAddChunk(this, chunk, encoding, false)
	};

	// Unshift should *always* be something directly out of read().
	Readable.prototype.unshift = function (chunk, encoding) {
	  return readableAddChunk(this, chunk, encoding, true)
	};
	function readableAddChunk(stream, chunk, encoding, addToFront) {
	  debug('readableAddChunk', chunk);
	  const state = stream._readableState;
	  let err;
	  if ((state.state & kObjectMode) === 0) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (state.encoding !== encoding) {
	        if (addToFront && state.encoding) {
	          // When unshifting, if state.encoding is set, we have to save
	          // the string in the BufferList with the state encoding.
	          chunk = Buffer.from(chunk, encoding).toString(state.encoding);
	        } else {
	          chunk = Buffer.from(chunk, encoding);
	          encoding = '';
	        }
	      }
	    } else if (chunk instanceof Buffer) {
	      encoding = '';
	    } else if (Stream._isUint8Array(chunk)) {
	      chunk = Stream._uint8ArrayToBuffer(chunk);
	      encoding = '';
	    } else if (chunk != null) {
	      err = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
	    }
	  }
	  if (err) {
	    errorOrDestroy(stream, err);
	  } else if (chunk === null) {
	    state.state &= ~kReading;
	    onEofChunk(stream, state);
	  } else if ((state.state & kObjectMode) !== 0 || (chunk && chunk.length > 0)) {
	    if (addToFront) {
	      if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
	      else if (state.destroyed || state.errored) return false
	      else addChunk(stream, state, chunk, true);
	    } else if (state.ended) {
	      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
	    } else if (state.destroyed || state.errored) {
	      return false
	    } else {
	      state.state &= ~kReading;
	      if (state.decoder && !encoding) {
	        chunk = state.decoder.write(chunk);
	        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
	        else maybeReadMore(stream, state);
	      } else {
	        addChunk(stream, state, chunk, false);
	      }
	    }
	  } else if (!addToFront) {
	    state.state &= ~kReading;
	    maybeReadMore(stream, state);
	  }

	  // We can push more data if we are below the highWaterMark.
	  // Also, if we have no data yet, we can stand some more bytes.
	  // This is to work around cases where hwm=0, such as the repl.
	  return !state.ended && (state.length < state.highWaterMark || state.length === 0)
	}
	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount('data') > 0) {
	    // Use the guard to avoid creating `Set()` repeatedly
	    // when we have multiple pipes.
	    if ((state.state & kMultiAwaitDrain) !== 0) {
	      state.awaitDrainWriters.clear();
	    } else {
	      state.awaitDrainWriters = null;
	    }
	    state.dataEmitted = true;
	    stream.emit('data', chunk);
	  } else {
	    // Update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);
	    else state.buffer.push(chunk);
	    if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}
	Readable.prototype.isPaused = function () {
	  const state = this._readableState;
	  return state[kPaused] === true || state.flowing === false
	};

	// Backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  const decoder = new StringDecoder(enc);
	  this._readableState.decoder = decoder;
	  // If setEncoding(null), decoder.encoding equals utf8.
	  this._readableState.encoding = this._readableState.decoder.encoding;
	  const buffer = this._readableState.buffer;
	  // Iterate over current buffer to convert already stored Buffers:
	  let content = '';
	  for (const data of buffer) {
	    content += decoder.write(data);
	  }
	  buffer.clear();
	  if (content !== '') buffer.push(content);
	  this._readableState.length = content.length;
	  return this
	};

	// Don't raise the hwm > 1GB.
	const MAX_HWM = 0x40000000;
	function computeNewHighWaterMark(n) {
	  if (n > MAX_HWM) {
	    throw new ERR_OUT_OF_RANGE('size', '<= 1GiB', n)
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts.
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || (state.length === 0 && state.ended)) return 0
	  if ((state.state & kObjectMode) !== 0) return 1
	  if (NumberIsNaN(n)) {
	    // Only flow one buffer at a time.
	    if (state.flowing && state.length) return state.buffer.first().length
	    return state.length
	  }
	  if (n <= state.length) return n
	  return state.ended ? state.length : 0
	}

	// You can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  // Same as parseInt(undefined, 10), however V8 7.3 performance regressed
	  // in this scenario, so we are doing it manually.
	  if (n === undefined) {
	    n = NaN;
	  } else if (!NumberIsInteger(n)) {
	    n = NumberParseInt(n, 10);
	  }
	  const state = this._readableState;
	  const nOrig = n;

	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n !== 0) state.state &= ~kEmittedReadable;

	  // If we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (
	    n === 0 &&
	    state.needReadable &&
	    ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)
	  ) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);
	    else emitReadable(this);
	    return null
	  }
	  n = howMuchToRead(n, state);

	  // If we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  let doRead = (state.state & kNeedReadable) !== 0;
	  debug('need readable', doRead);

	  // If we currently have less than the highWaterMark, then also read some.
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // However, if we've ended, then there's no point, if we're already
	  // reading, then it's unnecessary, if we're constructing we have to wait,
	  // and if we're destroyed or errored, then it's not allowed,
	  if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
	    doRead = false;
	    debug('reading, ended or constructing', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.state |= kReading | kSync;
	    // If the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.state |= kNeedReadable;

	    // Call internal read method
	    try {
	      this._read(state.highWaterMark);
	    } catch (err) {
	      errorOrDestroy(this, err);
	    }
	    state.state &= ~kSync;

	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	  let ret;
	  if (n > 0) ret = fromList(n, state);
	  else ret = null;
	  if (ret === null) {
	    state.needReadable = state.length <= state.highWaterMark;
	    n = 0;
	  } else {
	    state.length -= n;
	    if (state.multiAwaitDrain) {
	      state.awaitDrainWriters.clear();
	    } else {
	      state.awaitDrainWriters = null;
	    }
	  }
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
	    state.dataEmitted = true;
	    this.emit('data', ret);
	  }
	  return ret
	};
	function onEofChunk(stream, state) {
	  debug('onEofChunk');
	  if (state.ended) return
	  if (state.decoder) {
	    const chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	  if (state.sync) {
	    // If we are sync, wait until next tick to emit the data.
	    // Otherwise we risk emitting data in the flow()
	    // the readable code triggers during a read() call.
	    emitReadable(stream);
	  } else {
	    // Emit 'readable' now to make sure it gets picked up.
	    state.needReadable = false;
	    state.emittedReadable = true;
	    // We have to emit readable now that we are EOF. Modules
	    // in the ecosystem (e.g. dicer) rely on this event being sync.
	    emitReadable_(stream);
	  }
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  const state = stream._readableState;
	  debug('emitReadable', state.needReadable, state.emittedReadable);
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    process.nextTick(emitReadable_, stream);
	  }
	}
	function emitReadable_(stream) {
	  const state = stream._readableState;
	  debug('emitReadable_', state.destroyed, state.length, state.ended);
	  if (!state.destroyed && !state.errored && (state.length || state.ended)) {
	    stream.emit('readable');
	    state.emittedReadable = false;
	  }

	  // The stream needs another readable event if:
	  // 1. It is not flowing, as the flow mechanism will take
	  //    care of it.
	  // 2. It is not ended.
	  // 3. It is below the highWaterMark, so we can schedule
	  //    another readable later.
	  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
	  flow(stream);
	}

	// At this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore && state.constructed) {
	    state.readingMore = true;
	    process.nextTick(maybeReadMore_, stream, state);
	  }
	}
	function maybeReadMore_(stream, state) {
	  // Attempt to read more data if we should.
	  //
	  // The conditions for reading more data are (one of):
	  // - Not enough data buffered (state.length < state.highWaterMark). The loop
	  //   is responsible for filling the buffer with enough data if such data
	  //   is available. If highWaterMark is 0 and we are not in the flowing mode
	  //   we should _not_ attempt to buffer any extra data. We'll get more data
	  //   when the stream consumer calls read() instead.
	  // - No data in the buffer, and the stream is in flowing mode. In this mode
	  //   the loop below is responsible for ensuring read() is called. Failing to
	  //   call read here would abort the flow and there's no other mechanism for
	  //   continuing the flow if the stream consumer has just subscribed to the
	  //   'data' event.
	  //
	  // In addition to the above conditions to keep reading data, the following
	  // conditions prevent the data from being read:
	  // - The stream has ended (state.ended).
	  // - There is already a pending 'read' operation (state.reading). This is a
	  //   case where the stream has called the implementation defined _read()
	  //   method, but they are processing the call asynchronously and have _not_
	  //   called push() with new data. In this case we skip performing more
	  //   read()s. The execution ends in this method again after the _read() ends
	  //   up calling push() with more data.
	  while (
	    !state.reading &&
	    !state.ended &&
	    (state.length < state.highWaterMark || (state.flowing && state.length === 0))
	  ) {
	    const len = state.length;
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // Didn't get any data, stop spinning.
	      break
	  }
	  state.readingMore = false;
	}

	// Abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()')
	};
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  const src = this;
	  const state = this._readableState;
	  if (state.pipes.length === 1) {
	    if (!state.multiAwaitDrain) {
	      state.multiAwaitDrain = true;
	      state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
	    }
	  }
	  state.pipes.push(dest);
	  debug('pipe count=%d opts=%j', state.pipes.length, pipeOpts);
	  const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	  const endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) process.nextTick(endFn);
	  else src.once('end', endFn);
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }
	  function onend() {
	    debug('onend');
	    dest.end();
	  }
	  let ondrain;
	  let cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // Cleanup event handlers once the pipe is broken.
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    if (ondrain) {
	      dest.removeListener('drain', ondrain);
	    }
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);
	    cleanedUp = true;

	    // If the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	  function pause() {
	    // If the user unpiped during `dest.write()`, it is possible
	    // to get stuck in a permanently paused state if that write
	    // also returned false.
	    // => Check whether `dest` is still a piping destination.
	    if (!cleanedUp) {
	      if (state.pipes.length === 1 && state.pipes[0] === dest) {
	        debug('false write response, pause', 0);
	        state.awaitDrainWriters = dest;
	        state.multiAwaitDrain = false;
	      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
	        debug('false write response, pause', state.awaitDrainWriters.size);
	        state.awaitDrainWriters.add(dest);
	      }
	      src.pause();
	    }
	    if (!ondrain) {
	      // When the dest drains, it reduces the awaitDrain counter
	      // on the source.  This would be more elegant with a .once()
	      // handler in flow(), but adding and removing repeatedly is
	      // too slow.
	      ondrain = pipeOnDrain(src, dest);
	      dest.on('drain', ondrain);
	    }
	  }
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    const ret = dest.write(chunk);
	    debug('dest.write', ret);
	    if (ret === false) {
	      pause();
	    }
	  }

	  // If the dest has an error, then stop piping into it.
	  // However, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (dest.listenerCount('error') === 0) {
	      const s = dest._writableState || dest._readableState;
	      if (s && !s.errorEmitted) {
	        // User incorrectly emitted 'error' directly on the stream.
	        errorOrDestroy(dest, er);
	      } else {
	        dest.emit('error', er);
	      }
	    }
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // Tell the dest that it's being piped to.
	  dest.emit('pipe', src);

	  // Start the flow if it hasn't been started already.

	  if (dest.writableNeedDrain === true) {
	    pause();
	  } else if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	  return dest
	};
	function pipeOnDrain(src, dest) {
	  return function pipeOnDrainFunctionResult() {
	    const state = src._readableState;

	    // `ondrain` will call directly,
	    // `this` maybe not a reference to dest,
	    // so we use the real dest here.
	    if (state.awaitDrainWriters === dest) {
	      debug('pipeOnDrain', 1);
	      state.awaitDrainWriters = null;
	    } else if (state.multiAwaitDrain) {
	      debug('pipeOnDrain', state.awaitDrainWriters.size);
	      state.awaitDrainWriters.delete(dest);
	    }
	    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount('data')) {
	      src.resume();
	    }
	  }
	}
	Readable.prototype.unpipe = function (dest) {
	  const state = this._readableState;
	  const unpipeInfo = {
	    hasUnpiped: false
	  };

	  // If we're not piping anywhere, then do nothing.
	  if (state.pipes.length === 0) return this
	  if (!dest) {
	    // remove all.
	    const dests = state.pipes;
	    state.pipes = [];
	    this.pause();
	    for (let i = 0; i < dests.length; i++)
	      dests[i].emit('unpipe', this, {
	        hasUnpiped: false
	      });
	    return this
	  }

	  // Try to find the right one.
	  const index = ArrayPrototypeIndexOf(state.pipes, dest);
	  if (index === -1) return this
	  state.pipes.splice(index, 1);
	  if (state.pipes.length === 0) this.pause();
	  dest.emit('unpipe', this, unpipeInfo);
	  return this
	};

	// Set up data events if they are asked for
	// Ensure readable listeners eventually get something.
	Readable.prototype.on = function (ev, fn) {
	  const res = Stream.prototype.on.call(this, ev, fn);
	  const state = this._readableState;
	  if (ev === 'data') {
	    // Update readableListening so that resume() may be a no-op
	    // a few lines down. This is needed to support once('readable').
	    state.readableListening = this.listenerCount('readable') > 0;

	    // Try start flowing on next tick if stream isn't explicitly paused.
	    if (state.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.flowing = false;
	      state.emittedReadable = false;
	      debug('on readable', state.length, state.reading);
	      if (state.length) {
	        emitReadable(this);
	      } else if (!state.reading) {
	        process.nextTick(nReadingNextTick, this);
	      }
	    }
	  }
	  return res
	};
	Readable.prototype.addListener = Readable.prototype.on;
	Readable.prototype.removeListener = function (ev, fn) {
	  const res = Stream.prototype.removeListener.call(this, ev, fn);
	  if (ev === 'readable') {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res
	};
	Readable.prototype.off = Readable.prototype.removeListener;
	Readable.prototype.removeAllListeners = function (ev) {
	  const res = Stream.prototype.removeAllListeners.apply(this, arguments);
	  if (ev === 'readable' || ev === undefined) {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process.nextTick(updateReadableListening, this);
	  }
	  return res
	};
	function updateReadableListening(self) {
	  const state = self._readableState;
	  state.readableListening = self.listenerCount('readable') > 0;
	  if (state.resumeScheduled && state[kPaused] === false) {
	    // Flowing needs to be set to true now, otherwise
	    // the upcoming resume will not flow.
	    state.flowing = true;

	    // Crude way to check if we should resume.
	  } else if (self.listenerCount('data') > 0) {
	    self.resume();
	  } else if (!state.readableListening) {
	    state.flowing = null;
	  }
	}
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  const state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    // We flow only if there is no one listening
	    // for readable, but we still have to call
	    // resume().
	    state.flowing = !state.readableListening;
	    resume(this, state);
	  }
	  state[kPaused] = false;
	  return this
	};
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(resume_, stream, state);
	  }
	}
	function resume_(stream, state) {
	  debug('resume', state.reading);
	  if (!state.reading) {
	    stream.read(0);
	  }
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (this._readableState.flowing !== false) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  this._readableState[kPaused] = true;
	  return this
	};
	function flow(stream) {
	  const state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null);
	}

	// Wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  let paused = false;

	  // TODO (ronag): Should this.destroy(err) emit
	  // 'error' on the wrapped stream? Would require
	  // a static factory method, e.g. Readable.wrap(stream).

	  stream.on('data', (chunk) => {
	    if (!this.push(chunk) && stream.pause) {
	      paused = true;
	      stream.pause();
	    }
	  });
	  stream.on('end', () => {
	    this.push(null);
	  });
	  stream.on('error', (err) => {
	    errorOrDestroy(this, err);
	  });
	  stream.on('close', () => {
	    this.destroy();
	  });
	  stream.on('destroy', () => {
	    this.destroy();
	  });
	  this._read = () => {
	    if (paused && stream.resume) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  // Proxy all the other methods. Important when wrapping filters and duplexes.
	  const streamKeys = ObjectKeys(stream);
	  for (let j = 1; j < streamKeys.length; j++) {
	    const i = streamKeys[j];
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = stream[i].bind(stream);
	    }
	  }
	  return this
	};
	Readable.prototype[SymbolAsyncIterator] = function () {
	  return streamToAsyncIterator(this)
	};
	Readable.prototype.iterator = function (options) {
	  if (options !== undefined) {
	    validateObject(options, 'options');
	  }
	  return streamToAsyncIterator(this, options)
	};
	function streamToAsyncIterator(stream, options) {
	  if (typeof stream.read !== 'function') {
	    stream = Readable.wrap(stream, {
	      objectMode: true
	    });
	  }
	  const iter = createAsyncIterator(stream, options);
	  iter.stream = stream;
	  return iter
	}
	async function* createAsyncIterator(stream, options) {
	  let callback = nop;
	  function next(resolve) {
	    if (this === stream) {
	      callback();
	      callback = nop;
	    } else {
	      callback = resolve;
	    }
	  }
	  stream.on('readable', next);
	  let error;
	  const cleanup = eos(
	    stream,
	    {
	      writable: false
	    },
	    (err) => {
	      error = err ? aggregateTwoErrors(error, err) : null;
	      callback();
	      callback = nop;
	    }
	  );
	  try {
	    while (true) {
	      const chunk = stream.destroyed ? null : stream.read();
	      if (chunk !== null) {
	        yield chunk;
	      } else if (error) {
	        throw error
	      } else if (error === null) {
	        return
	      } else {
	        await new Promise(next);
	      }
	    }
	  } catch (err) {
	    error = aggregateTwoErrors(error, err);
	    throw error
	  } finally {
	    if (
	      (error || (options === null || options === undefined ? undefined : options.destroyOnReturn) !== false) &&
	      (error === undefined || stream._readableState.autoDestroy)
	    ) {
	      destroyImpl.destroyer(stream, null);
	    } else {
	      stream.off('readable', next);
	      cleanup();
	    }
	  }
	}

	// Making it explicit these properties are not enumerable
	// because otherwise some prototype manipulation in
	// userland will fail.
	ObjectDefineProperties(Readable.prototype, {
	  readable: {
	    __proto__: null,
	    get() {
	      const r = this._readableState;
	      // r.readable === false means that this is part of a Duplex stream
	      // where the readable side was disabled upon construction.
	      // Compat. The user might manually disable readable side through
	      // deprecated setter.
	      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted
	    },
	    set(val) {
	      // Backwards compat.
	      if (this._readableState) {
	        this._readableState.readable = !!val;
	      }
	    }
	  },
	  readableDidRead: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return this._readableState.dataEmitted
	    }
	  },
	  readableAborted: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return !!(
	        this._readableState.readable !== false &&
	        (this._readableState.destroyed || this._readableState.errored) &&
	        !this._readableState.endEmitted
	      )
	    }
	  },
	  readableHighWaterMark: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return this._readableState.highWaterMark
	    }
	  },
	  readableBuffer: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return this._readableState && this._readableState.buffer
	    }
	  },
	  readableFlowing: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return this._readableState.flowing
	    },
	    set: function (state) {
	      if (this._readableState) {
	        this._readableState.flowing = state;
	      }
	    }
	  },
	  readableLength: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState.length
	    }
	  },
	  readableObjectMode: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState ? this._readableState.objectMode : false
	    }
	  },
	  readableEncoding: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState ? this._readableState.encoding : null
	    }
	  },
	  errored: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState ? this._readableState.errored : null
	    }
	  },
	  closed: {
	    __proto__: null,
	    get() {
	      return this._readableState ? this._readableState.closed : false
	    }
	  },
	  destroyed: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState ? this._readableState.destroyed : false
	    },
	    set(value) {
	      // We ignore the value if the stream
	      // has not been initialized yet.
	      if (!this._readableState) {
	        return
	      }

	      // Backward compatibility, the user is explicitly
	      // managing destroyed.
	      this._readableState.destroyed = value;
	    }
	  },
	  readableEnded: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._readableState ? this._readableState.endEmitted : false
	    }
	  }
	});
	ObjectDefineProperties(ReadableState.prototype, {
	  // Legacy getter for `pipesCount`.
	  pipesCount: {
	    __proto__: null,
	    get() {
	      return this.pipes.length
	    }
	  },
	  // Legacy property for `paused`.
	  paused: {
	    __proto__: null,
	    get() {
	      return this[kPaused] !== false
	    },
	    set(value) {
	      this[kPaused] = !!value;
	    }
	  }
	});

	// Exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered.
	  if (state.length === 0) return null
	  let ret;
	  if (state.objectMode) ret = state.buffer.shift();
	  else if (!n || n >= state.length) {
	    // Read it all, truncate the list.
	    if (state.decoder) ret = state.buffer.join('');
	    else if (state.buffer.length === 1) ret = state.buffer.first();
	    else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list.
	    ret = state.buffer.consume(n, state.decoder);
	  }
	  return ret
	}
	function endReadable(stream) {
	  const state = stream._readableState;
	  debug('endReadable', state.endEmitted);
	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(endReadableNT, state, stream);
	  }
	}
	function endReadableNT(state, stream) {
	  debug('endReadableNT', state.endEmitted, state.length);

	  // Check that we didn't get one last unshift.
	  if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.emit('end');
	    if (stream.writable && stream.allowHalfOpen === false) {
	      process.nextTick(endWritableNT, stream);
	    } else if (state.autoDestroy) {
	      // In case of duplex streams we need a way to detect
	      // if the writable side is ready for autoDestroy as well.
	      const wState = stream._writableState;
	      const autoDestroy =
	        !wState ||
	        (wState.autoDestroy &&
	          // We don't expect the writable to ever 'finish'
	          // if writable is explicitly set to false.
	          (wState.finished || wState.writable === false));
	      if (autoDestroy) {
	        stream.destroy();
	      }
	    }
	  }
	}
	function endWritableNT(stream) {
	  const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
	  if (writable) {
	    stream.end();
	  }
	}
	Readable.from = function (iterable, opts) {
	  return from(Readable, iterable, opts)
	};
	let webStreamsAdapters;

	// Lazy to avoid circular references
	function lazyWebStreams() {
	  if (webStreamsAdapters === undefined) webStreamsAdapters = {};
	  return webStreamsAdapters
	}
	Readable.fromWeb = function (readableStream, options) {
	  return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options)
	};
	Readable.toWeb = function (streamReadable, options) {
	  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options)
	};
	Readable.wrap = function (src, options) {
	  var _ref, _src$readableObjectMo;
	  return new Readable({
	    objectMode:
	      (_ref =
	        (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== undefined
	          ? _src$readableObjectMo
	          : src.objectMode) !== null && _ref !== undefined
	        ? _ref
	        : true,
	    ...options,
	    destroy(err, callback) {
	      destroyImpl.destroyer(src, err);
	      callback(err);
	    }
	  }).wrap(src)
	};
	return readable;
}

var writable;
var hasRequiredWritable;

function requireWritable () {
	if (hasRequiredWritable) return writable;
	hasRequiredWritable = 1;

	/* replacement start */

	const process = requireProcess();

	/* replacement end */

	const {
	  ArrayPrototypeSlice,
	  Error,
	  FunctionPrototypeSymbolHasInstance,
	  ObjectDefineProperty,
	  ObjectDefineProperties,
	  ObjectSetPrototypeOf,
	  StringPrototypeToLowerCase,
	  Symbol,
	  SymbolHasInstance
	} = requirePrimordials();
	writable = Writable;
	Writable.WritableState = WritableState;
	const { EventEmitter: EE } = require$$0$5;
	const Stream = requireLegacy().Stream;
	const { Buffer } = require$$0$7;
	const destroyImpl = requireDestroy();
	const { addAbortSignal } = requireAddAbortSignal();
	const { getHighWaterMark, getDefaultHighWaterMark } = requireState();
	const {
	  ERR_INVALID_ARG_TYPE,
	  ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK,
	  ERR_STREAM_CANNOT_PIPE,
	  ERR_STREAM_DESTROYED,
	  ERR_STREAM_ALREADY_FINISHED,
	  ERR_STREAM_NULL_VALUES,
	  ERR_STREAM_WRITE_AFTER_END,
	  ERR_UNKNOWN_ENCODING
	} = requireErrors().codes;
	const { errorOrDestroy } = destroyImpl;
	ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
	ObjectSetPrototypeOf(Writable, Stream);
	function nop() {}
	const kOnFinished = Symbol('kOnFinished');
	function WritableState(options, stream, isDuplex) {
	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream,
	  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof requireDuplex();

	  // Object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!(options && options.objectMode);
	  if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);

	  // The point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write().
	  this.highWaterMark = options
	    ? getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex)
	    : getDefaultHighWaterMark(false);

	  // if _final has been called.
	  this.finalCalled = false;

	  // drain event flag.
	  this.needDrain = false;
	  // At the start of calling end()
	  this.ending = false;
	  // When end() has been called, and returned.
	  this.ended = false;
	  // When 'finish' is emitted.
	  this.finished = false;

	  // Has it been destroyed
	  this.destroyed = false;

	  // Should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  const noDecode = !!(options && options.decodeStrings === false);
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';

	  // Not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // A flag to see when we're in the middle of a write.
	  this.writing = false;

	  // When true all writes will be buffered until .uncork() call.
	  this.corked = 0;

	  // A flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // A flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // The callback that's passed to _write(chunk, cb).
	  this.onwrite = onwrite.bind(undefined, stream);

	  // The callback that the user supplies to write(chunk, encoding, cb).
	  this.writecb = null;

	  // The amount that is being written when _write is called.
	  this.writelen = 0;

	  // Storage for data passed to the afterWrite() callback in case of
	  // synchronous _write() completion.
	  this.afterWriteTickInfo = null;
	  resetBuffer(this);

	  // Number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted.
	  this.pendingcb = 0;

	  // Stream is still being constructed and cannot be
	  // destroyed until construction finished or failed.
	  // Async construction is opt in, therefore we start as
	  // constructed.
	  this.constructed = true;

	  // Emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams.
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again.
	  this.errorEmitted = false;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = !options || options.emitClose !== false;

	  // Should .destroy() be called after 'finish' (and potentially 'end').
	  this.autoDestroy = !options || options.autoDestroy !== false;

	  // Indicates whether the stream has errored. When true all write() calls
	  // should return false. This is needed since when autoDestroy
	  // is disabled we need a way to tell whether the stream has failed.
	  this.errored = null;

	  // Indicates whether the stream has finished destroying.
	  this.closed = false;

	  // True if close has been emitted or would have been emitted
	  // depending on emitClose.
	  this.closeEmitted = false;
	  this[kOnFinished] = [];
	}
	function resetBuffer(state) {
	  state.buffered = [];
	  state.bufferedIndex = 0;
	  state.allBuffers = true;
	  state.allNoop = true;
	}
	WritableState.prototype.getBuffer = function getBuffer() {
	  return ArrayPrototypeSlice(this.buffered, this.bufferedIndex)
	};
	ObjectDefineProperty(WritableState.prototype, 'bufferedRequestCount', {
	  __proto__: null,
	  get() {
	    return this.buffered.length - this.bufferedIndex
	  }
	});
	function Writable(options) {
	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the WritableState constructor, at least with V8 6.5.
	  const isDuplex = this instanceof requireDuplex();
	  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options)
	  this._writableState = new WritableState(options, this, isDuplex);
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	    if (typeof options.writev === 'function') this._writev = options.writev;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.final === 'function') this._final = options.final;
	    if (typeof options.construct === 'function') this._construct = options.construct;
	    if (options.signal) addAbortSignal(options.signal, this);
	  }
	  Stream.call(this, options);
	  destroyImpl.construct(this, () => {
	    const state = this._writableState;
	    if (!state.writing) {
	      clearBuffer(this, state);
	    }
	    finishMaybe(this, state);
	  });
	}
	ObjectDefineProperty(Writable, SymbolHasInstance, {
	  __proto__: null,
	  value: function (object) {
	    if (FunctionPrototypeSymbolHasInstance(this, object)) return true
	    if (this !== Writable) return false
	    return object && object._writableState instanceof WritableState
	  }
	});

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function _write(stream, chunk, encoding, cb) {
	  const state = stream._writableState;
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = state.defaultEncoding;
	  } else {
	    if (!encoding) encoding = state.defaultEncoding;
	    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)
	    if (typeof cb !== 'function') cb = nop;
	  }
	  if (chunk === null) {
	    throw new ERR_STREAM_NULL_VALUES()
	  } else if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      if (state.decodeStrings !== false) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = 'buffer';
	      }
	    } else if (chunk instanceof Buffer) {
	      encoding = 'buffer';
	    } else if (Stream._isUint8Array(chunk)) {
	      chunk = Stream._uint8ArrayToBuffer(chunk);
	      encoding = 'buffer';
	    } else {
	      throw new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk)
	    }
	  }
	  let err;
	  if (state.ending) {
	    err = new ERR_STREAM_WRITE_AFTER_END();
	  } else if (state.destroyed) {
	    err = new ERR_STREAM_DESTROYED('write');
	  }
	  if (err) {
	    process.nextTick(cb, err);
	    errorOrDestroy(stream, err, true);
	    return err
	  }
	  state.pendingcb++;
	  return writeOrBuffer(stream, state, chunk, encoding, cb)
	}
	Writable.prototype.write = function (chunk, encoding, cb) {
	  return _write(this, chunk, encoding, cb) === true
	};
	Writable.prototype.cork = function () {
	  this._writableState.corked++;
	};
	Writable.prototype.uncork = function () {
	  const state = this._writableState;
	  if (state.corked) {
	    state.corked--;
	    if (!state.writing) clearBuffer(this, state);
	  }
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = StringPrototypeToLowerCase(encoding);
	  if (!Buffer.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding)
	  this._writableState.defaultEncoding = encoding;
	  return this
	};

	// If we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, callback) {
	  const len = state.objectMode ? 1 : chunk.length;
	  state.length += len;

	  // stream._write resets state.length
	  const ret = state.length < state.highWaterMark;
	  // We must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	  if (state.writing || state.corked || state.errored || !state.constructed) {
	    state.buffered.push({
	      chunk,
	      encoding,
	      callback
	    });
	    if (state.allBuffers && encoding !== 'buffer') {
	      state.allBuffers = false;
	    }
	    if (state.allNoop && callback !== nop) {
	      state.allNoop = false;
	    }
	  } else {
	    state.writelen = len;
	    state.writecb = callback;
	    state.writing = true;
	    state.sync = true;
	    stream._write(chunk, encoding, state.onwrite);
	    state.sync = false;
	  }

	  // Return false if errored or destroyed in order to break
	  // any synchronous while(stream.write(data)) loops.
	  return ret && !state.errored && !state.destroyed
	}
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));
	  else if (writev) stream._writev(chunk, state.onwrite);
	  else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	function onwriteError(stream, state, er, cb) {
	  --state.pendingcb;
	  cb(er);
	  // Ensure callbacks are invoked even when autoDestroy is
	  // not enabled. Passing `er` here doesn't make sense since
	  // it's related to one specific write, not to the buffered
	  // writes.
	  errorBuffer(state);
	  // This can emit error, but error must always follow cb.
	  errorOrDestroy(stream, er);
	}
	function onwrite(stream, er) {
	  const state = stream._writableState;
	  const sync = state.sync;
	  const cb = state.writecb;
	  if (typeof cb !== 'function') {
	    errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
	    return
	  }
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	  if (er) {
	    // Avoid V8 leak, https://github.com/nodejs/node/pull/34103#issuecomment-652002364
	    er.stack; // eslint-disable-line no-unused-expressions

	    if (!state.errored) {
	      state.errored = er;
	    }

	    // In case of duplex streams we need to notify the readable side of the
	    // error.
	    if (stream._readableState && !stream._readableState.errored) {
	      stream._readableState.errored = er;
	    }
	    if (sync) {
	      process.nextTick(onwriteError, stream, state, er, cb);
	    } else {
	      onwriteError(stream, state, er, cb);
	    }
	  } else {
	    if (state.buffered.length > state.bufferedIndex) {
	      clearBuffer(stream, state);
	    }
	    if (sync) {
	      // It is a common case that the callback passed to .write() is always
	      // the same. In that case, we do not schedule a new nextTick(), but
	      // rather just increase a counter, to improve performance and avoid
	      // memory allocations.
	      if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
	        state.afterWriteTickInfo.count++;
	      } else {
	        state.afterWriteTickInfo = {
	          count: 1,
	          cb,
	          stream,
	          state
	        };
	        process.nextTick(afterWriteTick, state.afterWriteTickInfo);
	      }
	    } else {
	      afterWrite(stream, state, 1, cb);
	    }
	  }
	}
	function afterWriteTick({ stream, state, count, cb }) {
	  state.afterWriteTickInfo = null;
	  return afterWrite(stream, state, count, cb)
	}
	function afterWrite(stream, state, count, cb) {
	  const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
	  if (needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	  while (count-- > 0) {
	    state.pendingcb--;
	    cb();
	  }
	  if (state.destroyed) {
	    errorBuffer(state);
	  }
	  finishMaybe(stream, state);
	}

	// If there's something in the buffer waiting, then invoke callbacks.
	function errorBuffer(state) {
	  if (state.writing) {
	    return
	  }
	  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
	    var _state$errored;
	    const { chunk, callback } = state.buffered[n];
	    const len = state.objectMode ? 1 : chunk.length;
	    state.length -= len;
	    callback(
	      (_state$errored = state.errored) !== null && _state$errored !== undefined
	        ? _state$errored
	        : new ERR_STREAM_DESTROYED('write')
	    );
	  }
	  const onfinishCallbacks = state[kOnFinished].splice(0);
	  for (let i = 0; i < onfinishCallbacks.length; i++) {
	    var _state$errored2;
	    onfinishCallbacks[i](
	      (_state$errored2 = state.errored) !== null && _state$errored2 !== undefined
	        ? _state$errored2
	        : new ERR_STREAM_DESTROYED('end')
	    );
	  }
	  resetBuffer(state);
	}

	// If there's something in the buffer waiting, then process it.
	function clearBuffer(stream, state) {
	  if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
	    return
	  }
	  const { buffered, bufferedIndex, objectMode } = state;
	  const bufferedLength = buffered.length - bufferedIndex;
	  if (!bufferedLength) {
	    return
	  }
	  let i = bufferedIndex;
	  state.bufferProcessing = true;
	  if (bufferedLength > 1 && stream._writev) {
	    state.pendingcb -= bufferedLength - 1;
	    const callback = state.allNoop
	      ? nop
	      : (err) => {
	          for (let n = i; n < buffered.length; ++n) {
	            buffered[n].callback(err);
	          }
	        };
	    // Make a copy of `buffered` if it's going to be used by `callback` above,
	    // since `doWrite` will mutate the array.
	    const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
	    chunks.allBuffers = state.allBuffers;
	    doWrite(stream, state, true, state.length, chunks, '', callback);
	    resetBuffer(state);
	  } else {
	    do {
	      const { chunk, encoding, callback } = buffered[i];
	      buffered[i++] = null;
	      const len = objectMode ? 1 : chunk.length;
	      doWrite(stream, state, false, len, chunk, encoding, callback);
	    } while (i < buffered.length && !state.writing)
	    if (i === buffered.length) {
	      resetBuffer(state);
	    } else if (i > 256) {
	      buffered.splice(0, i);
	      state.bufferedIndex = 0;
	    } else {
	      state.bufferedIndex = i;
	    }
	  }
	  state.bufferProcessing = false;
	}
	Writable.prototype._write = function (chunk, encoding, cb) {
	  if (this._writev) {
	    this._writev(
	      [
	        {
	          chunk,
	          encoding
	        }
	      ],
	      cb
	    );
	  } else {
	    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()')
	  }
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function (chunk, encoding, cb) {
	  const state = this._writableState;
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  let err;
	  if (chunk !== null && chunk !== undefined) {
	    const ret = _write(this, chunk, encoding);
	    if (ret instanceof Error) {
	      err = ret;
	    }
	  }

	  // .end() fully uncorks.
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }
	  if (err) ; else if (!state.errored && !state.ending) {
	    // This is forgiving in terms of unnecessary calls to end() and can hide
	    // logic errors. However, usually such errors are harmless and causing a
	    // hard error can be disproportionately destructive. It is not always
	    // trivial for the user to determine whether end() needs to be called
	    // or not.

	    state.ending = true;
	    finishMaybe(this, state, true);
	    state.ended = true;
	  } else if (state.finished) {
	    err = new ERR_STREAM_ALREADY_FINISHED('end');
	  } else if (state.destroyed) {
	    err = new ERR_STREAM_DESTROYED('end');
	  }
	  if (typeof cb === 'function') {
	    if (err || state.finished) {
	      process.nextTick(cb, err);
	    } else {
	      state[kOnFinished].push(cb);
	    }
	  }
	  return this
	};
	function needFinish(state) {
	  return (
	    state.ending &&
	    !state.destroyed &&
	    state.constructed &&
	    state.length === 0 &&
	    !state.errored &&
	    state.buffered.length === 0 &&
	    !state.finished &&
	    !state.writing &&
	    !state.errorEmitted &&
	    !state.closeEmitted
	  )
	}
	function callFinal(stream, state) {
	  let called = false;
	  function onFinish(err) {
	    if (called) {
	      errorOrDestroy(stream, err !== null && err !== undefined ? err : ERR_MULTIPLE_CALLBACK());
	      return
	    }
	    called = true;
	    state.pendingcb--;
	    if (err) {
	      const onfinishCallbacks = state[kOnFinished].splice(0);
	      for (let i = 0; i < onfinishCallbacks.length; i++) {
	        onfinishCallbacks[i](err);
	      }
	      errorOrDestroy(stream, err, state.sync);
	    } else if (needFinish(state)) {
	      state.prefinished = true;
	      stream.emit('prefinish');
	      // Backwards compat. Don't check state.sync here.
	      // Some streams assume 'finish' will be emitted
	      // asynchronously relative to _final callback.
	      state.pendingcb++;
	      process.nextTick(finish, stream, state);
	    }
	  }
	  state.sync = true;
	  state.pendingcb++;
	  try {
	    stream._final(onFinish);
	  } catch (err) {
	    onFinish(err);
	  }
	  state.sync = false;
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function' && !state.destroyed) {
	      state.finalCalled = true;
	      callFinal(stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}
	function finishMaybe(stream, state, sync) {
	  if (needFinish(state)) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      if (sync) {
	        state.pendingcb++;
	        process.nextTick(
	          (stream, state) => {
	            if (needFinish(state)) {
	              finish(stream, state);
	            } else {
	              state.pendingcb--;
	            }
	          },
	          stream,
	          state
	        );
	      } else if (needFinish(state)) {
	        state.pendingcb++;
	        finish(stream, state);
	      }
	    }
	  }
	}
	function finish(stream, state) {
	  state.pendingcb--;
	  state.finished = true;
	  const onfinishCallbacks = state[kOnFinished].splice(0);
	  for (let i = 0; i < onfinishCallbacks.length; i++) {
	    onfinishCallbacks[i]();
	  }
	  stream.emit('finish');
	  if (state.autoDestroy) {
	    // In case of duplex streams we need a way to detect
	    // if the readable side is ready for autoDestroy as well.
	    const rState = stream._readableState;
	    const autoDestroy =
	      !rState ||
	      (rState.autoDestroy &&
	        // We don't expect the readable to ever 'end'
	        // if readable is explicitly set to false.
	        (rState.endEmitted || rState.readable === false));
	    if (autoDestroy) {
	      stream.destroy();
	    }
	  }
	}
	ObjectDefineProperties(Writable.prototype, {
	  closed: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.closed : false
	    }
	  },
	  destroyed: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.destroyed : false
	    },
	    set(value) {
	      // Backward compatibility, the user is explicitly managing destroyed.
	      if (this._writableState) {
	        this._writableState.destroyed = value;
	      }
	    }
	  },
	  writable: {
	    __proto__: null,
	    get() {
	      const w = this._writableState;
	      // w.writable === false means that this is part of a Duplex stream
	      // where the writable side was disabled upon construction.
	      // Compat. The user might manually disable writable side through
	      // deprecated setter.
	      return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended
	    },
	    set(val) {
	      // Backwards compatible.
	      if (this._writableState) {
	        this._writableState.writable = !!val;
	      }
	    }
	  },
	  writableFinished: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.finished : false
	    }
	  },
	  writableObjectMode: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.objectMode : false
	    }
	  },
	  writableBuffer: {
	    __proto__: null,
	    get() {
	      return this._writableState && this._writableState.getBuffer()
	    }
	  },
	  writableEnded: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.ending : false
	    }
	  },
	  writableNeedDrain: {
	    __proto__: null,
	    get() {
	      const wState = this._writableState;
	      if (!wState) return false
	      return !wState.destroyed && !wState.ending && wState.needDrain
	    }
	  },
	  writableHighWaterMark: {
	    __proto__: null,
	    get() {
	      return this._writableState && this._writableState.highWaterMark
	    }
	  },
	  writableCorked: {
	    __proto__: null,
	    get() {
	      return this._writableState ? this._writableState.corked : 0
	    }
	  },
	  writableLength: {
	    __proto__: null,
	    get() {
	      return this._writableState && this._writableState.length
	    }
	  },
	  errored: {
	    __proto__: null,
	    enumerable: false,
	    get() {
	      return this._writableState ? this._writableState.errored : null
	    }
	  },
	  writableAborted: {
	    __proto__: null,
	    enumerable: false,
	    get: function () {
	      return !!(
	        this._writableState.writable !== false &&
	        (this._writableState.destroyed || this._writableState.errored) &&
	        !this._writableState.finished
	      )
	    }
	  }
	});
	const destroy = destroyImpl.destroy;
	Writable.prototype.destroy = function (err, cb) {
	  const state = this._writableState;

	  // Invoke pending callbacks.
	  if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
	    process.nextTick(errorBuffer, state);
	  }
	  destroy.call(this, err, cb);
	  return this
	};
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  cb(err);
	};
	Writable.prototype[EE.captureRejectionSymbol] = function (err) {
	  this.destroy(err);
	};
	let webStreamsAdapters;

	// Lazy to avoid circular references
	function lazyWebStreams() {
	  if (webStreamsAdapters === undefined) webStreamsAdapters = {};
	  return webStreamsAdapters
	}
	Writable.fromWeb = function (writableStream, options) {
	  return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options)
	};
	Writable.toWeb = function (streamWritable) {
	  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable)
	};
	return writable;
}

/* replacement start */

var duplexify;
var hasRequiredDuplexify;

function requireDuplexify () {
	if (hasRequiredDuplexify) return duplexify;
	hasRequiredDuplexify = 1;
	const process = requireProcess()

	/* replacement end */

	;	const bufferModule = require$$0$7;
	const {
	  isReadable,
	  isWritable,
	  isIterable,
	  isNodeStream,
	  isReadableNodeStream,
	  isWritableNodeStream,
	  isDuplexNodeStream,
	  isReadableStream,
	  isWritableStream
	} = requireUtils();
	const eos = requireEndOfStream();
	const {
	  AbortError,
	  codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
	} = requireErrors();
	const { destroyer } = requireDestroy();
	const Duplex = requireDuplex();
	const Readable = requireReadable();
	const Writable = requireWritable();
	const { createDeferredPromise } = requireUtil();
	const from = requireFrom();
	const Blob = globalThis.Blob || bufferModule.Blob;
	const isBlob =
	  typeof Blob !== 'undefined'
	    ? function isBlob(b) {
	        return b instanceof Blob
	      }
	    : function isBlob(b) {
	        return false
	      };
	const AbortController = globalThis.AbortController || require$$0$2.AbortController;
	const { FunctionPrototypeCall } = requirePrimordials();

	// This is needed for pre node 17.
	class Duplexify extends Duplex {
	  constructor(options) {
	    super(options);

	    // https://github.com/nodejs/node/pull/34385

	    if ((options === null || options === undefined ? undefined : options.readable) === false) {
	      this._readableState.readable = false;
	      this._readableState.ended = true;
	      this._readableState.endEmitted = true;
	    }
	    if ((options === null || options === undefined ? undefined : options.writable) === false) {
	      this._writableState.writable = false;
	      this._writableState.ending = true;
	      this._writableState.ended = true;
	      this._writableState.finished = true;
	    }
	  }
	}
	duplexify = function duplexify(body, name) {
	  if (isDuplexNodeStream(body)) {
	    return body
	  }
	  if (isReadableNodeStream(body)) {
	    return _duplexify({
	      readable: body
	    })
	  }
	  if (isWritableNodeStream(body)) {
	    return _duplexify({
	      writable: body
	    })
	  }
	  if (isNodeStream(body)) {
	    return _duplexify({
	      writable: false,
	      readable: false
	    })
	  }
	  if (isReadableStream(body)) {
	    return _duplexify({
	      readable: Readable.fromWeb(body)
	    })
	  }
	  if (isWritableStream(body)) {
	    return _duplexify({
	      writable: Writable.fromWeb(body)
	    })
	  }
	  if (typeof body === 'function') {
	    const { value, write, final, destroy } = fromAsyncGen(body);
	    if (isIterable(value)) {
	      return from(Duplexify, value, {
	        // TODO (ronag): highWaterMark?
	        objectMode: true,
	        write,
	        final,
	        destroy
	      })
	    }
	    const then = value === null || value === undefined ? undefined : value.then;
	    if (typeof then === 'function') {
	      let d;
	      const promise = FunctionPrototypeCall(
	        then,
	        value,
	        (val) => {
	          if (val != null) {
	            throw new ERR_INVALID_RETURN_VALUE('nully', 'body', val)
	          }
	        },
	        (err) => {
	          destroyer(d, err);
	        }
	      );
	      return (d = new Duplexify({
	        // TODO (ronag): highWaterMark?
	        objectMode: true,
	        readable: false,
	        write,
	        final(cb) {
	          final(async () => {
	            try {
	              await promise;
	              process.nextTick(cb, null);
	            } catch (err) {
	              process.nextTick(cb, err);
	            }
	          });
	        },
	        destroy
	      }))
	    }
	    throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or AsyncFunction', name, value)
	  }
	  if (isBlob(body)) {
	    return duplexify(body.arrayBuffer())
	  }
	  if (isIterable(body)) {
	    return from(Duplexify, body, {
	      // TODO (ronag): highWaterMark?
	      objectMode: true,
	      writable: false
	    })
	  }
	  if (
	    isReadableStream(body === null || body === undefined ? undefined : body.readable) &&
	    isWritableStream(body === null || body === undefined ? undefined : body.writable)
	  ) {
	    return Duplexify.fromWeb(body)
	  }
	  if (
	    typeof (body === null || body === undefined ? undefined : body.writable) === 'object' ||
	    typeof (body === null || body === undefined ? undefined : body.readable) === 'object'
	  ) {
	    const readable =
	      body !== null && body !== undefined && body.readable
	        ? isReadableNodeStream(body === null || body === undefined ? undefined : body.readable)
	          ? body === null || body === undefined
	            ? undefined
	            : body.readable
	          : duplexify(body.readable)
	        : undefined;
	    const writable =
	      body !== null && body !== undefined && body.writable
	        ? isWritableNodeStream(body === null || body === undefined ? undefined : body.writable)
	          ? body === null || body === undefined
	            ? undefined
	            : body.writable
	          : duplexify(body.writable)
	        : undefined;
	    return _duplexify({
	      readable,
	      writable
	    })
	  }
	  const then = body === null || body === undefined ? undefined : body.then;
	  if (typeof then === 'function') {
	    let d;
	    FunctionPrototypeCall(
	      then,
	      body,
	      (val) => {
	        if (val != null) {
	          d.push(val);
	        }
	        d.push(null);
	      },
	      (err) => {
	        destroyer(d, err);
	      }
	    );
	    return (d = new Duplexify({
	      objectMode: true,
	      writable: false,
	      read() {}
	    }))
	  }
	  throw new ERR_INVALID_ARG_TYPE(
	    name,
	    [
	      'Blob',
	      'ReadableStream',
	      'WritableStream',
	      'Stream',
	      'Iterable',
	      'AsyncIterable',
	      'Function',
	      '{ readable, writable } pair',
	      'Promise'
	    ],
	    body
	  )
	};
	function fromAsyncGen(fn) {
	  let { promise, resolve } = createDeferredPromise();
	  const ac = new AbortController();
	  const signal = ac.signal;
	  const value = fn(
	    (async function* () {
	      while (true) {
	        const _promise = promise;
	        promise = null;
	        const { chunk, done, cb } = await _promise;
	        process.nextTick(cb);
	        if (done) return
	        if (signal.aborted)
	          throw new AbortError(undefined, {
	            cause: signal.reason
	          })
	        ;({ promise, resolve } = createDeferredPromise());
	        yield chunk;
	      }
	    })(),
	    {
	      signal
	    }
	  );
	  return {
	    value,
	    write(chunk, encoding, cb) {
	      const _resolve = resolve;
	      resolve = null;
	      _resolve({
	        chunk,
	        done: false,
	        cb
	      });
	    },
	    final(cb) {
	      const _resolve = resolve;
	      resolve = null;
	      _resolve({
	        done: true,
	        cb
	      });
	    },
	    destroy(err, cb) {
	      ac.abort();
	      cb(err);
	    }
	  }
	}
	function _duplexify(pair) {
	  const r = pair.readable && typeof pair.readable.read !== 'function' ? Readable.wrap(pair.readable) : pair.readable;
	  const w = pair.writable;
	  let readable = !!isReadable(r);
	  let writable = !!isWritable(w);
	  let ondrain;
	  let onfinish;
	  let onreadable;
	  let onclose;
	  let d;
	  function onfinished(err) {
	    const cb = onclose;
	    onclose = null;
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      d.destroy(err);
	    }
	  }

	  // TODO(ronag): Avoid double buffering.
	  // Implement Writable/Readable/Duplex traits.
	  // See, https://github.com/nodejs/node/pull/33515.
	  d = new Duplexify({
	    // TODO (ronag): highWaterMark?
	    readableObjectMode: !!(r !== null && r !== undefined && r.readableObjectMode),
	    writableObjectMode: !!(w !== null && w !== undefined && w.writableObjectMode),
	    readable,
	    writable
	  });
	  if (writable) {
	    eos(w, (err) => {
	      writable = false;
	      if (err) {
	        destroyer(r, err);
	      }
	      onfinished(err);
	    });
	    d._write = function (chunk, encoding, callback) {
	      if (w.write(chunk, encoding)) {
	        callback();
	      } else {
	        ondrain = callback;
	      }
	    };
	    d._final = function (callback) {
	      w.end();
	      onfinish = callback;
	    };
	    w.on('drain', function () {
	      if (ondrain) {
	        const cb = ondrain;
	        ondrain = null;
	        cb();
	      }
	    });
	    w.on('finish', function () {
	      if (onfinish) {
	        const cb = onfinish;
	        onfinish = null;
	        cb();
	      }
	    });
	  }
	  if (readable) {
	    eos(r, (err) => {
	      readable = false;
	      if (err) {
	        destroyer(r, err);
	      }
	      onfinished(err);
	    });
	    r.on('readable', function () {
	      if (onreadable) {
	        const cb = onreadable;
	        onreadable = null;
	        cb();
	      }
	    });
	    r.on('end', function () {
	      d.push(null);
	    });
	    d._read = function () {
	      while (true) {
	        const buf = r.read();
	        if (buf === null) {
	          onreadable = d._read;
	          return
	        }
	        if (!d.push(buf)) {
	          return
	        }
	      }
	    };
	  }
	  d._destroy = function (err, callback) {
	    if (!err && onclose !== null) {
	      err = new AbortError();
	    }
	    onreadable = null;
	    ondrain = null;
	    onfinish = null;
	    if (onclose === null) {
	      callback(err);
	    } else {
	      onclose = callback;
	      destroyer(w, err);
	      destroyer(r, err);
	    }
	  };
	  return d
	}
	return duplexify;
}

var duplex;
var hasRequiredDuplex;

function requireDuplex () {
	if (hasRequiredDuplex) return duplex;
	hasRequiredDuplex = 1;

	const {
	  ObjectDefineProperties,
	  ObjectGetOwnPropertyDescriptor,
	  ObjectKeys,
	  ObjectSetPrototypeOf
	} = requirePrimordials();
	duplex = Duplex;
	const Readable = requireReadable();
	const Writable = requireWritable();
	ObjectSetPrototypeOf(Duplex.prototype, Readable.prototype);
	ObjectSetPrototypeOf(Duplex, Readable);
	{
	  const keys = ObjectKeys(Writable.prototype);
	  // Allow the keys array to be GC'ed.
	  for (let i = 0; i < keys.length; i++) {
	    const method = keys[i];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options)
	  Readable.call(this, options);
	  Writable.call(this, options);
	  if (options) {
	    this.allowHalfOpen = options.allowHalfOpen !== false;
	    if (options.readable === false) {
	      this._readableState.readable = false;
	      this._readableState.ended = true;
	      this._readableState.endEmitted = true;
	    }
	    if (options.writable === false) {
	      this._writableState.writable = false;
	      this._writableState.ending = true;
	      this._writableState.ended = true;
	      this._writableState.finished = true;
	    }
	  } else {
	    this.allowHalfOpen = true;
	  }
	}
	ObjectDefineProperties(Duplex.prototype, {
	  writable: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writable')
	  },
	  writableHighWaterMark: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableHighWaterMark')
	  },
	  writableObjectMode: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableObjectMode')
	  },
	  writableBuffer: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableBuffer')
	  },
	  writableLength: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableLength')
	  },
	  writableFinished: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableFinished')
	  },
	  writableCorked: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableCorked')
	  },
	  writableEnded: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableEnded')
	  },
	  writableNeedDrain: {
	    __proto__: null,
	    ...ObjectGetOwnPropertyDescriptor(Writable.prototype, 'writableNeedDrain')
	  },
	  destroyed: {
	    __proto__: null,
	    get() {
	      if (this._readableState === undefined || this._writableState === undefined) {
	        return false
	      }
	      return this._readableState.destroyed && this._writableState.destroyed
	    },
	    set(value) {
	      // Backward compatibility, the user is explicitly
	      // managing destroyed.
	      if (this._readableState && this._writableState) {
	        this._readableState.destroyed = value;
	        this._writableState.destroyed = value;
	      }
	    }
	  }
	});
	let webStreamsAdapters;

	// Lazy to avoid circular references
	function lazyWebStreams() {
	  if (webStreamsAdapters === undefined) webStreamsAdapters = {};
	  return webStreamsAdapters
	}
	Duplex.fromWeb = function (pair, options) {
	  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options)
	};
	Duplex.toWeb = function (duplex) {
	  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex)
	};
	let duplexify;
	Duplex.from = function (body) {
	  if (!duplexify) {
	    duplexify = requireDuplexify();
	  }
	  return duplexify(body, 'body')
	};
	return duplex;
}

var transform;
var hasRequiredTransform;

function requireTransform () {
	if (hasRequiredTransform) return transform;
	hasRequiredTransform = 1;

	const { ObjectSetPrototypeOf, Symbol } = requirePrimordials();
	transform = Transform;
	const { ERR_METHOD_NOT_IMPLEMENTED } = requireErrors().codes;
	const Duplex = requireDuplex();
	const { getHighWaterMark } = requireState();
	ObjectSetPrototypeOf(Transform.prototype, Duplex.prototype);
	ObjectSetPrototypeOf(Transform, Duplex);
	const kCallback = Symbol('kCallback');
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options)

	  // TODO (ronag): This should preferably always be
	  // applied but would be semver-major. Or even better;
	  // make Transform a Readable with the Writable interface.
	  const readableHighWaterMark = options ? getHighWaterMark(this, options, 'readableHighWaterMark', true) : null;
	  if (readableHighWaterMark === 0) {
	    // A Duplex will buffer both on the writable and readable side while
	    // a Transform just wants to buffer hwm number of elements. To avoid
	    // buffering twice we disable buffering on the writable side.
	    options = {
	      ...options,
	      highWaterMark: null,
	      readableHighWaterMark,
	      // TODO (ronag): 0 is not optimal since we have
	      // a "bug" where we check needDrain before calling _write and not after.
	      // Refs: https://github.com/nodejs/node/pull/32887
	      // Refs: https://github.com/nodejs/node/pull/35941
	      writableHighWaterMark: options.writableHighWaterMark || 0
	    };
	  }
	  Duplex.call(this, options);

	  // We have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	  this[kCallback] = null;
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  // Backwards compat. Some Transform streams incorrectly implement _final
	  // instead of or in addition to _flush. By using 'prefinish' instead of
	  // implementing _final we continue supporting this unfortunate use case.
	  this.on('prefinish', prefinish);
	}
	function final(cb) {
	  if (typeof this._flush === 'function' && !this.destroyed) {
	    this._flush((er, data) => {
	      if (er) {
	        if (cb) {
	          cb(er);
	        } else {
	          this.destroy(er);
	        }
	        return
	      }
	      if (data != null) {
	        this.push(data);
	      }
	      this.push(null);
	      if (cb) {
	        cb();
	      }
	    });
	  } else {
	    this.push(null);
	    if (cb) {
	      cb();
	    }
	  }
	}
	function prefinish() {
	  if (this._final !== final) {
	    final.call(this);
	  }
	}
	Transform.prototype._final = final;
	Transform.prototype._transform = function (chunk, encoding, callback) {
	  throw new ERR_METHOD_NOT_IMPLEMENTED('_transform()')
	};
	Transform.prototype._write = function (chunk, encoding, callback) {
	  const rState = this._readableState;
	  const wState = this._writableState;
	  const length = rState.length;
	  this._transform(chunk, encoding, (err, val) => {
	    if (err) {
	      callback(err);
	      return
	    }
	    if (val != null) {
	      this.push(val);
	    }
	    if (
	      wState.ended ||
	      // Backwards compat.
	      length === rState.length ||
	      // Backwards compat.
	      rState.length < rState.highWaterMark
	    ) {
	      callback();
	    } else {
	      this[kCallback] = callback;
	    }
	  });
	};
	Transform.prototype._read = function () {
	  if (this[kCallback]) {
	    const callback = this[kCallback];
	    this[kCallback] = null;
	    callback();
	  }
	};
	return transform;
}

var passthrough;
var hasRequiredPassthrough;

function requirePassthrough () {
	if (hasRequiredPassthrough) return passthrough;
	hasRequiredPassthrough = 1;

	const { ObjectSetPrototypeOf } = requirePrimordials();
	passthrough = PassThrough;
	const Transform = requireTransform();
	ObjectSetPrototypeOf(PassThrough.prototype, Transform.prototype);
	ObjectSetPrototypeOf(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options)
	  Transform.call(this, options);
	}
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return passthrough;
}

/* replacement start */

var pipeline_1;
var hasRequiredPipeline;

function requirePipeline () {
	if (hasRequiredPipeline) return pipeline_1;
	hasRequiredPipeline = 1;
	const process = requireProcess()

	/* replacement end */
	// Ported from https://github.com/mafintosh/pump with
	// permission from the author, Mathias Buus (@mafintosh).

	;	const { ArrayIsArray, Promise, SymbolAsyncIterator, SymbolDispose } = requirePrimordials();
	const eos = requireEndOfStream();
	const { once } = requireUtil();
	const destroyImpl = requireDestroy();
	const Duplex = requireDuplex();
	const {
	  aggregateTwoErrors,
	  codes: {
	    ERR_INVALID_ARG_TYPE,
	    ERR_INVALID_RETURN_VALUE,
	    ERR_MISSING_ARGS,
	    ERR_STREAM_DESTROYED,
	    ERR_STREAM_PREMATURE_CLOSE
	  },
	  AbortError
	} = requireErrors();
	const { validateFunction, validateAbortSignal } = requireValidators();
	const {
	  isIterable,
	  isReadable,
	  isReadableNodeStream,
	  isNodeStream,
	  isTransformStream,
	  isWebStream,
	  isReadableStream,
	  isReadableFinished
	} = requireUtils();
	const AbortController = globalThis.AbortController || require$$0$2.AbortController;
	let PassThrough;
	let Readable;
	let addAbortListener;
	function destroyer(stream, reading, writing) {
	  let finished = false;
	  stream.on('close', () => {
	    finished = true;
	  });
	  const cleanup = eos(
	    stream,
	    {
	      readable: reading,
	      writable: writing
	    },
	    (err) => {
	      finished = !err;
	    }
	  );
	  return {
	    destroy: (err) => {
	      if (finished) return
	      finished = true;
	      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'));
	    },
	    cleanup
	  }
	}
	function popCallback(streams) {
	  // Streams should never be an empty array. It should always contain at least
	  // a single stream. Therefore optimize for the average case instead of
	  // checking for length === 0 as well.
	  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]');
	  return streams.pop()
	}
	function makeAsyncIterable(val) {
	  if (isIterable(val)) {
	    return val
	  } else if (isReadableNodeStream(val)) {
	    // Legacy streams are not Iterable.
	    return fromReadable(val)
	  }
	  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)
	}
	async function* fromReadable(val) {
	  if (!Readable) {
	    Readable = requireReadable();
	  }
	  yield* Readable.prototype[SymbolAsyncIterator].call(val);
	}
	async function pumpToNode(iterable, writable, finish, { end }) {
	  let error;
	  let onresolve = null;
	  const resume = (err) => {
	    if (err) {
	      error = err;
	    }
	    if (onresolve) {
	      const callback = onresolve;
	      onresolve = null;
	      callback();
	    }
	  };
	  const wait = () =>
	    new Promise((resolve, reject) => {
	      if (error) {
	        reject(error);
	      } else {
	        onresolve = () => {
	          if (error) {
	            reject(error);
	          } else {
	            resolve();
	          }
	        };
	      }
	    });
	  writable.on('drain', resume);
	  const cleanup = eos(
	    writable,
	    {
	      readable: false
	    },
	    resume
	  );
	  try {
	    if (writable.writableNeedDrain) {
	      await wait();
	    }
	    for await (const chunk of iterable) {
	      if (!writable.write(chunk)) {
	        await wait();
	      }
	    }
	    if (end) {
	      writable.end();
	      await wait();
	    }
	    finish();
	  } catch (err) {
	    finish(error !== err ? aggregateTwoErrors(error, err) : err);
	  } finally {
	    cleanup();
	    writable.off('drain', resume);
	  }
	}
	async function pumpToWeb(readable, writable, finish, { end }) {
	  if (isTransformStream(writable)) {
	    writable = writable.writable;
	  }
	  // https://streams.spec.whatwg.org/#example-manual-write-with-backpressure
	  const writer = writable.getWriter();
	  try {
	    for await (const chunk of readable) {
	      await writer.ready;
	      writer.write(chunk).catch(() => {});
	    }
	    await writer.ready;
	    if (end) {
	      await writer.close();
	    }
	    finish();
	  } catch (err) {
	    try {
	      await writer.abort(err);
	      finish(err);
	    } catch (err) {
	      finish(err);
	    }
	  }
	}
	function pipeline(...streams) {
	  return pipelineImpl(streams, once(popCallback(streams)))
	}
	function pipelineImpl(streams, callback, opts) {
	  if (streams.length === 1 && ArrayIsArray(streams[0])) {
	    streams = streams[0];
	  }
	  if (streams.length < 2) {
	    throw new ERR_MISSING_ARGS('streams')
	  }
	  const ac = new AbortController();
	  const signal = ac.signal;
	  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;

	  // Need to cleanup event listeners if last stream is readable
	  // https://github.com/nodejs/node/issues/35452
	  const lastStreamCleanup = [];
	  validateAbortSignal(outerSignal, 'options.signal');
	  function abort() {
	    finishImpl(new AbortError());
	  }
	  addAbortListener = addAbortListener || requireUtil().addAbortListener;
	  let disposable;
	  if (outerSignal) {
	    disposable = addAbortListener(outerSignal, abort);
	  }
	  let error;
	  let value;
	  const destroys = [];
	  let finishCount = 0;
	  function finish(err) {
	    finishImpl(err, --finishCount === 0);
	  }
	  function finishImpl(err, final) {
	    var _disposable;
	    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {
	      error = err;
	    }
	    if (!error && !final) {
	      return
	    }
	    while (destroys.length) {
	      destroys.shift()(error);
	    }
(_disposable = disposable) === null || _disposable === undefined ? undefined : _disposable[SymbolDispose]();
	    ac.abort();
	    if (final) {
	      if (!error) {
	        lastStreamCleanup.forEach((fn) => fn());
	      }
	      process.nextTick(callback, error, value);
	    }
	  }
	  let ret;
	  for (let i = 0; i < streams.length; i++) {
	    const stream = streams[i];
	    const reading = i < streams.length - 1;
	    const writing = i > 0;
	    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;
	    const isLastStream = i === streams.length - 1;
	    if (isNodeStream(stream)) {
	      if (end) {
	        const { destroy, cleanup } = destroyer(stream, reading, writing);
	        destroys.push(destroy);
	        if (isReadable(stream) && isLastStream) {
	          lastStreamCleanup.push(cleanup);
	        }
	      }

	      // Catch stream errors that occur after pipe/pump has completed.
	      function onError(err) {
	        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	          finish(err);
	        }
	      }
	      stream.on('error', onError);
	      if (isReadable(stream) && isLastStream) {
	        lastStreamCleanup.push(() => {
	          stream.removeListener('error', onError);
	        });
	      }
	    }
	    if (i === 0) {
	      if (typeof stream === 'function') {
	        ret = stream({
	          signal
	        });
	        if (!isIterable(ret)) {
	          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)
	        }
	      } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
	        ret = stream;
	      } else {
	        ret = Duplex.from(stream);
	      }
	    } else if (typeof stream === 'function') {
	      if (isTransformStream(ret)) {
	        var _ret;
	        ret = makeAsyncIterable((_ret = ret) === null || _ret === undefined ? undefined : _ret.readable);
	      } else {
	        ret = makeAsyncIterable(ret);
	      }
	      ret = stream(ret, {
	        signal
	      });
	      if (reading) {
	        if (!isIterable(ret, true)) {
	          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)
	        }
	      } else {
	        var _ret2;
	        if (!PassThrough) {
	          PassThrough = requirePassthrough();
	        }

	        // If the last argument to pipeline is not a stream
	        // we must create a proxy stream so that pipeline(...)
	        // always returns a stream which can be further
	        // composed through `.pipe(stream)`.

	        const pt = new PassThrough({
	          objectMode: true
	        });

	        // Handle Promises/A+ spec, `then` could be a getter that throws on
	        // second use.
	        const then = (_ret2 = ret) === null || _ret2 === undefined ? undefined : _ret2.then;
	        if (typeof then === 'function') {
	          finishCount++;
	          then.call(
	            ret,
	            (val) => {
	              value = val;
	              if (val != null) {
	                pt.write(val);
	              }
	              if (end) {
	                pt.end();
	              }
	              process.nextTick(finish);
	            },
	            (err) => {
	              pt.destroy(err);
	              process.nextTick(finish, err);
	            }
	          );
	        } else if (isIterable(ret, true)) {
	          finishCount++;
	          pumpToNode(ret, pt, finish, {
	            end
	          });
	        } else if (isReadableStream(ret) || isTransformStream(ret)) {
	          const toRead = ret.readable || ret;
	          finishCount++;
	          pumpToNode(toRead, pt, finish, {
	            end
	          });
	        } else {
	          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)
	        }
	        ret = pt;
	        const { destroy, cleanup } = destroyer(ret, false, true);
	        destroys.push(destroy);
	        if (isLastStream) {
	          lastStreamCleanup.push(cleanup);
	        }
	      }
	    } else if (isNodeStream(stream)) {
	      if (isReadableNodeStream(ret)) {
	        finishCount += 2;
	        const cleanup = pipe(ret, stream, finish, {
	          end
	        });
	        if (isReadable(stream) && isLastStream) {
	          lastStreamCleanup.push(cleanup);
	        }
	      } else if (isTransformStream(ret) || isReadableStream(ret)) {
	        const toRead = ret.readable || ret;
	        finishCount++;
	        pumpToNode(toRead, stream, finish, {
	          end
	        });
	      } else if (isIterable(ret)) {
	        finishCount++;
	        pumpToNode(ret, stream, finish, {
	          end
	        });
	      } else {
	        throw new ERR_INVALID_ARG_TYPE(
	          'val',
	          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
	          ret
	        )
	      }
	      ret = stream;
	    } else if (isWebStream(stream)) {
	      if (isReadableNodeStream(ret)) {
	        finishCount++;
	        pumpToWeb(makeAsyncIterable(ret), stream, finish, {
	          end
	        });
	      } else if (isReadableStream(ret) || isIterable(ret)) {
	        finishCount++;
	        pumpToWeb(ret, stream, finish, {
	          end
	        });
	      } else if (isTransformStream(ret)) {
	        finishCount++;
	        pumpToWeb(ret.readable, stream, finish, {
	          end
	        });
	      } else {
	        throw new ERR_INVALID_ARG_TYPE(
	          'val',
	          ['Readable', 'Iterable', 'AsyncIterable', 'ReadableStream', 'TransformStream'],
	          ret
	        )
	      }
	      ret = stream;
	    } else {
	      ret = Duplex.from(stream);
	    }
	  }
	  if (
	    (signal !== null && signal !== undefined && signal.aborted) ||
	    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)
	  ) {
	    process.nextTick(abort);
	  }
	  return ret
	}
	function pipe(src, dst, finish, { end }) {
	  let ended = false;
	  dst.on('close', () => {
	    if (!ended) {
	      // Finish if the destination closes before the source has completed.
	      finish(new ERR_STREAM_PREMATURE_CLOSE());
	    }
	  });
	  src.pipe(dst, {
	    end: false
	  }); // If end is true we already will have a listener to end dst.

	  if (end) {
	    // Compat. Before node v10.12.0 stdio used to throw an error so
	    // pipe() did/does not end() stdio destinations.
	    // Now they allow it but "secretly" don't close the underlying fd.

	    function endFn() {
	      ended = true;
	      dst.end();
	    }
	    if (isReadableFinished(src)) {
	      // End the destination if the source has already ended.
	      process.nextTick(endFn);
	    } else {
	      src.once('end', endFn);
	    }
	  } else {
	    finish();
	  }
	  eos(
	    src,
	    {
	      readable: true,
	      writable: false
	    },
	    (err) => {
	      const rState = src._readableState;
	      if (
	        err &&
	        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&
	        rState &&
	        rState.ended &&
	        !rState.errored &&
	        !rState.errorEmitted
	      ) {
	        // Some readable streams will emit 'close' before 'end'. However, since
	        // this is on the readable side 'end' should still be emitted if the
	        // stream has been ended and no error emitted. This should be allowed in
	        // favor of backwards compatibility. Since the stream is piped to a
	        // destination this should not result in any observable difference.
	        // We don't need to check if this is a writable premature close since
	        // eos will only fail with premature close on the reading side for
	        // duplex streams.
	        src.once('end', finish).once('error', finish);
	      } else {
	        finish(err);
	      }
	    }
	  );
	  return eos(
	    dst,
	    {
	      readable: false,
	      writable: true
	    },
	    finish
	  )
	}
	pipeline_1 = {
	  pipelineImpl,
	  pipeline
	};
	return pipeline_1;
}

var compose;
var hasRequiredCompose;

function requireCompose () {
	if (hasRequiredCompose) return compose;
	hasRequiredCompose = 1;

	const { pipeline } = requirePipeline();
	const Duplex = requireDuplex();
	const { destroyer } = requireDestroy();
	const {
	  isNodeStream,
	  isReadable,
	  isWritable,
	  isWebStream,
	  isTransformStream,
	  isWritableStream,
	  isReadableStream
	} = requireUtils();
	const {
	  AbortError,
	  codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
	} = requireErrors();
	const eos = requireEndOfStream();
	compose = function compose(...streams) {
	  if (streams.length === 0) {
	    throw new ERR_MISSING_ARGS('streams')
	  }
	  if (streams.length === 1) {
	    return Duplex.from(streams[0])
	  }
	  const orgStreams = [...streams];
	  if (typeof streams[0] === 'function') {
	    streams[0] = Duplex.from(streams[0]);
	  }
	  if (typeof streams[streams.length - 1] === 'function') {
	    const idx = streams.length - 1;
	    streams[idx] = Duplex.from(streams[idx]);
	  }
	  for (let n = 0; n < streams.length; ++n) {
	    if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
	      // TODO(ronag): Add checks for non streams.
	      continue
	    }
	    if (
	      n < streams.length - 1 &&
	      !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))
	    ) {
	      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be readable')
	    }
	    if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
	      throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], 'must be writable')
	    }
	  }
	  let ondrain;
	  let onfinish;
	  let onreadable;
	  let onclose;
	  let d;
	  function onfinished(err) {
	    const cb = onclose;
	    onclose = null;
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      d.destroy(err);
	    } else if (!readable && !writable) {
	      d.destroy();
	    }
	  }
	  const head = streams[0];
	  const tail = pipeline(streams, onfinished);
	  const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
	  const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));

	  // TODO(ronag): Avoid double buffering.
	  // Implement Writable/Readable/Duplex traits.
	  // See, https://github.com/nodejs/node/pull/33515.
	  d = new Duplex({
	    // TODO (ronag): highWaterMark?
	    writableObjectMode: !!(head !== null && head !== undefined && head.writableObjectMode),
	    readableObjectMode: !!(tail !== null && tail !== undefined && tail.readableObjectMode),
	    writable,
	    readable
	  });
	  if (writable) {
	    if (isNodeStream(head)) {
	      d._write = function (chunk, encoding, callback) {
	        if (head.write(chunk, encoding)) {
	          callback();
	        } else {
	          ondrain = callback;
	        }
	      };
	      d._final = function (callback) {
	        head.end();
	        onfinish = callback;
	      };
	      head.on('drain', function () {
	        if (ondrain) {
	          const cb = ondrain;
	          ondrain = null;
	          cb();
	        }
	      });
	    } else if (isWebStream(head)) {
	      const writable = isTransformStream(head) ? head.writable : head;
	      const writer = writable.getWriter();
	      d._write = async function (chunk, encoding, callback) {
	        try {
	          await writer.ready;
	          writer.write(chunk).catch(() => {});
	          callback();
	        } catch (err) {
	          callback(err);
	        }
	      };
	      d._final = async function (callback) {
	        try {
	          await writer.ready;
	          writer.close().catch(() => {});
	          onfinish = callback;
	        } catch (err) {
	          callback(err);
	        }
	      };
	    }
	    const toRead = isTransformStream(tail) ? tail.readable : tail;
	    eos(toRead, () => {
	      if (onfinish) {
	        const cb = onfinish;
	        onfinish = null;
	        cb();
	      }
	    });
	  }
	  if (readable) {
	    if (isNodeStream(tail)) {
	      tail.on('readable', function () {
	        if (onreadable) {
	          const cb = onreadable;
	          onreadable = null;
	          cb();
	        }
	      });
	      tail.on('end', function () {
	        d.push(null);
	      });
	      d._read = function () {
	        while (true) {
	          const buf = tail.read();
	          if (buf === null) {
	            onreadable = d._read;
	            return
	          }
	          if (!d.push(buf)) {
	            return
	          }
	        }
	      };
	    } else if (isWebStream(tail)) {
	      const readable = isTransformStream(tail) ? tail.readable : tail;
	      const reader = readable.getReader();
	      d._read = async function () {
	        while (true) {
	          try {
	            const { value, done } = await reader.read();
	            if (!d.push(value)) {
	              return
	            }
	            if (done) {
	              d.push(null);
	              return
	            }
	          } catch {
	            return
	          }
	        }
	      };
	    }
	  }
	  d._destroy = function (err, callback) {
	    if (!err && onclose !== null) {
	      err = new AbortError();
	    }
	    onreadable = null;
	    ondrain = null;
	    onfinish = null;
	    if (onclose === null) {
	      callback(err);
	    } else {
	      onclose = callback;
	      if (isNodeStream(tail)) {
	        destroyer(tail, err);
	      }
	    }
	  };
	  return d
	};
	return compose;
}

var hasRequiredOperators;

function requireOperators () {
	if (hasRequiredOperators) return operators;
	hasRequiredOperators = 1;

	const AbortController = globalThis.AbortController || require$$0$2.AbortController;
	const {
	  codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
	  AbortError
	} = requireErrors();
	const { validateAbortSignal, validateInteger, validateObject } = requireValidators();
	const kWeakHandler = requirePrimordials().Symbol('kWeak');
	const kResistStopPropagation = requirePrimordials().Symbol('kResistStopPropagation');
	const { finished } = requireEndOfStream();
	const staticCompose = requireCompose();
	const { addAbortSignalNoValidate } = requireAddAbortSignal();
	const { isWritable, isNodeStream } = requireUtils();
	const { deprecate } = requireUtil();
	const {
	  ArrayPrototypePush,
	  Boolean,
	  MathFloor,
	  Number,
	  NumberIsNaN,
	  Promise,
	  PromiseReject,
	  PromiseResolve,
	  PromisePrototypeThen,
	  Symbol
	} = requirePrimordials();
	const kEmpty = Symbol('kEmpty');
	const kEof = Symbol('kEof');
	function compose(stream, options) {
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  if (isNodeStream(stream) && !isWritable(stream)) {
	    throw new ERR_INVALID_ARG_VALUE('stream', stream, 'must be writable')
	  }
	  const composedStream = staticCompose(this, stream);
	  if (options !== null && options !== undefined && options.signal) {
	    // Not validating as we already validated before
	    addAbortSignalNoValidate(options.signal, composedStream);
	  }
	  return composedStream
	}
	function map(fn, options) {
	  if (typeof fn !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
	  }
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  let concurrency = 1;
	  if ((options === null || options === undefined ? undefined : options.concurrency) != null) {
	    concurrency = MathFloor(options.concurrency);
	  }
	  let highWaterMark = concurrency - 1;
	  if ((options === null || options === undefined ? undefined : options.highWaterMark) != null) {
	    highWaterMark = MathFloor(options.highWaterMark);
	  }
	  validateInteger(concurrency, 'options.concurrency', 1);
	  validateInteger(highWaterMark, 'options.highWaterMark', 0);
	  highWaterMark += concurrency;
	  return async function* map() {
	    const signal = requireUtil().AbortSignalAny(
	      [options === null || options === undefined ? undefined : options.signal].filter(Boolean)
	    );
	    const stream = this;
	    const queue = [];
	    const signalOpt = {
	      signal
	    };
	    let next;
	    let resume;
	    let done = false;
	    let cnt = 0;
	    function onCatch() {
	      done = true;
	      afterItemProcessed();
	    }
	    function afterItemProcessed() {
	      cnt -= 1;
	      maybeResume();
	    }
	    function maybeResume() {
	      if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
	        resume();
	        resume = null;
	      }
	    }
	    async function pump() {
	      try {
	        for await (let val of stream) {
	          if (done) {
	            return
	          }
	          if (signal.aborted) {
	            throw new AbortError()
	          }
	          try {
	            val = fn(val, signalOpt);
	            if (val === kEmpty) {
	              continue
	            }
	            val = PromiseResolve(val);
	          } catch (err) {
	            val = PromiseReject(err);
	          }
	          cnt += 1;
	          PromisePrototypeThen(val, afterItemProcessed, onCatch);
	          queue.push(val);
	          if (next) {
	            next();
	            next = null;
	          }
	          if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
	            await new Promise((resolve) => {
	              resume = resolve;
	            });
	          }
	        }
	        queue.push(kEof);
	      } catch (err) {
	        const val = PromiseReject(err);
	        PromisePrototypeThen(val, afterItemProcessed, onCatch);
	        queue.push(val);
	      } finally {
	        done = true;
	        if (next) {
	          next();
	          next = null;
	        }
	      }
	    }
	    pump();
	    try {
	      while (true) {
	        while (queue.length > 0) {
	          const val = await queue[0];
	          if (val === kEof) {
	            return
	          }
	          if (signal.aborted) {
	            throw new AbortError()
	          }
	          if (val !== kEmpty) {
	            yield val;
	          }
	          queue.shift();
	          maybeResume();
	        }
	        await new Promise((resolve) => {
	          next = resolve;
	        });
	      }
	    } finally {
	      done = true;
	      if (resume) {
	        resume();
	        resume = null;
	      }
	    }
	  }.call(this)
	}
	function asIndexedPairs(options = undefined) {
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  return async function* asIndexedPairs() {
	    let index = 0;
	    for await (const val of this) {
	      var _options$signal;
	      if (
	        options !== null &&
	        options !== undefined &&
	        (_options$signal = options.signal) !== null &&
	        _options$signal !== undefined &&
	        _options$signal.aborted
	      ) {
	        throw new AbortError({
	          cause: options.signal.reason
	        })
	      }
	      yield [index++, val];
	    }
	  }.call(this)
	}
	async function some(fn, options = undefined) {
	  for await (const unused of filter.call(this, fn, options)) {
	    return true
	  }
	  return false
	}
	async function every(fn, options = undefined) {
	  if (typeof fn !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
	  }
	  // https://en.wikipedia.org/wiki/De_Morgan%27s_laws
	  return !(await some.call(
	    this,
	    async (...args) => {
	      return !(await fn(...args))
	    },
	    options
	  ))
	}
	async function find(fn, options) {
	  for await (const result of filter.call(this, fn, options)) {
	    return result
	  }
	  return undefined
	}
	async function forEach(fn, options) {
	  if (typeof fn !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
	  }
	  async function forEachFn(value, options) {
	    await fn(value, options);
	    return kEmpty
	  }
	  // eslint-disable-next-line no-unused-vars
	  for await (const unused of map.call(this, forEachFn, options));
	}
	function filter(fn, options) {
	  if (typeof fn !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('fn', ['Function', 'AsyncFunction'], fn)
	  }
	  async function filterFn(value, options) {
	    if (await fn(value, options)) {
	      return value
	    }
	    return kEmpty
	  }
	  return map.call(this, filterFn, options)
	}

	// Specific to provide better error to reduce since the argument is only
	// missing if the stream has no items in it - but the code is still appropriate
	class ReduceAwareErrMissingArgs extends ERR_MISSING_ARGS {
	  constructor() {
	    super('reduce');
	    this.message = 'Reduce of an empty stream requires an initial value';
	  }
	}
	async function reduce(reducer, initialValue, options) {
	  var _options$signal2;
	  if (typeof reducer !== 'function') {
	    throw new ERR_INVALID_ARG_TYPE('reducer', ['Function', 'AsyncFunction'], reducer)
	  }
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  let hasInitialValue = arguments.length > 1;
	  if (
	    options !== null &&
	    options !== undefined &&
	    (_options$signal2 = options.signal) !== null &&
	    _options$signal2 !== undefined &&
	    _options$signal2.aborted
	  ) {
	    const err = new AbortError(undefined, {
	      cause: options.signal.reason
	    });
	    this.once('error', () => {}); // The error is already propagated
	    await finished(this.destroy(err));
	    throw err
	  }
	  const ac = new AbortController();
	  const signal = ac.signal;
	  if (options !== null && options !== undefined && options.signal) {
	    const opts = {
	      once: true,
	      [kWeakHandler]: this,
	      [kResistStopPropagation]: true
	    };
	    options.signal.addEventListener('abort', () => ac.abort(), opts);
	  }
	  let gotAnyItemFromStream = false;
	  try {
	    for await (const value of this) {
	      var _options$signal3;
	      gotAnyItemFromStream = true;
	      if (
	        options !== null &&
	        options !== undefined &&
	        (_options$signal3 = options.signal) !== null &&
	        _options$signal3 !== undefined &&
	        _options$signal3.aborted
	      ) {
	        throw new AbortError()
	      }
	      if (!hasInitialValue) {
	        initialValue = value;
	        hasInitialValue = true;
	      } else {
	        initialValue = await reducer(initialValue, value, {
	          signal
	        });
	      }
	    }
	    if (!gotAnyItemFromStream && !hasInitialValue) {
	      throw new ReduceAwareErrMissingArgs()
	    }
	  } finally {
	    ac.abort();
	  }
	  return initialValue
	}
	async function toArray(options) {
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  const result = [];
	  for await (const val of this) {
	    var _options$signal4;
	    if (
	      options !== null &&
	      options !== undefined &&
	      (_options$signal4 = options.signal) !== null &&
	      _options$signal4 !== undefined &&
	      _options$signal4.aborted
	    ) {
	      throw new AbortError(undefined, {
	        cause: options.signal.reason
	      })
	    }
	    ArrayPrototypePush(result, val);
	  }
	  return result
	}
	function flatMap(fn, options) {
	  const values = map.call(this, fn, options);
	  return async function* flatMap() {
	    for await (const val of values) {
	      yield* val;
	    }
	  }.call(this)
	}
	function toIntegerOrInfinity(number) {
	  // We coerce here to align with the spec
	  // https://github.com/tc39/proposal-iterator-helpers/issues/169
	  number = Number(number);
	  if (NumberIsNaN(number)) {
	    return 0
	  }
	  if (number < 0) {
	    throw new ERR_OUT_OF_RANGE('number', '>= 0', number)
	  }
	  return number
	}
	function drop(number, options = undefined) {
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  number = toIntegerOrInfinity(number);
	  return async function* drop() {
	    var _options$signal5;
	    if (
	      options !== null &&
	      options !== undefined &&
	      (_options$signal5 = options.signal) !== null &&
	      _options$signal5 !== undefined &&
	      _options$signal5.aborted
	    ) {
	      throw new AbortError()
	    }
	    for await (const val of this) {
	      var _options$signal6;
	      if (
	        options !== null &&
	        options !== undefined &&
	        (_options$signal6 = options.signal) !== null &&
	        _options$signal6 !== undefined &&
	        _options$signal6.aborted
	      ) {
	        throw new AbortError()
	      }
	      if (number-- <= 0) {
	        yield val;
	      }
	    }
	  }.call(this)
	}
	function take(number, options = undefined) {
	  if (options != null) {
	    validateObject(options, 'options');
	  }
	  if ((options === null || options === undefined ? undefined : options.signal) != null) {
	    validateAbortSignal(options.signal, 'options.signal');
	  }
	  number = toIntegerOrInfinity(number);
	  return async function* take() {
	    var _options$signal7;
	    if (
	      options !== null &&
	      options !== undefined &&
	      (_options$signal7 = options.signal) !== null &&
	      _options$signal7 !== undefined &&
	      _options$signal7.aborted
	    ) {
	      throw new AbortError()
	    }
	    for await (const val of this) {
	      var _options$signal8;
	      if (
	        options !== null &&
	        options !== undefined &&
	        (_options$signal8 = options.signal) !== null &&
	        _options$signal8 !== undefined &&
	        _options$signal8.aborted
	      ) {
	        throw new AbortError()
	      }
	      if (number-- > 0) {
	        yield val;
	      }

	      // Don't get another item from iterator in case we reached the end
	      if (number <= 0) {
	        return
	      }
	    }
	  }.call(this)
	}
	operators.streamReturningOperators = {
	  asIndexedPairs: deprecate(asIndexedPairs, 'readable.asIndexedPairs will be removed in a future version.'),
	  drop,
	  filter,
	  flatMap,
	  map,
	  take,
	  compose
	};
	operators.promiseReturningOperators = {
	  every,
	  forEach,
	  reduce,
	  toArray,
	  some,
	  find
	};
	return operators;
}

var promises;
var hasRequiredPromises;

function requirePromises () {
	if (hasRequiredPromises) return promises;
	hasRequiredPromises = 1;

	const { ArrayPrototypePop, Promise } = requirePrimordials();
	const { isIterable, isNodeStream, isWebStream } = requireUtils();
	const { pipelineImpl: pl } = requirePipeline();
	const { finished } = requireEndOfStream();
	requireStream();
	function pipeline(...streams) {
	  return new Promise((resolve, reject) => {
	    let signal;
	    let end;
	    const lastArg = streams[streams.length - 1];
	    if (
	      lastArg &&
	      typeof lastArg === 'object' &&
	      !isNodeStream(lastArg) &&
	      !isIterable(lastArg) &&
	      !isWebStream(lastArg)
	    ) {
	      const options = ArrayPrototypePop(streams);
	      signal = options.signal;
	      end = options.end;
	    }
	    pl(
	      streams,
	      (err, value) => {
	        if (err) {
	          reject(err);
	        } else {
	          resolve(value);
	        }
	      },
	      {
	        signal,
	        end
	      }
	    );
	  })
	}
	promises = {
	  finished,
	  pipeline
	};
	return promises;
}

var hasRequiredStream;

function requireStream () {
	if (hasRequiredStream) return stream.exports;
	hasRequiredStream = 1;

	/* replacement start */

	const { Buffer } = require$$0$7;

	/* replacement end */

	const { ObjectDefineProperty, ObjectKeys, ReflectApply } = requirePrimordials();
	const {
	  promisify: { custom: customPromisify }
	} = requireUtil();
	const { streamReturningOperators, promiseReturningOperators } = requireOperators();
	const {
	  codes: { ERR_ILLEGAL_CONSTRUCTOR }
	} = requireErrors();
	const compose = requireCompose();
	const { setDefaultHighWaterMark, getDefaultHighWaterMark } = requireState();
	const { pipeline } = requirePipeline();
	const { destroyer } = requireDestroy();
	const eos = requireEndOfStream();
	const promises = requirePromises();
	const utils = requireUtils();
	const Stream = (stream.exports = requireLegacy().Stream);
	Stream.isDestroyed = utils.isDestroyed;
	Stream.isDisturbed = utils.isDisturbed;
	Stream.isErrored = utils.isErrored;
	Stream.isReadable = utils.isReadable;
	Stream.isWritable = utils.isWritable;
	Stream.Readable = requireReadable();
	for (const key of ObjectKeys(streamReturningOperators)) {
	  const op = streamReturningOperators[key];
	  function fn(...args) {
	    if (new.target) {
	      throw ERR_ILLEGAL_CONSTRUCTOR()
	    }
	    return Stream.Readable.from(ReflectApply(op, this, args))
	  }
	  ObjectDefineProperty(fn, 'name', {
	    __proto__: null,
	    value: op.name
	  });
	  ObjectDefineProperty(fn, 'length', {
	    __proto__: null,
	    value: op.length
	  });
	  ObjectDefineProperty(Stream.Readable.prototype, key, {
	    __proto__: null,
	    value: fn,
	    enumerable: false,
	    configurable: true,
	    writable: true
	  });
	}
	for (const key of ObjectKeys(promiseReturningOperators)) {
	  const op = promiseReturningOperators[key];
	  function fn(...args) {
	    if (new.target) {
	      throw ERR_ILLEGAL_CONSTRUCTOR()
	    }
	    return ReflectApply(op, this, args)
	  }
	  ObjectDefineProperty(fn, 'name', {
	    __proto__: null,
	    value: op.name
	  });
	  ObjectDefineProperty(fn, 'length', {
	    __proto__: null,
	    value: op.length
	  });
	  ObjectDefineProperty(Stream.Readable.prototype, key, {
	    __proto__: null,
	    value: fn,
	    enumerable: false,
	    configurable: true,
	    writable: true
	  });
	}
	Stream.Writable = requireWritable();
	Stream.Duplex = requireDuplex();
	Stream.Transform = requireTransform();
	Stream.PassThrough = requirePassthrough();
	Stream.pipeline = pipeline;
	const { addAbortSignal } = requireAddAbortSignal();
	Stream.addAbortSignal = addAbortSignal;
	Stream.finished = eos;
	Stream.destroy = destroyer;
	Stream.compose = compose;
	Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
	Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
	ObjectDefineProperty(Stream, 'promises', {
	  __proto__: null,
	  configurable: true,
	  enumerable: true,
	  get() {
	    return promises
	  }
	});
	ObjectDefineProperty(pipeline, customPromisify, {
	  __proto__: null,
	  enumerable: true,
	  get() {
	    return promises.pipeline
	  }
	});
	ObjectDefineProperty(eos, customPromisify, {
	  __proto__: null,
	  enumerable: true,
	  get() {
	    return promises.finished
	  }
	});

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	Stream._isUint8Array = function isUint8Array(value) {
	  return value instanceof Uint8Array
	};
	Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)
	};
	return stream.exports;
}

ours.exports;

var hasRequiredOurs;

function requireOurs () {
	if (hasRequiredOurs) return ours.exports;
	hasRequiredOurs = 1;
	(function (module) {

		const Stream = require$$0$6;
		if (Stream && process.env.READABLE_STREAM === 'disable') {
		  const promises = Stream.promises;

		  // Explicit export naming is needed for ESM
		  module.exports._uint8ArrayToBuffer = Stream._uint8ArrayToBuffer;
		  module.exports._isUint8Array = Stream._isUint8Array;
		  module.exports.isDisturbed = Stream.isDisturbed;
		  module.exports.isErrored = Stream.isErrored;
		  module.exports.isReadable = Stream.isReadable;
		  module.exports.Readable = Stream.Readable;
		  module.exports.Writable = Stream.Writable;
		  module.exports.Duplex = Stream.Duplex;
		  module.exports.Transform = Stream.Transform;
		  module.exports.PassThrough = Stream.PassThrough;
		  module.exports.addAbortSignal = Stream.addAbortSignal;
		  module.exports.finished = Stream.finished;
		  module.exports.destroy = Stream.destroy;
		  module.exports.pipeline = Stream.pipeline;
		  module.exports.compose = Stream.compose;
		  Object.defineProperty(Stream, 'promises', {
		    configurable: true,
		    enumerable: true,
		    get() {
		      return promises
		    }
		  });
		  module.exports.Stream = Stream.Stream;
		} else {
		  const CustomStream = requireStream();
		  const promises = requirePromises();
		  const originalDestroy = CustomStream.Readable.destroy;
		  module.exports = CustomStream.Readable;

		  // Explicit export naming is needed for ESM
		  module.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
		  module.exports._isUint8Array = CustomStream._isUint8Array;
		  module.exports.isDisturbed = CustomStream.isDisturbed;
		  module.exports.isErrored = CustomStream.isErrored;
		  module.exports.isReadable = CustomStream.isReadable;
		  module.exports.Readable = CustomStream.Readable;
		  module.exports.Writable = CustomStream.Writable;
		  module.exports.Duplex = CustomStream.Duplex;
		  module.exports.Transform = CustomStream.Transform;
		  module.exports.PassThrough = CustomStream.PassThrough;
		  module.exports.addAbortSignal = CustomStream.addAbortSignal;
		  module.exports.finished = CustomStream.finished;
		  module.exports.destroy = CustomStream.destroy;
		  module.exports.destroy = originalDestroy;
		  module.exports.pipeline = CustomStream.pipeline;
		  module.exports.compose = CustomStream.compose;
		  Object.defineProperty(CustomStream, 'promises', {
		    configurable: true,
		    enumerable: true,
		    get() {
		      return promises
		    }
		  });
		  module.exports.Stream = CustomStream.Stream;
		}

		// Allow default importing
		module.exports.default = module.exports; 
	} (ours));
	return ours.exports;
}

var inherits = {exports: {}};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

var hasRequiredInherits;

function requireInherits () {
	if (hasRequiredInherits) return inherits.exports;
	hasRequiredInherits = 1;
	try {
	  var util = require('util');
	  /* istanbul ignore next */
	  if (typeof util.inherits !== 'function') throw '';
	  inherits.exports = util.inherits;
	} catch (e) {
	  /* istanbul ignore next */
	  inherits.exports = requireInherits_browser();
	}
	return inherits.exports;
}

var BufferList_1;
var hasRequiredBufferList;

function requireBufferList () {
	if (hasRequiredBufferList) return BufferList_1;
	hasRequiredBufferList = 1;

	const { Buffer } = require$$0$7;
	const symbol = Symbol.for('BufferList');

	function BufferList (buf) {
	  if (!(this instanceof BufferList)) {
	    return new BufferList(buf)
	  }

	  BufferList._init.call(this, buf);
	}

	BufferList._init = function _init (buf) {
	  Object.defineProperty(this, symbol, { value: true });

	  this._bufs = [];
	  this.length = 0;

	  if (buf) {
	    this.append(buf);
	  }
	};

	BufferList.prototype._new = function _new (buf) {
	  return new BufferList(buf)
	};

	BufferList.prototype._offset = function _offset (offset) {
	  if (offset === 0) {
	    return [0, 0]
	  }

	  let tot = 0;

	  for (let i = 0; i < this._bufs.length; i++) {
	    const _t = tot + this._bufs[i].length;
	    if (offset < _t || i === this._bufs.length - 1) {
	      return [i, offset - tot]
	    }
	    tot = _t;
	  }
	};

	BufferList.prototype._reverseOffset = function (blOffset) {
	  const bufferId = blOffset[0];
	  let offset = blOffset[1];

	  for (let i = 0; i < bufferId; i++) {
	    offset += this._bufs[i].length;
	  }

	  return offset
	};

	BufferList.prototype.getBuffers = function getBuffers () {
	  return this._bufs
	};

	BufferList.prototype.get = function get (index) {
	  if (index > this.length || index < 0) {
	    return undefined
	  }

	  const offset = this._offset(index);

	  return this._bufs[offset[0]][offset[1]]
	};

	BufferList.prototype.slice = function slice (start, end) {
	  if (typeof start === 'number' && start < 0) {
	    start += this.length;
	  }

	  if (typeof end === 'number' && end < 0) {
	    end += this.length;
	  }

	  return this.copy(null, 0, start, end)
	};

	BufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {
	  if (typeof srcStart !== 'number' || srcStart < 0) {
	    srcStart = 0;
	  }

	  if (typeof srcEnd !== 'number' || srcEnd > this.length) {
	    srcEnd = this.length;
	  }

	  if (srcStart >= this.length) {
	    return dst || Buffer.alloc(0)
	  }

	  if (srcEnd <= 0) {
	    return dst || Buffer.alloc(0)
	  }

	  const copy = !!dst;
	  const off = this._offset(srcStart);
	  const len = srcEnd - srcStart;
	  let bytes = len;
	  let bufoff = (copy && dstStart) || 0;
	  let start = off[1];

	  // copy/slice everything
	  if (srcStart === 0 && srcEnd === this.length) {
	    if (!copy) {
	      // slice, but full concat if multiple buffers
	      return this._bufs.length === 1
	        ? this._bufs[0]
	        : Buffer.concat(this._bufs, this.length)
	    }

	    // copy, need to copy individual buffers
	    for (let i = 0; i < this._bufs.length; i++) {
	      this._bufs[i].copy(dst, bufoff);
	      bufoff += this._bufs[i].length;
	    }

	    return dst
	  }

	  // easy, cheap case where it's a subset of one of the buffers
	  if (bytes <= this._bufs[off[0]].length - start) {
	    return copy
	      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
	      : this._bufs[off[0]].slice(start, start + bytes)
	  }

	  if (!copy) {
	    // a slice, we need something to copy in to
	    dst = Buffer.allocUnsafe(len);
	  }

	  for (let i = off[0]; i < this._bufs.length; i++) {
	    const l = this._bufs[i].length - start;

	    if (bytes > l) {
	      this._bufs[i].copy(dst, bufoff, start);
	      bufoff += l;
	    } else {
	      this._bufs[i].copy(dst, bufoff, start, start + bytes);
	      bufoff += l;
	      break
	    }

	    bytes -= l;

	    if (start) {
	      start = 0;
	    }
	  }

	  // safeguard so that we don't return uninitialized memory
	  if (dst.length > bufoff) return dst.slice(0, bufoff)

	  return dst
	};

	BufferList.prototype.shallowSlice = function shallowSlice (start, end) {
	  start = start || 0;
	  end = typeof end !== 'number' ? this.length : end;

	  if (start < 0) {
	    start += this.length;
	  }

	  if (end < 0) {
	    end += this.length;
	  }

	  if (start === end) {
	    return this._new()
	  }

	  const startOffset = this._offset(start);
	  const endOffset = this._offset(end);
	  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);

	  if (endOffset[1] === 0) {
	    buffers.pop();
	  } else {
	    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
	  }

	  if (startOffset[1] !== 0) {
	    buffers[0] = buffers[0].slice(startOffset[1]);
	  }

	  return this._new(buffers)
	};

	BufferList.prototype.toString = function toString (encoding, start, end) {
	  return this.slice(start, end).toString(encoding)
	};

	BufferList.prototype.consume = function consume (bytes) {
	  // first, normalize the argument, in accordance with how Buffer does it
	  bytes = Math.trunc(bytes);
	  // do nothing if not a positive number
	  if (Number.isNaN(bytes) || bytes <= 0) return this

	  while (this._bufs.length) {
	    if (bytes >= this._bufs[0].length) {
	      bytes -= this._bufs[0].length;
	      this.length -= this._bufs[0].length;
	      this._bufs.shift();
	    } else {
	      this._bufs[0] = this._bufs[0].slice(bytes);
	      this.length -= bytes;
	      break
	    }
	  }

	  return this
	};

	BufferList.prototype.duplicate = function duplicate () {
	  const copy = this._new();

	  for (let i = 0; i < this._bufs.length; i++) {
	    copy.append(this._bufs[i]);
	  }

	  return copy
	};

	BufferList.prototype.append = function append (buf) {
	  return this._attach(buf, BufferList.prototype._appendBuffer)
	};

	BufferList.prototype.prepend = function prepend (buf) {
	  return this._attach(buf, BufferList.prototype._prependBuffer, true)
	};

	BufferList.prototype._attach = function _attach (buf, attacher, prepend) {
	  if (buf == null) {
	    return this
	  }

	  if (buf.buffer) {
	    // append/prepend a view of the underlying ArrayBuffer
	    attacher.call(this, Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
	  } else if (Array.isArray(buf)) {
	    const [starting, modifier] = prepend ? [buf.length - 1, -1] : [0, 1];

	    for (let i = starting; i >= 0 && i < buf.length; i += modifier) {
	      this._attach(buf[i], attacher, prepend);
	    }
	  } else if (this._isBufferList(buf)) {
	    // unwrap argument into individual BufferLists
	    const [starting, modifier] = prepend ? [buf._bufs.length - 1, -1] : [0, 1];

	    for (let i = starting; i >= 0 && i < buf._bufs.length; i += modifier) {
	      this._attach(buf._bufs[i], attacher, prepend);
	    }
	  } else {
	    // coerce number arguments to strings, since Buffer(number) does
	    // uninitialized memory allocation
	    if (typeof buf === 'number') {
	      buf = buf.toString();
	    }

	    attacher.call(this, Buffer.from(buf));
	  }

	  return this
	};

	BufferList.prototype._appendBuffer = function appendBuffer (buf) {
	  this._bufs.push(buf);
	  this.length += buf.length;
	};

	BufferList.prototype._prependBuffer = function prependBuffer (buf) {
	  this._bufs.unshift(buf);
	  this.length += buf.length;
	};

	BufferList.prototype.indexOf = function (search, offset, encoding) {
	  if (encoding === undefined && typeof offset === 'string') {
	    encoding = offset;
	    offset = undefined;
	  }

	  if (typeof search === 'function' || Array.isArray(search)) {
	    throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
	  } else if (typeof search === 'number') {
	    search = Buffer.from([search]);
	  } else if (typeof search === 'string') {
	    search = Buffer.from(search, encoding);
	  } else if (this._isBufferList(search)) {
	    search = search.slice();
	  } else if (Array.isArray(search.buffer)) {
	    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
	  } else if (!Buffer.isBuffer(search)) {
	    search = Buffer.from(search);
	  }

	  offset = Number(offset || 0);

	  if (isNaN(offset)) {
	    offset = 0;
	  }

	  if (offset < 0) {
	    offset = this.length + offset;
	  }

	  if (offset < 0) {
	    offset = 0;
	  }

	  if (search.length === 0) {
	    return offset > this.length ? this.length : offset
	  }

	  const blOffset = this._offset(offset);
	  let blIndex = blOffset[0]; // index of which internal buffer we're working on
	  let buffOffset = blOffset[1]; // offset of the internal buffer we're working on

	  // scan over each buffer
	  for (; blIndex < this._bufs.length; blIndex++) {
	    const buff = this._bufs[blIndex];

	    while (buffOffset < buff.length) {
	      const availableWindow = buff.length - buffOffset;

	      if (availableWindow >= search.length) {
	        const nativeSearchResult = buff.indexOf(search, buffOffset);

	        if (nativeSearchResult !== -1) {
	          return this._reverseOffset([blIndex, nativeSearchResult])
	        }

	        buffOffset = buff.length - search.length + 1; // end of native search window
	      } else {
	        const revOffset = this._reverseOffset([blIndex, buffOffset]);

	        if (this._match(revOffset, search)) {
	          return revOffset
	        }

	        buffOffset++;
	      }
	    }

	    buffOffset = 0;
	  }

	  return -1
	};

	BufferList.prototype._match = function (offset, search) {
	  if (this.length - offset < search.length) {
	    return false
	  }

	  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
	    if (this.get(offset + searchOffset) !== search[searchOffset]) {
	      return false
	    }
	  }
	  return true
	}

	;(function () {
	  const methods = {
	    readDoubleBE: 8,
	    readDoubleLE: 8,
	    readFloatBE: 4,
	    readFloatLE: 4,
	    readBigInt64BE: 8,
	    readBigInt64LE: 8,
	    readBigUInt64BE: 8,
	    readBigUInt64LE: 8,
	    readInt32BE: 4,
	    readInt32LE: 4,
	    readUInt32BE: 4,
	    readUInt32LE: 4,
	    readInt16BE: 2,
	    readInt16LE: 2,
	    readUInt16BE: 2,
	    readUInt16LE: 2,
	    readInt8: 1,
	    readUInt8: 1,
	    readIntBE: null,
	    readIntLE: null,
	    readUIntBE: null,
	    readUIntLE: null
	  };

	  for (const m in methods) {
	    (function (m) {
	      if (methods[m] === null) {
	        BufferList.prototype[m] = function (offset, byteLength) {
	          return this.slice(offset, offset + byteLength)[m](0, byteLength)
	        };
	      } else {
	        BufferList.prototype[m] = function (offset = 0) {
	          return this.slice(offset, offset + methods[m])[m](0)
	        };
	      }
	    }(m));
	  }
	}());

	// Used internally by the class and also as an indicator of this object being
	// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
	// environment because there could be multiple different copies of the
	// BufferList class and some `BufferList`s might be `BufferList`s.
	BufferList.prototype._isBufferList = function _isBufferList (b) {
	  return b instanceof BufferList || BufferList.isBufferList(b)
	};

	BufferList.isBufferList = function isBufferList (b) {
	  return b != null && b[symbol]
	};

	BufferList_1 = BufferList;
	return BufferList_1;
}

var hasRequiredBl;

function requireBl () {
	if (hasRequiredBl) return bl.exports;
	hasRequiredBl = 1;

	const DuplexStream = requireOurs().Duplex;
	const inherits = requireInherits();
	const BufferList = requireBufferList();

	function BufferListStream (callback) {
	  if (!(this instanceof BufferListStream)) {
	    return new BufferListStream(callback)
	  }

	  if (typeof callback === 'function') {
	    this._callback = callback;

	    const piper = function piper (err) {
	      if (this._callback) {
	        this._callback(err);
	        this._callback = null;
	      }
	    }.bind(this);

	    this.on('pipe', function onPipe (src) {
	      src.on('error', piper);
	    });
	    this.on('unpipe', function onUnpipe (src) {
	      src.removeListener('error', piper);
	    });

	    callback = null;
	  }

	  BufferList._init.call(this, callback);
	  DuplexStream.call(this);
	}

	inherits(BufferListStream, DuplexStream);
	Object.assign(BufferListStream.prototype, BufferList.prototype);

	BufferListStream.prototype._new = function _new (callback) {
	  return new BufferListStream(callback)
	};

	BufferListStream.prototype._write = function _write (buf, encoding, callback) {
	  this._appendBuffer(buf);

	  if (typeof callback === 'function') {
	    callback();
	  }
	};

	BufferListStream.prototype._read = function _read (size) {
	  if (!this.length) {
	    return this.push(null)
	  }

	  size = Math.min(size, this.length);
	  this.push(this.slice(0, size));
	  this.consume(size);
	};

	BufferListStream.prototype.end = function end (chunk) {
	  DuplexStream.prototype.end.call(this, chunk);

	  if (this._callback) {
	    this._callback(null, this.slice());
	    this._callback = null;
	  }
	};

	BufferListStream.prototype._destroy = function _destroy (err, cb) {
	  this._bufs.length = 0;
	  this.length = 0;
	  cb(err);
	};

	BufferListStream.prototype._isBufferList = function _isBufferList (b) {
	  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)
	};

	BufferListStream.isBufferList = BufferList.isBufferList;

	bl.exports = BufferListStream;
	bl.exports.BufferListStream = BufferListStream;
	bl.exports.BufferList = BufferList;
	return bl.exports;
}

var hasRequiredIncomingMessageStream;

function requireIncomingMessageStream () {
	if (hasRequiredIncomingMessageStream) return incomingMessageStream.exports;
	hasRequiredIncomingMessageStream = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _bl = _interopRequireDefault(requireBl());
		var _stream = require$$0$6;
		var _message = _interopRequireDefault(requireMessage());
		var _packet = requirePacket();
		var _errors = requireErrors$1();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		/**
		  IncomingMessageStream
		  Transform received TDS data into individual IncomingMessage streams.
		*/
		class IncomingMessageStream extends _stream.Transform {
		  constructor(debug) {
		    super({
		      readableObjectMode: true
		    });
		    this.debug = debug;
		    this.currentMessage = undefined;
		    this.bl = new _bl.default();
		  }
		  pause() {
		    super.pause();
		    if (this.currentMessage) {
		      this.currentMessage.pause();
		    }
		    return this;
		  }
		  resume() {
		    super.resume();
		    if (this.currentMessage) {
		      this.currentMessage.resume();
		    }
		    return this;
		  }
		  processBufferedData(callback) {
		    // The packet header is always 8 bytes of length.
		    while (this.bl.length >= _packet.HEADER_LENGTH) {
		      // Get the full packet length
		      const length = this.bl.readUInt16BE(2);
		      if (length < _packet.HEADER_LENGTH) {
		        return callback(new _errors.ConnectionError('Unable to process incoming packet'));
		      }
		      if (this.bl.length >= length) {
		        const data = this.bl.slice(0, length);
		        this.bl.consume(length);

		        // TODO: Get rid of creating `Packet` instances here.
		        const packet = new _packet.Packet(data);
		        this.debug.packet('Received', packet);
		        this.debug.data(packet);
		        let message = this.currentMessage;
		        if (message === undefined) {
		          this.currentMessage = message = new _message.default({
		            type: packet.type(),
		            resetConnection: false
		          });
		          this.push(message);
		        }
		        if (packet.isLast()) {
		          // Wait until the current message was fully processed before we
		          // continue processing any remaining messages.
		          message.once('end', () => {
		            this.currentMessage = undefined;
		            this.processBufferedData(callback);
		          });
		          message.end(packet.data());
		          return;
		        } else if (!message.write(packet.data())) {
		          // If too much data is buffering up in the
		          // current message, wait for it to drain.
		          message.once('drain', () => {
		            this.processBufferedData(callback);
		          });
		          return;
		        }
		      } else {
		        break;
		      }
		    }

		    // Not enough data to read the next packet. Stop here and wait for
		    // the next call to `_transform`.
		    callback();
		  }
		  _transform(chunk, _encoding, callback) {
		    this.bl.append(chunk);
		    this.processBufferedData(callback);
		  }
		}
		exports$1.default = IncomingMessageStream;
		module.exports = IncomingMessageStream;
		
	} (incomingMessageStream, incomingMessageStream.exports));
	return incomingMessageStream.exports;
}

var outgoingMessageStream = {exports: {}};

var hasRequiredOutgoingMessageStream;

function requireOutgoingMessageStream () {
	if (hasRequiredOutgoingMessageStream) return outgoingMessageStream.exports;
	hasRequiredOutgoingMessageStream = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _bl = _interopRequireDefault(requireBl());
		var _stream = require$$0$6;
		var _packet = requirePacket();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		class OutgoingMessageStream extends _stream.Duplex {
		  constructor(debug, {
		    packetSize
		  }) {
		    super({
		      writableObjectMode: true
		    });
		    this.packetSize = packetSize;
		    this.debug = debug;
		    this.bl = new _bl.default();

		    // When the writable side is ended, push `null`
		    // to also end the readable side.
		    this.on('finish', () => {
		      this.push(null);
		    });
		  }
		  _write(message, _encoding, callback) {
		    const length = this.packetSize - _packet.HEADER_LENGTH;
		    let packetNumber = 0;
		    this.currentMessage = message;
		    this.currentMessage.on('data', data => {
		      if (message.ignore) {
		        return;
		      }
		      this.bl.append(data);
		      while (this.bl.length > length) {
		        const data = this.bl.slice(0, length);
		        this.bl.consume(length);

		        // TODO: Get rid of creating `Packet` instances here.
		        const packet = new _packet.Packet(message.type);
		        packet.packetId(packetNumber += 1);
		        packet.resetConnection(message.resetConnection);
		        packet.addData(data);
		        this.debug.packet('Sent', packet);
		        this.debug.data(packet);
		        if (this.push(packet.buffer) === false) {
		          message.pause();
		        }
		      }
		    });
		    this.currentMessage.on('end', () => {
		      const data = this.bl.slice();
		      this.bl.consume(data.length);

		      // TODO: Get rid of creating `Packet` instances here.
		      const packet = new _packet.Packet(message.type);
		      packet.packetId(packetNumber += 1);
		      packet.resetConnection(message.resetConnection);
		      packet.last(true);
		      packet.ignore(message.ignore);
		      packet.addData(data);
		      this.debug.packet('Sent', packet);
		      this.debug.data(packet);
		      this.push(packet.buffer);
		      this.currentMessage = undefined;
		      callback();
		    });
		  }
		  _read(_size) {
		    // If we do have a message, resume it and get data flowing.
		    // Otherwise, there is nothing to do.
		    if (this.currentMessage) {
		      this.currentMessage.resume();
		    }
		  }
		}
		exports$1.default = OutgoingMessageStream;
		module.exports = OutgoingMessageStream;
		
	} (outgoingMessageStream, outgoingMessageStream.exports));
	return outgoingMessageStream.exports;
}

var hasRequiredMessageIo;

function requireMessageIo () {
	if (hasRequiredMessageIo) return messageIo.exports;
	hasRequiredMessageIo = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _nativeDuplexpair = _interopRequireDefault(requireNativeDuplexpair());
		var tls = _interopRequireWildcard(require$$1$3);
		var _events = require$$0$5;
		var _message = _interopRequireDefault(requireMessage());
		var _packet = requirePacket();
		var _incomingMessageStream = _interopRequireDefault(requireIncomingMessageStream());
		var _outgoingMessageStream = _interopRequireDefault(requireOutgoingMessageStream());
		function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
		function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		class MessageIO extends _events.EventEmitter {
		  constructor(socket, packetSize, debug) {
		    super();
		    this.socket = socket;
		    this.debug = debug;
		    this.tlsNegotiationComplete = false;
		    this.incomingMessageStream = new _incomingMessageStream.default(this.debug);
		    this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();
		    this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {
		      packetSize: packetSize
		    });
		    this.socket.pipe(this.incomingMessageStream);
		    this.outgoingMessageStream.pipe(this.socket);
		  }
		  packetSize(...args) {
		    if (args.length > 0) {
		      const packetSize = args[0];
		      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);
		      this.outgoingMessageStream.packetSize = packetSize;
		    }
		    if (this.securePair) {
		      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
		    }
		    return this.outgoingMessageStream.packetSize;
		  }

		  // Negotiate TLS encryption.
		  startTls(credentialsDetails, hostname, trustServerCertificate) {
		    if (!credentialsDetails.maxVersion || !['TLSv1.2', 'TLSv1.1', 'TLSv1'].includes(credentialsDetails.maxVersion)) {
		      credentialsDetails.maxVersion = 'TLSv1.2';
		    }
		    const secureContext = tls.createSecureContext(credentialsDetails);
		    return new Promise((resolve, reject) => {
		      const duplexpair = new _nativeDuplexpair.default();
		      const securePair = this.securePair = {
		        cleartext: tls.connect({
		          socket: duplexpair.socket1,
		          servername: hostname,
		          secureContext: secureContext,
		          rejectUnauthorized: !trustServerCertificate
		        }),
		        encrypted: duplexpair.socket2
		      };
		      const onSecureConnect = () => {
		        securePair.encrypted.removeListener('readable', onReadable);
		        securePair.cleartext.removeListener('error', onError);
		        securePair.cleartext.removeListener('secureConnect', onSecureConnect);

		        // If we encounter any errors from this point on,
		        // we just forward them to the actual network socket.
		        securePair.cleartext.once('error', err => {
		          this.socket.destroy(err);
		        });
		        const cipher = securePair.cleartext.getCipher();
		        if (cipher) {
		          this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');
		        }
		        this.emit('secure', securePair.cleartext);
		        securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);
		        this.outgoingMessageStream.unpipe(this.socket);
		        this.socket.unpipe(this.incomingMessageStream);
		        this.socket.pipe(securePair.encrypted);
		        securePair.encrypted.pipe(this.socket);
		        securePair.cleartext.pipe(this.incomingMessageStream);
		        this.outgoingMessageStream.pipe(securePair.cleartext);
		        this.tlsNegotiationComplete = true;
		        resolve();
		      };
		      const onError = err => {
		        securePair.encrypted.removeListener('readable', onReadable);
		        securePair.cleartext.removeListener('error', onError);
		        securePair.cleartext.removeListener('secureConnect', onSecureConnect);
		        securePair.cleartext.destroy();
		        securePair.encrypted.destroy();
		        reject(err);
		      };
		      const onReadable = () => {
		        // When there is handshake data on the encrypted stream of the secure pair,
		        // we wrap it into a `PRELOGIN` message and send it to the server.
		        //
		        // For each `PRELOGIN` message we sent we get back exactly one response message
		        // that contains the server's handshake response data.
		        const message = new _message.default({
		          type: _packet.TYPE.PRELOGIN,
		          resetConnection: false
		        });
		        let chunk;
		        while (chunk = securePair.encrypted.read()) {
		          message.write(chunk);
		        }
		        this.outgoingMessageStream.write(message);
		        message.end();
		        this.readMessage().then(async response => {
		          // Setup readable handler for the next round of handshaking.
		          // If we encounter a `secureConnect` on the cleartext side
		          // of the secure pair, the `readable` handler is cleared
		          // and no further handshake handling will happen.
		          securePair.encrypted.once('readable', onReadable);
		          for await (const data of response) {
		            // We feed the server's handshake response back into the
		            // encrypted end of the secure pair.
		            securePair.encrypted.write(data);
		          }
		        }).catch(onError);
		      };
		      securePair.cleartext.once('error', onError);
		      securePair.cleartext.once('secureConnect', onSecureConnect);
		      securePair.encrypted.once('readable', onReadable);
		    });
		  }

		  // TODO listen for 'drain' event when socket.write returns false.
		  // TODO implement incomplete request cancelation (2.2.1.6)
		  sendMessage(packetType, data, resetConnection) {
		    const message = new _message.default({
		      type: packetType,
		      resetConnection: resetConnection
		    });
		    message.end(data);
		    this.outgoingMessageStream.write(message);
		    return message;
		  }

		  /**
		   * Read the next incoming message from the socket.
		   */
		  async readMessage() {
		    const result = await this.incomingMessageIterator.next();
		    if (result.done) {
		      throw new Error('unexpected end of message stream');
		    }
		    return result.value;
		  }
		}
		exports$1.default = MessageIO;
		module.exports = MessageIO;
		
	} (messageIo, messageIo.exports));
	return messageIo.exports;
}

var tokenStreamParser = {};

var streamParser = {exports: {}};

var colmetadataTokenParser = {exports: {}};

var metadataParser = {exports: {}};

var collation = {};

var hasRequiredCollation;

function requireCollation () {
	if (hasRequiredCollation) return collation;
	hasRequiredCollation = 1;

	Object.defineProperty(collation, "__esModule", {
	  value: true
	});
	collation.codepageBySortId = collation.codepageByLanguageId = collation.Flags = collation.Collation = void 0;
	// http://technet.microsoft.com/en-us/library/aa176553(v=sql.80).aspx
	const codepageByLanguageId = collation.codepageByLanguageId = {
	  // Arabic_*
	  [0x0401]: 'CP1256',
	  // Chinese_Taiwan_Stroke_*
	  // Chinese_Traditional_Stroke_Count_*
	  // Chinese_Taiwan_Bopomofo_*
	  // Chinese_Traditional_Bopomofo_*
	  [0x0404]: 'CP950',
	  // Czech_*
	  [0x0405]: 'CP1250',
	  // Danish_Greenlandic_*
	  // Danish_Norwegian_*
	  [0x0406]: 'CP1252',
	  // Greek_*
	  [0x0408]: 'CP1253',
	  // Latin1_General_*
	  [0x0409]: 'CP1252',
	  // Traditional_Spanish_*
	  [0x040A]: 'CP1252',
	  // Finnish_Swedish_*
	  [0x040B]: 'CP1252',
	  // French_*
	  [0x040C]: 'CP1252',
	  // Hebrew_*
	  [0x040D]: 'CP1255',
	  // Hungarian_*
	  // Hungarian_Technical_*
	  [0x040E]: 'CP1250',
	  // Icelandic_*
	  [0x040F]: 'CP1252',
	  // Japanese_*
	  // Japanese_XJIS_*
	  // Japanese_Unicode_*
	  // Japanese_Bushu_Kakusu_*
	  [0x0411]: 'CP932',
	  // Korean_*
	  // Korean_Wansung_*
	  [0x0412]: 'CP949',
	  // Norwegian_*
	  [0x0414]: 'CP1252',
	  // Polish_*
	  [0x0415]: 'CP1250',
	  // Romansh_*
	  [0x0417]: 'CP1252',
	  // Romanian_*
	  [0x0418]: 'CP1250',
	  // Cyrillic_*
	  [0x0419]: 'CP1251',
	  // Croatian_*
	  [0x041A]: 'CP1250',
	  // Slovak_*
	  [0x041B]: 'CP1250',
	  // Albanian_*
	  [0x041C]: 'CP1250',
	  // Thai_*
	  [0x041E]: 'CP874',
	  // Turkish_*
	  [0x041F]: 'CP1254',
	  // Urdu_*
	  [0x0420]: 'CP1256',
	  // Ukrainian_*
	  [0x0422]: 'CP1251',
	  // Slovenian_*
	  [0x0424]: 'CP1250',
	  // Estonian_*
	  [0x0425]: 'CP1257',
	  // Latvian_*
	  [0x0426]: 'CP1257',
	  // Lithuanian_*
	  [0x0427]: 'CP1257',
	  // Persian_*
	  [0x0429]: 'CP1256',
	  // Vietnamese_*
	  [0x042A]: 'CP1258',
	  // Azeri_Latin_*
	  [0x042C]: 'CP1254',
	  // Upper_Sorbian_*
	  [0x042E]: 'CP1252',
	  // Macedonian_FYROM_*
	  [0x042F]: 'CP1251',
	  // Sami_Norway_*
	  [0x043B]: 'CP1252',
	  // Kazakh_*
	  [0x043F]: 'CP1251',
	  // Turkmen_*
	  [0x0442]: 'CP1250',
	  // Uzbek_Latin_*
	  [0x0443]: 'CP1254',
	  // Tatar_*
	  [0x0444]: 'CP1251',
	  // Welsh_*
	  [0x0452]: 'CP1252',
	  // Frisian_*
	  [0x0462]: 'CP1252',
	  // Bashkir_*
	  [0x046D]: 'CP1251',
	  // Mapudungan_*
	  [0x047A]: 'CP1252',
	  // Mohawk_*
	  [0x047C]: 'CP1252',
	  // Breton_*
	  [0x047E]: 'CP1252',
	  // Uighur_*
	  [0x0480]: 'CP1256',
	  // Corsican_*
	  [0x0483]: 'CP1252',
	  // Yakut_*
	  [0x0485]: 'CP1251',
	  // Dari_*
	  [0x048C]: 'CP1256',
	  // Chinese_PRC_*
	  // Chinese_Simplified_Pinyin_*
	  // Chinese_PRC_Stroke_*
	  // Chinese_Simplified_Stroke_Order_*
	  [0x0804]: 'CP936',
	  // Serbian_Latin_*
	  [0x081A]: 'CP1250',
	  // Azeri_Cyrillic_*
	  [0x082C]: 'CP1251',
	  // Sami_Sweden_Finland_*
	  [0x083B]: 'CP1252',
	  // Tamazight_*
	  [0x085F]: 'CP1252',
	  // Chinese_Hong_Kong_Stroke_*
	  [0x0C04]: 'CP950',
	  // Modern_Spanish_*
	  [0x0C0A]: 'CP1252',
	  // Serbian_Cyrillic_*
	  [0x0C1A]: 'CP1251',
	  // Chinese_Traditional_Pinyin_*
	  // Chinese_Traditional_Stroke_Order_*
	  [0x1404]: 'CP950',
	  // Bosnian_Latin_*
	  [0x141A]: 'CP1250',
	  // Bosnian_Cyrillic_*
	  [0x201A]: 'CP1251',
	  // German
	  // German_PhoneBook_*
	  [0x0407]: 'CP1252',
	  // Georgian_Modern_Sort_*
	  [0x0437]: 'CP1252'
	};
	const codepageBySortId = collation.codepageBySortId = {
	  [30]: 'CP437',
	  // SQL_Latin1_General_CP437_BIN
	  [31]: 'CP437',
	  // SQL_Latin1_General_CP437_CS_AS
	  [32]: 'CP437',
	  // SQL_Latin1_General_CP437_CI_AS
	  [33]: 'CP437',
	  // SQL_Latin1_General_Pref_CP437_CI_AS
	  [34]: 'CP437',
	  // SQL_Latin1_General_CP437_CI_AI
	  [40]: 'CP850',
	  // SQL_Latin1_General_CP850_BIN
	  [41]: 'CP850',
	  // SQL_Latin1_General_CP850_CS_AS
	  [42]: 'CP850',
	  // SQL_Latin1_General_CP850_CI_AS
	  [43]: 'CP850',
	  // SQL_Latin1_General_Pref_CP850_CI_AS
	  [44]: 'CP850',
	  // SQL_Latin1_General_CP850_CI_AI
	  [49]: 'CP850',
	  // SQL_1xCompat_CP850_CI_AS
	  [51]: 'CP1252',
	  // SQL_Latin1_General_Cp1_CS_AS_KI_WI
	  [52]: 'CP1252',
	  // SQL_Latin1_General_Cp1_CI_AS_KI_WI
	  [53]: 'CP1252',
	  // SQL_Latin1_General_Pref_Cp1_CI_AS_KI_WI
	  [54]: 'CP1252',
	  // SQL_Latin1_General_Cp1_CI_AI_KI_WI
	  [55]: 'CP850',
	  // SQL_AltDiction_CP850_CS_AS
	  [56]: 'CP850',
	  // SQL_AltDiction_Pref_CP850_CI_AS
	  [57]: 'CP850',
	  // SQL_AltDiction_CP850_CI_AI
	  [58]: 'CP850',
	  // SQL_Scandinavian_Pref_CP850_CI_AS
	  [59]: 'CP850',
	  // SQL_Scandinavian_CP850_CS_AS
	  [60]: 'CP850',
	  // SQL_Scandinavian_CP850_CI_AS
	  [61]: 'CP850',
	  // SQL_AltDiction_CP850_CI_AS
	  [80]: 'CP1250',
	  // SQL_Latin1_General_1250_BIN
	  [81]: 'CP1250',
	  // SQL_Latin1_General_CP1250_CS_AS
	  [82]: 'CP1250',
	  // SQL_Latin1_General_Cp1250_CI_AS_KI_WI
	  [83]: 'CP1250',
	  // SQL_Czech_Cp1250_CS_AS_KI_WI
	  [84]: 'CP1250',
	  // SQL_Czech_Cp1250_CI_AS_KI_WI
	  [85]: 'CP1250',
	  // SQL_Hungarian_Cp1250_CS_AS_KI_WI
	  [86]: 'CP1250',
	  // SQL_Hungarian_Cp1250_CI_AS_KI_WI
	  [87]: 'CP1250',
	  // SQL_Polish_Cp1250_CS_AS_KI_WI
	  [88]: 'CP1250',
	  // SQL_Polish_Cp1250_CI_AS_KI_WI
	  [89]: 'CP1250',
	  // SQL_Romanian_Cp1250_CS_AS_KI_WI
	  [90]: 'CP1250',
	  // SQL_Romanian_Cp1250_CI_AS_KI_WI
	  [91]: 'CP1250',
	  // SQL_Croatian_Cp1250_CS_AS_KI_WI
	  [92]: 'CP1250',
	  // SQL_Croatian_Cp1250_CI_AS_KI_WI
	  [93]: 'CP1250',
	  // SQL_Slovak_Cp1250_CS_AS_KI_WI
	  [94]: 'CP1250',
	  // SQL_Slovak_Cp1250_CI_AS_KI_WI
	  [95]: 'CP1250',
	  // SQL_Slovenian_Cp1250_CS_AS_KI_WI
	  [96]: 'CP1250',
	  // SQL_Slovenian_Cp1250_CI_AS_KI_WI
	  [104]: 'CP1251',
	  // SQL_Latin1_General_1251_BIN
	  [105]: 'CP1251',
	  // SQL_Latin1_General_CP1251_CS_AS
	  [106]: 'CP1251',
	  // SQL_Latin1_General_CP1251_CI_AS
	  [107]: 'CP1251',
	  // SQL_Ukrainian_Cp1251_CS_AS_KI_WI
	  [108]: 'CP1251',
	  // SQL_Ukrainian_Cp1251_CI_AS_KI_WI
	  [112]: 'CP1253',
	  // SQL_Latin1_General_1253_BIN
	  [113]: 'CP1253',
	  // SQL_Latin1_General_CP1253_CS_AS
	  [114]: 'CP1253',
	  // SQL_Latin1_General_CP1253_CI_AS
	  [120]: 'CP1253',
	  // SQL_MixDiction_CP1253_CS_AS
	  [121]: 'CP1253',
	  // SQL_AltDiction_CP1253_CS_AS
	  [122]: 'CP1253',
	  // SQL_AltDiction2_CP1253_CS_AS
	  [124]: 'CP1253',
	  // SQL_Latin1_General_CP1253_CI_AI
	  [128]: 'CP1254',
	  // SQL_Latin1_General_1254_BIN
	  [129]: 'CP1254',
	  // SQL_Latin1_General_Cp1254_CS_AS_KI_WI
	  [130]: 'CP1254',
	  // SQL_Latin1_General_Cp1254_CI_AS_KI_WI
	  [136]: 'CP1255',
	  // SQL_Latin1_General_1255_BIN
	  [137]: 'CP1255',
	  // SQL_Latin1_General_CP1255_CS_AS
	  [138]: 'CP1255',
	  // SQL_Latin1_General_CP1255_CI_AS
	  [144]: 'CP1256',
	  // SQL_Latin1_General_1256_BIN
	  [145]: 'CP1256',
	  // SQL_Latin1_General_CP1256_CS_AS
	  [146]: 'CP1256',
	  // SQL_Latin1_General_CP1256_CI_AS
	  [152]: 'CP1257',
	  // SQL_Latin1_General_1257_BIN
	  [153]: 'CP1257',
	  // SQL_Latin1_General_CP1257_CS_AS
	  [154]: 'CP1257',
	  // SQL_Latin1_General_CP1257_CI_AS
	  [155]: 'CP1257',
	  // SQL_Estonian_Cp1257_CS_AS_KI_WI
	  [156]: 'CP1257',
	  // SQL_Estonian_Cp1257_CI_AS_KI_WI
	  [157]: 'CP1257',
	  // SQL_Latvian_Cp1257_CS_AS_KI_WI
	  [158]: 'CP1257',
	  // SQL_Latvian_Cp1257_CI_AS_KI_WI
	  [159]: 'CP1257',
	  // SQL_Lithuanian_Cp1257_CS_AS_KI_WI
	  [160]: 'CP1257',
	  // SQL_Lithuanian_Cp1257_CI_AS_KI_WI
	  [183]: 'CP1252',
	  // SQL_Danish_Pref_Cp1_CI_AS_KI_WI
	  [184]: 'CP1252',
	  // SQL_SwedishPhone_Pref_Cp1_CI_AS_KI_WI
	  [185]: 'CP1252',
	  // SQL_SwedishStd_Pref_Cp1_CI_AS_KI_WI
	  [186]: 'CP1252' // SQL_Icelandic_Pref_Cp1_CI_AS_KI_WI
	};
	const Flags = collation.Flags = {
	  IGNORE_CASE: 1 << 0,
	  IGNORE_ACCENT: 1 << 1,
	  IGNORE_KANA: 1 << 2,
	  IGNORE_WIDTH: 1 << 3,
	  BINARY: 1 << 4,
	  BINARY2: 1 << 5,
	  UTF8: 1 << 6
	};
	class Collation {
	  static fromBuffer(buffer, offset = 0) {
	    let lcid = (buffer[offset + 2] & 0x0F) << 16;
	    lcid |= buffer[offset + 1] << 8;
	    lcid |= buffer[offset + 0];
	    let flags = (buffer[offset + 3] & 0x0F) << 4;
	    flags |= (buffer[offset + 2] & 0xF0) >>> 4;
	    const version = (buffer[offset + 3] & 0xF0) >>> 4;
	    const sortId = buffer[offset + 4];
	    return new this(lcid, flags, version, sortId);
	  }
	  constructor(lcid, flags, version, sortId) {
	    this.buffer = undefined;
	    this.lcid = lcid;
	    this.flags = flags;
	    this.version = version;
	    this.sortId = sortId;
	    if (this.flags & Flags.UTF8) {
	      this.codepage = 'utf-8';
	    } else if (this.sortId) {
	      this.codepage = codepageBySortId[this.sortId];
	    } else {
	      // The last 16 bits of the LCID are the language id.
	      // The first 4 bits define additional sort orders.
	      const languageId = this.lcid & 0xFFFF;
	      this.codepage = codepageByLanguageId[languageId];
	    }
	  }
	  toBuffer() {
	    if (this.buffer) {
	      return this.buffer;
	    }
	    this.buffer = Buffer.alloc(5);
	    this.buffer[0] = this.lcid & 0xFF;
	    this.buffer[1] = this.lcid >>> 8 & 0xFF;
	    this.buffer[2] = this.lcid >>> 16 & 0x0F | (this.flags & 0x0F) << 4;
	    this.buffer[3] = (this.flags & 0xF0) >>> 4 | (this.version & 0x0F) << 4;
	    this.buffer[4] = this.sortId & 0xFF;
	    return this.buffer;
	  }
	}
	collation.Collation = Collation;
	
	return collation;
}

var dataType = {};

var _null = {exports: {}};

var hasRequired_null;

function require_null () {
	if (hasRequired_null) return _null.exports;
	hasRequired_null = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const Null = {
		  id: 0x1F,
		  type: 'NULL',
		  name: 'Null',
		  declaration() {
		    throw new Error('not implemented');
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = Null;
		module.exports = Null;
		
	} (_null, _null.exports));
	return _null.exports;
}

var tinyint = {exports: {}};

var intn = {exports: {}};

var hasRequiredIntn;

function requireIntn () {
	if (hasRequiredIntn) return intn.exports;
	hasRequiredIntn = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const IntN = {
		  id: 0x26,
		  type: 'INTN',
		  name: 'IntN',
		  declaration() {
		    throw new Error('not implemented');
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = IntN;
		module.exports = IntN;
		
	} (intn, intn.exports));
	return intn.exports;
}

var hasRequiredTinyint;

function requireTinyint () {
	if (hasRequiredTinyint) return tinyint.exports;
	hasRequiredTinyint = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _intn = _interopRequireDefault(requireIntn());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const DATA_LENGTH = Buffer.from([0x01]);
		const NULL_LENGTH = Buffer.from([0x00]);
		const TinyInt = {
		  id: 0x30,
		  type: 'INT1',
		  name: 'TinyInt',
		  declaration: function () {
		    return 'tinyint';
		  },
		  generateTypeInfo() {
		    return Buffer.from([_intn.default.id, 0x01]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const buffer = Buffer.alloc(1);
		    buffer.writeUInt8(Number(parameter.value), 0);
		    yield buffer;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'number') {
		      value = Number(value);
		    }
		    if (isNaN(value)) {
		      throw new TypeError('Invalid number.');
		    }
		    if (value < 0 || value > 255) {
		      throw new TypeError('Value must be between 0 and 255, inclusive.');
		    }
		    return value | 0;
		  }
		};
		exports$1.default = TinyInt;
		module.exports = TinyInt;
		
	} (tinyint, tinyint.exports));
	return tinyint.exports;
}

var bit = {exports: {}};

var bitn = {exports: {}};

var hasRequiredBitn;

function requireBitn () {
	if (hasRequiredBitn) return bitn.exports;
	hasRequiredBitn = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const BitN = {
		  id: 0x68,
		  type: 'BITN',
		  name: 'BitN',
		  declaration() {
		    throw new Error('not implemented');
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  *generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = BitN;
		module.exports = BitN;
		
	} (bitn, bitn.exports));
	return bitn.exports;
}

var hasRequiredBit;

function requireBit () {
	if (hasRequiredBit) return bit.exports;
	hasRequiredBit = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _bitn = _interopRequireDefault(requireBitn());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const DATA_LENGTH = Buffer.from([0x01]);
		const NULL_LENGTH = Buffer.from([0x00]);
		const Bit = {
		  id: 0x32,
		  type: 'BIT',
		  name: 'Bit',
		  declaration: function () {
		    return 'bit';
		  },
		  generateTypeInfo() {
		    return Buffer.from([_bitn.default.id, 0x01]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    yield parameter.value ? Buffer.from([0x01]) : Buffer.from([0x00]);
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (value) {
		      return true;
		    } else {
		      return false;
		    }
		  }
		};
		exports$1.default = Bit;
		module.exports = Bit;
		
	} (bit, bit.exports));
	return bit.exports;
}

var smallint = {exports: {}};

var hasRequiredSmallint;

function requireSmallint () {
	if (hasRequiredSmallint) return smallint.exports;
	hasRequiredSmallint = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _intn = _interopRequireDefault(requireIntn());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const DATA_LENGTH = Buffer.from([0x02]);
		const NULL_LENGTH = Buffer.from([0x00]);
		const SmallInt = {
		  id: 0x34,
		  type: 'INT2',
		  name: 'SmallInt',
		  declaration: function () {
		    return 'smallint';
		  },
		  generateTypeInfo() {
		    return Buffer.from([_intn.default.id, 0x02]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const buffer = Buffer.alloc(2);
		    buffer.writeInt16LE(Number(parameter.value), 0);
		    yield buffer;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'number') {
		      value = Number(value);
		    }
		    if (isNaN(value)) {
		      throw new TypeError('Invalid number.');
		    }
		    if (value < -32768 || value > 32767) {
		      throw new TypeError('Value must be between -32768 and 32767, inclusive.');
		    }
		    return value | 0;
		  }
		};
		exports$1.default = SmallInt;
		module.exports = SmallInt;
		
	} (smallint, smallint.exports));
	return smallint.exports;
}

var int = {exports: {}};

var hasRequiredInt;

function requireInt () {
	if (hasRequiredInt) return int.exports;
	hasRequiredInt = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _intn = _interopRequireDefault(requireIntn());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const NULL_LENGTH = Buffer.from([0x00]);
		const DATA_LENGTH = Buffer.from([0x04]);
		const Int = {
		  id: 0x38,
		  type: 'INT4',
		  name: 'Int',
		  declaration: function () {
		    return 'int';
		  },
		  generateTypeInfo() {
		    return Buffer.from([_intn.default.id, 0x04]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const buffer = Buffer.alloc(4);
		    buffer.writeInt32LE(Number(parameter.value), 0);
		    yield buffer;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'number') {
		      value = Number(value);
		    }
		    if (isNaN(value)) {
		      throw new TypeError('Invalid number.');
		    }
		    if (value < -2147483648 || value > 2147483647) {
		      throw new TypeError('Value must be between -2147483648 and 2147483647, inclusive.');
		    }
		    return value | 0;
		  }
		};
		exports$1.default = Int;
		module.exports = Int;
		
	} (int, int.exports));
	return int.exports;
}

var smalldatetime = {exports: {}};

var datetimen = {exports: {}};

var hasRequiredDatetimen;

function requireDatetimen () {
	if (hasRequiredDatetimen) return datetimen.exports;
	hasRequiredDatetimen = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const DateTimeN = {
		  id: 0x6F,
		  type: 'DATETIMN',
		  name: 'DateTimeN',
		  declaration() {
		    throw new Error('not implemented');
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = DateTimeN;
		module.exports = DateTimeN;
		
	} (datetimen, datetimen.exports));
	return datetimen.exports;
}

var hasRequiredSmalldatetime;

function requireSmalldatetime () {
	if (hasRequiredSmalldatetime) return smalldatetime.exports;
	hasRequiredSmalldatetime = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _datetimen = _interopRequireDefault(requireDatetimen());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const EPOCH_DATE = new Date(1900, 0, 1);
		const UTC_EPOCH_DATE = new Date(Date.UTC(1900, 0, 1));
		const DATA_LENGTH = Buffer.from([0x04]);
		const NULL_LENGTH = Buffer.from([0x00]);
		const SmallDateTime = {
		  id: 0x3A,
		  type: 'DATETIM4',
		  name: 'SmallDateTime',
		  declaration: function () {
		    return 'smalldatetime';
		  },
		  generateTypeInfo() {
		    return Buffer.from([_datetimen.default.id, 0x04]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  generateParameterData: function* (parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const buffer = Buffer.alloc(4);
		    let days, dstDiff, minutes;
		    if (options.useUTC) {
		      days = Math.floor((parameter.value.getTime() - UTC_EPOCH_DATE.getTime()) / (1000 * 60 * 60 * 24));
		      minutes = parameter.value.getUTCHours() * 60 + parameter.value.getUTCMinutes();
		    } else {
		      dstDiff = -(parameter.value.getTimezoneOffset() - EPOCH_DATE.getTimezoneOffset()) * 60 * 1000;
		      days = Math.floor((parameter.value.getTime() - EPOCH_DATE.getTime() + dstDiff) / (1000 * 60 * 60 * 24));
		      minutes = parameter.value.getHours() * 60 + parameter.value.getMinutes();
		    }
		    buffer.writeUInt16LE(days, 0);
		    buffer.writeUInt16LE(minutes, 2);
		    yield buffer;
		  },
		  validate: function (value, collation, options) {
		    if (value == null) {
		      return null;
		    }
		    if (!(value instanceof Date)) {
		      value = new Date(Date.parse(value));
		    }
		    value = value;
		    let year, month, date;
		    if (options && options.useUTC) {
		      year = value.getUTCFullYear();
		      month = value.getUTCMonth();
		      date = value.getUTCDate();
		    } else {
		      year = value.getFullYear();
		      month = value.getMonth();
		      date = value.getDate();
		    }
		    if (year < 1900 || year > 2079) {
		      throw new TypeError('Out of range.');
		    }
		    if (year === 2079) {
		      // Month is 0-indexed, i.e. Jan = 0, Dec = 11
		      // See: https://learn.microsoft.com/en-us/sql/t-sql/data-types/smalldatetime-transact-sql?view=sql-server-ver16
		      if (month > 5 || month === 5 && date > 6) {
		        throw new TypeError('Out of range.');
		      }
		    }
		    if (isNaN(value)) {
		      throw new TypeError('Invalid date.');
		    }
		    return value;
		  }
		};
		exports$1.default = SmallDateTime;
		module.exports = SmallDateTime;
		
	} (smalldatetime, smalldatetime.exports));
	return smalldatetime.exports;
}

var real = {exports: {}};

var floatn = {exports: {}};

var hasRequiredFloatn;

function requireFloatn () {
	if (hasRequiredFloatn) return floatn.exports;
	hasRequiredFloatn = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const FloatN = {
		  id: 0x6D,
		  type: 'FLTN',
		  name: 'FloatN',
		  declaration() {
		    throw new Error('not implemented');
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = FloatN;
		module.exports = FloatN;
		
	} (floatn, floatn.exports));
	return floatn.exports;
}

var hasRequiredReal;

function requireReal () {
	if (hasRequiredReal) return real.exports;
	hasRequiredReal = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _floatn = _interopRequireDefault(requireFloatn());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const NULL_LENGTH = Buffer.from([0x00]);
		const DATA_LENGTH = Buffer.from([0x04]);
		const Real = {
		  id: 0x3B,
		  type: 'FLT4',
		  name: 'Real',
		  declaration: function () {
		    return 'real';
		  },
		  generateTypeInfo() {
		    return Buffer.from([_floatn.default.id, 0x04]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const buffer = Buffer.alloc(4);
		    buffer.writeFloatLE(parseFloat(parameter.value), 0);
		    yield buffer;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    value = parseFloat(value);
		    if (isNaN(value)) {
		      throw new TypeError('Invalid number.');
		    }
		    return value;
		  }
		};
		exports$1.default = Real;
		module.exports = Real;
		
	} (real, real.exports));
	return real.exports;
}

var money = {exports: {}};

var moneyn = {exports: {}};

var hasRequiredMoneyn;

function requireMoneyn () {
	if (hasRequiredMoneyn) return moneyn.exports;
	hasRequiredMoneyn = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const MoneyN = {
		  id: 0x6E,
		  type: 'MONEYN',
		  name: 'MoneyN',
		  declaration() {
		    throw new Error('not implemented');
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = MoneyN;
		module.exports = MoneyN;
		
	} (moneyn, moneyn.exports));
	return moneyn.exports;
}

var hasRequiredMoney;

function requireMoney () {
	if (hasRequiredMoney) return money.exports;
	hasRequiredMoney = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _moneyn = _interopRequireDefault(requireMoneyn());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
		const SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
		const NULL_LENGTH = Buffer.from([0x00]);
		const DATA_LENGTH = Buffer.from([0x08]);
		const Money = {
		  id: 0x3C,
		  type: 'MONEY',
		  name: 'Money',
		  declaration: function () {
		    return 'money';
		  },
		  generateTypeInfo: function () {
		    return Buffer.from([_moneyn.default.id, 0x08]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const value = parameter.value * 10000;
		    const buffer = Buffer.alloc(8);
		    buffer.writeInt32LE(Math.floor(value * SHIFT_RIGHT_32), 0);
		    buffer.writeInt32LE(value & -1, 4);
		    yield buffer;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    value = parseFloat(value);
		    if (isNaN(value)) {
		      throw new TypeError('Invalid number.');
		    }
		    // money -922337203685477.5808 to 922337203685477.5807
		    // in javascript -922337203685477.5808 === -922337203685477.6
		    //                922337203685477.5807 === 922337203685477.6
		    // javascript number doesn't have enough precision.
		    if (value < -922337203685477.6 || value > 922337203685477.6) {
		      throw new TypeError('Value must be between -922337203685477.5808 and 922337203685477.5807, inclusive.');
		    }
		    return value;
		  }
		};
		exports$1.default = Money;
		module.exports = Money;
		
	} (money, money.exports));
	return money.exports;
}

var datetime = {exports: {}};

//! @version @js-joda/core - 5.6.5
//! @copyright (c) 2015-present, Philipp Thrwchter, Pattrick Hper & js-joda contributors
//! @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
//! @license BSD-3-Clause (see LICENSE in the root directory of this source tree)

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

function createErrorType(name, init, superErrorClass) {
  if (superErrorClass === void 0) {
    superErrorClass = Error;
  }
  function JsJodaException(message) {
    if (!Error.captureStackTrace) {
      this.stack = new Error().stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
    this.message = message;
    init && init.apply(this, arguments);
    this.toString = function () {
      return this.name + ": " + this.message;
    };
  }
  JsJodaException.prototype = Object.create(superErrorClass.prototype);
  JsJodaException.prototype.name = name;
  JsJodaException.prototype.constructor = JsJodaException;
  return JsJodaException;
}
var DateTimeException = createErrorType('DateTimeException', messageWithCause);
var DateTimeParseException = createErrorType('DateTimeParseException', messageForDateTimeParseException);
var UnsupportedTemporalTypeException = createErrorType('UnsupportedTemporalTypeException', null, DateTimeException);
var ArithmeticException = createErrorType('ArithmeticException');
var IllegalArgumentException = createErrorType('IllegalArgumentException');
var IllegalStateException = createErrorType('IllegalStateException');
var NullPointerException = createErrorType('NullPointerException');
function messageWithCause(message, cause) {
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
}
function messageForDateTimeParseException(message, text, index, cause) {
  if (text === void 0) {
    text = '';
  }
  if (index === void 0) {
    index = 0;
  }
  if (cause === void 0) {
    cause = null;
  }
  var msg = message || this.name;
  msg += ": " + text + ", at index: " + index;
  if (cause !== null && cause instanceof Error) {
    msg += "\n-------\nCaused by: " + cause.stack + "\n-------\n";
  }
  this.message = msg;
  this.parsedString = function () {
    return text;
  };
  this.errorIndex = function () {
    return index;
  };
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
function assert(assertion, msg, error) {
  if (!assertion) {
    if (error) {
      throw new error(msg);
    } else {
      throw new Error(msg);
    }
  }
}
function requireNonNull(value, parameterName) {
  if (value == null) {
    throw new NullPointerException(parameterName + " must not be null");
  }
  return value;
}
function requireInstance(value, _class, parameterName) {
  if (!(value instanceof _class)) {
    throw new IllegalArgumentException(parameterName + " must be an instance of " + (_class.name ? _class.name : _class) + (value && value.constructor && value.constructor.name ? ", but is " + value.constructor.name : ''));
  }
  return value;
}
function abstractMethodFail(methodName) {
  throw new TypeError("abstract method \"" + methodName + "\" is not implemented");
}

var assert$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    abstractMethodFail: abstractMethodFail,
    assert: assert,
    requireInstance: requireInstance,
    requireNonNull: requireNonNull
});

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var MAX_SAFE_INTEGER = 9007199254740991;
var MIN_SAFE_INTEGER = -9007199254740991;
var MathUtil = function () {
  function MathUtil() {}
  MathUtil.intDiv = function intDiv(x, y) {
    var r = x / y;
    r = MathUtil.roundDown(r);
    return MathUtil.safeZero(r);
  };
  MathUtil.intMod = function intMod(x, y) {
    var r = x - MathUtil.intDiv(x, y) * y;
    r = MathUtil.roundDown(r);
    return MathUtil.safeZero(r);
  };
  MathUtil.roundDown = function roundDown(r) {
    if (r < 0) {
      return Math.ceil(r);
    } else {
      return Math.floor(r);
    }
  };
  MathUtil.floorDiv = function floorDiv(x, y) {
    var r = Math.floor(x / y);
    return MathUtil.safeZero(r);
  };
  MathUtil.floorMod = function floorMod(x, y) {
    var r = x - MathUtil.floorDiv(x, y) * y;
    return MathUtil.safeZero(r);
  };
  MathUtil.safeAdd = function safeAdd(x, y) {
    MathUtil.verifyInt(x);
    MathUtil.verifyInt(y);
    if (x === 0) {
      return MathUtil.safeZero(y);
    }
    if (y === 0) {
      return MathUtil.safeZero(x);
    }
    var r = MathUtil.safeToInt(x + y);
    if (r === x || r === y) {
      throw new ArithmeticException('Invalid addition beyond MAX_SAFE_INTEGER!');
    }
    return r;
  };
  MathUtil.safeSubtract = function safeSubtract(x, y) {
    MathUtil.verifyInt(x);
    MathUtil.verifyInt(y);
    if (x === 0 && y === 0) {
      return 0;
    } else if (x === 0) {
      return MathUtil.safeZero(-1 * y);
    } else if (y === 0) {
      return MathUtil.safeZero(x);
    }
    return MathUtil.safeToInt(x - y);
  };
  MathUtil.safeMultiply = function safeMultiply(x, y) {
    MathUtil.verifyInt(x);
    MathUtil.verifyInt(y);
    if (x === 1) {
      return MathUtil.safeZero(y);
    }
    if (y === 1) {
      return MathUtil.safeZero(x);
    }
    if (x === 0 || y === 0) {
      return 0;
    }
    var r = MathUtil.safeToInt(x * y);
    if (r / y !== x || x === MIN_SAFE_INTEGER && y === -1 || y === MIN_SAFE_INTEGER && x === -1) {
      throw new ArithmeticException("Multiplication overflows: " + x + " * " + y);
    }
    return r;
  };
  MathUtil.parseInt = function (_parseInt) {
    function parseInt(_x) {
      return _parseInt.apply(this, arguments);
    }
    parseInt.toString = function () {
      return _parseInt.toString();
    };
    return parseInt;
  }(function (value) {
    var r = parseInt(value);
    return MathUtil.safeToInt(r);
  });
  MathUtil.safeToInt = function safeToInt(value) {
    MathUtil.verifyInt(value);
    return MathUtil.safeZero(value);
  };
  MathUtil.verifyInt = function verifyInt(value) {
    if (value == null) {
      throw new ArithmeticException("Invalid value: '" + value + "', using null or undefined as argument");
    }
    if (isNaN(value)) {
      throw new ArithmeticException('Invalid int value, using NaN as argument');
    }
    if (Number.isInteger) {
      if (!Number.isInteger(Number(value))) {
        throw new ArithmeticException("Invalid value: '" + value + "' is a float");
      }
    } else if (value % 1 !== 0) {
      throw new ArithmeticException("Invalid value: '" + value + "' is a float");
    }
    if (value > MAX_SAFE_INTEGER || value < MIN_SAFE_INTEGER) {
      throw new ArithmeticException("Calculation overflows an int: " + value);
    }
  };
  MathUtil.safeZero = function safeZero(value) {
    return value === 0 ? 0 : +value;
  };
  MathUtil.compareNumbers = function compareNumbers(a, b) {
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  };
  MathUtil.smi = function smi(int) {
    return int >>> 1 & 0x40000000 | int & 0xBFFFFFFF;
  };
  MathUtil.hash = function hash(number) {
    if (number !== number || number === Infinity) {
      return 0;
    }
    var result = number;
    while (number > 0xFFFFFFFF) {
      number /= 0xFFFFFFFF;
      result ^= number;
    }
    return MathUtil.smi(result);
  };
  MathUtil.hashCode = function hashCode() {
    var result = 17;
    for (var _len = arguments.length, numbers = new Array(_len), _key = 0; _key < _len; _key++) {
      numbers[_key] = arguments[_key];
    }
    for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {
      var n = _numbers[_i];
      result = (result << 5) - result + MathUtil.hash(n);
    }
    return MathUtil.hash(result);
  };
  return MathUtil;
}();
MathUtil.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
MathUtil.MIN_SAFE_INTEGER = MIN_SAFE_INTEGER;

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var Enum = function () {
  function Enum(name) {
    this._name = name;
  }
  var _proto = Enum.prototype;
  _proto.equals = function equals(other) {
    return this === other;
  };
  _proto.toString = function toString() {
    return this._name;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Enum;
}();

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var TemporalAmount = function () {
  function TemporalAmount() {}
  var _proto = TemporalAmount.prototype;
  _proto.get = function get(unit) {
    abstractMethodFail('get');
  };
  _proto.units = function units() {
    abstractMethodFail('units');
  };
  _proto.addTo = function addTo(temporal) {
    abstractMethodFail('addTo');
  };
  _proto.subtractFrom = function subtractFrom(temporal) {
    abstractMethodFail('subtractFrom');
  };
  return TemporalAmount;
}();
if (typeof Symbol !== 'undefined' && Symbol.toPrimitive) {
  TemporalAmount.prototype[Symbol.toPrimitive] = function (hint) {
    if (hint !== 'number') {
      return this.toString();
    }
    throw new TypeError('A conversion from TemporalAmount to a number is not allowed. ' + 'To compare use the methods .equals(), .compareTo(), .isBefore() ' + 'or one that is more suitable to your use case.');
  };
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var TemporalUnit = function () {
  function TemporalUnit() {}
  var _proto = TemporalUnit.prototype;
  _proto.duration = function duration() {
    abstractMethodFail('duration');
  };
  _proto.isDurationEstimated = function isDurationEstimated() {
    abstractMethodFail('isDurationEstimated');
  };
  _proto.isDateBased = function isDateBased() {
    abstractMethodFail('isDateBased');
  };
  _proto.isTimeBased = function isTimeBased() {
    abstractMethodFail('isTimeBased');
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    abstractMethodFail('isSupportedBy');
  };
  _proto.addTo = function addTo(dateTime, periodToAdd) {
    abstractMethodFail('addTo');
  };
  _proto.between = function between(temporal1, temporal2) {
    abstractMethodFail('between');
  };
  return TemporalUnit;
}();

var Duration = function (_TemporalAmount) {
  _inheritsLoose(Duration, _TemporalAmount);
  function Duration(seconds, nanos) {
    var _this;
    _this = _TemporalAmount.call(this) || this;
    _this._seconds = MathUtil.safeToInt(seconds);
    _this._nanos = MathUtil.safeToInt(nanos);
    return _this;
  }
  Duration.ofDays = function ofDays(days) {
    return Duration._create(MathUtil.safeMultiply(days, LocalTime.SECONDS_PER_DAY), 0);
  };
  Duration.ofHours = function ofHours(hours) {
    return Duration._create(MathUtil.safeMultiply(hours, LocalTime.SECONDS_PER_HOUR), 0);
  };
  Duration.ofMinutes = function ofMinutes(minutes) {
    return Duration._create(MathUtil.safeMultiply(minutes, LocalTime.SECONDS_PER_MINUTE), 0);
  };
  Duration.ofSeconds = function ofSeconds(seconds, nanoAdjustment) {
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }
    var secs = MathUtil.safeAdd(seconds, MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND));
    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    return Duration._create(secs, nos);
  };
  Duration.ofMillis = function ofMillis(millis) {
    var secs = MathUtil.intDiv(millis, 1000);
    var mos = MathUtil.intMod(millis, 1000);
    if (mos < 0) {
      mos += 1000;
      secs--;
    }
    return Duration._create(secs, mos * 1000000);
  };
  Duration.ofNanos = function ofNanos(nanos) {
    var secs = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_SECOND);
    if (nos < 0) {
      nos += LocalTime.NANOS_PER_SECOND;
      secs--;
    }
    return this._create(secs, nos);
  };
  Duration.of = function of(amount, unit) {
    return Duration.ZERO.plus(amount, unit);
  };
  Duration.from = function from(amount) {
    requireNonNull(amount, 'amount');
    requireInstance(amount, TemporalAmount);
    var duration = Duration.ZERO;
    amount.units().forEach(function (unit) {
      duration = duration.plus(amount.get(unit), unit);
    });
    return duration;
  };
  Duration.between = function between(startInclusive, endExclusive) {
    requireNonNull(startInclusive, 'startInclusive');
    requireNonNull(endExclusive, 'endExclusive');
    var secs = startInclusive.until(endExclusive, ChronoUnit.SECONDS);
    var nanos = 0;
    if (startInclusive.isSupported(ChronoField.NANO_OF_SECOND) && endExclusive.isSupported(ChronoField.NANO_OF_SECOND)) {
      try {
        var startNos = startInclusive.getLong(ChronoField.NANO_OF_SECOND);
        nanos = endExclusive.getLong(ChronoField.NANO_OF_SECOND) - startNos;
        if (secs > 0 && nanos < 0) {
          nanos += LocalTime.NANOS_PER_SECOND;
        } else if (secs < 0 && nanos > 0) {
          nanos -= LocalTime.NANOS_PER_SECOND;
        } else if (secs === 0 && nanos !== 0) {
          var adjustedEnd = endExclusive.with(ChronoField.NANO_OF_SECOND, startNos);
          secs = startInclusive.until(adjustedEnd, ChronoUnit.SECONDS);
        }
      } catch (e) {}
    }
    return this.ofSeconds(secs, nanos);
  };
  Duration.parse = function parse(text) {
    requireNonNull(text, 'text');
    var PATTERN = new RegExp('([-+]?)P(?:([-+]?[0-9]+)D)?(T(?:([-+]?[0-9]+)H)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)(?:[.,]([0-9]{0,9}))?S)?)?', 'i');
    var matches = PATTERN.exec(text);
    if (matches !== null) {
      if ('T' === matches[3] === false) {
        var negate = '-' === matches[1];
        var dayMatch = matches[2];
        var hourMatch = matches[4];
        var minuteMatch = matches[5];
        var secondMatch = matches[6];
        var fractionMatch = matches[7];
        if (dayMatch != null || hourMatch != null || minuteMatch != null || secondMatch != null) {
          var daysAsSecs = Duration._parseNumber(text, dayMatch, LocalTime.SECONDS_PER_DAY, 'days');
          var hoursAsSecs = Duration._parseNumber(text, hourMatch, LocalTime.SECONDS_PER_HOUR, 'hours');
          var minsAsSecs = Duration._parseNumber(text, minuteMatch, LocalTime.SECONDS_PER_MINUTE, 'minutes');
          var seconds = Duration._parseNumber(text, secondMatch, 1, 'seconds');
          var negativeSecs = secondMatch != null && secondMatch.charAt(0) === '-';
          var nanos = Duration._parseFraction(text, fractionMatch, negativeSecs ? -1 : 1);
          try {
            return Duration._create(negate, daysAsSecs, hoursAsSecs, minsAsSecs, seconds, nanos);
          } catch (ex) {
            throw new DateTimeParseException('Text cannot be parsed to a Duration: overflow', text, 0, ex);
          }
        }
      }
    }
    throw new DateTimeParseException('Text cannot be parsed to a Duration', text, 0);
  };
  Duration._parseNumber = function _parseNumber(text, parsed, multiplier, errorText) {
    if (parsed == null) {
      return 0;
    }
    try {
      if (parsed[0] === '+') {
        parsed = parsed.substring(1);
      }
      return MathUtil.safeMultiply(parseFloat(parsed), multiplier);
    } catch (ex) {
      throw new DateTimeParseException("Text cannot be parsed to a Duration: " + errorText, text, 0, ex);
    }
  };
  Duration._parseFraction = function _parseFraction(text, parsed, negate) {
    if (parsed == null || parsed.length === 0) {
      return 0;
    }
    parsed = (parsed + "000000000").substring(0, 9);
    return parseFloat(parsed) * negate;
  };
  Duration._create = function _create() {
    if (arguments.length <= 2) {
      return Duration._createSecondsNanos(arguments[0], arguments[1]);
    } else {
      return Duration._createNegateDaysHoursMinutesSecondsNanos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
    }
  };
  Duration._createNegateDaysHoursMinutesSecondsNanos = function _createNegateDaysHoursMinutesSecondsNanos(negate, daysAsSecs, hoursAsSecs, minsAsSecs, secs, nanos) {
    var seconds = MathUtil.safeAdd(daysAsSecs, MathUtil.safeAdd(hoursAsSecs, MathUtil.safeAdd(minsAsSecs, secs)));
    if (negate) {
      return Duration.ofSeconds(seconds, nanos).negated();
    }
    return Duration.ofSeconds(seconds, nanos);
  };
  Duration._createSecondsNanos = function _createSecondsNanos(seconds, nanoAdjustment) {
    if (seconds === void 0) {
      seconds = 0;
    }
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }
    if (seconds === 0 && nanoAdjustment === 0) {
      return Duration.ZERO;
    }
    return new Duration(seconds, nanoAdjustment);
  };
  var _proto = Duration.prototype;
  _proto.get = function get(unit) {
    if (unit === ChronoUnit.SECONDS) {
      return this._seconds;
    } else if (unit === ChronoUnit.NANOS) {
      return this._nanos;
    } else {
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
  };
  _proto.units = function units() {
    return [ChronoUnit.SECONDS, ChronoUnit.NANOS];
  };
  _proto.isZero = function isZero() {
    return this._seconds === 0 && this._nanos === 0;
  };
  _proto.isNegative = function isNegative() {
    return this._seconds < 0;
  };
  _proto.seconds = function seconds() {
    return this._seconds;
  };
  _proto.nano = function nano() {
    return this._nanos;
  };
  _proto.withSeconds = function withSeconds(seconds) {
    return Duration._create(seconds, this._nanos);
  };
  _proto.withNanos = function withNanos(nanoOfSecond) {
    ChronoField.NANO_OF_SECOND.checkValidIntValue(nanoOfSecond);
    return Duration._create(this._seconds, nanoOfSecond);
  };
  _proto.plusDuration = function plusDuration(duration) {
    requireNonNull(duration, 'duration');
    return this.plus(duration.seconds(), duration.nano());
  };
  _proto.plus = function plus(durationOrNumber, unitOrNumber) {
    if (arguments.length === 1) {
      return this.plusDuration(durationOrNumber);
    } else if (arguments.length === 2 && unitOrNumber instanceof TemporalUnit) {
      return this.plusAmountUnit(durationOrNumber, unitOrNumber);
    } else {
      return this.plusSecondsNanos(durationOrNumber, unitOrNumber);
    }
  };
  _proto.plusAmountUnit = function plusAmountUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');
    if (unit === ChronoUnit.DAYS) {
      return this.plusSecondsNanos(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY), 0);
    }
    if (unit.isDurationEstimated()) {
      throw new UnsupportedTemporalTypeException('Unit must not have an estimated duration');
    }
    if (amountToAdd === 0) {
      return this;
    }
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusSecondsNanos(MathUtil.intDiv(amountToAdd, 1000000 * 1000) * 1000, MathUtil.intMod(amountToAdd, 1000000 * 1000) * 1000);
        case ChronoUnit.MILLIS:
          return this.plusMillis(amountToAdd);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
      }
      return this.plusSecondsNanos(MathUtil.safeMultiply(unit.duration().seconds(), amountToAdd), 0);
    }
    var duration = unit.duration().multipliedBy(amountToAdd);
    return this.plusSecondsNanos(duration.seconds(), duration.nano());
  };
  _proto.plusDays = function plusDays(daysToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(daysToAdd, LocalTime.SECONDS_PER_DAY), 0);
  };
  _proto.plusHours = function plusHours(hoursToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(hoursToAdd, LocalTime.SECONDS_PER_HOUR), 0);
  };
  _proto.plusMinutes = function plusMinutes(minutesToAdd) {
    return this.plusSecondsNanos(MathUtil.safeMultiply(minutesToAdd, LocalTime.SECONDS_PER_MINUTE), 0);
  };
  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    return this.plusSecondsNanos(secondsToAdd, 0);
  };
  _proto.plusMillis = function plusMillis(millisToAdd) {
    return this.plusSecondsNanos(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * 1000000);
  };
  _proto.plusNanos = function plusNanos(nanosToAdd) {
    return this.plusSecondsNanos(0, nanosToAdd);
  };
  _proto.plusSecondsNanos = function plusSecondsNanos(secondsToAdd, nanosToAdd) {
    requireNonNull(secondsToAdd, 'secondsToAdd');
    requireNonNull(nanosToAdd, 'nanosToAdd');
    if (secondsToAdd === 0 && nanosToAdd === 0) {
      return this;
    }
    var epochSec = MathUtil.safeAdd(this._seconds, secondsToAdd);
    epochSec = MathUtil.safeAdd(epochSec, MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND));
    nanosToAdd = MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_SECOND);
    var nanoAdjustment = MathUtil.safeAdd(this._nanos, nanosToAdd);
    return Duration.ofSeconds(epochSec, nanoAdjustment);
  };
  _proto.minus = function minus(durationOrNumber, unit) {
    if (arguments.length === 1) {
      return this.minusDuration(durationOrNumber);
    } else {
      return this.minusAmountUnit(durationOrNumber, unit);
    }
  };
  _proto.minusDuration = function minusDuration(duration) {
    requireNonNull(duration, 'duration');
    var secsToSubtract = duration.seconds();
    var nanosToSubtract = duration.nano();
    if (secsToSubtract === MIN_SAFE_INTEGER) {
      return this.plus(MAX_SAFE_INTEGER, -nanosToSubtract);
    }
    return this.plus(-secsToSubtract, -nanosToSubtract);
  };
  _proto.minusAmountUnit = function minusAmountUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, 'amountToSubtract');
    requireNonNull(unit, 'unit');
    return amountToSubtract === MIN_SAFE_INTEGER ? this.plusAmountUnit(MAX_SAFE_INTEGER, unit) : this.plusAmountUnit(-amountToSubtract, unit);
  };
  _proto.minusDays = function minusDays(daysToSubtract) {
    return daysToSubtract === MIN_SAFE_INTEGER ? this.plusDays(MAX_SAFE_INTEGER) : this.plusDays(-daysToSubtract);
  };
  _proto.minusHours = function minusHours(hoursToSubtract) {
    return hoursToSubtract === MIN_SAFE_INTEGER ? this.plusHours(MAX_SAFE_INTEGER) : this.plusHours(-hoursToSubtract);
  };
  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
    return minutesToSubtract === MIN_SAFE_INTEGER ? this.plusMinutes(MAX_SAFE_INTEGER) : this.plusMinutes(-minutesToSubtract);
  };
  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return secondsToSubtract === MIN_SAFE_INTEGER ? this.plusSeconds(MAX_SAFE_INTEGER) : this.plusSeconds(-secondsToSubtract);
  };
  _proto.minusMillis = function minusMillis(millisToSubtract) {
    return millisToSubtract === MIN_SAFE_INTEGER ? this.plusMillis(MAX_SAFE_INTEGER) : this.plusMillis(-millisToSubtract);
  };
  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return nanosToSubtract === MIN_SAFE_INTEGER ? this.plusNanos(MAX_SAFE_INTEGER) : this.plusNanos(-nanosToSubtract);
  };
  _proto.multipliedBy = function multipliedBy(multiplicand) {
    if (multiplicand === 0) {
      return Duration.ZERO;
    }
    if (multiplicand === 1) {
      return this;
    }
    var secs = MathUtil.safeMultiply(this._seconds, multiplicand);
    var nos = MathUtil.safeMultiply(this._nanos, multiplicand);
    secs = secs + MathUtil.intDiv(nos, LocalTime.NANOS_PER_SECOND);
    nos = MathUtil.intMod(nos, LocalTime.NANOS_PER_SECOND);
    return Duration.ofSeconds(secs, nos);
  };
  _proto.dividedBy = function dividedBy(divisor) {
    if (divisor === 0) {
      throw new ArithmeticException('Cannot divide by zero');
    }
    if (divisor === 1) {
      return this;
    }
    var secs = MathUtil.intDiv(this._seconds, divisor);
    var secsMod = MathUtil.roundDown((this._seconds / divisor - secs) * LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.intDiv(this._nanos, divisor);
    nos = secsMod + nos;
    return Duration.ofSeconds(secs, nos);
  };
  _proto.negated = function negated() {
    return this.multipliedBy(-1);
  };
  _proto.abs = function abs() {
    return this.isNegative() ? this.negated() : this;
  };
  _proto.addTo = function addTo(temporal) {
    requireNonNull(temporal, 'temporal');
    if (this._seconds !== 0) {
      temporal = temporal.plus(this._seconds, ChronoUnit.SECONDS);
    }
    if (this._nanos !== 0) {
      temporal = temporal.plus(this._nanos, ChronoUnit.NANOS);
    }
    return temporal;
  };
  _proto.subtractFrom = function subtractFrom(temporal) {
    requireNonNull(temporal, 'temporal');
    if (this._seconds !== 0) {
      temporal = temporal.minus(this._seconds, ChronoUnit.SECONDS);
    }
    if (this._nanos !== 0) {
      temporal = temporal.minus(this._nanos, ChronoUnit.NANOS);
    }
    return temporal;
  };
  _proto.toDays = function toDays() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_DAY);
  };
  _proto.toHours = function toHours() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
  };
  _proto.toMinutes = function toMinutes() {
    return MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_MINUTE);
  };
  _proto.toMillis = function toMillis() {
    var millis = Math.round(MathUtil.safeMultiply(this._seconds, 1000));
    millis = MathUtil.safeAdd(millis, MathUtil.intDiv(this._nanos, 1000000));
    return millis;
  };
  _proto.toNanos = function toNanos() {
    var totalNanos = MathUtil.safeMultiply(this._seconds, LocalTime.NANOS_PER_SECOND);
    totalNanos = MathUtil.safeAdd(totalNanos, this._nanos);
    return totalNanos;
  };
  _proto.compareTo = function compareTo(otherDuration) {
    requireNonNull(otherDuration, 'otherDuration');
    requireInstance(otherDuration, Duration, 'otherDuration');
    var cmp = MathUtil.compareNumbers(this._seconds, otherDuration.seconds());
    if (cmp !== 0) {
      return cmp;
    }
    return this._nanos - otherDuration.nano();
  };
  _proto.equals = function equals(otherDuration) {
    if (this === otherDuration) {
      return true;
    }
    if (otherDuration instanceof Duration) {
      return this.seconds() === otherDuration.seconds() && this.nano() === otherDuration.nano();
    }
    return false;
  };
  _proto.toString = function toString() {
    if (this === Duration.ZERO) {
      return 'PT0S';
    }
    var hours = MathUtil.intDiv(this._seconds, LocalTime.SECONDS_PER_HOUR);
    var minutes = MathUtil.intDiv(MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_HOUR), LocalTime.SECONDS_PER_MINUTE);
    var secs = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_MINUTE);
    var rval = 'PT';
    if (hours !== 0) {
      rval += hours + "H";
    }
    if (minutes !== 0) {
      rval += minutes + "M";
    }
    if (secs === 0 && this._nanos === 0 && rval.length > 2) {
      return rval;
    }
    if (secs < 0 && this._nanos > 0) {
      if (secs === -1) {
        rval += '-0';
      } else {
        rval += secs + 1;
      }
    } else {
      rval += secs;
    }
    if (this._nanos > 0) {
      rval += '.';
      var nanoString;
      if (secs < 0) {
        nanoString = "" + (2 * LocalTime.NANOS_PER_SECOND - this._nanos);
      } else {
        nanoString = "" + (LocalTime.NANOS_PER_SECOND + this._nanos);
      }
      nanoString = nanoString.slice(1, nanoString.length);
      rval += nanoString;
      while (rval.charAt(rval.length - 1) === '0') {
        rval = rval.slice(0, rval.length - 1);
      }
    }
    rval += 'S';
    return rval;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Duration;
}(TemporalAmount);
function _init$n() {
  Duration.ZERO = new Duration(0, 0);
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE.md in the root directory of this source tree)
 */var YearConstants = function YearConstants() {};
function _init$m() {
  YearConstants.MIN_VALUE = -999999;
  YearConstants.MAX_VALUE = 999999;
}

var ChronoUnit = function (_TemporalUnit) {
  _inheritsLoose(ChronoUnit, _TemporalUnit);
  function ChronoUnit(name, estimatedDuration) {
    var _this;
    _this = _TemporalUnit.call(this) || this;
    _this._name = name;
    _this._duration = estimatedDuration;
    return _this;
  }
  var _proto = ChronoUnit.prototype;
  _proto.duration = function duration() {
    return this._duration;
  };
  _proto.isDurationEstimated = function isDurationEstimated() {
    return this.isDateBased() || this === ChronoUnit.FOREVER;
  };
  _proto.isDateBased = function isDateBased() {
    return this.compareTo(ChronoUnit.DAYS) >= 0 && this !== ChronoUnit.FOREVER;
  };
  _proto.isTimeBased = function isTimeBased() {
    return this.compareTo(ChronoUnit.DAYS) < 0;
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    if (this === ChronoUnit.FOREVER) {
      return false;
    }
    try {
      temporal.plus(1, this);
      return true;
    } catch (e) {
      try {
        temporal.plus(-1, this);
        return true;
      } catch (e2) {
        return false;
      }
    }
  };
  _proto.addTo = function addTo(temporal, amount) {
    return temporal.plus(amount, this);
  };
  _proto.between = function between(temporal1, temporal2) {
    return temporal1.until(temporal2, this);
  };
  _proto.toString = function toString() {
    return this._name;
  };
  _proto.compareTo = function compareTo(other) {
    return this.duration().compareTo(other.duration());
  };
  return ChronoUnit;
}(TemporalUnit);
function _init$l() {
  ChronoUnit.NANOS = new ChronoUnit('Nanos', Duration.ofNanos(1));
  ChronoUnit.MICROS = new ChronoUnit('Micros', Duration.ofNanos(1000));
  ChronoUnit.MILLIS = new ChronoUnit('Millis', Duration.ofNanos(1000000));
  ChronoUnit.SECONDS = new ChronoUnit('Seconds', Duration.ofSeconds(1));
  ChronoUnit.MINUTES = new ChronoUnit('Minutes', Duration.ofSeconds(60));
  ChronoUnit.HOURS = new ChronoUnit('Hours', Duration.ofSeconds(3600));
  ChronoUnit.HALF_DAYS = new ChronoUnit('HalfDays', Duration.ofSeconds(43200));
  ChronoUnit.DAYS = new ChronoUnit('Days', Duration.ofSeconds(86400));
  ChronoUnit.WEEKS = new ChronoUnit('Weeks', Duration.ofSeconds(7 * 86400));
  ChronoUnit.MONTHS = new ChronoUnit('Months', Duration.ofSeconds(31556952 / 12));
  ChronoUnit.YEARS = new ChronoUnit('Years', Duration.ofSeconds(31556952));
  ChronoUnit.DECADES = new ChronoUnit('Decades', Duration.ofSeconds(31556952 * 10));
  ChronoUnit.CENTURIES = new ChronoUnit('Centuries', Duration.ofSeconds(31556952 * 100));
  ChronoUnit.MILLENNIA = new ChronoUnit('Millennia', Duration.ofSeconds(31556952 * 1000));
  ChronoUnit.ERAS = new ChronoUnit('Eras', Duration.ofSeconds(31556952 * (YearConstants.MAX_VALUE + 1)));
  ChronoUnit.FOREVER = new ChronoUnit('Forever', Duration.ofSeconds(MathUtil.MAX_SAFE_INTEGER, 999999999));
}

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */
var TemporalField = function () {
  function TemporalField() {}
  var _proto = TemporalField.prototype;
  _proto.isDateBased = function isDateBased() {
    abstractMethodFail('isDateBased');
  };
  _proto.isTimeBased = function isTimeBased() {
    abstractMethodFail('isTimeBased');
  };
  _proto.baseUnit = function baseUnit() {
    abstractMethodFail('baseUnit');
  };
  _proto.rangeUnit = function rangeUnit() {
    abstractMethodFail('rangeUnit');
  };
  _proto.range = function range() {
    abstractMethodFail('range');
  };
  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
    abstractMethodFail('rangeRefinedBy');
  };
  _proto.getFrom = function getFrom(temporal) {
    abstractMethodFail('getFrom');
  };
  _proto.adjustInto = function adjustInto(temporal, newValue) {
    abstractMethodFail('adjustInto');
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    abstractMethodFail('isSupportedBy');
  };
  _proto.displayName = function displayName() {
    abstractMethodFail('displayName');
  };
  _proto.equals = function equals(other) {
    abstractMethodFail('equals');
  };
  _proto.name = function name() {
    abstractMethodFail('name');
  };
  return TemporalField;
}();

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var ValueRange = function () {
  function ValueRange(minSmallest, minLargest, maxSmallest, maxLargest) {
    assert(!(minSmallest > minLargest), "Smallest minimum value '" + minSmallest + "' must be less than largest minimum value '" + minLargest + "'", IllegalArgumentException);
    assert(!(maxSmallest > maxLargest), "Smallest maximum value '" + maxSmallest + "' must be less than largest maximum value '" + maxLargest + "'", IllegalArgumentException);
    assert(!(minLargest > maxLargest), "Minimum value '" + minLargest + "' must be less than maximum value '" + maxLargest + "'", IllegalArgumentException);
    this._minSmallest = minSmallest;
    this._minLargest = minLargest;
    this._maxLargest = maxLargest;
    this._maxSmallest = maxSmallest;
  }
  var _proto = ValueRange.prototype;
  _proto.isFixed = function isFixed() {
    return this._minSmallest === this._minLargest && this._maxSmallest === this._maxLargest;
  };
  _proto.minimum = function minimum() {
    return this._minSmallest;
  };
  _proto.largestMinimum = function largestMinimum() {
    return this._minLargest;
  };
  _proto.maximum = function maximum() {
    return this._maxLargest;
  };
  _proto.smallestMaximum = function smallestMaximum() {
    return this._maxSmallest;
  };
  _proto.isValidValue = function isValidValue(value) {
    return this.minimum() <= value && value <= this.maximum();
  };
  _proto.checkValidValue = function checkValidValue(value, field) {
    var msg;
    if (!this.isValidValue(value)) {
      if (field != null) {
        msg = "Invalid value for " + field + " (valid values " + this.toString() + "): " + value;
      } else {
        msg = "Invalid value (valid values " + this.toString() + "): " + value;
      }
      return assert(false, msg, DateTimeException);
    }
    return value;
  };
  _proto.checkValidIntValue = function checkValidIntValue(value, field) {
    if (this.isValidIntValue(value) === false) {
      throw new DateTimeException("Invalid int value for " + field + ": " + value);
    }
    return value;
  };
  _proto.isValidIntValue = function isValidIntValue(value) {
    return this.isIntValue() && this.isValidValue(value);
  };
  _proto.isIntValue = function isIntValue() {
    return this.minimum() >= MathUtil.MIN_SAFE_INTEGER && this.maximum() <= MathUtil.MAX_SAFE_INTEGER;
  };
  _proto.equals = function equals(other) {
    if (other === this) {
      return true;
    }
    if (other instanceof ValueRange) {
      return this._minSmallest === other._minSmallest && this._minLargest === other._minLargest && this._maxSmallest === other._maxSmallest && this._maxLargest === other._maxLargest;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._minSmallest, this._minLargest, this._maxSmallest, this._maxLargest);
  };
  _proto.toString = function toString() {
    var str = this.minimum() + (this.minimum() !== this.largestMinimum() ? "/" + this.largestMinimum() : '');
    str += ' - ';
    str += this.smallestMaximum() + (this.smallestMaximum() !== this.maximum() ? "/" + this.maximum() : '');
    return str;
  };
  ValueRange.of = function of() {
    if (arguments.length === 2) {
      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[1]);
    } else if (arguments.length === 3) {
      return new ValueRange(arguments[0], arguments[0], arguments[1], arguments[2]);
    } else if (arguments.length === 4) {
      return new ValueRange(arguments[0], arguments[1], arguments[2], arguments[3]);
    } else {
      return assert(false, "Invalid number of arguments " + arguments.length, IllegalArgumentException);
    }
  };
  return ValueRange;
}();

var ChronoField = function (_TemporalField) {
  _inheritsLoose(ChronoField, _TemporalField);
  ChronoField.byName = function byName(fieldName) {
    for (var prop in ChronoField) {
      if (ChronoField[prop]) {
        if (ChronoField[prop] instanceof ChronoField && ChronoField[prop].name() === fieldName) {
          return ChronoField[prop];
        }
      }
    }
  };
  function ChronoField(name, baseUnit, rangeUnit, range) {
    var _this;
    _this = _TemporalField.call(this) || this;
    _this._name = name;
    _this._baseUnit = baseUnit;
    _this._rangeUnit = rangeUnit;
    _this._range = range;
    return _this;
  }
  var _proto = ChronoField.prototype;
  _proto.name = function name() {
    return this._name;
  };
  _proto.baseUnit = function baseUnit() {
    return this._baseUnit;
  };
  _proto.rangeUnit = function rangeUnit() {
    return this._rangeUnit;
  };
  _proto.range = function range() {
    return this._range;
  };
  _proto.displayName = function displayName() {
    return this.toString();
  };
  _proto.checkValidValue = function checkValidValue(value) {
    return this.range().checkValidValue(value, this);
  };
  _proto.checkValidIntValue = function checkValidIntValue(value) {
    return this.range().checkValidIntValue(value, this);
  };
  _proto.isDateBased = function isDateBased() {
    var dateBased = this === ChronoField.DAY_OF_WEEK || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH || this === ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR || this === ChronoField.DAY_OF_MONTH || this === ChronoField.DAY_OF_YEAR || this === ChronoField.EPOCH_DAY || this === ChronoField.ALIGNED_WEEK_OF_MONTH || this === ChronoField.ALIGNED_WEEK_OF_YEAR || this === ChronoField.MONTH_OF_YEAR || this === ChronoField.PROLEPTIC_MONTH || this === ChronoField.YEAR_OF_ERA || this === ChronoField.YEAR || this === ChronoField.ERA;
    return dateBased;
  };
  _proto.isTimeBased = function isTimeBased() {
    var timeBased = this === ChronoField.NANO_OF_SECOND || this === ChronoField.NANO_OF_DAY || this === ChronoField.MICRO_OF_SECOND || this === ChronoField.MICRO_OF_DAY || this === ChronoField.MILLI_OF_SECOND || this === ChronoField.MILLI_OF_DAY || this === ChronoField.SECOND_OF_MINUTE || this === ChronoField.SECOND_OF_DAY || this === ChronoField.MINUTE_OF_HOUR || this === ChronoField.MINUTE_OF_DAY || this === ChronoField.HOUR_OF_AMPM || this === ChronoField.CLOCK_HOUR_OF_AMPM || this === ChronoField.HOUR_OF_DAY || this === ChronoField.CLOCK_HOUR_OF_DAY || this === ChronoField.AMPM_OF_DAY;
    return timeBased;
  };
  _proto.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return temporal.range(this);
  };
  _proto.getFrom = function getFrom(temporal) {
    return temporal.getLong(this);
  };
  _proto.toString = function toString() {
    return this.name();
  };
  _proto.equals = function equals(other) {
    return this === other;
  };
  _proto.adjustInto = function adjustInto(temporal, newValue) {
    return temporal.with(this, newValue);
  };
  _proto.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(this);
  };
  return ChronoField;
}(TemporalField);
function _init$k() {
  ChronoField.NANO_OF_SECOND = new ChronoField('NanoOfSecond', ChronoUnit.NANOS, ChronoUnit.SECONDS, ValueRange.of(0, 999999999));
  ChronoField.NANO_OF_DAY = new ChronoField('NanoOfDay', ChronoUnit.NANOS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000000 - 1));
  ChronoField.MICRO_OF_SECOND = new ChronoField('MicroOfSecond', ChronoUnit.MICROS, ChronoUnit.SECONDS, ValueRange.of(0, 999999));
  ChronoField.MICRO_OF_DAY = new ChronoField('MicroOfDay', ChronoUnit.MICROS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000000 - 1));
  ChronoField.MILLI_OF_SECOND = new ChronoField('MilliOfSecond', ChronoUnit.MILLIS, ChronoUnit.SECONDS, ValueRange.of(0, 999));
  ChronoField.MILLI_OF_DAY = new ChronoField('MilliOfDay', ChronoUnit.MILLIS, ChronoUnit.DAYS, ValueRange.of(0, 86400 * 1000 - 1));
  ChronoField.SECOND_OF_MINUTE = new ChronoField('SecondOfMinute', ChronoUnit.SECONDS, ChronoUnit.MINUTES, ValueRange.of(0, 59));
  ChronoField.SECOND_OF_DAY = new ChronoField('SecondOfDay', ChronoUnit.SECONDS, ChronoUnit.DAYS, ValueRange.of(0, 86400 - 1));
  ChronoField.MINUTE_OF_HOUR = new ChronoField('MinuteOfHour', ChronoUnit.MINUTES, ChronoUnit.HOURS, ValueRange.of(0, 59));
  ChronoField.MINUTE_OF_DAY = new ChronoField('MinuteOfDay', ChronoUnit.MINUTES, ChronoUnit.DAYS, ValueRange.of(0, 24 * 60 - 1));
  ChronoField.HOUR_OF_AMPM = new ChronoField('HourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(0, 11));
  ChronoField.CLOCK_HOUR_OF_AMPM = new ChronoField('ClockHourOfAmPm', ChronoUnit.HOURS, ChronoUnit.HALF_DAYS, ValueRange.of(1, 12));
  ChronoField.HOUR_OF_DAY = new ChronoField('HourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(0, 23));
  ChronoField.CLOCK_HOUR_OF_DAY = new ChronoField('ClockHourOfDay', ChronoUnit.HOURS, ChronoUnit.DAYS, ValueRange.of(1, 24));
  ChronoField.AMPM_OF_DAY = new ChronoField('AmPmOfDay', ChronoUnit.HALF_DAYS, ChronoUnit.DAYS, ValueRange.of(0, 1));
  ChronoField.DAY_OF_WEEK = new ChronoField('DayOfWeek', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH = new ChronoField('AlignedDayOfWeekInMonth', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR = new ChronoField('AlignedDayOfWeekInYear', ChronoUnit.DAYS, ChronoUnit.WEEKS, ValueRange.of(1, 7));
  ChronoField.DAY_OF_MONTH = new ChronoField('DayOfMonth', ChronoUnit.DAYS, ChronoUnit.MONTHS, ValueRange.of(1, 28, 31), 'day');
  ChronoField.DAY_OF_YEAR = new ChronoField('DayOfYear', ChronoUnit.DAYS, ChronoUnit.YEARS, ValueRange.of(1, 365, 366));
  ChronoField.EPOCH_DAY = new ChronoField('EpochDay', ChronoUnit.DAYS, ChronoUnit.FOREVER, ValueRange.of(-365961662, 364522971));
  ChronoField.ALIGNED_WEEK_OF_MONTH = new ChronoField('AlignedWeekOfMonth', ChronoUnit.WEEKS, ChronoUnit.MONTHS, ValueRange.of(1, 4, 5));
  ChronoField.ALIGNED_WEEK_OF_YEAR = new ChronoField('AlignedWeekOfYear', ChronoUnit.WEEKS, ChronoUnit.YEARS, ValueRange.of(1, 53));
  ChronoField.MONTH_OF_YEAR = new ChronoField('MonthOfYear', ChronoUnit.MONTHS, ChronoUnit.YEARS, ValueRange.of(1, 12), 'month');
  ChronoField.PROLEPTIC_MONTH = new ChronoField('ProlepticMonth', ChronoUnit.MONTHS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE * 12, YearConstants.MAX_VALUE * 12 + 11));
  ChronoField.YEAR_OF_ERA = new ChronoField('YearOfEra', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(1, YearConstants.MAX_VALUE, YearConstants.MAX_VALUE + 1));
  ChronoField.YEAR = new ChronoField('Year', ChronoUnit.YEARS, ChronoUnit.FOREVER, ValueRange.of(YearConstants.MIN_VALUE, YearConstants.MAX_VALUE), 'year');
  ChronoField.ERA = new ChronoField('Era', ChronoUnit.ERAS, ChronoUnit.FOREVER, ValueRange.of(0, 1));
  ChronoField.INSTANT_SECONDS = new ChronoField('InstantSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(MIN_SAFE_INTEGER, MAX_SAFE_INTEGER));
  ChronoField.OFFSET_SECONDS = new ChronoField('OffsetSeconds', ChronoUnit.SECONDS, ChronoUnit.FOREVER, ValueRange.of(-18 * 3600, 18 * 3600));
}

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var TemporalQueries = function () {
  function TemporalQueries() {}
  TemporalQueries.zoneId = function zoneId() {
    return TemporalQueries.ZONE_ID;
  };
  TemporalQueries.chronology = function chronology() {
    return TemporalQueries.CHRONO;
  };
  TemporalQueries.precision = function precision() {
    return TemporalQueries.PRECISION;
  };
  TemporalQueries.zone = function zone() {
    return TemporalQueries.ZONE;
  };
  TemporalQueries.offset = function offset() {
    return TemporalQueries.OFFSET;
  };
  TemporalQueries.localDate = function localDate() {
    return TemporalQueries.LOCAL_DATE;
  };
  TemporalQueries.localTime = function localTime() {
    return TemporalQueries.LOCAL_TIME;
  };
  return TemporalQueries;
}();

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var TemporalAccessor = function () {
  function TemporalAccessor() {}
  var _proto = TemporalAccessor.prototype;
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.chronology() || _query === TemporalQueries.precision()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.get = function get(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    abstractMethodFail('getLong');
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (this.isSupported(field)) {
        return field.range();
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.isSupported = function isSupported(field) {
    abstractMethodFail('isSupported');
  };
  return TemporalAccessor;
}();

var TemporalQuery = function (_Enum) {
  _inheritsLoose(TemporalQuery, _Enum);
  function TemporalQuery() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = TemporalQuery.prototype;
  _proto.queryFrom = function queryFrom(temporal) {
    abstractMethodFail('queryFrom');
  };
  return TemporalQuery;
}(Enum);
function createTemporalQuery(name, queryFromFunction) {
  var ExtendedTemporalQuery = function (_TemporalQuery) {
    _inheritsLoose(ExtendedTemporalQuery, _TemporalQuery);
    function ExtendedTemporalQuery() {
      return _TemporalQuery.apply(this, arguments) || this;
    }
    return ExtendedTemporalQuery;
  }(TemporalQuery);
  ExtendedTemporalQuery.prototype.queryFrom = queryFromFunction;
  return new ExtendedTemporalQuery(name);
}

var DayOfWeek = function (_TemporalAccessor) {
  _inheritsLoose(DayOfWeek, _TemporalAccessor);
  function DayOfWeek(ordinal, name) {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this._ordinal = ordinal;
    _this._name = name;
    return _this;
  }
  var _proto = DayOfWeek.prototype;
  _proto.ordinal = function ordinal() {
    return this._ordinal;
  };
  _proto.name = function name() {
    return this._name;
  };
  DayOfWeek.values = function values() {
    return ENUMS.slice();
  };
  DayOfWeek.valueOf = function valueOf(name) {
    var ordinal = 0;
    for (ordinal; ordinal < ENUMS.length; ordinal++) {
      if (ENUMS[ordinal].name() === name) {
        break;
      }
    }
    return DayOfWeek.of(ordinal + 1);
  };
  DayOfWeek.of = function of(dayOfWeek) {
    if (dayOfWeek < 1 || dayOfWeek > 7) {
      throw new DateTimeException("Invalid value for DayOfWeek: " + dayOfWeek);
    }
    return ENUMS[dayOfWeek - 1];
  };
  DayOfWeek.from = function from(temporal) {
    assert(temporal != null, 'temporal', NullPointerException);
    if (temporal instanceof DayOfWeek) {
      return temporal;
    }
    try {
      return DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));
    } catch (ex) {
      if (ex instanceof DateTimeException) {
        throw new DateTimeException("Unable to obtain DayOfWeek from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''), ex);
      } else {
        throw ex;
      }
    }
  };
  _proto.value = function value() {
    return this._ordinal + 1;
  };
  _proto.displayName = function displayName(style, locale) {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');
  };
  _proto.isSupported = function isSupported(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.DAY_OF_WEEK;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return field.range();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return this.value();
    }
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    if (field === ChronoField.DAY_OF_WEEK) {
      return this.value();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.plus = function plus(days) {
    var amount = MathUtil.floorMod(days, 7);
    return ENUMS[MathUtil.floorMod(this._ordinal + (amount + 7), 7)];
  };
  _proto.minus = function minus(days) {
    return this.plus(-1 * MathUtil.floorMod(days, 7));
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.DAYS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    assert(_query != null, 'query', NullPointerException);
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    return temporal.with(ChronoField.DAY_OF_WEEK, this.value());
  };
  _proto.equals = function equals(other) {
    return this === other;
  };
  _proto.toString = function toString() {
    return this._name;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, DayOfWeek, 'other');
    return this._ordinal - other._ordinal;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return DayOfWeek;
}(TemporalAccessor);
var ENUMS;
function _init$j() {
  DayOfWeek.MONDAY = new DayOfWeek(0, 'MONDAY');
  DayOfWeek.TUESDAY = new DayOfWeek(1, 'TUESDAY');
  DayOfWeek.WEDNESDAY = new DayOfWeek(2, 'WEDNESDAY');
  DayOfWeek.THURSDAY = new DayOfWeek(3, 'THURSDAY');
  DayOfWeek.FRIDAY = new DayOfWeek(4, 'FRIDAY');
  DayOfWeek.SATURDAY = new DayOfWeek(5, 'SATURDAY');
  DayOfWeek.SUNDAY = new DayOfWeek(6, 'SUNDAY');
  DayOfWeek.FROM = createTemporalQuery('DayOfWeek.FROM', function (temporal) {
    return DayOfWeek.from(temporal);
  });
  ENUMS = [DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY];
}

var Month = function (_TemporalAccessor) {
  _inheritsLoose(Month, _TemporalAccessor);
  function Month(value, name) {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this._value = MathUtil.safeToInt(value);
    _this._name = name;
    return _this;
  }
  var _proto = Month.prototype;
  _proto.value = function value() {
    return this._value;
  };
  _proto.ordinal = function ordinal() {
    return this._value - 1;
  };
  _proto.name = function name() {
    return this._name;
  };
  _proto.displayName = function displayName(style, locale) {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented yet!');
  };
  _proto.isSupported = function isSupported(field) {
    if (null === field) {
      return false;
    }
    if (field instanceof ChronoField) {
      return field === ChronoField.MONTH_OF_YEAR;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.get = function get(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return this.value();
    }
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return this.value();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.plus = function plus(months) {
    var amount = MathUtil.intMod(months, 12) + 12;
    var newMonthVal = MathUtil.intMod(this.value() + amount, 12);
    newMonthVal = newMonthVal === 0 ? 12 : newMonthVal;
    return Month.of(newMonthVal);
  };
  _proto.minus = function minus(months) {
    return this.plus(-1 * MathUtil.intMod(months, 12));
  };
  _proto.length = function length(leapYear) {
    switch (this) {
      case Month.FEBRUARY:
        return leapYear ? 29 : 28;
      case Month.APRIL:
      case Month.JUNE:
      case Month.SEPTEMBER:
      case Month.NOVEMBER:
        return 30;
      default:
        return 31;
    }
  };
  _proto.minLength = function minLength() {
    switch (this) {
      case Month.FEBRUARY:
        return 28;
      case Month.APRIL:
      case Month.JUNE:
      case Month.SEPTEMBER:
      case Month.NOVEMBER:
        return 30;
      default:
        return 31;
    }
  };
  _proto.maxLength = function maxLength() {
    switch (this) {
      case Month.FEBRUARY:
        return 29;
      case Month.APRIL:
      case Month.JUNE:
      case Month.SEPTEMBER:
      case Month.NOVEMBER:
        return 30;
      default:
        return 31;
    }
  };
  _proto.firstDayOfYear = function firstDayOfYear(leapYear) {
    var leap = leapYear ? 1 : 0;
    switch (this) {
      case Month.JANUARY:
        return 1;
      case Month.FEBRUARY:
        return 32;
      case Month.MARCH:
        return 60 + leap;
      case Month.APRIL:
        return 91 + leap;
      case Month.MAY:
        return 121 + leap;
      case Month.JUNE:
        return 152 + leap;
      case Month.JULY:
        return 182 + leap;
      case Month.AUGUST:
        return 213 + leap;
      case Month.SEPTEMBER:
        return 244 + leap;
      case Month.OCTOBER:
        return 274 + leap;
      case Month.NOVEMBER:
        return 305 + leap;
      case Month.DECEMBER:
      default:
        return 335 + leap;
    }
  };
  _proto.firstMonthOfQuarter = function firstMonthOfQuarter() {
    switch (this) {
      case Month.JANUARY:
      case Month.FEBRUARY:
      case Month.MARCH:
        return Month.JANUARY;
      case Month.APRIL:
      case Month.MAY:
      case Month.JUNE:
        return Month.APRIL;
      case Month.JULY:
      case Month.AUGUST:
      case Month.SEPTEMBER:
        return Month.JULY;
      case Month.OCTOBER:
      case Month.NOVEMBER:
      case Month.DECEMBER:
      default:
        return Month.OCTOBER;
    }
  };
  _proto.query = function query(_query) {
    assert(_query != null, 'query() parameter must not be null', DateTimeException);
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.MONTHS;
    }
    return _TemporalAccessor.prototype.query.call(this, _query);
  };
  _proto.toString = function toString() {
    switch (this) {
      case Month.JANUARY:
        return 'JANUARY';
      case Month.FEBRUARY:
        return 'FEBRUARY';
      case Month.MARCH:
        return 'MARCH';
      case Month.APRIL:
        return 'APRIL';
      case Month.MAY:
        return 'MAY';
      case Month.JUNE:
        return 'JUNE';
      case Month.JULY:
        return 'JULY';
      case Month.AUGUST:
        return 'AUGUST';
      case Month.SEPTEMBER:
        return 'SEPTEMBER';
      case Month.OCTOBER:
        return 'OCTOBER';
      case Month.NOVEMBER:
        return 'NOVEMBER';
      case Month.DECEMBER:
        return 'DECEMBER';
      default:
        return "unknown Month, value: " + this.value();
    }
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.MONTH_OF_YEAR, this.value());
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Month, 'other');
    return this._value - other._value;
  };
  _proto.equals = function equals(other) {
    return this === other;
  };
  Month.valueOf = function valueOf(name) {
    var ordinal = 0;
    for (ordinal; ordinal < MONTHS.length; ordinal++) {
      if (MONTHS[ordinal].name() === name) {
        break;
      }
    }
    return Month.of(ordinal + 1);
  };
  Month.values = function values() {
    return MONTHS.slice();
  };
  Month.of = function of(month) {
    if (month < 1 || month > 12) {
      assert(false, "Invalid value for MonthOfYear: " + month, DateTimeException);
    }
    return MONTHS[month - 1];
  };
  Month.from = function from(temporal) {
    if (temporal instanceof Month) {
      return temporal;
    }
    try {
      return Month.of(temporal.get(ChronoField.MONTH_OF_YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Month from TemporalAccessor: " + temporal + " of type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''), ex);
    }
  };
  return Month;
}(TemporalAccessor);
var MONTHS;
function _init$i() {
  Month.JANUARY = new Month(1, 'JANUARY');
  Month.FEBRUARY = new Month(2, 'FEBRUARY');
  Month.MARCH = new Month(3, 'MARCH');
  Month.APRIL = new Month(4, 'APRIL');
  Month.MAY = new Month(5, 'MAY');
  Month.JUNE = new Month(6, 'JUNE');
  Month.JULY = new Month(7, 'JULY');
  Month.AUGUST = new Month(8, 'AUGUST');
  Month.SEPTEMBER = new Month(9, 'SEPTEMBER');
  Month.OCTOBER = new Month(10, 'OCTOBER');
  Month.NOVEMBER = new Month(11, 'NOVEMBER');
  Month.DECEMBER = new Month(12, 'DECEMBER');
  MONTHS = [Month.JANUARY, Month.FEBRUARY, Month.MARCH, Month.APRIL, Month.MAY, Month.JUNE, Month.JULY, Month.AUGUST, Month.SEPTEMBER, Month.OCTOBER, Month.NOVEMBER, Month.DECEMBER];
}

var PATTERN = /([-+]?)P(?:([-+]?[0-9]+)Y)?(?:([-+]?[0-9]+)M)?(?:([-+]?[0-9]+)W)?(?:([-+]?[0-9]+)D)?/;
var Period = function (_TemporalAmount) {
  _inheritsLoose(Period, _TemporalAmount);
  function Period(years, months, days) {
    var _this;
    _this = _TemporalAmount.call(this) || this;
    var _years = MathUtil.safeToInt(years);
    var _months = MathUtil.safeToInt(months);
    var _days = MathUtil.safeToInt(days);
    if (_years === 0 && _months === 0 && _days === 0) {
      if (!Period.ZERO) {
        _this._years = _years;
        _this._months = _months;
        _this._days = _days;
        Period.ZERO = _assertThisInitialized(_this);
      }
      return Period.ZERO || _assertThisInitialized(_this);
    }
    _this._years = _years;
    _this._months = _months;
    _this._days = _days;
    return _this;
  }
  Period.ofYears = function ofYears(years) {
    return Period.create(years, 0, 0);
  };
  Period.ofMonths = function ofMonths(months) {
    return Period.create(0, months, 0);
  };
  Period.ofWeeks = function ofWeeks(weeks) {
    return Period.create(0, 0, MathUtil.safeMultiply(weeks, 7));
  };
  Period.ofDays = function ofDays(days) {
    return Period.create(0, 0, days);
  };
  Period.of = function of(years, months, days) {
    return Period.create(years, months, days);
  };
  Period.from = function from(amount) {
    if (amount instanceof Period) {
      return amount;
    }
    requireNonNull(amount, 'amount');
    var years = 0;
    var months = 0;
    var days = 0;
    var units = amount.units();
    for (var i = 0; i < units.length; i++) {
      var unit = units[i];
      var unitAmount = amount.get(unit);
      if (unit === ChronoUnit.YEARS) {
        years = MathUtil.safeToInt(unitAmount);
      } else if (unit === ChronoUnit.MONTHS) {
        months = MathUtil.safeToInt(unitAmount);
      } else if (unit === ChronoUnit.DAYS) {
        days = MathUtil.safeToInt(unitAmount);
      } else {
        throw new DateTimeException("Unit must be Years, Months or Days, but was " + unit);
      }
    }
    return Period.create(years, months, days);
  };
  Period.between = function between(startDate, endDate) {
    requireNonNull(startDate, 'startDate');
    requireNonNull(endDate, 'endDate');
    requireInstance(startDate, LocalDate, 'startDate');
    requireInstance(endDate, LocalDate, 'endDate');
    return startDate.until(endDate);
  };
  Period.parse = function parse(text) {
    requireNonNull(text, 'text');
    try {
      return Period._parse(text);
    } catch (ex) {
      if (ex instanceof ArithmeticException) {
        throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0, ex);
      } else {
        throw ex;
      }
    }
  };
  Period._parse = function _parse(text) {
    var matches = PATTERN.exec(text);
    if (matches != null) {
      var negate = '-' === matches[1] ? -1 : 1;
      var yearMatch = matches[2];
      var monthMatch = matches[3];
      var weekMatch = matches[4];
      var dayMatch = matches[5];
      if (yearMatch != null || monthMatch != null || weekMatch != null || dayMatch != null) {
        var years = Period._parseNumber(text, yearMatch, negate);
        var months = Period._parseNumber(text, monthMatch, negate);
        var weeks = Period._parseNumber(text, weekMatch, negate);
        var days = Period._parseNumber(text, dayMatch, negate);
        days = MathUtil.safeAdd(days, MathUtil.safeMultiply(weeks, 7));
        return Period.create(years, months, days);
      }
    }
    throw new DateTimeParseException('Text cannot be parsed to a Period', text, 0);
  };
  Period._parseNumber = function _parseNumber(text, str, negate) {
    if (str == null) {
      return 0;
    }
    var val = MathUtil.parseInt(str);
    return MathUtil.safeMultiply(val, negate);
  };
  Period.create = function create(years, months, days) {
    return new Period(years, months, days);
  };
  var _proto = Period.prototype;
  _proto.units = function units() {
    return [ChronoUnit.YEARS, ChronoUnit.MONTHS, ChronoUnit.DAYS];
  };
  _proto.chronology = function chronology() {
    return IsoChronology.INSTANCE;
  };
  _proto.get = function get(unit) {
    if (unit === ChronoUnit.YEARS) {
      return this._years;
    }
    if (unit === ChronoUnit.MONTHS) {
      return this._months;
    }
    if (unit === ChronoUnit.DAYS) {
      return this._days;
    }
    throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
  };
  _proto.isZero = function isZero() {
    return this === Period.ZERO;
  };
  _proto.isNegative = function isNegative() {
    return this._years < 0 || this._months < 0 || this._days < 0;
  };
  _proto.years = function years() {
    return this._years;
  };
  _proto.months = function months() {
    return this._months;
  };
  _proto.days = function days() {
    return this._days;
  };
  _proto.withYears = function withYears(years) {
    if (years === this._years) {
      return this;
    }
    return Period.create(years, this._months, this._days);
  };
  _proto.withMonths = function withMonths(months) {
    if (months === this._months) {
      return this;
    }
    return Period.create(this._years, months, this._days);
  };
  _proto.withDays = function withDays(days) {
    if (days === this._days) {
      return this;
    }
    return Period.create(this._years, this._months, days);
  };
  _proto.plus = function plus(amountToAdd) {
    var amount = Period.from(amountToAdd);
    return Period.create(MathUtil.safeAdd(this._years, amount._years), MathUtil.safeAdd(this._months, amount._months), MathUtil.safeAdd(this._days, amount._days));
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    return Period.create(MathUtil.safeToInt(MathUtil.safeAdd(this._years, yearsToAdd)), this._months, this._days);
  };
  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }
    return Period.create(this._years, MathUtil.safeToInt(MathUtil.safeAdd(this._months, monthsToAdd)), this._days);
  };
  _proto.plusDays = function plusDays(daysToAdd) {
    if (daysToAdd === 0) {
      return this;
    }
    return Period.create(this._years, this._months, MathUtil.safeToInt(MathUtil.safeAdd(this._days, daysToAdd)));
  };
  _proto.minus = function minus(amountToSubtract) {
    var amount = Period.from(amountToSubtract);
    return Period.create(MathUtil.safeSubtract(this._years, amount._years), MathUtil.safeSubtract(this._months, amount._months), MathUtil.safeSubtract(this._days, amount._days));
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return this.plusYears(-1 * yearsToSubtract);
  };
  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return this.plusMonths(-1 * monthsToSubtract);
  };
  _proto.minusDays = function minusDays(daysToSubtract) {
    return this.plusDays(-1 * daysToSubtract);
  };
  _proto.multipliedBy = function multipliedBy(scalar) {
    if (this === Period.ZERO || scalar === 1) {
      return this;
    }
    return Period.create(MathUtil.safeMultiply(this._years, scalar), MathUtil.safeMultiply(this._months, scalar), MathUtil.safeMultiply(this._days, scalar));
  };
  _proto.negated = function negated() {
    return this.multipliedBy(-1);
  };
  _proto.normalized = function normalized() {
    var totalMonths = this.toTotalMonths();
    var splitYears = MathUtil.intDiv(totalMonths, 12);
    var splitMonths = MathUtil.intMod(totalMonths, 12);
    if (splitYears === this._years && splitMonths === this._months) {
      return this;
    }
    return Period.create(MathUtil.safeToInt(splitYears), splitMonths, this._days);
  };
  _proto.toTotalMonths = function toTotalMonths() {
    return this._years * 12 + this._months;
  };
  _proto.addTo = function addTo(temporal) {
    requireNonNull(temporal, 'temporal');
    if (this._years !== 0) {
      if (this._months !== 0) {
        temporal = temporal.plus(this.toTotalMonths(), ChronoUnit.MONTHS);
      } else {
        temporal = temporal.plus(this._years, ChronoUnit.YEARS);
      }
    } else if (this._months !== 0) {
      temporal = temporal.plus(this._months, ChronoUnit.MONTHS);
    }
    if (this._days !== 0) {
      temporal = temporal.plus(this._days, ChronoUnit.DAYS);
    }
    return temporal;
  };
  _proto.subtractFrom = function subtractFrom(temporal) {
    requireNonNull(temporal, 'temporal');
    if (this._years !== 0) {
      if (this._months !== 0) {
        temporal = temporal.minus(this.toTotalMonths(), ChronoUnit.MONTHS);
      } else {
        temporal = temporal.minus(this._years, ChronoUnit.YEARS);
      }
    } else if (this._months !== 0) {
      temporal = temporal.minus(this._months, ChronoUnit.MONTHS);
    }
    if (this._days !== 0) {
      temporal = temporal.minus(this._days, ChronoUnit.DAYS);
    }
    return temporal;
  };
  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }
    if (obj instanceof Period) {
      var other = obj;
      return this._years === other._years && this._months === other._months && this._days === other._days;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._years, this._months, this._days);
  };
  _proto.toString = function toString() {
    if (this === Period.ZERO) {
      return 'P0D';
    } else {
      var buf = 'P';
      if (this._years !== 0) {
        buf += this._years + "Y";
      }
      if (this._months !== 0) {
        buf += this._months + "M";
      }
      if (this._days !== 0) {
        buf += this._days + "D";
      }
      return buf;
    }
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Period;
}(TemporalAmount);
function _init$h() {
  Period.ofDays(0);
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var ParsePosition = function () {
  function ParsePosition(index) {
    this._index = index;
    this._errorIndex = -1;
  }
  var _proto = ParsePosition.prototype;
  _proto.getIndex = function getIndex() {
    return this._index;
  };
  _proto.setIndex = function setIndex(index) {
    this._index = index;
  };
  _proto.getErrorIndex = function getErrorIndex() {
    return this._errorIndex;
  };
  _proto.setErrorIndex = function setErrorIndex(errorIndex) {
    this._errorIndex = errorIndex;
  };
  return ParsePosition;
}();

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var EnumMap = function () {
  function EnumMap() {
    this._map = {};
  }
  var _proto = EnumMap.prototype;
  _proto.putAll = function putAll(otherMap) {
    for (var key in otherMap._map) {
      this._map[key] = otherMap._map[key];
    }
    return this;
  };
  _proto.containsKey = function containsKey(key) {
    return this._map.hasOwnProperty(key.name()) && this.get(key) !== undefined;
  };
  _proto.get = function get(key) {
    return this._map[key.name()];
  };
  _proto.put = function put(key, val) {
    return this.set(key, val);
  };
  _proto.set = function set(key, val) {
    this._map[key.name()] = val;
    return this;
  };
  _proto.retainAll = function retainAll(keyList) {
    var map = {};
    for (var i = 0; i < keyList.length; i++) {
      var key = keyList[i].name();
      map[key] = this._map[key];
    }
    this._map = map;
    return this;
  };
  _proto.remove = function remove(key) {
    var keyName = key.name();
    var val = this._map[keyName];
    this._map[keyName] = undefined;
    return val;
  };
  _proto.keySet = function keySet() {
    return this._map;
  };
  _proto.clear = function clear() {
    this._map = {};
  };
  return EnumMap;
}();

var ResolverStyle = function (_Enum) {
  _inheritsLoose(ResolverStyle, _Enum);
  function ResolverStyle() {
    return _Enum.apply(this, arguments) || this;
  }
  return ResolverStyle;
}(Enum);
ResolverStyle.STRICT = new ResolverStyle('STRICT');
ResolverStyle.SMART = new ResolverStyle('SMART');
ResolverStyle.LENIENT = new ResolverStyle('LENIENT');

var Temporal = function (_TemporalAccessor) {
  _inheritsLoose(Temporal, _TemporalAccessor);
  function Temporal() {
    return _TemporalAccessor.apply(this, arguments) || this;
  }
  var _proto = Temporal.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    abstractMethodFail('isSupported');
  };
  _proto.minus = function minus(amount, unit) {
    if (arguments.length < 2) {
      return this._minusAmount(amount);
    } else {
      return this._minusUnit(amount, unit);
    }
  };
  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount, 'amount');
    requireInstance(amount, TemporalAmount, 'amount');
    return amount.subtractFrom(this);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, 'amountToSubtract');
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit, 'unit');
    return this._plusUnit(-amountToSubtract, unit);
  };
  _proto.plus = function plus(amount, unit) {
    if (arguments.length < 2) {
      return this._plusAmount(amount);
    } else {
      return this._plusUnit(amount, unit);
    }
  };
  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount, 'amount');
    requireInstance(amount, TemporalAmount, 'amount');
    return amount.addTo(this);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    abstractMethodFail('_plusUnit');
  };
  _proto.until = function until(endTemporal, unit) {
    abstractMethodFail('until');
  };
  _proto.with = function _with(adjusterOrField, newValue) {
    if (arguments.length < 2) {
      return this._withAdjuster(adjusterOrField);
    } else {
      return this._withField(adjusterOrField, newValue);
    }
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    assert(typeof adjuster.adjustInto === 'function', 'adjuster must be a TemporalAdjuster', IllegalArgumentException);
    return adjuster.adjustInto(this);
  };
  _proto._withField = function _withField(field, newValue) {
    abstractMethodFail('_withField');
  };
  return Temporal;
}(TemporalAccessor);
if (typeof Symbol !== 'undefined' && Symbol.toPrimitive) {
  Temporal.prototype[Symbol.toPrimitive] = function (hint) {
    if (hint !== 'number') {
      return this.toString();
    }
    throw new TypeError('A conversion from Temporal to a number is not allowed. ' + 'To compare use the methods .equals(), .compareTo(), .isBefore() ' + 'or one that is more suitable to your use case.');
  };
}

var ChronoLocalDate = function (_Temporal) {
  _inheritsLoose(ChronoLocalDate, _Temporal);
  function ChronoLocalDate() {
    return _Temporal.apply(this, arguments) || this;
  }
  var _proto = ChronoLocalDate.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.DAYS;
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toEpochDay());
    } else if (_query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toEpochDay());
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.format(this);
  };
  return ChronoLocalDate;
}(Temporal);

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var StringUtil = function () {
  function StringUtil() {}
  StringUtil.startsWith = function startsWith(text, pattern) {
    return text.indexOf(pattern) === 0;
  };
  StringUtil.hashCode = function hashCode(text) {
    var len = text.length;
    if (len === 0) {
      return 0;
    }
    var hash = 0;
    for (var i = 0; i < len; i++) {
      var chr = text.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return MathUtil.smi(hash);
  };
  return StringUtil;
}();

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var ZoneId = function () {
  function ZoneId() {}
  ZoneId.systemDefault = function systemDefault() {
    throw new DateTimeException('not supported operation');
  };
  ZoneId.getAvailableZoneIds = function getAvailableZoneIds() {
    throw new DateTimeException('not supported operation');
  };
  ZoneId.of = function of(zoneId) {
    throw new DateTimeException("not supported operation" + zoneId);
  };
  ZoneId.ofOffset = function ofOffset(prefix, offset) {
    throw new DateTimeException("not supported operation" + prefix + offset);
  };
  ZoneId.from = function from(temporal) {
    throw new DateTimeException("not supported operation" + temporal);
  };
  var _proto = ZoneId.prototype;
  _proto.id = function id() {
    abstractMethodFail('ZoneId.id');
  };
  _proto.rules = function rules() {
    abstractMethodFail('ZoneId.rules');
  };
  _proto.normalized = function normalized() {
    var rules = this.rules();
    if (rules.isFixedOffset()) {
      return rules.offset(Instant.EPOCH);
    }
    return this;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof ZoneId) {
      return this.id() === other.id();
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return StringUtil.hashCode(this.id());
  };
  _proto.toString = function toString() {
    return this.id();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return ZoneId;
}();

var ZoneRules = function () {
  function ZoneRules() {}
  ZoneRules.of = function of(offset) {
    requireNonNull(offset, 'offset');
    return new Fixed(offset);
  };
  var _proto = ZoneRules.prototype;
  _proto.isFixedOffset = function isFixedOffset() {
    abstractMethodFail('ZoneRules.isFixedOffset');
  };
  _proto.offset = function offset(instantOrLocalDateTime) {
    if (instantOrLocalDateTime instanceof Instant) {
      return this.offsetOfInstant(instantOrLocalDateTime);
    } else {
      return this.offsetOfLocalDateTime(instantOrLocalDateTime);
    }
  };
  _proto.offsetOfInstant = function offsetOfInstant(instant) {
    abstractMethodFail('ZoneRules.offsetInstant');
  };
  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
    abstractMethodFail('ZoneRules.offsetOfEpochMilli');
  };
  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
    abstractMethodFail('ZoneRules.offsetLocalDateTime');
  };
  _proto.validOffsets = function validOffsets(localDateTime) {
    abstractMethodFail('ZoneRules.validOffsets');
  };
  _proto.transition = function transition(localDateTime) {
    abstractMethodFail('ZoneRules.transition');
  };
  _proto.standardOffset = function standardOffset(instant) {
    abstractMethodFail('ZoneRules.standardOffset');
  };
  _proto.daylightSavings = function daylightSavings(instant) {
    abstractMethodFail('ZoneRules.daylightSavings');
  };
  _proto.isDaylightSavings = function isDaylightSavings(instant) {
    abstractMethodFail('ZoneRules.isDaylightSavings');
  };
  _proto.isValidOffset = function isValidOffset(localDateTime, offset) {
    abstractMethodFail('ZoneRules.isValidOffset');
  };
  _proto.nextTransition = function nextTransition(instant) {
    abstractMethodFail('ZoneRules.nextTransition');
  };
  _proto.previousTransition = function previousTransition(instant) {
    abstractMethodFail('ZoneRules.previousTransition');
  };
  _proto.transitions = function transitions() {
    abstractMethodFail('ZoneRules.transitions');
  };
  _proto.transitionRules = function transitionRules() {
    abstractMethodFail('ZoneRules.transitionRules');
  };
  _proto.toString = function toString() {
    abstractMethodFail('ZoneRules.toString');
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return ZoneRules;
}();
var Fixed = function (_ZoneRules) {
  _inheritsLoose(Fixed, _ZoneRules);
  function Fixed(offset) {
    var _this;
    _this = _ZoneRules.call(this) || this;
    _this._offset = offset;
    return _this;
  }
  var _proto2 = Fixed.prototype;
  _proto2.isFixedOffset = function isFixedOffset() {
    return true;
  };
  _proto2.offsetOfInstant = function offsetOfInstant() {
    return this._offset;
  };
  _proto2.offsetOfEpochMilli = function offsetOfEpochMilli() {
    return this._offset;
  };
  _proto2.offsetOfLocalDateTime = function offsetOfLocalDateTime() {
    return this._offset;
  };
  _proto2.validOffsets = function validOffsets() {
    return [this._offset];
  };
  _proto2.transition = function transition() {
    return null;
  };
  _proto2.standardOffset = function standardOffset() {
    return this._offset;
  };
  _proto2.daylightSavings = function daylightSavings() {
    return Duration.ZERO;
  };
  _proto2.isDaylightSavings = function isDaylightSavings() {
    return false;
  };
  _proto2.isValidOffset = function isValidOffset(localDateTime, offset) {
    return this._offset.equals(offset);
  };
  _proto2.nextTransition = function nextTransition() {
    return null;
  };
  _proto2.previousTransition = function previousTransition() {
    return null;
  };
  _proto2.transitions = function transitions() {
    return [];
  };
  _proto2.transitionRules = function transitionRules() {
    return [];
  };
  _proto2.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof Fixed) {
      return this._offset.equals(other._offset);
    }
    return false;
  };
  _proto2.toString = function toString() {
    return "FixedRules:" + this._offset.toString();
  };
  return Fixed;
}(ZoneRules);

var SECONDS_CACHE = {};
var ID_CACHE = {};
var ZoneOffset = function (_ZoneId) {
  _inheritsLoose(ZoneOffset, _ZoneId);
  function ZoneOffset(totalSeconds) {
    var _this;
    _this = _ZoneId.call(this) || this;
    ZoneOffset._validateTotalSeconds(totalSeconds);
    _this._totalSeconds = MathUtil.safeToInt(totalSeconds);
    _this._rules = ZoneRules.of(_assertThisInitialized(_this));
    _this._id = ZoneOffset._buildId(totalSeconds);
    return _this;
  }
  var _proto = ZoneOffset.prototype;
  _proto.totalSeconds = function totalSeconds() {
    return this._totalSeconds;
  };
  _proto.id = function id() {
    return this._id;
  };
  ZoneOffset._buildId = function _buildId(totalSeconds) {
    if (totalSeconds === 0) {
      return 'Z';
    } else {
      var absTotalSeconds = Math.abs(totalSeconds);
      var absHours = MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_HOUR);
      var absMinutes = MathUtil.intMod(MathUtil.intDiv(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
      var buf = "" + (totalSeconds < 0 ? '-' : '+') + (absHours < 10 ? '0' : '') + absHours + (absMinutes < 10 ? ':0' : ':') + absMinutes;
      var absSeconds = MathUtil.intMod(absTotalSeconds, LocalTime.SECONDS_PER_MINUTE);
      if (absSeconds !== 0) {
        buf += (absSeconds < 10 ? ':0' : ':') + absSeconds;
      }
      return buf;
    }
  };
  ZoneOffset._validateTotalSeconds = function _validateTotalSeconds(totalSeconds) {
    if (Math.abs(totalSeconds) > ZoneOffset.MAX_SECONDS) {
      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');
    }
  };
  ZoneOffset._validate = function _validate(hours, minutes, seconds) {
    if (hours < -18 || hours > 18) {
      throw new DateTimeException("Zone offset hours not in valid range: value " + hours + " is not in the range -18 to 18");
    }
    if (hours > 0) {
      if (minutes < 0 || seconds < 0) {
        throw new DateTimeException('Zone offset minutes and seconds must be positive because hours is positive');
      }
    } else if (hours < 0) {
      if (minutes > 0 || seconds > 0) {
        throw new DateTimeException('Zone offset minutes and seconds must be negative because hours is negative');
      }
    } else if (minutes > 0 && seconds < 0 || minutes < 0 && seconds > 0) {
      throw new DateTimeException('Zone offset minutes and seconds must have the same sign');
    }
    if (Math.abs(minutes) > 59) {
      throw new DateTimeException("Zone offset minutes not in valid range: abs(value) " + Math.abs(minutes) + " is not in the range 0 to 59");
    }
    if (Math.abs(seconds) > 59) {
      throw new DateTimeException("Zone offset seconds not in valid range: abs(value) " + Math.abs(seconds) + " is not in the range 0 to 59");
    }
    if (Math.abs(hours) === 18 && (Math.abs(minutes) > 0 || Math.abs(seconds) > 0)) {
      throw new DateTimeException('Zone offset not in valid range: -18:00 to +18:00');
    }
  };
  ZoneOffset.of = function of(offsetId) {
    requireNonNull(offsetId, 'offsetId');
    var offset = ID_CACHE[offsetId];
    if (offset != null) {
      return offset;
    }
    var hours, minutes, seconds;
    switch (offsetId.length) {
      case 2:
        offsetId = offsetId[0] + "0" + offsetId[1];
      case 3:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = 0;
        seconds = 0;
        break;
      case 5:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 3, false);
        seconds = 0;
        break;
      case 6:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 4, true);
        seconds = 0;
        break;
      case 7:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 3, false);
        seconds = ZoneOffset._parseNumber(offsetId, 5, false);
        break;
      case 9:
        hours = ZoneOffset._parseNumber(offsetId, 1, false);
        minutes = ZoneOffset._parseNumber(offsetId, 4, true);
        seconds = ZoneOffset._parseNumber(offsetId, 7, true);
        break;
      default:
        throw new DateTimeException("Invalid ID for ZoneOffset, invalid format: " + offsetId);
    }
    var first = offsetId[0];
    if (first !== '+' && first !== '-') {
      throw new DateTimeException("Invalid ID for ZoneOffset, plus/minus not found when expected: " + offsetId);
    }
    if (first === '-') {
      return ZoneOffset.ofHoursMinutesSeconds(-hours, -minutes, -seconds);
    } else {
      return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, seconds);
    }
  };
  ZoneOffset._parseNumber = function _parseNumber(offsetId, pos, precededByColon) {
    if (precededByColon && offsetId[pos - 1] !== ':') {
      throw new DateTimeException("Invalid ID for ZoneOffset, colon not found when expected: " + offsetId);
    }
    var ch1 = offsetId[pos];
    var ch2 = offsetId[pos + 1];
    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {
      throw new DateTimeException("Invalid ID for ZoneOffset, non numeric characters found: " + offsetId);
    }
    return (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
  };
  ZoneOffset.ofHours = function ofHours(hours) {
    return ZoneOffset.ofHoursMinutesSeconds(hours, 0, 0);
  };
  ZoneOffset.ofHoursMinutes = function ofHoursMinutes(hours, minutes) {
    return ZoneOffset.ofHoursMinutesSeconds(hours, minutes, 0);
  };
  ZoneOffset.ofHoursMinutesSeconds = function ofHoursMinutesSeconds(hours, minutes, seconds) {
    ZoneOffset._validate(hours, minutes, seconds);
    var totalSeconds = hours * LocalTime.SECONDS_PER_HOUR + minutes * LocalTime.SECONDS_PER_MINUTE + seconds;
    return ZoneOffset.ofTotalSeconds(totalSeconds);
  };
  ZoneOffset.ofTotalMinutes = function ofTotalMinutes(totalMinutes) {
    var totalSeconds = totalMinutes * LocalTime.SECONDS_PER_MINUTE;
    return ZoneOffset.ofTotalSeconds(totalSeconds);
  };
  ZoneOffset.ofTotalSeconds = function ofTotalSeconds(totalSeconds) {
    if (totalSeconds % (15 * LocalTime.SECONDS_PER_MINUTE) === 0) {
      var totalSecs = totalSeconds;
      var result = SECONDS_CACHE[totalSecs];
      if (result == null) {
        result = new ZoneOffset(totalSeconds);
        SECONDS_CACHE[totalSecs] = result;
        ID_CACHE[result.id()] = result;
      }
      return result;
    } else {
      return new ZoneOffset(totalSeconds);
    }
  };
  _proto.rules = function rules() {
    return this._rules;
  };
  _proto.get = function get(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    if (field === ChronoField.OFFSET_SECONDS) {
      return this._totalSeconds;
    } else if (field instanceof ChronoField) {
      throw new DateTimeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.precision() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.OFFSET_SECONDS, this._totalSeconds);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    return other._totalSeconds - this._totalSeconds;
  };
  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }
    if (obj instanceof ZoneOffset) {
      return this._totalSeconds === obj._totalSeconds;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._totalSeconds;
  };
  _proto.toString = function toString() {
    return this._id;
  };
  return ZoneOffset;
}(ZoneId);
function _init$g() {
  ZoneOffset.MAX_SECONDS = 18 * LocalTime.SECONDS_PER_HOUR;
  ZoneOffset.UTC = ZoneOffset.ofTotalSeconds(0);
  ZoneOffset.MIN = ZoneOffset.ofTotalSeconds(-ZoneOffset.MAX_SECONDS);
  ZoneOffset.MAX = ZoneOffset.ofTotalSeconds(ZoneOffset.MAX_SECONDS);
}

var DateTimeBuilder = function (_TemporalAccessor) {
  _inheritsLoose(DateTimeBuilder, _TemporalAccessor);
  DateTimeBuilder.create = function create(field, value) {
    var dtb = new DateTimeBuilder();
    dtb._addFieldValue(field, value);
    return dtb;
  };
  function DateTimeBuilder() {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this.fieldValues = new EnumMap();
    _this.chrono = null;
    _this.zone = null;
    _this.date = null;
    _this.time = null;
    _this.leapSecond = false;
    _this.excessDays = null;
    return _this;
  }
  var _proto = DateTimeBuilder.prototype;
  _proto.getFieldValue0 = function getFieldValue0(field) {
    return this.fieldValues.get(field);
  };
  _proto._addFieldValue = function _addFieldValue(field, value) {
    requireNonNull(field, 'field');
    var old = this.getFieldValue0(field);
    if (old != null && old !== value) {
      throw new DateTimeException("Conflict found: " + field + " " + old + " differs from " + field + " " + value + ": " + this);
    }
    return this._putFieldValue0(field, value);
  };
  _proto._putFieldValue0 = function _putFieldValue0(field, value) {
    this.fieldValues.put(field, value);
    return this;
  };
  _proto.resolve = function resolve(resolverStyle, resolverFields) {
    if (resolverFields != null) {
      this.fieldValues.retainAll(resolverFields);
    }
    this._mergeDate(resolverStyle);
    this._mergeTime(resolverStyle);
    this._resolveTimeInferZeroes(resolverStyle);
    if (this.excessDays != null && this.excessDays.isZero() === false && this.date != null && this.time != null) {
      this.date = this.date.plus(this.excessDays);
      this.excessDays = Period.ZERO;
    }
    this._resolveInstant();
    return this;
  };
  _proto._mergeDate = function _mergeDate(resolverStyle) {
    this._checkDate(IsoChronology.INSTANCE.resolveDate(this.fieldValues, resolverStyle));
  };
  _proto._checkDate = function _checkDate(date) {
    if (date != null) {
      this._addObject(date);
      for (var fieldName in this.fieldValues.keySet()) {
        var field = ChronoField.byName(fieldName);
        if (field) {
          if (this.fieldValues.get(field) !== undefined) {
            if (field.isDateBased()) {
              var val1 = void 0;
              try {
                val1 = date.getLong(field);
              } catch (ex) {
                if (ex instanceof DateTimeException) {
                  continue;
                } else {
                  throw ex;
                }
              }
              var val2 = this.fieldValues.get(field);
              if (val1 !== val2) {
                throw new DateTimeException("Conflict found: Field " + field + " " + val1 + " differs from " + field + " " + val2 + " derived from " + date);
              }
            }
          }
        }
      }
    }
  };
  _proto._mergeTime = function _mergeTime(resolverStyle) {
    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_DAY)) {
      var ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        if (resolverStyle === ResolverStyle.SMART && ch === 0) ; else {
          ChronoField.CLOCK_HOUR_OF_DAY.checkValidValue(ch);
        }
      }
      this._addFieldValue(ChronoField.HOUR_OF_DAY, ch === 24 ? 0 : ch);
    }
    if (this.fieldValues.containsKey(ChronoField.CLOCK_HOUR_OF_AMPM)) {
      var _ch = this.fieldValues.remove(ChronoField.CLOCK_HOUR_OF_AMPM);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        if (resolverStyle === ResolverStyle.SMART && _ch === 0) ; else {
          ChronoField.CLOCK_HOUR_OF_AMPM.checkValidValue(_ch);
        }
      }
      this._addFieldValue(ChronoField.HOUR_OF_AMPM, _ch === 12 ? 0 : _ch);
    }
    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY)) {
        ChronoField.AMPM_OF_DAY.checkValidValue(this.fieldValues.get(ChronoField.AMPM_OF_DAY));
      }
      if (this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
        ChronoField.HOUR_OF_AMPM.checkValidValue(this.fieldValues.get(ChronoField.HOUR_OF_AMPM));
      }
    }
    if (this.fieldValues.containsKey(ChronoField.AMPM_OF_DAY) && this.fieldValues.containsKey(ChronoField.HOUR_OF_AMPM)) {
      var ap = this.fieldValues.remove(ChronoField.AMPM_OF_DAY);
      var hap = this.fieldValues.remove(ChronoField.HOUR_OF_AMPM);
      this._addFieldValue(ChronoField.HOUR_OF_DAY, ap * 12 + hap);
    }
    if (this.fieldValues.containsKey(ChronoField.NANO_OF_DAY)) {
      var nod = this.fieldValues.remove(ChronoField.NANO_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.NANO_OF_DAY.checkValidValue(nod);
      }
      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(nod, 1000000000));
      this._addFieldValue(ChronoField.NANO_OF_SECOND, MathUtil.intMod(nod, 1000000000));
    }
    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_DAY)) {
      var cod = this.fieldValues.remove(ChronoField.MICRO_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MICRO_OF_DAY.checkValidValue(cod);
      }
      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(cod, 1000000));
      this._addFieldValue(ChronoField.MICRO_OF_SECOND, MathUtil.intMod(cod, 1000000));
    }
    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_DAY)) {
      var lod = this.fieldValues.remove(ChronoField.MILLI_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MILLI_OF_DAY.checkValidValue(lod);
      }
      this._addFieldValue(ChronoField.SECOND_OF_DAY, MathUtil.intDiv(lod, 1000));
      this._addFieldValue(ChronoField.MILLI_OF_SECOND, MathUtil.intMod(lod, 1000));
    }
    if (this.fieldValues.containsKey(ChronoField.SECOND_OF_DAY)) {
      var sod = this.fieldValues.remove(ChronoField.SECOND_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.SECOND_OF_DAY.checkValidValue(sod);
      }
      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(sod, 3600));
      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(MathUtil.intDiv(sod, 60), 60));
      this._addFieldValue(ChronoField.SECOND_OF_MINUTE, MathUtil.intMod(sod, 60));
    }
    if (this.fieldValues.containsKey(ChronoField.MINUTE_OF_DAY)) {
      var mod = this.fieldValues.remove(ChronoField.MINUTE_OF_DAY);
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.MINUTE_OF_DAY.checkValidValue(mod);
      }
      this._addFieldValue(ChronoField.HOUR_OF_DAY, MathUtil.intDiv(mod, 60));
      this._addFieldValue(ChronoField.MINUTE_OF_HOUR, MathUtil.intMod(mod, 60));
    }
    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
        ChronoField.MILLI_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MILLI_OF_SECOND));
      }
      if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
        ChronoField.MICRO_OF_SECOND.checkValidValue(this.fieldValues.get(ChronoField.MICRO_OF_SECOND));
      }
    }
    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
      var los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
      var cos = this.fieldValues.get(ChronoField.MICRO_OF_SECOND);
      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, los * 1000 + MathUtil.intMod(cos, 1000));
    }
    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
      var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
      this._putFieldValue0(ChronoField.MICRO_OF_SECOND, MathUtil.intDiv(nos, 1000));
      this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
    }
    if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND) && this.fieldValues.containsKey(ChronoField.NANO_OF_SECOND)) {
      var _nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
      this._putFieldValue0(ChronoField.MILLI_OF_SECOND, MathUtil.intDiv(_nos, 1000000));
      this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
    }
    if (this.fieldValues.containsKey(ChronoField.MICRO_OF_SECOND)) {
      var _cos = this.fieldValues.remove(ChronoField.MICRO_OF_SECOND);
      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _cos * 1000);
    } else if (this.fieldValues.containsKey(ChronoField.MILLI_OF_SECOND)) {
      var _los = this.fieldValues.remove(ChronoField.MILLI_OF_SECOND);
      this._putFieldValue0(ChronoField.NANO_OF_SECOND, _los * 1000000);
    }
  };
  _proto._resolveTimeInferZeroes = function _resolveTimeInferZeroes(resolverStyle) {
    var hod = this.fieldValues.get(ChronoField.HOUR_OF_DAY);
    var moh = this.fieldValues.get(ChronoField.MINUTE_OF_HOUR);
    var som = this.fieldValues.get(ChronoField.SECOND_OF_MINUTE);
    var nos = this.fieldValues.get(ChronoField.NANO_OF_SECOND);
    if (hod == null) {
      return;
    }
    if (moh == null && (som != null || nos != null)) {
      return;
    }
    if (moh != null && som == null && nos != null) {
      return;
    }
    if (resolverStyle !== ResolverStyle.LENIENT) {
      if (hod != null) {
        if (resolverStyle === ResolverStyle.SMART && hod === 24 && (moh == null || moh === 0) && (som == null || som === 0) && (nos == null || nos === 0)) {
          hod = 0;
          this.excessDays = Period.ofDays(1);
        }
        var hodVal = ChronoField.HOUR_OF_DAY.checkValidIntValue(hod);
        if (moh != null) {
          var mohVal = ChronoField.MINUTE_OF_HOUR.checkValidIntValue(moh);
          if (som != null) {
            var somVal = ChronoField.SECOND_OF_MINUTE.checkValidIntValue(som);
            if (nos != null) {
              var nosVal = ChronoField.NANO_OF_SECOND.checkValidIntValue(nos);
              this._addObject(LocalTime.of(hodVal, mohVal, somVal, nosVal));
            } else {
              this._addObject(LocalTime.of(hodVal, mohVal, somVal));
            }
          } else {
            if (nos == null) {
              this._addObject(LocalTime.of(hodVal, mohVal));
            }
          }
        } else {
          if (som == null && nos == null) {
            this._addObject(LocalTime.of(hodVal, 0));
          }
        }
      }
    } else {
      if (hod != null) {
        var _hodVal = hod;
        if (moh != null) {
          if (som != null) {
            if (nos == null) {
              nos = 0;
            }
            var totalNanos = MathUtil.safeMultiply(_hodVal, 3600000000000);
            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(moh, 60000000000));
            totalNanos = MathUtil.safeAdd(totalNanos, MathUtil.safeMultiply(som, 1000000000));
            totalNanos = MathUtil.safeAdd(totalNanos, nos);
            var excessDays = MathUtil.floorDiv(totalNanos, 86400000000000);
            var nod = MathUtil.floorMod(totalNanos, 86400000000000);
            this._addObject(LocalTime.ofNanoOfDay(nod));
            this.excessDays = Period.ofDays(excessDays);
          } else {
            var totalSecs = MathUtil.safeMultiply(_hodVal, 3600);
            totalSecs = MathUtil.safeAdd(totalSecs, MathUtil.safeMultiply(moh, 60));
            var _excessDays = MathUtil.floorDiv(totalSecs, 86400);
            var sod = MathUtil.floorMod(totalSecs, 86400);
            this._addObject(LocalTime.ofSecondOfDay(sod));
            this.excessDays = Period.ofDays(_excessDays);
          }
        } else {
          var _excessDays2 = MathUtil.safeToInt(MathUtil.floorDiv(_hodVal, 24));
          _hodVal = MathUtil.floorMod(_hodVal, 24);
          this._addObject(LocalTime.of(_hodVal, 0));
          this.excessDays = Period.ofDays(_excessDays2);
        }
      }
    }
    this.fieldValues.remove(ChronoField.HOUR_OF_DAY);
    this.fieldValues.remove(ChronoField.MINUTE_OF_HOUR);
    this.fieldValues.remove(ChronoField.SECOND_OF_MINUTE);
    this.fieldValues.remove(ChronoField.NANO_OF_SECOND);
  };
  _proto._addObject = function _addObject(dateOrTime) {
    if (dateOrTime instanceof ChronoLocalDate) {
      this.date = dateOrTime;
    } else if (dateOrTime instanceof LocalTime) {
      this.time = dateOrTime;
    }
  };
  _proto._resolveInstant = function _resolveInstant() {
    if (this.date != null && this.time != null) {
      var offsetSecs = this.fieldValues.get(ChronoField.OFFSET_SECONDS);
      if (offsetSecs != null) {
        var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
        var instant = this.date.atTime(this.time).atZone(offset).getLong(ChronoField.INSTANT_SECONDS);
        this.fieldValues.put(ChronoField.INSTANT_SECONDS, instant);
      } else if (this.zone != null) {
        var _instant = this.date.atTime(this.time).atZone(this.zone).getLong(ChronoField.INSTANT_SECONDS);
        this.fieldValues.put(ChronoField.INSTANT_SECONDS, _instant);
      }
    }
  };
  _proto.build = function build(type) {
    return type.queryFrom(this);
  };
  _proto.isSupported = function isSupported(field) {
    if (field == null) {
      return false;
    }
    return this.fieldValues.containsKey(field) && this.fieldValues.get(field) !== undefined || this.date != null && this.date.isSupported(field) || this.time != null && this.time.isSupported(field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    var value = this.getFieldValue0(field);
    if (value == null) {
      if (this.date != null && this.date.isSupported(field)) {
        return this.date.getLong(field);
      }
      if (this.time != null && this.time.isSupported(field)) {
        return this.time.getLong(field);
      }
      throw new DateTimeException("Field not found: " + field);
    }
    return value;
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId()) {
      return this.zone;
    } else if (_query === TemporalQueries.chronology()) {
      return this.chrono;
    } else if (_query === TemporalQueries.localDate()) {
      return this.date != null ? LocalDate.from(this.date) : null;
    } else if (_query === TemporalQueries.localTime()) {
      return this.time;
    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
      return _query.queryFrom(this);
    } else if (_query === TemporalQueries.precision()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  return DateTimeBuilder;
}(TemporalAccessor);

var DateTimeParseContext = function () {
  function DateTimeParseContext() {
    if (arguments.length === 1) {
      if (arguments[0] instanceof DateTimeParseContext) {
        this._constructorSelf.apply(this, arguments);
        return;
      } else {
        this._constructorFormatter.apply(this, arguments);
      }
    } else {
      this._constructorParam.apply(this, arguments);
    }
    this._caseSensitive = true;
    this._strict = true;
    this._parsed = [new Parsed(this)];
  }
  var _proto = DateTimeParseContext.prototype;
  _proto._constructorParam = function _constructorParam(locale, symbols, chronology) {
    this._locale = locale;
    this._symbols = symbols;
    this._overrideChronology = chronology;
  };
  _proto._constructorFormatter = function _constructorFormatter(formatter) {
    this._locale = formatter.locale();
    this._symbols = formatter.decimalStyle();
    this._overrideChronology = formatter.chronology();
  };
  _proto._constructorSelf = function _constructorSelf(other) {
    this._locale = other._locale;
    this._symbols = other._symbols;
    this._overrideChronology = other._overrideChronology;
    this._overrideZone = other._overrideZone;
    this._caseSensitive = other._caseSensitive;
    this._strict = other._strict;
    this._parsed = [new Parsed(this)];
  };
  _proto.copy = function copy() {
    return new DateTimeParseContext(this);
  };
  _proto.symbols = function symbols() {
    return this._symbols;
  };
  _proto.isStrict = function isStrict() {
    return this._strict;
  };
  _proto.setStrict = function setStrict(strict) {
    this._strict = strict;
  };
  _proto.locale = function locale() {
    return this._locale;
  };
  _proto.setLocale = function setLocale(locale) {
    this._locale = locale;
  };
  _proto.startOptional = function startOptional() {
    this._parsed.push(this.currentParsed().copy());
  };
  _proto.endOptional = function endOptional(successful) {
    if (successful) {
      this._parsed.splice(this._parsed.length - 2, 1);
    } else {
      this._parsed.splice(this._parsed.length - 1, 1);
    }
  };
  _proto.isCaseSensitive = function isCaseSensitive() {
    return this._caseSensitive;
  };
  _proto.setCaseSensitive = function setCaseSensitive(caseSensitive) {
    this._caseSensitive = caseSensitive;
  };
  _proto.subSequenceEquals = function subSequenceEquals(cs1, offset1, cs2, offset2, length) {
    if (offset1 + length > cs1.length || offset2 + length > cs2.length) {
      return false;
    }
    if (!this.isCaseSensitive()) {
      cs1 = cs1.toLowerCase();
      cs2 = cs2.toLowerCase();
    }
    for (var i = 0; i < length; i++) {
      var ch1 = cs1[offset1 + i];
      var ch2 = cs2[offset2 + i];
      if (ch1 !== ch2) {
        return false;
      }
    }
    return true;
  };
  _proto.charEquals = function charEquals(ch1, ch2) {
    if (this.isCaseSensitive()) {
      return ch1 === ch2;
    }
    return this.charEqualsIgnoreCase(ch1, ch2);
  };
  _proto.charEqualsIgnoreCase = function charEqualsIgnoreCase(c1, c2) {
    return c1 === c2 || c1.toLowerCase() === c2.toLowerCase();
  };
  _proto.setParsedField = function setParsedField(field, value, errorPos, successPos) {
    var currentParsedFieldValues = this.currentParsed().fieldValues;
    var old = currentParsedFieldValues.get(field);
    currentParsedFieldValues.set(field, value);
    return old != null && old !== value ? ~errorPos : successPos;
  };
  _proto.setParsedZone = function setParsedZone(zone) {
    requireNonNull(zone, 'zone');
    this.currentParsed().zone = zone;
  };
  _proto.getParsed = function getParsed(field) {
    return this.currentParsed().fieldValues.get(field);
  };
  _proto.toParsed = function toParsed() {
    return this.currentParsed();
  };
  _proto.currentParsed = function currentParsed() {
    return this._parsed[this._parsed.length - 1];
  };
  _proto.setParsedLeapSecond = function setParsedLeapSecond() {
    this.currentParsed().leapSecond = true;
  };
  _proto.getEffectiveChronology = function getEffectiveChronology() {
    var chrono = this.currentParsed().chrono;
    if (chrono == null) {
      chrono = this._overrideChronology;
      if (chrono == null) {
        chrono = IsoChronology.INSTANCE;
      }
    }
    return chrono;
  };
  return DateTimeParseContext;
}();
var Parsed = function (_Temporal) {
  _inheritsLoose(Parsed, _Temporal);
  function Parsed(dateTimeParseContext) {
    var _this;
    _this = _Temporal.call(this) || this;
    _this.chrono = null;
    _this.zone = null;
    _this.fieldValues = new EnumMap();
    _this.leapSecond = false;
    _this.dateTimeParseContext = dateTimeParseContext;
    return _this;
  }
  var _proto2 = Parsed.prototype;
  _proto2.copy = function copy() {
    var cloned = new Parsed();
    cloned.chrono = this.chrono;
    cloned.zone = this.zone;
    cloned.fieldValues.putAll(this.fieldValues);
    cloned.leapSecond = this.leapSecond;
    cloned.dateTimeParseContext = this.dateTimeParseContext;
    return cloned;
  };
  _proto2.toString = function toString() {
    return this.fieldValues + ", " + this.chrono + ", " + this.zone;
  };
  _proto2.isSupported = function isSupported(field) {
    return this.fieldValues.containsKey(field);
  };
  _proto2.get = function get(field) {
    var val = this.fieldValues.get(field);
    assert(val != null);
    return val;
  };
  _proto2.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chrono;
    }
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
      return this.zone;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto2.toBuilder = function toBuilder() {
    var builder = new DateTimeBuilder();
    builder.fieldValues.putAll(this.fieldValues);
    builder.chrono = this.dateTimeParseContext.getEffectiveChronology();
    if (this.zone != null) {
      builder.zone = this.zone;
    } else {
      builder.zone = this.overrideZone;
    }
    builder.leapSecond = this.leapSecond;
    builder.excessDays = this.excessDays;
    return builder;
  };
  return Parsed;
}(Temporal);

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var DateTimePrintContext = function () {
  function DateTimePrintContext(temporal, localeOrFormatter, symbols) {
    if (arguments.length === 2 && arguments[1] instanceof DateTimeFormatter) {
      this._temporal = DateTimePrintContext.adjust(temporal, localeOrFormatter);
      this._locale = localeOrFormatter.locale();
      this._symbols = localeOrFormatter.decimalStyle();
    } else {
      this._temporal = temporal;
      this._locale = localeOrFormatter;
      this._symbols = symbols;
    }
    this._optional = 0;
  }
  DateTimePrintContext.adjust = function adjust(temporal, formatter) {
    return temporal;
  };
  var _proto = DateTimePrintContext.prototype;
  _proto.symbols = function symbols() {
    return this._symbols;
  };
  _proto.startOptional = function startOptional() {
    this._optional++;
  };
  _proto.endOptional = function endOptional() {
    this._optional--;
  };
  _proto.getValueQuery = function getValueQuery(query) {
    var result = this._temporal.query(query);
    if (result == null && this._optional === 0) {
      throw new DateTimeException("Unable to extract value: " + this._temporal);
    }
    return result;
  };
  _proto.getValue = function getValue(field) {
    try {
      return this._temporal.getLong(field);
    } catch (ex) {
      if (ex instanceof DateTimeException && this._optional > 0) {
        return null;
      }
      throw ex;
    }
  };
  _proto.temporal = function temporal() {
    return this._temporal;
  };
  _proto.locale = function locale() {
    return this._locale;
  };
  _proto.setDateTime = function setDateTime(temporal) {
    this._temporal = temporal;
  };
  _proto.setLocale = function setLocale(locale) {
    this._locale = locale;
  };
  return DateTimePrintContext;
}();

var IsoFields = {};
var QUARTER_DAYS = [0, 90, 181, 273, 0, 91, 182, 274];
var Field = function (_TemporalField) {
  _inheritsLoose(Field, _TemporalField);
  function Field() {
    return _TemporalField.apply(this, arguments) || this;
  }
  var _proto = Field.prototype;
  _proto.isDateBased = function isDateBased() {
    return true;
  };
  _proto.isTimeBased = function isTimeBased() {
    return false;
  };
  _proto._isIso = function _isIso() {
    return true;
  };
  Field._getWeekRangeByLocalDate = function _getWeekRangeByLocalDate(date) {
    var wby = Field._getWeekBasedYear(date);
    return ValueRange.of(1, Field._getWeekRangeByYear(wby));
  };
  Field._getWeekRangeByYear = function _getWeekRangeByYear(wby) {
    var date = LocalDate.of(wby, 1, 1);
    if (date.dayOfWeek() === DayOfWeek.THURSDAY || date.dayOfWeek() === DayOfWeek.WEDNESDAY && date.isLeapYear()) {
      return 53;
    }
    return 52;
  };
  Field._getWeek = function _getWeek(date) {
    var dow0 = date.dayOfWeek().ordinal();
    var doy0 = date.dayOfYear() - 1;
    var doyThu0 = doy0 + (3 - dow0);
    var alignedWeek = MathUtil.intDiv(doyThu0, 7);
    var firstThuDoy0 = doyThu0 - alignedWeek * 7;
    var firstMonDoy0 = firstThuDoy0 - 3;
    if (firstMonDoy0 < -3) {
      firstMonDoy0 += 7;
    }
    if (doy0 < firstMonDoy0) {
      return Field._getWeekRangeByLocalDate(date.withDayOfYear(180).minusYears(1)).maximum();
    }
    var week = MathUtil.intDiv(doy0 - firstMonDoy0, 7) + 1;
    if (week === 53) {
      if ((firstMonDoy0 === -3 || firstMonDoy0 === -2 && date.isLeapYear()) === false) {
        week = 1;
      }
    }
    return week;
  };
  Field._getWeekBasedYear = function _getWeekBasedYear(date) {
    var year = date.year();
    var doy = date.dayOfYear();
    if (doy <= 3) {
      var dow = date.dayOfWeek().ordinal();
      if (doy - dow < -2) {
        year--;
      }
    } else if (doy >= 363) {
      var _dow = date.dayOfWeek().ordinal();
      doy = doy - 363 - (date.isLeapYear() ? 1 : 0);
      if (doy - _dow >= 0) {
        year++;
      }
    }
    return year;
  };
  _proto.displayName = function displayName() {
    return this.toString();
  };
  _proto.resolve = function resolve() {
    return null;
  };
  _proto.name = function name() {
    return this.toString();
  };
  return Field;
}(TemporalField);
var DAY_OF_QUARTER_FIELD = function (_Field) {
  _inheritsLoose(DAY_OF_QUARTER_FIELD, _Field);
  function DAY_OF_QUARTER_FIELD() {
    return _Field.apply(this, arguments) || this;
  }
  var _proto2 = DAY_OF_QUARTER_FIELD.prototype;
  _proto2.toString = function toString() {
    return 'DayOfQuarter';
  };
  _proto2.baseUnit = function baseUnit() {
    return ChronoUnit.DAYS;
  };
  _proto2.rangeUnit = function rangeUnit() {
    return QUARTER_YEARS;
  };
  _proto2.range = function range() {
    return ValueRange.of(1, 90, 92);
  };
  _proto2.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.DAY_OF_YEAR) && temporal.isSupported(ChronoField.MONTH_OF_YEAR) && temporal.isSupported(ChronoField.YEAR) && this._isIso(temporal);
  };
  _proto2.rangeRefinedBy = function rangeRefinedBy(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');
    }
    var qoy = temporal.getLong(QUARTER_OF_YEAR);
    if (qoy === 1) {
      var year = temporal.getLong(ChronoField.YEAR);
      return IsoChronology.isLeapYear(year) ? ValueRange.of(1, 91) : ValueRange.of(1, 90);
    } else if (qoy === 2) {
      return ValueRange.of(1, 91);
    } else if (qoy === 3 || qoy === 4) {
      return ValueRange.of(1, 92);
    }
    return this.range();
  };
  _proto2.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: DayOfQuarter');
    }
    var doy = temporal.get(ChronoField.DAY_OF_YEAR);
    var moy = temporal.get(ChronoField.MONTH_OF_YEAR);
    var year = temporal.getLong(ChronoField.YEAR);
    return doy - QUARTER_DAYS[MathUtil.intDiv(moy - 1, 3) + (IsoChronology.isLeapYear(year) ? 4 : 0)];
  };
  _proto2.adjustInto = function adjustInto(temporal, newValue) {
    var curValue = this.getFrom(temporal);
    this.range().checkValidValue(newValue, this);
    return temporal.with(ChronoField.DAY_OF_YEAR, temporal.getLong(ChronoField.DAY_OF_YEAR) + (newValue - curValue));
  };
  _proto2.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
    var yearLong = fieldValues.get(ChronoField.YEAR);
    var qoyLong = fieldValues.get(QUARTER_OF_YEAR);
    if (yearLong == null || qoyLong == null) {
      return null;
    }
    var y = ChronoField.YEAR.checkValidIntValue(yearLong);
    var doq = fieldValues.get(DAY_OF_QUARTER);
    var date;
    if (resolverStyle === ResolverStyle.LENIENT) {
      var qoy = qoyLong;
      date = LocalDate.of(y, 1, 1);
      date = date.plusMonths(MathUtil.safeMultiply(MathUtil.safeSubtract(qoy, 1), 3));
      date = date.plusDays(MathUtil.safeSubtract(doq, 1));
    } else {
      var _qoy = QUARTER_OF_YEAR.range().checkValidIntValue(qoyLong, QUARTER_OF_YEAR);
      if (resolverStyle === ResolverStyle.STRICT) {
        var max = 92;
        if (_qoy === 1) {
          max = IsoChronology.isLeapYear(y) ? 91 : 90;
        } else if (_qoy === 2) {
          max = 91;
        }
        ValueRange.of(1, max).checkValidValue(doq, this);
      } else {
        this.range().checkValidValue(doq, this);
      }
      date = LocalDate.of(y, (_qoy - 1) * 3 + 1, 1).plusDays(doq - 1);
    }
    fieldValues.remove(this);
    fieldValues.remove(ChronoField.YEAR);
    fieldValues.remove(QUARTER_OF_YEAR);
    return date;
  };
  return DAY_OF_QUARTER_FIELD;
}(Field);
var QUARTER_OF_YEAR_FIELD = function (_Field2) {
  _inheritsLoose(QUARTER_OF_YEAR_FIELD, _Field2);
  function QUARTER_OF_YEAR_FIELD() {
    return _Field2.apply(this, arguments) || this;
  }
  var _proto3 = QUARTER_OF_YEAR_FIELD.prototype;
  _proto3.toString = function toString() {
    return 'QuarterOfYear';
  };
  _proto3.baseUnit = function baseUnit() {
    return QUARTER_YEARS;
  };
  _proto3.rangeUnit = function rangeUnit() {
    return ChronoUnit.YEARS;
  };
  _proto3.range = function range() {
    return ValueRange.of(1, 4);
  };
  _proto3.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.MONTH_OF_YEAR) && this._isIso(temporal);
  };
  _proto3.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return this.range();
  };
  _proto3.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: QuarterOfYear');
    }
    var moy = temporal.getLong(ChronoField.MONTH_OF_YEAR);
    return MathUtil.intDiv(moy + 2, 3);
  };
  _proto3.adjustInto = function adjustInto(temporal, newValue) {
    var curValue = this.getFrom(temporal);
    this.range().checkValidValue(newValue, this);
    return temporal.with(ChronoField.MONTH_OF_YEAR, temporal.getLong(ChronoField.MONTH_OF_YEAR) + (newValue - curValue) * 3);
  };
  return QUARTER_OF_YEAR_FIELD;
}(Field);
var WEEK_OF_WEEK_BASED_YEAR_FIELD = function (_Field3) {
  _inheritsLoose(WEEK_OF_WEEK_BASED_YEAR_FIELD, _Field3);
  function WEEK_OF_WEEK_BASED_YEAR_FIELD() {
    return _Field3.apply(this, arguments) || this;
  }
  var _proto4 = WEEK_OF_WEEK_BASED_YEAR_FIELD.prototype;
  _proto4.toString = function toString() {
    return 'WeekOfWeekBasedYear';
  };
  _proto4.baseUnit = function baseUnit() {
    return ChronoUnit.WEEKS;
  };
  _proto4.rangeUnit = function rangeUnit() {
    return WEEK_BASED_YEARS;
  };
  _proto4.range = function range() {
    return ValueRange.of(1, 52, 53);
  };
  _proto4.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
  };
  _proto4.rangeRefinedBy = function rangeRefinedBy(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');
    }
    return Field._getWeekRangeByLocalDate(LocalDate.from(temporal));
  };
  _proto4.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekOfWeekBasedYear');
    }
    return Field._getWeek(LocalDate.from(temporal));
  };
  _proto4.adjustInto = function adjustInto(temporal, newValue) {
    this.range().checkValidValue(newValue, this);
    return temporal.plus(MathUtil.safeSubtract(newValue, this.getFrom(temporal)), ChronoUnit.WEEKS);
  };
  _proto4.resolve = function resolve(fieldValues, partialTemporal, resolverStyle) {
    var wbyLong = fieldValues.get(WEEK_BASED_YEAR);
    var dowLong = fieldValues.get(ChronoField.DAY_OF_WEEK);
    if (wbyLong == null || dowLong == null) {
      return null;
    }
    var wby = WEEK_BASED_YEAR.range().checkValidIntValue(wbyLong, WEEK_BASED_YEAR);
    var wowby = fieldValues.get(WEEK_OF_WEEK_BASED_YEAR);
    var date;
    if (resolverStyle === ResolverStyle.LENIENT) {
      var dow = dowLong;
      var weeks = 0;
      if (dow > 7) {
        weeks = MathUtil.intDiv(dow - 1, 7);
        dow = MathUtil.intMod(dow - 1, 7) + 1;
      } else if (dow < 1) {
        weeks = MathUtil.intDiv(dow, 7) - 1;
        dow = MathUtil.intMod(dow, 7) + 7;
      }
      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).plusWeeks(weeks).with(ChronoField.DAY_OF_WEEK, dow);
    } else {
      var _dow2 = ChronoField.DAY_OF_WEEK.checkValidIntValue(dowLong);
      if (resolverStyle === ResolverStyle.STRICT) {
        var temp = LocalDate.of(wby, 1, 4);
        var range = Field._getWeekRangeByLocalDate(temp);
        range.checkValidValue(wowby, this);
      } else {
        this.range().checkValidValue(wowby, this);
      }
      date = LocalDate.of(wby, 1, 4).plusWeeks(wowby - 1).with(ChronoField.DAY_OF_WEEK, _dow2);
    }
    fieldValues.remove(this);
    fieldValues.remove(WEEK_BASED_YEAR);
    fieldValues.remove(ChronoField.DAY_OF_WEEK);
    return date;
  };
  _proto4.displayName = function displayName() {
    return 'Week';
  };
  return WEEK_OF_WEEK_BASED_YEAR_FIELD;
}(Field);
var WEEK_BASED_YEAR_FIELD = function (_Field4) {
  _inheritsLoose(WEEK_BASED_YEAR_FIELD, _Field4);
  function WEEK_BASED_YEAR_FIELD() {
    return _Field4.apply(this, arguments) || this;
  }
  var _proto5 = WEEK_BASED_YEAR_FIELD.prototype;
  _proto5.toString = function toString() {
    return 'WeekBasedYear';
  };
  _proto5.baseUnit = function baseUnit() {
    return WEEK_BASED_YEARS;
  };
  _proto5.rangeUnit = function rangeUnit() {
    return ChronoUnit.FOREVER;
  };
  _proto5.range = function range() {
    return ChronoField.YEAR.range();
  };
  _proto5.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY) && this._isIso(temporal);
  };
  _proto5.rangeRefinedBy = function rangeRefinedBy(temporal) {
    return ChronoField.YEAR.range();
  };
  _proto5.getFrom = function getFrom(temporal) {
    if (temporal.isSupported(this) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');
    }
    return Field._getWeekBasedYear(LocalDate.from(temporal));
  };
  _proto5.adjustInto = function adjustInto(temporal, newValue) {
    if (this.isSupportedBy(temporal) === false) {
      throw new UnsupportedTemporalTypeException('Unsupported field: WeekBasedYear');
    }
    var newWby = this.range().checkValidIntValue(newValue, WEEK_BASED_YEAR);
    var date = LocalDate.from(temporal);
    var dow = date.get(ChronoField.DAY_OF_WEEK);
    var week = Field._getWeek(date);
    if (week === 53 && Field._getWeekRangeByYear(newWby) === 52) {
      week = 52;
    }
    var resolved = LocalDate.of(newWby, 1, 4);
    var days = dow - resolved.get(ChronoField.DAY_OF_WEEK) + (week - 1) * 7;
    resolved = resolved.plusDays(days);
    return temporal.with(resolved);
  };
  return WEEK_BASED_YEAR_FIELD;
}(Field);
var Unit = function (_TemporalUnit) {
  _inheritsLoose(Unit, _TemporalUnit);
  function Unit(name, estimatedDuration) {
    var _this;
    _this = _TemporalUnit.call(this) || this;
    _this._name = name;
    _this._duration = estimatedDuration;
    return _this;
  }
  var _proto6 = Unit.prototype;
  _proto6.duration = function duration() {
    return this._duration;
  };
  _proto6.isDurationEstimated = function isDurationEstimated() {
    return true;
  };
  _proto6.isDateBased = function isDateBased() {
    return true;
  };
  _proto6.isTimeBased = function isTimeBased() {
    return false;
  };
  _proto6.isSupportedBy = function isSupportedBy(temporal) {
    return temporal.isSupported(ChronoField.EPOCH_DAY);
  };
  _proto6.addTo = function addTo(temporal, periodToAdd) {
    switch (this) {
      case WEEK_BASED_YEARS:
        {
          var added = MathUtil.safeAdd(temporal.get(WEEK_BASED_YEAR), periodToAdd);
          return temporal.with(WEEK_BASED_YEAR, added);
        }
      case QUARTER_YEARS:
        return temporal.plus(MathUtil.intDiv(periodToAdd, 256), ChronoUnit.YEARS).plus(MathUtil.intMod(periodToAdd, 256) * 3, ChronoUnit.MONTHS);
      default:
        throw new IllegalStateException('Unreachable');
    }
  };
  _proto6.between = function between(temporal1, temporal2) {
    switch (this) {
      case WEEK_BASED_YEARS:
        return MathUtil.safeSubtract(temporal2.getLong(WEEK_BASED_YEAR), temporal1.getLong(WEEK_BASED_YEAR));
      case QUARTER_YEARS:
        return MathUtil.intDiv(temporal1.until(temporal2, ChronoUnit.MONTHS), 3);
      default:
        throw new IllegalStateException('Unreachable');
    }
  };
  _proto6.toString = function toString() {
    return this._name;
  };
  return Unit;
}(TemporalUnit);
var DAY_OF_QUARTER = null;
var QUARTER_OF_YEAR = null;
var WEEK_OF_WEEK_BASED_YEAR = null;
var WEEK_BASED_YEAR = null;
var WEEK_BASED_YEARS = null;
var QUARTER_YEARS = null;
function _init$f() {
  DAY_OF_QUARTER = new DAY_OF_QUARTER_FIELD();
  QUARTER_OF_YEAR = new QUARTER_OF_YEAR_FIELD();
  WEEK_OF_WEEK_BASED_YEAR = new WEEK_OF_WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEAR = new WEEK_BASED_YEAR_FIELD();
  WEEK_BASED_YEARS = new Unit('WeekBasedYears', Duration.ofSeconds(31556952));
  QUARTER_YEARS = new Unit('QuarterYears', Duration.ofSeconds(31556952 / 4));
  IsoFields.DAY_OF_QUARTER = DAY_OF_QUARTER;
  IsoFields.QUARTER_OF_YEAR = QUARTER_OF_YEAR;
  IsoFields.WEEK_OF_WEEK_BASED_YEAR = WEEK_OF_WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEAR = WEEK_BASED_YEAR;
  IsoFields.WEEK_BASED_YEARS = WEEK_BASED_YEARS;
  IsoFields.QUARTER_YEARS = QUARTER_YEARS;
  LocalDate.prototype.isoWeekOfWeekyear = function () {
    return this.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR);
  };
  LocalDate.prototype.isoWeekyear = function () {
    return this.get(IsoFields.WEEK_BASED_YEAR);
  };
}

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var DecimalStyle = function () {
  function DecimalStyle(zeroChar, positiveSignChar, negativeSignChar, decimalPointChar) {
    this._zeroDigit = zeroChar;
    this._zeroDigitCharCode = zeroChar.charCodeAt(0);
    this._positiveSign = positiveSignChar;
    this._negativeSign = negativeSignChar;
    this._decimalSeparator = decimalPointChar;
  }
  var _proto = DecimalStyle.prototype;
  _proto.positiveSign = function positiveSign() {
    return this._positiveSign;
  };
  _proto.withPositiveSign = function withPositiveSign(positiveSign) {
    if (positiveSign === this._positiveSign) {
      return this;
    }
    return new DecimalStyle(this._zeroDigit, positiveSign, this._negativeSign, this._decimalSeparator);
  };
  _proto.negativeSign = function negativeSign() {
    return this._negativeSign;
  };
  _proto.withNegativeSign = function withNegativeSign(negativeSign) {
    if (negativeSign === this._negativeSign) {
      return this;
    }
    return new DecimalStyle(this._zeroDigit, this._positiveSign, negativeSign, this._decimalSeparator);
  };
  _proto.zeroDigit = function zeroDigit() {
    return this._zeroDigit;
  };
  _proto.withZeroDigit = function withZeroDigit(zeroDigit) {
    if (zeroDigit === this._zeroDigit) {
      return this;
    }
    return new DecimalStyle(zeroDigit, this._positiveSign, this._negativeSign, this._decimalSeparator);
  };
  _proto.decimalSeparator = function decimalSeparator() {
    return this._decimalSeparator;
  };
  _proto.withDecimalSeparator = function withDecimalSeparator(decimalSeparator) {
    if (decimalSeparator === this._decimalSeparator) {
      return this;
    }
    return new DecimalStyle(this._zeroDigit, this._positiveSign, this._negativeSign, decimalSeparator);
  };
  _proto.convertToDigit = function convertToDigit(char) {
    var val = char.charCodeAt(0) - this._zeroDigitCharCode;
    return val >= 0 && val <= 9 ? val : -1;
  };
  _proto.convertNumberToI18N = function convertNumberToI18N(numericText) {
    if (this._zeroDigit === '0') {
      return numericText;
    }
    var diff = this._zeroDigitCharCode - '0'.charCodeAt(0);
    var convertedText = '';
    for (var i = 0; i < numericText.length; i++) {
      convertedText += String.fromCharCode(numericText.charCodeAt(i) + diff);
    }
    return convertedText;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof DecimalStyle) {
      return this._zeroDigit === other._zeroDigit && this._positiveSign === other._positiveSign && this._negativeSign === other._negativeSign && this._decimalSeparator === other._decimalSeparator;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator;
  };
  _proto.toString = function toString() {
    return "DecimalStyle[" + this._zeroDigit + this._positiveSign + this._negativeSign + this._decimalSeparator + "]";
  };
  DecimalStyle.of = function of() {
    throw new Error('not yet supported');
  };
  DecimalStyle.availableLocales = function availableLocales() {
    throw new Error('not yet supported');
  };
  return DecimalStyle;
}();
DecimalStyle.STANDARD = new DecimalStyle('0', '+', '-', '.');

var SignStyle = function (_Enum) {
  _inheritsLoose(SignStyle, _Enum);
  function SignStyle() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = SignStyle.prototype;
  _proto.parse = function parse(positive, strict, fixedWidth) {
    switch (this) {
      case SignStyle.NORMAL:
        return !positive || !strict;
      case SignStyle.ALWAYS:
      case SignStyle.EXCEEDS_PAD:
        return true;
      default:
        return !strict && !fixedWidth;
    }
  };
  return SignStyle;
}(Enum);
SignStyle.NORMAL = new SignStyle('NORMAL');
SignStyle.NEVER = new SignStyle('NEVER');
SignStyle.ALWAYS = new SignStyle('ALWAYS');
SignStyle.EXCEEDS_PAD = new SignStyle('EXCEEDS_PAD');
SignStyle.NOT_NEGATIVE = new SignStyle('NOT_NEGATIVE');

var TextStyle = function (_Enum) {
  _inheritsLoose(TextStyle, _Enum);
  function TextStyle() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = TextStyle.prototype;
  _proto.isStandalone = function isStandalone() {
    switch (this) {
      case TextStyle.FULL_STANDALONE:
      case TextStyle.SHORT_STANDALONE:
      case TextStyle.NARROW_STANDALONE:
        return true;
      default:
        return false;
    }
  };
  _proto.asStandalone = function asStandalone() {
    switch (this) {
      case TextStyle.FULL:
        return TextStyle.FULL_STANDALONE;
      case TextStyle.SHORT:
        return TextStyle.SHORT_STANDALONE;
      case TextStyle.NARROW:
        return TextStyle.NARROW_STANDALONE;
      default:
        return this;
    }
  };
  _proto.asNormal = function asNormal() {
    switch (this) {
      case TextStyle.FULL_STANDALONE:
        return TextStyle.FULL;
      case TextStyle.SHORT_STANDALONE:
        return TextStyle.SHORT;
      case TextStyle.NARROW_STANDALONE:
        return TextStyle.NARROW;
      default:
        return this;
    }
  };
  return TextStyle;
}(Enum);
TextStyle.FULL = new TextStyle('FULL');
TextStyle.FULL_STANDALONE = new TextStyle('FULL_STANDALONE');
TextStyle.SHORT = new TextStyle('SHORT');
TextStyle.SHORT_STANDALONE = new TextStyle('SHORT_STANDALONE');
TextStyle.NARROW = new TextStyle('NARROW');
TextStyle.NARROW_STANDALONE = new TextStyle('NARROW_STANDALONE');

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var CharLiteralPrinterParser = function () {
  function CharLiteralPrinterParser(literal) {
    if (literal.length > 1) {
      throw new IllegalArgumentException("invalid literal, too long: \"" + literal + "\"");
    }
    this._literal = literal;
  }
  var _proto = CharLiteralPrinterParser.prototype;
  _proto.print = function print(context, buf) {
    buf.append(this._literal);
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    if (position === length) {
      return ~position;
    }
    var ch = text.charAt(position);
    if (context.charEquals(this._literal, ch) === false) {
      return ~position;
    }
    return position + this._literal.length;
  };
  _proto.toString = function toString() {
    if (this._literal === '\'') {
      return "''";
    }
    return "'" + this._literal + "'";
  };
  return CharLiteralPrinterParser;
}();

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var CompositePrinterParser = function () {
  function CompositePrinterParser(printerParsers, optional) {
    this._printerParsers = printerParsers;
    this._optional = optional;
  }
  var _proto = CompositePrinterParser.prototype;
  _proto.withOptional = function withOptional(optional) {
    if (optional === this._optional) {
      return this;
    }
    return new CompositePrinterParser(this._printerParsers, optional);
  };
  _proto.print = function print(context, buf) {
    var length = buf.length();
    if (this._optional) {
      context.startOptional();
    }
    try {
      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        if (pp.print(context, buf) === false) {
          buf.setLength(length);
          return true;
        }
      }
    } finally {
      if (this._optional) {
        context.endOptional();
      }
    }
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    if (this._optional) {
      context.startOptional();
      var pos = position;
      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        pos = pp.parse(context, text, pos);
        if (pos < 0) {
          context.endOptional(false);
          return position;
        }
      }
      context.endOptional(true);
      return pos;
    } else {
      for (var _i = 0; _i < this._printerParsers.length; _i++) {
        var _pp = this._printerParsers[_i];
        position = _pp.parse(context, text, position);
        if (position < 0) {
          break;
        }
      }
      return position;
    }
  };
  _proto.toString = function toString() {
    var buf = '';
    if (this._printerParsers != null) {
      buf += this._optional ? '[' : '(';
      for (var i = 0; i < this._printerParsers.length; i++) {
        var pp = this._printerParsers[i];
        buf += pp.toString();
      }
      buf += this._optional ? ']' : ')';
    }
    return buf;
  };
  return CompositePrinterParser;
}();

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var FractionPrinterParser = function () {
  function FractionPrinterParser(field, minWidth, maxWidth, decimalPoint) {
    requireNonNull(field, 'field');
    if (field.range().isFixed() === false) {
      throw new IllegalArgumentException("Field must have a fixed set of values: " + field);
    }
    if (minWidth < 0 || minWidth > 9) {
      throw new IllegalArgumentException("Minimum width must be from 0 to 9 inclusive but was " + minWidth);
    }
    if (maxWidth < 1 || maxWidth > 9) {
      throw new IllegalArgumentException("Maximum width must be from 1 to 9 inclusive but was " + maxWidth);
    }
    if (maxWidth < minWidth) {
      throw new IllegalArgumentException("Maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
    }
    this.field = field;
    this.minWidth = minWidth;
    this.maxWidth = maxWidth;
    this.decimalPoint = decimalPoint;
  }
  var _proto = FractionPrinterParser.prototype;
  _proto.print = function print(context, buf) {
    var value = context.getValue(this.field);
    if (value === null) {
      return false;
    }
    var symbols = context.symbols();
    if (value === 0) {
      if (this.minWidth > 0) {
        if (this.decimalPoint) {
          buf.append(symbols.decimalSeparator());
        }
        for (var i = 0; i < this.minWidth; i++) {
          buf.append(symbols.zeroDigit());
        }
      }
    } else {
      var fraction = this.convertToFraction(value, symbols.zeroDigit());
      var outputScale = Math.min(Math.max(fraction.length, this.minWidth), this.maxWidth);
      fraction = fraction.substr(0, outputScale);
      if (fraction * 1 > 0) {
        while (fraction.length > this.minWidth && fraction[fraction.length - 1] === '0') {
          fraction = fraction.substr(0, fraction.length - 1);
        }
      }
      var str = fraction;
      str = symbols.convertNumberToI18N(str);
      if (this.decimalPoint) {
        buf.append(symbols.decimalSeparator());
      }
      buf.append(str);
    }
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var effectiveMin = context.isStrict() ? this.minWidth : 0;
    var effectiveMax = context.isStrict() ? this.maxWidth : 9;
    var length = text.length;
    if (position === length) {
      return effectiveMin > 0 ? ~position : position;
    }
    if (this.decimalPoint) {
      if (text[position] !== context.symbols().decimalSeparator()) {
        return effectiveMin > 0 ? ~position : position;
      }
      position++;
    }
    var minEndPos = position + effectiveMin;
    if (minEndPos > length) {
      return ~position;
    }
    var maxEndPos = Math.min(position + effectiveMax, length);
    var total = 0;
    var pos = position;
    while (pos < maxEndPos) {
      var ch = text.charAt(pos++);
      var digit = context.symbols().convertToDigit(ch);
      if (digit < 0) {
        if (pos < minEndPos) {
          return ~position;
        }
        pos--;
        break;
      }
      total = total * 10 + digit;
    }
    var moveLeft = pos - position;
    var scale = Math.pow(10, moveLeft);
    var value = this.convertFromFraction(total, scale);
    return context.setParsedField(this.field, value, position, pos);
  };
  _proto.convertToFraction = function convertToFraction(value, zeroDigit) {
    var range = this.field.range();
    range.checkValidValue(value, this.field);
    var _min = range.minimum();
    var _range = range.maximum() - _min + 1;
    var _value = value - _min;
    var _scaled = MathUtil.intDiv(_value * 1000000000, _range);
    var fraction = "" + _scaled;
    while (fraction.length < 9) {
      fraction = zeroDigit + fraction;
    }
    return fraction;
  };
  _proto.convertFromFraction = function convertFromFraction(total, scale) {
    var range = this.field.range();
    var _min = range.minimum();
    var _range = range.maximum() - _min + 1;
    var _value = MathUtil.intDiv(total * _range, scale);
    return _value;
  };
  _proto.toString = function toString() {
    var decimal = this.decimalPoint ? ',DecimalPoint' : '';
    return "Fraction(" + this.field + "," + this.minWidth + "," + this.maxWidth + decimal + ")";
  };
  return FractionPrinterParser;
}();

var MAX_WIDTH$1 = 15;
var EXCEED_POINTS = [0, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000];
var NumberPrinterParser = function () {
  function NumberPrinterParser(field, minWidth, maxWidth, signStyle, subsequentWidth) {
    if (subsequentWidth === void 0) {
      subsequentWidth = 0;
    }
    this._field = field;
    this._minWidth = minWidth;
    this._maxWidth = maxWidth;
    this._signStyle = signStyle;
    this._subsequentWidth = subsequentWidth;
  }
  var _proto = NumberPrinterParser.prototype;
  _proto.field = function field() {
    return this._field;
  };
  _proto.minWidth = function minWidth() {
    return this._minWidth;
  };
  _proto.maxWidth = function maxWidth() {
    return this._maxWidth;
  };
  _proto.signStyle = function signStyle() {
    return this._signStyle;
  };
  _proto.withFixedWidth = function withFixedWidth() {
    if (this._subsequentWidth === -1) {
      return this;
    }
    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, -1);
  };
  _proto.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
    return new NumberPrinterParser(this._field, this._minWidth, this._maxWidth, this._signStyle, this._subsequentWidth + subsequentWidth);
  };
  _proto._isFixedWidth = function _isFixedWidth() {
    return this._subsequentWidth === -1 || this._subsequentWidth > 0 && this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE;
  };
  _proto.print = function print(context, buf) {
    var contextValue = context.getValue(this._field);
    if (contextValue == null) {
      return false;
    }
    var value = this._getValue(context, contextValue);
    var symbols = context.symbols();
    var str = "" + Math.abs(value);
    if (str.length > this._maxWidth) {
      throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " exceeds the maximum print width of " + this._maxWidth);
    }
    str = symbols.convertNumberToI18N(str);
    if (value >= 0) {
      switch (this._signStyle) {
        case SignStyle.EXCEEDS_PAD:
          if (this._minWidth < MAX_WIDTH$1 && value >= EXCEED_POINTS[this._minWidth]) {
            buf.append(symbols.positiveSign());
          }
          break;
        case SignStyle.ALWAYS:
          buf.append(symbols.positiveSign());
          break;
      }
    } else {
      switch (this._signStyle) {
        case SignStyle.NORMAL:
        case SignStyle.EXCEEDS_PAD:
        case SignStyle.ALWAYS:
          buf.append(symbols.negativeSign());
          break;
        case SignStyle.NOT_NEGATIVE:
          throw new DateTimeException("Field " + this._field + " cannot be printed as the value " + value + " cannot be negative according to the SignStyle");
      }
    }
    for (var i = 0; i < this._minWidth - str.length; i++) {
      buf.append(symbols.zeroDigit());
    }
    buf.append(str);
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    if (position === length) {
      return ~position;
    }
    assert(position >= 0 && position < length);
    var sign = text.charAt(position);
    var negative = false;
    var positive = false;
    if (sign === context.symbols().positiveSign()) {
      if (this._signStyle.parse(true, context.isStrict(), this._minWidth === this._maxWidth) === false) {
        return ~position;
      }
      positive = true;
      position++;
    } else if (sign === context.symbols().negativeSign()) {
      if (this._signStyle.parse(false, context.isStrict(), this._minWidth === this._maxWidth) === false) {
        return ~position;
      }
      negative = true;
      position++;
    } else {
      if (this._signStyle === SignStyle.ALWAYS && context.isStrict()) {
        return ~position;
      }
    }
    var effMinWidth = context.isStrict() || this._isFixedWidth() ? this._minWidth : 1;
    var minEndPos = position + effMinWidth;
    if (minEndPos > length) {
      return ~position;
    }
    var effMaxWidth = (context.isStrict() || this._isFixedWidth() ? this._maxWidth : 9) + Math.max(this._subsequentWidth, 0);
    var total = 0;
    var pos = position;
    for (var pass = 0; pass < 2; pass++) {
      var maxEndPos = Math.min(pos + effMaxWidth, length);
      while (pos < maxEndPos) {
        var ch = text.charAt(pos++);
        var digit = context.symbols().convertToDigit(ch);
        if (digit < 0) {
          pos--;
          if (pos < minEndPos) {
            return ~position;
          }
          break;
        }
        if (pos - position > MAX_WIDTH$1) {
          throw new ArithmeticException('number text exceeds length');
        } else {
          total = total * 10 + digit;
        }
      }
      if (this._subsequentWidth > 0 && pass === 0) {
        var parseLen = pos - position;
        effMaxWidth = Math.max(effMinWidth, parseLen - this._subsequentWidth);
        pos = position;
        total = 0;
      } else {
        break;
      }
    }
    if (negative) {
      if (total === 0 && context.isStrict()) {
        return ~(position - 1);
      }
      if (total !== 0) {
        total = -total;
      }
    } else if (this._signStyle === SignStyle.EXCEEDS_PAD && context.isStrict()) {
      var _parseLen = pos - position;
      if (positive) {
        if (_parseLen <= this._minWidth) {
          return ~(position - 1);
        }
      } else {
        if (_parseLen > this._minWidth) {
          return ~position;
        }
      }
    }
    return this._setValue(context, total, position, pos);
  };
  _proto._getValue = function _getValue(context, value) {
    return value;
  };
  _proto._setValue = function _setValue(context, value, errorPos, successPos) {
    return context.setParsedField(this._field, value, errorPos, successPos);
  };
  _proto.toString = function toString() {
    if (this._minWidth === 1 && this._maxWidth === MAX_WIDTH$1 && this._signStyle === SignStyle.NORMAL) {
      return "Value(" + this._field + ")";
    }
    if (this._minWidth === this._maxWidth && this._signStyle === SignStyle.NOT_NEGATIVE) {
      return "Value(" + this._field + "," + this._minWidth + ")";
    }
    return "Value(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + this._signStyle + ")";
  };
  return NumberPrinterParser;
}();
var ReducedPrinterParser = function (_NumberPrinterParser) {
  _inheritsLoose(ReducedPrinterParser, _NumberPrinterParser);
  function ReducedPrinterParser(field, width, maxWidth, baseValue, baseDate) {
    var _this;
    _this = _NumberPrinterParser.call(this, field, width, maxWidth, SignStyle.NOT_NEGATIVE) || this;
    if (width < 1 || width > 10) {
      throw new IllegalArgumentException("The width must be from 1 to 10 inclusive but was " + width);
    }
    if (maxWidth < 1 || maxWidth > 10) {
      throw new IllegalArgumentException("The maxWidth must be from 1 to 10 inclusive but was " + maxWidth);
    }
    if (maxWidth < width) {
      throw new IllegalArgumentException('The maxWidth must be greater than the width');
    }
    if (baseDate === null) {
      if (field.range().isValidValue(baseValue) === false) {
        throw new IllegalArgumentException('The base value must be within the range of the field');
      }
      if (baseValue + EXCEED_POINTS[width] > MathUtil.MAX_SAFE_INTEGER) {
        throw new DateTimeException('Unable to add printer-parser as the range exceeds the capacity of an int');
      }
    }
    _this._baseValue = baseValue;
    _this._baseDate = baseDate;
    return _this;
  }
  var _proto2 = ReducedPrinterParser.prototype;
  _proto2._getValue = function _getValue(context, value) {
    var absValue = Math.abs(value);
    var baseValue = this._baseValue;
    if (this._baseDate !== null) {
      context.temporal();
      var chrono = IsoChronology.INSTANCE;
      baseValue = chrono.date(this._baseDate).get(this._field);
    }
    if (value >= baseValue && value < baseValue + EXCEED_POINTS[this._minWidth]) {
      return absValue % EXCEED_POINTS[this._minWidth];
    }
    return absValue % EXCEED_POINTS[this._maxWidth];
  };
  _proto2._setValue = function _setValue(context, value, errorPos, successPos) {
    var baseValue = this._baseValue;
    if (this._baseDate != null) {
      var chrono = context.getEffectiveChronology();
      baseValue = chrono.date(this._baseDate).get(this._field);
    }
    var parseLen = successPos - errorPos;
    if (parseLen === this._minWidth && value >= 0) {
      var range = EXCEED_POINTS[this._minWidth];
      var lastPart = baseValue % range;
      var basePart = baseValue - lastPart;
      if (baseValue > 0) {
        value = basePart + value;
      } else {
        value = basePart - value;
      }
      if (value < baseValue) {
        value += range;
      }
    }
    return context.setParsedField(this._field, value, errorPos, successPos);
  };
  _proto2.withFixedWidth = function withFixedWidth() {
    if (this._subsequentWidth === -1) {
      return this;
    }
    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate);
  };
  _proto2.withSubsequentWidth = function withSubsequentWidth(subsequentWidth) {
    return new ReducedPrinterParser(this._field, this._minWidth, this._maxWidth, this._baseValue, this._baseDate, this._subsequentWidth + subsequentWidth);
  };
  _proto2.isFixedWidth = function isFixedWidth(context) {
    if (context.isStrict() === false) {
      return false;
    }
    return _NumberPrinterParser.prototype.isFixedWidth.call(this, context);
  };
  _proto2.toString = function toString() {
    return "ReducedValue(" + this._field + "," + this._minWidth + "," + this._maxWidth + "," + (this._baseDate != null ? this._baseDate : this._baseValue) + ")";
  };
  return ReducedPrinterParser;
}(NumberPrinterParser);

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var PATTERNS = ['+HH', '+HHmm', '+HH:mm', '+HHMM', '+HH:MM', '+HHMMss', '+HH:MM:ss', '+HHMMSS', '+HH:MM:SS'];
var OffsetIdPrinterParser = function () {
  function OffsetIdPrinterParser(noOffsetText, pattern) {
    requireNonNull(noOffsetText, 'noOffsetText');
    requireNonNull(pattern, 'pattern');
    this.noOffsetText = noOffsetText;
    this.type = this._checkPattern(pattern);
  }
  var _proto = OffsetIdPrinterParser.prototype;
  _proto._checkPattern = function _checkPattern(pattern) {
    for (var i = 0; i < PATTERNS.length; i++) {
      if (PATTERNS[i] === pattern) {
        return i;
      }
    }
    throw new IllegalArgumentException("Invalid zone offset pattern: " + pattern);
  };
  _proto.print = function print(context, buf) {
    var offsetSecs = context.getValue(ChronoField.OFFSET_SECONDS);
    if (offsetSecs == null) {
      return false;
    }
    var totalSecs = MathUtil.safeToInt(offsetSecs);
    if (totalSecs === 0) {
      buf.append(this.noOffsetText);
    } else {
      var absHours = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 3600), 100));
      var absMinutes = Math.abs(MathUtil.intMod(MathUtil.intDiv(totalSecs, 60), 60));
      var absSeconds = Math.abs(MathUtil.intMod(totalSecs, 60));
      var bufPos = buf.length();
      var output = absHours;
      buf.append(totalSecs < 0 ? '-' : '+').appendChar(MathUtil.intDiv(absHours, 10) + "0").appendChar(MathUtil.intMod(absHours, 10) + "0");
      if (this.type >= 3 || this.type >= 1 && absMinutes > 0) {
        buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absMinutes, 10) + "0").appendChar(absMinutes % 10 + "0");
        output += absMinutes;
        if (this.type >= 7 || this.type >= 5 && absSeconds > 0) {
          buf.append(this.type % 2 === 0 ? ':' : '').appendChar(MathUtil.intDiv(absSeconds, 10) + "0").appendChar(absSeconds % 10 + "0");
          output += absSeconds;
        }
      }
      if (output === 0) {
        buf.setLength(bufPos);
        buf.append(this.noOffsetText);
      }
    }
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    var noOffsetLen = this.noOffsetText.length;
    if (noOffsetLen === 0) {
      if (position === length) {
        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position);
      }
    } else {
      if (position === length) {
        return ~position;
      }
      if (context.subSequenceEquals(text, position, this.noOffsetText, 0, noOffsetLen)) {
        return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
      }
    }
    var sign = text[position];
    if (sign === '+' || sign === '-') {
      var negative = sign === '-' ? -1 : 1;
      var array = [0, 0, 0, 0];
      array[0] = position + 1;
      if ((this._parseNumber(array, 1, text, true) || this._parseNumber(array, 2, text, this.type >= 3) || this._parseNumber(array, 3, text, false)) === false) {
        var offsetSecs = MathUtil.safeZero(negative * (array[1] * 3600 + array[2] * 60 + array[3]));
        return context.setParsedField(ChronoField.OFFSET_SECONDS, offsetSecs, position, array[0]);
      }
    }
    if (noOffsetLen === 0) {
      return context.setParsedField(ChronoField.OFFSET_SECONDS, 0, position, position + noOffsetLen);
    }
    return ~position;
  };
  _proto._parseNumber = function _parseNumber(array, arrayIndex, parseText, required) {
    if ((this.type + 3) / 2 < arrayIndex) {
      return false;
    }
    var pos = array[0];
    if (this.type % 2 === 0 && arrayIndex > 1) {
      if (pos + 1 > parseText.length || parseText[pos] !== ':') {
        return required;
      }
      pos++;
    }
    if (pos + 2 > parseText.length) {
      return required;
    }
    var ch1 = parseText[pos++];
    var ch2 = parseText[pos++];
    if (ch1 < '0' || ch1 > '9' || ch2 < '0' || ch2 > '9') {
      return required;
    }
    var value = (ch1.charCodeAt(0) - 48) * 10 + (ch2.charCodeAt(0) - 48);
    if (value < 0 || value > 59) {
      return required;
    }
    array[arrayIndex] = value;
    array[0] = pos;
    return false;
  };
  _proto.toString = function toString() {
    var converted = this.noOffsetText.replace('\'', '\'\'');
    return "Offset(" + PATTERNS[this.type] + ",'" + converted + "')";
  };
  return OffsetIdPrinterParser;
}();
OffsetIdPrinterParser.INSTANCE_ID = new OffsetIdPrinterParser('Z', '+HH:MM:ss');
OffsetIdPrinterParser.PATTERNS = PATTERNS;

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var PadPrinterParserDecorator = function () {
  function PadPrinterParserDecorator(printerParser, padWidth, padChar) {
    this._printerParser = printerParser;
    this._padWidth = padWidth;
    this._padChar = padChar;
  }
  var _proto = PadPrinterParserDecorator.prototype;
  _proto.print = function print(context, buf) {
    var preLen = buf.length();
    if (this._printerParser.print(context, buf) === false) {
      return false;
    }
    var len = buf.length() - preLen;
    if (len > this._padWidth) {
      throw new DateTimeException("Cannot print as output of " + len + " characters exceeds pad width of " + this._padWidth);
    }
    for (var i = 0; i < this._padWidth - len; i++) {
      buf.insert(preLen, this._padChar);
    }
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var strict = context.isStrict();
    var caseSensitive = context.isCaseSensitive();
    assert(!(position > text.length));
    assert(position >= 0);
    if (position === text.length) {
      return ~position;
    }
    var endPos = position + this._padWidth;
    if (endPos > text.length) {
      if (strict) {
        return ~position;
      }
      endPos = text.length;
    }
    var pos = position;
    while (pos < endPos && (caseSensitive ? text[pos] === this._padChar : context.charEquals(text[pos], this._padChar))) {
      pos++;
    }
    text = text.substring(0, endPos);
    var resultPos = this._printerParser.parse(context, text, pos);
    if (resultPos !== endPos && strict) {
      return ~(position + pos);
    }
    return resultPos;
  };
  _proto.toString = function toString() {
    return "Pad(" + this._printerParser + "," + this._padWidth + (this._padChar === ' ' ? ')' : ",'" + this._padChar + "')");
  };
  return PadPrinterParserDecorator;
}();

var SettingsParser = function (_Enum) {
  _inheritsLoose(SettingsParser, _Enum);
  function SettingsParser() {
    return _Enum.apply(this, arguments) || this;
  }
  var _proto = SettingsParser.prototype;
  _proto.print = function print() {
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    switch (this) {
      case SettingsParser.SENSITIVE:
        context.setCaseSensitive(true);
        break;
      case SettingsParser.INSENSITIVE:
        context.setCaseSensitive(false);
        break;
      case SettingsParser.STRICT:
        context.setStrict(true);
        break;
      case SettingsParser.LENIENT:
        context.setStrict(false);
        break;
    }
    return position;
  };
  _proto.toString = function toString() {
    switch (this) {
      case SettingsParser.SENSITIVE:
        return 'ParseCaseSensitive(true)';
      case SettingsParser.INSENSITIVE:
        return 'ParseCaseSensitive(false)';
      case SettingsParser.STRICT:
        return 'ParseStrict(true)';
      case SettingsParser.LENIENT:
        return 'ParseStrict(false)';
    }
  };
  return SettingsParser;
}(Enum);
SettingsParser.SENSITIVE = new SettingsParser('SENSITIVE');
SettingsParser.INSENSITIVE = new SettingsParser('INSENSITIVE');
SettingsParser.STRICT = new SettingsParser('STRICT');
SettingsParser.LENIENT = new SettingsParser('LENIENT');

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var StringLiteralPrinterParser = function () {
  function StringLiteralPrinterParser(literal) {
    this._literal = literal;
  }
  var _proto = StringLiteralPrinterParser.prototype;
  _proto.print = function print(context, buf) {
    buf.append(this._literal);
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    assert(!(position > length || position < 0));
    if (context.subSequenceEquals(text, position, this._literal, 0, this._literal.length) === false) {
      return ~position;
    }
    return position + this._literal.length;
  };
  _proto.toString = function toString() {
    var converted = this._literal.replace("'", "''");
    return "'" + converted + "'";
  };
  return StringLiteralPrinterParser;
}();

/*
 * @copyright (c) 2016, Philipp Thrwchter, Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var ZoneRulesProvider = function () {
  function ZoneRulesProvider() {}
  ZoneRulesProvider.getRules = function getRules(zoneId) {
    throw new DateTimeException("unsupported ZoneId:" + zoneId);
  };
  ZoneRulesProvider.getAvailableZoneIds = function getAvailableZoneIds() {
    return [];
  };
  return ZoneRulesProvider;
}();

var ZoneRegion = function (_ZoneId) {
  _inheritsLoose(ZoneRegion, _ZoneId);
  ZoneRegion.ofId = function ofId(zoneId) {
    var rules = ZoneRulesProvider.getRules(zoneId);
    return new ZoneRegion(zoneId, rules);
  };
  function ZoneRegion(id, rules) {
    var _this;
    _this = _ZoneId.call(this) || this;
    _this._id = id;
    _this._rules = rules;
    return _this;
  }
  var _proto = ZoneRegion.prototype;
  _proto.id = function id() {
    return this._id;
  };
  _proto.rules = function rules() {
    return this._rules;
  };
  return ZoneRegion;
}(ZoneId);

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var ZoneIdPrinterParser = function () {
  function ZoneIdPrinterParser(query, description) {
    this.query = query;
    this.description = description;
  }
  var _proto = ZoneIdPrinterParser.prototype;
  _proto.print = function print(context, buf) {
    var zone = context.getValueQuery(this.query);
    if (zone == null) {
      return false;
    }
    buf.append(zone.id());
    return true;
  };
  _proto.parse = function parse(context, text, position) {
    var length = text.length;
    if (position > length) {
      return ~position;
    }
    if (position === length) {
      return ~position;
    }
    var nextChar = text.charAt(position);
    if (nextChar === '+' || nextChar === '-') {
      var newContext = context.copy();
      var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
      if (endPos < 0) {
        return endPos;
      }
      var offset = newContext.getParsed(ChronoField.OFFSET_SECONDS);
      var zone = ZoneOffset.ofTotalSeconds(offset);
      context.setParsedZone(zone);
      return endPos;
    } else if (length >= position + 2) {
      var nextNextChar = text.charAt(position + 1);
      if (context.charEquals(nextChar, 'U') && context.charEquals(nextNextChar, 'T')) {
        if (length >= position + 3 && context.charEquals(text.charAt(position + 2), 'C')) {
          return this._parsePrefixedOffset(context, text, position, position + 3);
        }
        return this._parsePrefixedOffset(context, text, position, position + 2);
      } else if (context.charEquals(nextChar, 'G') && length >= position + 3 && context.charEquals(nextNextChar, 'M') && context.charEquals(text.charAt(position + 2), 'T')) {
        return this._parsePrefixedOffset(context, text, position, position + 3);
      }
    }
    if (text.substr(position, 6) === 'SYSTEM') {
      context.setParsedZone(ZoneId.systemDefault());
      return position + 6;
    }
    if (context.charEquals(nextChar, 'Z')) {
      context.setParsedZone(ZoneOffset.UTC);
      return position + 1;
    }
    var availableZoneIds = ZoneRulesProvider.getAvailableZoneIds();
    if (zoneIdTree.size !== availableZoneIds.length) {
      zoneIdTree = ZoneIdTree.createTreeMap(availableZoneIds);
    }
    var maxParseLength = length - position;
    var treeMap = zoneIdTree.treeMap;
    var parsedZoneId = null;
    var parseLength = 0;
    while (treeMap != null) {
      var parsedSubZoneId = text.substr(position, Math.min(treeMap.length, maxParseLength));
      treeMap = treeMap.get(parsedSubZoneId);
      if (treeMap != null && treeMap.isLeaf) {
        parsedZoneId = parsedSubZoneId;
        parseLength = treeMap.length;
      }
    }
    if (parsedZoneId != null) {
      context.setParsedZone(ZoneRegion.ofId(parsedZoneId));
      return position + parseLength;
    }
    return ~position;
  };
  _proto._parsePrefixedOffset = function _parsePrefixedOffset(context, text, prefixPos, position) {
    var prefix = text.substring(prefixPos, position).toUpperCase();
    var newContext = context.copy();
    if (position < text.length && context.charEquals(text.charAt(position), 'Z')) {
      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
      return position;
    }
    var endPos = OffsetIdPrinterParser.INSTANCE_ID.parse(newContext, text, position);
    if (endPos < 0) {
      context.setParsedZone(ZoneId.ofOffset(prefix, ZoneOffset.UTC));
      return position;
    }
    var offsetSecs = newContext.getParsed(ChronoField.OFFSET_SECONDS);
    var offset = ZoneOffset.ofTotalSeconds(offsetSecs);
    context.setParsedZone(ZoneId.ofOffset(prefix, offset));
    return endPos;
  };
  _proto.toString = function toString() {
    return this.description;
  };
  return ZoneIdPrinterParser;
}();
var ZoneIdTree = function () {
  ZoneIdTree.createTreeMap = function createTreeMap(availableZoneIds) {
    var sortedZoneIds = availableZoneIds.sort(function (a, b) {
      return a.length - b.length;
    });
    var treeMap = new ZoneIdTreeMap(sortedZoneIds[0].length, false);
    for (var i = 0; i < sortedZoneIds.length; i++) {
      treeMap.add(sortedZoneIds[i]);
    }
    return new ZoneIdTree(sortedZoneIds.length, treeMap);
  };
  function ZoneIdTree(size, treeMap) {
    this.size = size;
    this.treeMap = treeMap;
  }
  return ZoneIdTree;
}();
var ZoneIdTreeMap = function () {
  function ZoneIdTreeMap(length, isLeaf) {
    if (length === void 0) {
      length = 0;
    }
    if (isLeaf === void 0) {
      isLeaf = false;
    }
    this.length = length;
    this.isLeaf = isLeaf;
    this._treeMap = {};
  }
  var _proto2 = ZoneIdTreeMap.prototype;
  _proto2.add = function add(zoneId) {
    var idLength = zoneId.length;
    if (idLength === this.length) {
      this._treeMap[zoneId] = new ZoneIdTreeMap(idLength, true);
    } else if (idLength > this.length) {
      var subZoneId = zoneId.substr(0, this.length);
      var subTreeMap = this._treeMap[subZoneId];
      if (subTreeMap == null) {
        subTreeMap = new ZoneIdTreeMap(idLength, false);
        this._treeMap[subZoneId] = subTreeMap;
      }
      subTreeMap.add(zoneId);
    }
  };
  _proto2.get = function get(zoneId) {
    return this._treeMap[zoneId];
  };
  return ZoneIdTreeMap;
}();
var zoneIdTree = new ZoneIdTree([]);

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var MAX_WIDTH = 15;
var DateTimeFormatterBuilder = function () {
  function DateTimeFormatterBuilder() {
    this._active = this;
    this._parent = null;
    this._printerParsers = [];
    this._optional = false;
    this._padNextWidth = 0;
    this._padNextChar = null;
    this._valueParserIndex = -1;
  }
  DateTimeFormatterBuilder._of = function _of(parent, optional) {
    requireNonNull(parent, 'parent');
    requireNonNull(optional, 'optional');
    var dtFormatterBuilder = new DateTimeFormatterBuilder();
    dtFormatterBuilder._parent = parent;
    dtFormatterBuilder._optional = optional;
    return dtFormatterBuilder;
  };
  var _proto = DateTimeFormatterBuilder.prototype;
  _proto.parseCaseSensitive = function parseCaseSensitive() {
    this._appendInternalPrinterParser(SettingsParser.SENSITIVE);
    return this;
  };
  _proto.parseCaseInsensitive = function parseCaseInsensitive() {
    this._appendInternalPrinterParser(SettingsParser.INSENSITIVE);
    return this;
  };
  _proto.parseStrict = function parseStrict() {
    this._appendInternalPrinterParser(SettingsParser.STRICT);
    return this;
  };
  _proto.parseLenient = function parseLenient() {
    this._appendInternalPrinterParser(SettingsParser.LENIENT);
    return this;
  };
  _proto.parseDefaulting = function parseDefaulting(field, value) {
    requireNonNull(field);
    this._appendInternal(new DefaultingParser(field, value));
    return this;
  };
  _proto.appendValue = function appendValue() {
    if (arguments.length === 1) {
      return this._appendValue1.apply(this, arguments);
    } else if (arguments.length === 2) {
      return this._appendValue2.apply(this, arguments);
    } else {
      return this._appendValue4.apply(this, arguments);
    }
  };
  _proto._appendValue1 = function _appendValue1(field) {
    requireNonNull(field);
    this._appendValuePrinterParser(new NumberPrinterParser(field, 1, MAX_WIDTH, SignStyle.NORMAL));
    return this;
  };
  _proto._appendValue2 = function _appendValue2(field, width) {
    requireNonNull(field);
    if (width < 1 || width > MAX_WIDTH) {
      throw new IllegalArgumentException("The width must be from 1 to " + MAX_WIDTH + " inclusive but was " + width);
    }
    var pp = new NumberPrinterParser(field, width, width, SignStyle.NOT_NEGATIVE);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto._appendValue4 = function _appendValue4(field, minWidth, maxWidth, signStyle) {
    requireNonNull(field);
    requireNonNull(signStyle);
    if (minWidth === maxWidth && signStyle === SignStyle.NOT_NEGATIVE) {
      return this._appendValue2(field, maxWidth);
    }
    if (minWidth < 1 || minWidth > MAX_WIDTH) {
      throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + minWidth);
    }
    if (maxWidth < 1 || maxWidth > MAX_WIDTH) {
      throw new IllegalArgumentException("The minimum width must be from 1 to " + MAX_WIDTH + " inclusive but was " + maxWidth);
    }
    if (maxWidth < minWidth) {
      throw new IllegalArgumentException("The maximum width must exceed or equal the minimum width but " + maxWidth + " < " + minWidth);
    }
    var pp = new NumberPrinterParser(field, minWidth, maxWidth, signStyle);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto.appendValueReduced = function appendValueReduced() {
    if (arguments.length === 4 && arguments[3] instanceof ChronoLocalDate) {
      return this._appendValueReducedFieldWidthMaxWidthBaseDate.apply(this, arguments);
    } else {
      return this._appendValueReducedFieldWidthMaxWidthBaseValue.apply(this, arguments);
    }
  };
  _proto._appendValueReducedFieldWidthMaxWidthBaseValue = function _appendValueReducedFieldWidthMaxWidthBaseValue(field, width, maxWidth, baseValue) {
    requireNonNull(field, 'field');
    var pp = new ReducedPrinterParser(field, width, maxWidth, baseValue, null);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto._appendValueReducedFieldWidthMaxWidthBaseDate = function _appendValueReducedFieldWidthMaxWidthBaseDate(field, width, maxWidth, baseDate) {
    requireNonNull(field, 'field');
    requireNonNull(baseDate, 'baseDate');
    requireInstance(baseDate, ChronoLocalDate, 'baseDate');
    var pp = new ReducedPrinterParser(field, width, maxWidth, 0, baseDate);
    this._appendValuePrinterParser(pp);
    return this;
  };
  _proto._appendValuePrinterParser = function _appendValuePrinterParser(pp) {
    assert(pp != null);
    if (this._active._valueParserIndex >= 0 && this._active._printerParsers[this._active._valueParserIndex] instanceof NumberPrinterParser) {
      var activeValueParser = this._active._valueParserIndex;
      var basePP = this._active._printerParsers[activeValueParser];
      if (pp.minWidth() === pp.maxWidth() && pp.signStyle() === SignStyle.NOT_NEGATIVE) {
        basePP = basePP.withSubsequentWidth(pp.maxWidth());
        this._appendInternal(pp.withFixedWidth());
        this._active._valueParserIndex = activeValueParser;
      } else {
        basePP = basePP.withFixedWidth();
        this._active._valueParserIndex = this._appendInternal(pp);
      }
      this._active._printerParsers[activeValueParser] = basePP;
    } else {
      this._active._valueParserIndex = this._appendInternal(pp);
    }
    return this;
  };
  _proto.appendFraction = function appendFraction(field, minWidth, maxWidth, decimalPoint) {
    this._appendInternal(new FractionPrinterParser(field, minWidth, maxWidth, decimalPoint));
    return this;
  };
  _proto.appendInstant = function appendInstant(fractionalDigits) {
    if (fractionalDigits === void 0) {
      fractionalDigits = -2;
    }
    if (fractionalDigits < -2 || fractionalDigits > 9) {
      throw new IllegalArgumentException("Invalid fractional digits: " + fractionalDigits);
    }
    this._appendInternal(new InstantPrinterParser(fractionalDigits));
    return this;
  };
  _proto.appendOffsetId = function appendOffsetId() {
    this._appendInternal(OffsetIdPrinterParser.INSTANCE_ID);
    return this;
  };
  _proto.appendOffset = function appendOffset(pattern, noOffsetText) {
    this._appendInternalPrinterParser(new OffsetIdPrinterParser(noOffsetText, pattern));
    return this;
  };
  _proto.appendZoneId = function appendZoneId() {
    this._appendInternal(new ZoneIdPrinterParser(TemporalQueries.zoneId(), 'ZoneId()'));
    return this;
  };
  _proto.appendPattern = function appendPattern(pattern) {
    requireNonNull(pattern, 'pattern');
    this._parsePattern(pattern);
    return this;
  };
  _proto.appendZoneText = function appendZoneText() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };
  _proto.appendText = function appendText() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };
  _proto.appendLocalizedOffset = function appendLocalizedOffset() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };
  _proto.appendWeekField = function appendWeekField() {
    throw new IllegalArgumentException('Pattern using (localized) text not implemented, use @js-joda/locale plugin!');
  };
  _proto._parsePattern = function _parsePattern(pattern) {
    var FIELD_MAP = {
      'G': ChronoField.ERA,
      'y': ChronoField.YEAR_OF_ERA,
      'u': ChronoField.YEAR,
      'Q': IsoFields.QUARTER_OF_YEAR,
      'q': IsoFields.QUARTER_OF_YEAR,
      'M': ChronoField.MONTH_OF_YEAR,
      'L': ChronoField.MONTH_OF_YEAR,
      'D': ChronoField.DAY_OF_YEAR,
      'd': ChronoField.DAY_OF_MONTH,
      'F': ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH,
      'E': ChronoField.DAY_OF_WEEK,
      'c': ChronoField.DAY_OF_WEEK,
      'e': ChronoField.DAY_OF_WEEK,
      'a': ChronoField.AMPM_OF_DAY,
      'H': ChronoField.HOUR_OF_DAY,
      'k': ChronoField.CLOCK_HOUR_OF_DAY,
      'K': ChronoField.HOUR_OF_AMPM,
      'h': ChronoField.CLOCK_HOUR_OF_AMPM,
      'm': ChronoField.MINUTE_OF_HOUR,
      's': ChronoField.SECOND_OF_MINUTE,
      'S': ChronoField.NANO_OF_SECOND,
      'A': ChronoField.MILLI_OF_DAY,
      'n': ChronoField.NANO_OF_SECOND,
      'N': ChronoField.NANO_OF_DAY
    };
    for (var pos = 0; pos < pattern.length; pos++) {
      var cur = pattern.charAt(pos);
      if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {
        var start = pos++;
        for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++);
        var count = pos - start;
        if (cur === 'p') {
          var pad = 0;
          if (pos < pattern.length) {
            cur = pattern.charAt(pos);
            if (cur >= 'A' && cur <= 'Z' || cur >= 'a' && cur <= 'z') {
              pad = count;
              start = pos++;
              for (; pos < pattern.length && pattern.charAt(pos) === cur; pos++);
              count = pos - start;
            }
          }
          if (pad === 0) {
            throw new IllegalArgumentException("Pad letter 'p' must be followed by valid pad pattern: " + pattern);
          }
          this.padNext(pad);
        }
        var field = FIELD_MAP[cur];
        if (field != null) {
          this._parseField(cur, count, field);
        } else if (cur === 'z') {
          if (count > 4) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          } else if (count === 4) {
            this.appendZoneText(TextStyle.FULL);
          } else {
            this.appendZoneText(TextStyle.SHORT);
          }
        } else if (cur === 'V') {
          if (count !== 2) {
            throw new IllegalArgumentException("Pattern letter count must be 2: " + cur);
          }
          this.appendZoneId();
        } else if (cur === 'Z') {
          if (count < 4) {
            this.appendOffset('+HHMM', '+0000');
          } else if (count === 4) {
            this.appendLocalizedOffset(TextStyle.FULL);
          } else if (count === 5) {
            this.appendOffset('+HH:MM:ss', 'Z');
          } else {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
        } else if (cur === 'O') {
          if (count === 1) {
            this.appendLocalizedOffset(TextStyle.SHORT);
          } else if (count === 4) {
            this.appendLocalizedOffset(TextStyle.FULL);
          } else {
            throw new IllegalArgumentException("Pattern letter count must be 1 or 4: " + cur);
          }
        } else if (cur === 'X') {
          if (count > 5) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], 'Z');
        } else if (cur === 'x') {
          if (count > 5) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          var zero = count === 1 ? '+00' : count % 2 === 0 ? '+0000' : '+00:00';
          this.appendOffset(OffsetIdPrinterParser.PATTERNS[count + (count === 1 ? 0 : 1)], zero);
        } else if (cur === 'W') {
          if (count > 1) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          this.appendWeekField('W', count);
        } else if (cur === 'w') {
          if (count > 2) {
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
          }
          this.appendWeekField('w', count);
        } else if (cur === 'Y') {
          this.appendWeekField('Y', count);
        } else {
          throw new IllegalArgumentException("Unknown pattern letter: " + cur);
        }
        pos--;
      } else if (cur === '\'') {
        var _start = pos++;
        for (; pos < pattern.length; pos++) {
          if (pattern.charAt(pos) === '\'') {
            if (pos + 1 < pattern.length && pattern.charAt(pos + 1) === '\'') {
              pos++;
            } else {
              break;
            }
          }
        }
        if (pos >= pattern.length) {
          throw new IllegalArgumentException("Pattern ends with an incomplete string literal: " + pattern);
        }
        var str = pattern.substring(_start + 1, pos);
        if (str.length === 0) {
          this.appendLiteral('\'');
        } else {
          this.appendLiteral(str.replace('\'\'', '\''));
        }
      } else if (cur === '[') {
        this.optionalStart();
      } else if (cur === ']') {
        if (this._active._parent === null) {
          throw new IllegalArgumentException('Pattern invalid as it contains ] without previous [');
        }
        this.optionalEnd();
      } else if (cur === '{' || cur === '}' || cur === '#') {
        throw new IllegalArgumentException("Pattern includes reserved character: '" + cur + "'");
      } else {
        this.appendLiteral(cur);
      }
    }
  };
  _proto._parseField = function _parseField(cur, count, field) {
    switch (cur) {
      case 'u':
      case 'y':
        if (count === 2) {
          this.appendValueReduced(field, 2, 2, ReducedPrinterParser.BASE_DATE);
        } else if (count < 4) {
          this.appendValue(field, count, MAX_WIDTH, SignStyle.NORMAL);
        } else {
          this.appendValue(field, count, MAX_WIDTH, SignStyle.EXCEEDS_PAD);
        }
        break;
      case 'M':
      case 'Q':
        switch (count) {
          case 1:
            this.appendValue(field);
            break;
          case 2:
            this.appendValue(field, 2);
            break;
          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'L':
      case 'q':
        switch (count) {
          case 1:
            this.appendValue(field);
            break;
          case 2:
            this.appendValue(field, 2);
            break;
          case 3:
            this.appendText(field, TextStyle.SHORT_STANDALONE);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL_STANDALONE);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW_STANDALONE);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'e':
        switch (count) {
          case 1:
          case 2:
            this.appendWeekField('e', count);
            break;
          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'c':
        switch (count) {
          case 1:
            this.appendWeekField('c', count);
            break;
          case 2:
            throw new IllegalArgumentException("Invalid number of pattern letters: " + cur);
          case 3:
            this.appendText(field, TextStyle.SHORT_STANDALONE);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL_STANDALONE);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW_STANDALONE);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'a':
        if (count === 1) {
          this.appendText(field, TextStyle.SHORT);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'E':
      case 'G':
        switch (count) {
          case 1:
          case 2:
          case 3:
            this.appendText(field, TextStyle.SHORT);
            break;
          case 4:
            this.appendText(field, TextStyle.FULL);
            break;
          case 5:
            this.appendText(field, TextStyle.NARROW);
            break;
          default:
            throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'S':
        this.appendFraction(ChronoField.NANO_OF_SECOND, count, count, false);
        break;
      case 'F':
        if (count === 1) {
          this.appendValue(field);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'd':
      case 'h':
      case 'H':
      case 'k':
      case 'K':
      case 'm':
      case 's':
        if (count === 1) {
          this.appendValue(field);
        } else if (count === 2) {
          this.appendValue(field, count);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      case 'D':
        if (count === 1) {
          this.appendValue(field);
        } else if (count <= 3) {
          this.appendValue(field, count);
        } else {
          throw new IllegalArgumentException("Too many pattern letters: " + cur);
        }
        break;
      default:
        if (count === 1) {
          this.appendValue(field);
        } else {
          this.appendValue(field, count);
        }
        break;
    }
  };
  _proto.padNext = function padNext() {
    if (arguments.length === 1) {
      return this._padNext1.apply(this, arguments);
    } else {
      return this._padNext2.apply(this, arguments);
    }
  };
  _proto._padNext1 = function _padNext1(padWidth) {
    return this._padNext2(padWidth, ' ');
  };
  _proto._padNext2 = function _padNext2(padWidth, padChar) {
    if (padWidth < 1) {
      throw new IllegalArgumentException("The pad width must be at least one but was " + padWidth);
    }
    this._active._padNextWidth = padWidth;
    this._active._padNextChar = padChar;
    this._active._valueParserIndex = -1;
    return this;
  };
  _proto.optionalStart = function optionalStart() {
    this._active._valueParserIndex = -1;
    this._active = DateTimeFormatterBuilder._of(this._active, true);
    return this;
  };
  _proto.optionalEnd = function optionalEnd() {
    if (this._active._parent == null) {
      throw new IllegalStateException('Cannot call optionalEnd() as there was no previous call to optionalStart()');
    }
    if (this._active._printerParsers.length > 0) {
      var cpp = new CompositePrinterParser(this._active._printerParsers, this._active._optional);
      this._active = this._active._parent;
      this._appendInternal(cpp);
    } else {
      this._active = this._active._parent;
    }
    return this;
  };
  _proto._appendInternal = function _appendInternal(pp) {
    assert(pp != null);
    if (this._active._padNextWidth > 0) {
      if (pp != null) {
        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
      }
      this._active._padNextWidth = 0;
      this._active._padNextChar = 0;
    }
    this._active._printerParsers.push(pp);
    this._active._valueParserIndex = -1;
    return this._active._printerParsers.length - 1;
  };
  _proto.appendLiteral = function appendLiteral(literal) {
    assert(literal != null);
    if (literal.length > 0) {
      if (literal.length === 1) {
        this._appendInternalPrinterParser(new CharLiteralPrinterParser(literal.charAt(0)));
      } else {
        this._appendInternalPrinterParser(new StringLiteralPrinterParser(literal));
      }
    }
    return this;
  };
  _proto._appendInternalPrinterParser = function _appendInternalPrinterParser(pp) {
    assert(pp != null);
    if (this._active._padNextWidth > 0) {
      if (pp != null) {
        pp = new PadPrinterParserDecorator(pp, this._active._padNextWidth, this._active._padNextChar);
      }
      this._active._padNextWidth = 0;
      this._active._padNextChar = 0;
    }
    this._active._printerParsers.push(pp);
    this._active._valueParserIndex = -1;
    return this._active._printerParsers.length - 1;
  };
  _proto.append = function append(formatter) {
    requireNonNull(formatter, 'formatter');
    this._appendInternal(formatter._toPrinterParser(false));
    return this;
  };
  _proto.toFormatter = function toFormatter(resolverStyle) {
    if (resolverStyle === void 0) {
      resolverStyle = ResolverStyle.SMART;
    }
    while (this._active._parent != null) {
      this.optionalEnd();
    }
    var pp = new CompositePrinterParser(this._printerParsers, false);
    return new DateTimeFormatter(pp, null, DecimalStyle.STANDARD, resolverStyle, null, null, null);
  };
  return DateTimeFormatterBuilder;
}();
var SECONDS_PER_10000_YEARS = 146097 * 25 * 86400;
var SECONDS_0000_TO_1970 = (146097 * 5 - (30 * 365 + 7)) * 86400;
var InstantPrinterParser = function () {
  function InstantPrinterParser(fractionalDigits) {
    this.fractionalDigits = fractionalDigits;
  }
  var _proto2 = InstantPrinterParser.prototype;
  _proto2.print = function print(context, buf) {
    var inSecs = context.getValue(ChronoField.INSTANT_SECONDS);
    var inNanos = 0;
    if (context.temporal().isSupported(ChronoField.NANO_OF_SECOND)) {
      inNanos = context.temporal().getLong(ChronoField.NANO_OF_SECOND);
    }
    if (inSecs == null) {
      return false;
    }
    var inSec = inSecs;
    var inNano = ChronoField.NANO_OF_SECOND.checkValidIntValue(inNanos);
    if (inSec >= -SECONDS_0000_TO_1970) {
      var zeroSecs = inSec - SECONDS_PER_10000_YEARS + SECONDS_0000_TO_1970;
      var hi = MathUtil.floorDiv(zeroSecs, SECONDS_PER_10000_YEARS) + 1;
      var lo = MathUtil.floorMod(zeroSecs, SECONDS_PER_10000_YEARS);
      var ldt = LocalDateTime.ofEpochSecond(lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
      if (hi > 0) {
        buf.append('+').append(hi);
      }
      buf.append(ldt.toString());
      if (ldt.second() === 0) {
        buf.append(':00');
      }
    } else {
      var _zeroSecs = inSec + SECONDS_0000_TO_1970;
      var _hi = MathUtil.intDiv(_zeroSecs, SECONDS_PER_10000_YEARS);
      var _lo = MathUtil.intMod(_zeroSecs, SECONDS_PER_10000_YEARS);
      var _ldt = LocalDateTime.ofEpochSecond(_lo - SECONDS_0000_TO_1970, 0, ZoneOffset.UTC);
      var pos = buf.length();
      buf.append(_ldt.toString());
      if (_ldt.second() === 0) {
        buf.append(':00');
      }
      if (_hi < 0) {
        if (_ldt.year() === -1e4) {
          buf.replace(pos, pos + 2, "" + (_hi - 1));
        } else if (_lo === 0) {
          buf.insert(pos, _hi);
        } else {
          buf.insert(pos + 1, Math.abs(_hi));
        }
      }
    }
    if (this.fractionalDigits === -2) {
      if (inNano !== 0) {
        buf.append('.');
        if (MathUtil.intMod(inNano, 1000000) === 0) {
          buf.append(("" + (MathUtil.intDiv(inNano, 1000000) + 1000)).substring(1));
        } else if (MathUtil.intMod(inNano, 1000) === 0) {
          buf.append(("" + (MathUtil.intDiv(inNano, 1000) + 1000000)).substring(1));
        } else {
          buf.append(("" + (inNano + 1000000000)).substring(1));
        }
      }
    } else if (this.fractionalDigits > 0 || this.fractionalDigits === -1 && inNano > 0) {
      buf.append('.');
      var div = 100000000;
      for (var i = 0; this.fractionalDigits === -1 && inNano > 0 || i < this.fractionalDigits; i++) {
        var digit = MathUtil.intDiv(inNano, div);
        buf.append(digit);
        inNano = inNano - digit * div;
        div = MathUtil.intDiv(div, 10);
      }
    }
    buf.append('Z');
    return true;
  };
  _proto2.parse = function parse(context, text, position) {
    var newContext = context.copy();
    var minDigits = this.fractionalDigits < 0 ? 0 : this.fractionalDigits;
    var maxDigits = this.fractionalDigits < 0 ? 9 : this.fractionalDigits;
    var parser = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).appendFraction(ChronoField.NANO_OF_SECOND, minDigits, maxDigits, true).appendLiteral('Z').toFormatter()._toPrinterParser(false);
    var pos = parser.parse(newContext, text, position);
    if (pos < 0) {
      return pos;
    }
    var yearParsed = newContext.getParsed(ChronoField.YEAR);
    var month = newContext.getParsed(ChronoField.MONTH_OF_YEAR);
    var day = newContext.getParsed(ChronoField.DAY_OF_MONTH);
    var hour = newContext.getParsed(ChronoField.HOUR_OF_DAY);
    var min = newContext.getParsed(ChronoField.MINUTE_OF_HOUR);
    var secVal = newContext.getParsed(ChronoField.SECOND_OF_MINUTE);
    var nanoVal = newContext.getParsed(ChronoField.NANO_OF_SECOND);
    var sec = secVal != null ? secVal : 0;
    var nano = nanoVal != null ? nanoVal : 0;
    var year = MathUtil.intMod(yearParsed, 10000);
    var days = 0;
    if (hour === 24 && min === 0 && sec === 0 && nano === 0) {
      hour = 0;
      days = 1;
    } else if (hour === 23 && min === 59 && sec === 60) {
      context.setParsedLeapSecond();
      sec = 59;
    }
    var instantSecs;
    try {
      var ldt = LocalDateTime.of(year, month, day, hour, min, sec, 0).plusDays(days);
      instantSecs = ldt.toEpochSecond(ZoneOffset.UTC);
      instantSecs += MathUtil.safeMultiply(MathUtil.intDiv(yearParsed, 10000), SECONDS_PER_10000_YEARS);
    } catch (ex) {
      return ~position;
    }
    var successPos = pos;
    successPos = context.setParsedField(ChronoField.INSTANT_SECONDS, instantSecs, position, successPos);
    return context.setParsedField(ChronoField.NANO_OF_SECOND, nano, position, successPos);
  };
  _proto2.toString = function toString() {
    return 'Instant()';
  };
  return InstantPrinterParser;
}();
var DefaultingParser = function () {
  function DefaultingParser(field, value) {
    this._field = field;
    this._value = value;
  }
  var _proto3 = DefaultingParser.prototype;
  _proto3.print = function print() {
    return true;
  };
  _proto3.parse = function parse(context, text, position) {
    if (context.getParsed(this._field) == null) {
      context.setParsedField(this._field, this._value, position, position);
    }
    return position;
  };
  return DefaultingParser;
}();
function _init$e() {
  ReducedPrinterParser.BASE_DATE = LocalDate.of(2000, 1, 1);
  DateTimeFormatterBuilder.CompositePrinterParser = CompositePrinterParser;
  DateTimeFormatterBuilder.PadPrinterParserDecorator = PadPrinterParserDecorator;
  DateTimeFormatterBuilder.SettingsParser = SettingsParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.StringLiteralPrinterParser = StringLiteralPrinterParser;
  DateTimeFormatterBuilder.CharLiteralPrinterParser = CharLiteralPrinterParser;
  DateTimeFormatterBuilder.NumberPrinterParser = NumberPrinterParser;
  DateTimeFormatterBuilder.ReducedPrinterParser = ReducedPrinterParser;
  DateTimeFormatterBuilder.FractionPrinterParser = FractionPrinterParser;
  DateTimeFormatterBuilder.OffsetIdPrinterParser = OffsetIdPrinterParser;
  DateTimeFormatterBuilder.ZoneIdPrinterParser = ZoneIdPrinterParser;
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */var StringBuilder = function () {
  function StringBuilder() {
    this._str = '';
  }
  var _proto = StringBuilder.prototype;
  _proto.append = function append(str) {
    this._str += str;
    return this;
  };
  _proto.appendChar = function appendChar(str) {
    this._str += str[0];
    return this;
  };
  _proto.insert = function insert(offset, str) {
    this._str = this._str.slice(0, offset) + str + this._str.slice(offset);
    return this;
  };
  _proto.replace = function replace(start, end, str) {
    this._str = this._str.slice(0, start) + str + this._str.slice(end);
    return this;
  };
  _proto.length = function length() {
    return this._str.length;
  };
  _proto.setLength = function setLength(length) {
    this._str = this._str.slice(0, length);
    return this;
  };
  _proto.toString = function toString() {
    return this._str;
  };
  return StringBuilder;
}();

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var DateTimeFormatter = function () {
  DateTimeFormatter.parsedExcessDays = function parsedExcessDays() {
    return DateTimeFormatter.PARSED_EXCESS_DAYS;
  };
  DateTimeFormatter.parsedLeapSecond = function parsedLeapSecond() {
    return DateTimeFormatter.PARSED_LEAP_SECOND;
  };
  DateTimeFormatter.ofPattern = function ofPattern(pattern) {
    return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter();
  };
  function DateTimeFormatter(printerParser, locale, decimalStyle, resolverStyle, resolverFields, chrono, zone) {
    if (chrono === void 0) {
      chrono = IsoChronology.INSTANCE;
    }
    assert(printerParser != null);
    assert(decimalStyle != null);
    assert(resolverStyle != null);
    this._printerParser = printerParser;
    this._locale = locale;
    this._decimalStyle = decimalStyle;
    this._resolverStyle = resolverStyle;
    this._resolverFields = resolverFields;
    this._chrono = chrono;
    this._zone = zone;
  }
  var _proto = DateTimeFormatter.prototype;
  _proto.locale = function locale() {
    return this._locale;
  };
  _proto.decimalStyle = function decimalStyle() {
    return this._decimalStyle;
  };
  _proto.chronology = function chronology() {
    return this._chrono;
  };
  _proto.withChronology = function withChronology(chrono) {
    if (this._chrono != null && this._chrono.equals(chrono)) {
      return this;
    }
    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, this._resolverStyle, this._resolverFields, chrono, this._zone);
  };
  _proto.withLocale = function withLocale() {
    return this;
  };
  _proto.withResolverStyle = function withResolverStyle(resolverStyle) {
    requireNonNull(resolverStyle, 'resolverStyle');
    if (resolverStyle.equals(this._resolverStyle)) {
      return this;
    }
    return new DateTimeFormatter(this._printerParser, this._locale, this._decimalStyle, resolverStyle, this._resolverFields, this._chrono, this._zone);
  };
  _proto.format = function format(temporal) {
    var buf = new StringBuilder(32);
    this._formatTo(temporal, buf);
    return buf.toString();
  };
  _proto._formatTo = function _formatTo(temporal, appendable) {
    requireNonNull(temporal, 'temporal');
    requireNonNull(appendable, 'appendable');
    var context = new DateTimePrintContext(temporal, this);
    this._printerParser.print(context, appendable);
  };
  _proto.parse = function parse(text, type) {
    if (arguments.length === 1) {
      return this.parse1(text);
    } else {
      return this.parse2(text, type);
    }
  };
  _proto.parse1 = function parse1(text) {
    requireNonNull(text, 'text');
    try {
      return this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
    } catch (ex) {
      if (ex instanceof DateTimeParseException) {
        throw ex;
      } else {
        throw this._createError(text, ex);
      }
    }
  };
  _proto.parse2 = function parse2(text, type) {
    requireNonNull(text, 'text');
    requireNonNull(type, 'type');
    try {
      var builder = this._parseToBuilder(text, null).resolve(this._resolverStyle, this._resolverFields);
      return builder.build(type);
    } catch (ex) {
      if (ex instanceof DateTimeParseException) {
        throw ex;
      } else {
        throw this._createError(text, ex);
      }
    }
  };
  _proto._createError = function _createError(text, ex) {
    var abbr = '';
    if (text.length > 64) {
      abbr = text.substring(0, 64) + "...";
    } else {
      abbr = text;
    }
    return new DateTimeParseException("Text '" + abbr + "' could not be parsed: " + ex.message, text, 0, ex);
  };
  _proto._parseToBuilder = function _parseToBuilder(text, position) {
    var pos = position != null ? position : new ParsePosition(0);
    var result = this._parseUnresolved0(text, pos);
    if (result == null || pos.getErrorIndex() >= 0 || position == null && pos.getIndex() < text.length) {
      var abbr = '';
      if (text.length > 64) {
        abbr = text.substr(0, 64).toString() + "...";
      } else {
        abbr = text;
      }
      if (pos.getErrorIndex() >= 0) {
        throw new DateTimeParseException("Text '" + abbr + "' could not be parsed at index " + pos.getErrorIndex(), text, pos.getErrorIndex());
      } else {
        throw new DateTimeParseException("Text '" + abbr + "' could not be parsed, unparsed text found at index " + pos.getIndex(), text, pos.getIndex());
      }
    }
    return result.toBuilder();
  };
  _proto.parseUnresolved = function parseUnresolved(text, position) {
    return this._parseUnresolved0(text, position);
  };
  _proto._parseUnresolved0 = function _parseUnresolved0(text, position) {
    assert(text != null, 'text', NullPointerException);
    assert(position != null, 'position', NullPointerException);
    var context = new DateTimeParseContext(this);
    var pos = position.getIndex();
    pos = this._printerParser.parse(context, text, pos);
    if (pos < 0) {
      position.setErrorIndex(~pos);
      return null;
    }
    position.setIndex(pos);
    return context.toParsed();
  };
  _proto._toPrinterParser = function _toPrinterParser(optional) {
    return this._printerParser.withOptional(optional);
  };
  _proto.toString = function toString() {
    var pattern = this._printerParser.toString();
    return pattern.indexOf('[') === 0 ? pattern : pattern.substring(1, pattern.length - 1);
  };
  return DateTimeFormatter;
}();
function _init$d() {
  DateTimeFormatter.ISO_LOCAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_LOCAL_TIME = new DateTimeFormatterBuilder().appendValue(ChronoField.HOUR_OF_DAY, 2).appendLiteral(':').appendValue(ChronoField.MINUTE_OF_HOUR, 2).optionalStart().appendLiteral(':').appendValue(ChronoField.SECOND_OF_MINUTE, 2).optionalStart().appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_LOCAL_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T').append(DateTimeFormatter.ISO_LOCAL_TIME).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_INSTANT = new DateTimeFormatterBuilder().parseCaseInsensitive().appendInstant().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_OFFSET_DATE_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ZONED_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_OFFSET_DATE_TIME).optionalStart().appendLiteral('[').parseCaseSensitive().appendZoneId().appendLiteral(']').toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.BASIC_ISO_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendValue(ChronoField.MONTH_OF_YEAR, 2).appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_OFFSET_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).appendOffsetId().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_ORDINAL_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.DAY_OF_YEAR).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_WEEK_DATE = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-W').appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR).appendLiteral('-').appendValue(ChronoField.DAY_OF_WEEK).toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_DATE).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.ISO_TIME = new DateTimeFormatterBuilder().parseCaseInsensitive().append(DateTimeFormatter.ISO_LOCAL_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT);
  DateTimeFormatter.ISO_DATE_TIME = new DateTimeFormatterBuilder().append(DateTimeFormatter.ISO_LOCAL_DATE_TIME).optionalStart().appendOffsetId().optionalEnd().toFormatter(ResolverStyle.STRICT).withChronology(IsoChronology.INSTANCE);
  DateTimeFormatter.PARSED_EXCESS_DAYS = createTemporalQuery('PARSED_EXCESS_DAYS', function (temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.excessDays;
    } else {
      return Period.ZERO;
    }
  });
  DateTimeFormatter.PARSED_LEAP_SECOND = createTemporalQuery('PARSED_LEAP_SECOND', function (temporal) {
    if (temporal instanceof DateTimeBuilder) {
      return temporal.leapSecond;
    } else {
      return false;
    }
  });
}

var MonthDay = function (_TemporalAccessor) {
  _inheritsLoose(MonthDay, _TemporalAccessor);
  MonthDay.now = function now(zoneIdOrClock) {
    if (arguments.length === 0) {
      return MonthDay.now0();
    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
      return MonthDay.nowZoneId(zoneIdOrClock);
    } else {
      return MonthDay.nowClock(zoneIdOrClock);
    }
  };
  MonthDay.now0 = function now0() {
    return this.nowClock(Clock.systemDefaultZone());
  };
  MonthDay.nowZoneId = function nowZoneId(zone) {
    requireNonNull(zone, 'zone');
    return this.nowClock(Clock.system(zone));
  };
  MonthDay.nowClock = function nowClock(clock) {
    requireNonNull(clock, 'clock');
    var now = LocalDate.now(clock);
    return MonthDay.of(now.month(), now.dayOfMonth());
  };
  MonthDay.of = function of(monthOrNumber, number) {
    if (arguments.length === 2 && monthOrNumber instanceof Month) {
      return MonthDay.ofMonthNumber(monthOrNumber, number);
    } else {
      return MonthDay.ofNumberNumber(monthOrNumber, number);
    }
  };
  MonthDay.ofMonthNumber = function ofMonthNumber(month, dayOfMonth) {
    requireNonNull(month, 'month');
    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
    if (dayOfMonth > month.maxLength()) {
      throw new DateTimeException("Illegal value for DayOfMonth field, value " + dayOfMonth + " is not valid for month " + month.toString());
    }
    return new MonthDay(month.value(), dayOfMonth);
  };
  MonthDay.ofNumberNumber = function ofNumberNumber(month, dayOfMonth) {
    requireNonNull(month, 'month');
    requireNonNull(dayOfMonth, 'dayOfMonth');
    return MonthDay.of(Month.of(month), dayOfMonth);
  };
  MonthDay.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    requireInstance(temporal, TemporalAccessor, 'temporal');
    if (temporal instanceof MonthDay) {
      return temporal;
    }
    try {
      return MonthDay.of(temporal.get(ChronoField.MONTH_OF_YEAR), temporal.get(ChronoField.DAY_OF_MONTH));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain MonthDay from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  MonthDay.parse = function parse(text, formatter) {
    if (arguments.length === 1) {
      return MonthDay.parseString(text);
    } else {
      return MonthDay.parseStringFormatter(text, formatter);
    }
  };
  MonthDay.parseString = function parseString(text) {
    return MonthDay.parseStringFormatter(text, PARSER$2);
  };
  MonthDay.parseStringFormatter = function parseStringFormatter(text, formatter) {
    requireNonNull(text, 'text');
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.parse(text, MonthDay.FROM);
  };
  function MonthDay(month, dayOfMonth) {
    var _this;
    _this = _TemporalAccessor.call(this) || this;
    _this._month = MathUtil.safeToInt(month);
    _this._day = MathUtil.safeToInt(dayOfMonth);
    return _this;
  }
  var _proto = MonthDay.prototype;
  _proto.monthValue = function monthValue() {
    return this._month;
  };
  _proto.month = function month() {
    return Month.of(this._month);
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._day;
  };
  _proto.isSupported = function isSupported(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.MONTH_OF_YEAR || field === ChronoField.DAY_OF_MONTH;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field === ChronoField.MONTH_OF_YEAR) {
      return field.range();
    } else if (field === ChronoField.DAY_OF_MONTH) {
      return ValueRange.of(1, this.month().minLength(), this.month().maxLength());
    }
    return _TemporalAccessor.prototype.range.call(this, field);
  };
  _proto.get = function get(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.DAY_OF_MONTH:
          return this._day;
        case ChronoField.MONTH_OF_YEAR:
          return this._month;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.isValidYear = function isValidYear(year) {
    return (this._day === 29 && this._month === 2 && Year.isLeap(year) === false) === false;
  };
  _proto.withMonth = function withMonth(month) {
    return this.with(Month.of(month));
  };
  _proto.with = function _with(month) {
    requireNonNull(month, 'month');
    if (month.value() === this._month) {
      return this;
    }
    var day = Math.min(this._day, month.maxLength());
    return new MonthDay(month.value(), day);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    if (dayOfMonth === this._day) {
      return this;
    }
    return MonthDay.of(this._month, dayOfMonth);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    requireInstance(_query, TemporalQuery, 'query');
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    }
    return _TemporalAccessor.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    temporal = temporal.with(ChronoField.MONTH_OF_YEAR, this._month);
    return temporal.with(ChronoField.DAY_OF_MONTH, Math.min(temporal.range(ChronoField.DAY_OF_MONTH).maximum(), this._day));
  };
  _proto.atYear = function atYear(year) {
    return LocalDate.of(year, this._month, this.isValidYear(year) ? this._day : 28);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, MonthDay, 'other');
    var cmp = this._month - other.monthValue();
    if (cmp === 0) {
      cmp = this._day - other.dayOfMonth();
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    requireInstance(other, MonthDay, 'other');
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    requireInstance(other, MonthDay, 'other');
    return this.compareTo(other) < 0;
  };
  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }
    if (obj instanceof MonthDay) {
      var other = obj;
      return this.monthValue() === other.monthValue() && this.dayOfMonth() === other.dayOfMonth();
    }
    return false;
  };
  _proto.toString = function toString() {
    return "--" + (this._month < 10 ? '0' : '') + this._month + (this._day < 10 ? '-0' : '-') + this._day;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.format(this);
  };
  return MonthDay;
}(TemporalAccessor);
var PARSER$2;
function _init$c() {
  PARSER$2 = new DateTimeFormatterBuilder().appendLiteral('--').appendValue(ChronoField.MONTH_OF_YEAR, 2).appendLiteral('-').appendValue(ChronoField.DAY_OF_MONTH, 2).toFormatter();
  MonthDay.FROM = createTemporalQuery('MonthDay.FROM', function (temporal) {
    return MonthDay.from(temporal);
  });
}

var YearMonth = function (_Temporal) {
  _inheritsLoose(YearMonth, _Temporal);
  YearMonth.now = function now(zoneIdOrClock) {
    if (arguments.length === 0) {
      return YearMonth.now0();
    } else if (arguments.length === 1 && zoneIdOrClock instanceof ZoneId) {
      return YearMonth.nowZoneId(zoneIdOrClock);
    } else {
      return YearMonth.nowClock(zoneIdOrClock);
    }
  };
  YearMonth.now0 = function now0() {
    return YearMonth.nowClock(Clock.systemDefaultZone());
  };
  YearMonth.nowZoneId = function nowZoneId(zone) {
    return YearMonth.nowClock(Clock.system(zone));
  };
  YearMonth.nowClock = function nowClock(clock) {
    var now = LocalDate.now(clock);
    return YearMonth.of(now.year(), now.month());
  };
  YearMonth.of = function of(year, monthOrNumber) {
    if (arguments.length === 2 && monthOrNumber instanceof Month) {
      return YearMonth.ofNumberMonth(year, monthOrNumber);
    } else {
      return YearMonth.ofNumberNumber(year, monthOrNumber);
    }
  };
  YearMonth.ofNumberMonth = function ofNumberMonth(year, month) {
    requireNonNull(month, 'month');
    requireInstance(month, Month, 'month');
    return YearMonth.ofNumberNumber(year, month.value());
  };
  YearMonth.ofNumberNumber = function ofNumberNumber(year, month) {
    requireNonNull(year, 'year');
    requireNonNull(month, 'month');
    ChronoField.YEAR.checkValidValue(year);
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    return new YearMonth(year, month);
  };
  YearMonth.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    if (temporal instanceof YearMonth) {
      return temporal;
    }
    try {
      return YearMonth.of(temporal.get(ChronoField.YEAR), temporal.get(ChronoField.MONTH_OF_YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain YearMonth from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  YearMonth.parse = function parse(text, formatter) {
    if (arguments.length === 1) {
      return YearMonth.parseString(text);
    } else {
      return YearMonth.parseStringFormatter(text, formatter);
    }
  };
  YearMonth.parseString = function parseString(text) {
    return YearMonth.parseStringFormatter(text, PARSER$1);
  };
  YearMonth.parseStringFormatter = function parseStringFormatter(text, formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, YearMonth.FROM);
  };
  function YearMonth(year, month) {
    var _this;
    _this = _Temporal.call(this) || this;
    _this._year = MathUtil.safeToInt(year);
    _this._month = MathUtil.safeToInt(month);
    return _this;
  }
  var _proto = YearMonth.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
      return this.isSupportedField(fieldOrUnit);
    } else {
      return this.isSupportedUnit(fieldOrUnit);
    }
  };
  _proto.isSupportedField = function isSupportedField(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.YEAR || field === ChronoField.MONTH_OF_YEAR || field === ChronoField.PROLEPTIC_MONTH || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.isSupportedUnit = function isSupportedUnit(unit) {
    if (unit instanceof ChronoUnit) {
      return unit === ChronoUnit.MONTHS || unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
    }
    return unit != null && unit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field === ChronoField.YEAR_OF_ERA) {
      return this.year() <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
    }
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get(field) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.MONTH_OF_YEAR:
          return this._month;
        case ChronoField.PROLEPTIC_MONTH:
          return this._getProlepticMonth();
        case ChronoField.YEAR_OF_ERA:
          return this._year < 1 ? 1 - this._year : this._year;
        case ChronoField.YEAR:
          return this._year;
        case ChronoField.ERA:
          return this._year < 1 ? 0 : 1;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto._getProlepticMonth = function _getProlepticMonth() {
    return MathUtil.safeAdd(MathUtil.safeMultiply(this._year, 12), this._month - 1);
  };
  _proto.year = function year() {
    return this._year;
  };
  _proto.monthValue = function monthValue() {
    return this._month;
  };
  _proto.month = function month() {
    return Month.of(this._month);
  };
  _proto.isLeapYear = function isLeapYear() {
    return IsoChronology.isLeapYear(this._year);
  };
  _proto.isValidDay = function isValidDay(dayOfMonth) {
    return dayOfMonth >= 1 && dayOfMonth <= this.lengthOfMonth();
  };
  _proto.lengthOfMonth = function lengthOfMonth() {
    return this.month().length(this.isLeapYear());
  };
  _proto.lengthOfYear = function lengthOfYear() {
    return this.isLeapYear() ? 366 : 365;
  };
  _proto.with = function _with(adjusterOrField, value) {
    if (arguments.length === 1) {
      return this._withAdjuster(adjusterOrField);
    } else {
      return this._withField(adjusterOrField, value);
    }
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    if (field instanceof ChronoField) {
      var f = field;
      f.checkValidValue(newValue);
      switch (f) {
        case ChronoField.MONTH_OF_YEAR:
          return this.withMonth(newValue);
        case ChronoField.PROLEPTIC_MONTH:
          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
        case ChronoField.YEAR_OF_ERA:
          return this.withYear(this._year < 1 ? 1 - newValue : newValue);
        case ChronoField.YEAR:
          return this.withYear(newValue);
        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    ChronoField.YEAR.checkValidValue(year);
    return new YearMonth(year, this._month);
  };
  _proto.withMonth = function withMonth(month) {
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    return new YearMonth(this._year, month);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit, 'unit');
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.MONTHS:
          return this.plusMonths(amountToAdd);
        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);
        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));
        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
    return this.withYear(newYear);
  };
  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }
    var monthCount = this._year * 12 + (this._month - 1);
    var calcMonths = monthCount + monthsToAdd;
    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
    return new YearMonth(newYear, newMonth);
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MIN_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
  };
  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return monthsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusMonths(Math.MAX_SAFE_INTEGER).plusMonths(1) : this.plusMonths(-monthsToSubtract);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    requireInstance(_query, TemporalQuery, 'query');
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.MONTHS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    requireInstance(temporal, Temporal, 'temporal');
    return temporal.with(ChronoField.PROLEPTIC_MONTH, this._getProlepticMonth());
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    requireInstance(endExclusive, Temporal, 'endExclusive');
    requireInstance(unit, TemporalUnit, 'unit');
    var end = YearMonth.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var monthsUntil = end._getProlepticMonth() - this._getProlepticMonth();
      switch (unit) {
        case ChronoUnit.MONTHS:
          return monthsUntil;
        case ChronoUnit.YEARS:
          return MathUtil.intDiv(monthsUntil, 12);
        case ChronoUnit.DECADES:
          return MathUtil.intDiv(monthsUntil, 120);
        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(monthsUntil, 1200);
        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(monthsUntil, 12000);
        case ChronoUnit.ERAS:
          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  _proto.atDay = function atDay(dayOfMonth) {
    requireNonNull(dayOfMonth, 'dayOfMonth');
    return LocalDate.of(this._year, this._month, dayOfMonth);
  };
  _proto.atEndOfMonth = function atEndOfMonth() {
    return LocalDate.of(this._year, this._month, this.lengthOfMonth());
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, YearMonth, 'other');
    var cmp = this._year - other.year();
    if (cmp === 0) {
      cmp = this._month - other.monthValue();
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.equals = function equals(obj) {
    if (this === obj) {
      return true;
    }
    if (obj instanceof YearMonth) {
      var other = obj;
      return this.year() === other.year() && this.monthValue() === other.monthValue();
    }
    return false;
  };
  _proto.toString = function toString() {
    return PARSER$1.format(this);
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };
  return YearMonth;
}(Temporal);
var PARSER$1;
function _init$b() {
  PARSER$1 = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).appendLiteral('-').appendValue(ChronoField.MONTH_OF_YEAR, 2).toFormatter();
  YearMonth.FROM = createTemporalQuery('YearMonth.FROM', function (temporal) {
    return YearMonth.from(temporal);
  });
}

var Year = function (_Temporal) {
  _inheritsLoose(Year, _Temporal);
  function Year(value) {
    var _this;
    _this = _Temporal.call(this) || this;
    _this._year = MathUtil.safeToInt(value);
    return _this;
  }
  var _proto = Year.prototype;
  _proto.value = function value() {
    return this._year;
  };
  Year.now = function now(zoneIdOrClock) {
    if (zoneIdOrClock === void 0) {
      zoneIdOrClock = undefined;
    }
    if (zoneIdOrClock === undefined) {
      return Year.now0();
    } else if (zoneIdOrClock instanceof ZoneId) {
      return Year.nowZoneId(zoneIdOrClock);
    } else {
      return Year.nowClock(zoneIdOrClock);
    }
  };
  Year.now0 = function now0() {
    return Year.nowClock(Clock.systemDefaultZone());
  };
  Year.nowZoneId = function nowZoneId(zone) {
    requireNonNull(zone, 'zone');
    requireInstance(zone, ZoneId, 'zone');
    return Year.nowClock(Clock.system(zone));
  };
  Year.nowClock = function nowClock(clock) {
    requireNonNull(clock, 'clock');
    requireInstance(clock, Clock, 'clock');
    var now = LocalDate.now(clock);
    return Year.of(now.year());
  };
  Year.of = function of(isoYear) {
    requireNonNull(isoYear, 'isoYear');
    ChronoField.YEAR.checkValidValue(isoYear);
    return new Year(isoYear);
  };
  Year.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    requireInstance(temporal, TemporalAccessor, 'temporal');
    if (temporal instanceof Year) {
      return temporal;
    }
    try {
      return Year.of(temporal.get(ChronoField.YEAR));
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Year from TemporalAccessor: " + temporal + ", type " + (temporal && temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  Year.parse = function parse(text, formatter) {
    if (arguments.length <= 1) {
      return Year.parseText(text);
    } else {
      return Year.parseTextFormatter(text, formatter);
    }
  };
  Year.parseText = function parseText(text) {
    requireNonNull(text, 'text');
    return Year.parse(text, PARSER);
  };
  Year.parseTextFormatter = function parseTextFormatter(text, formatter) {
    if (formatter === void 0) {
      formatter = PARSER;
    }
    requireNonNull(text, 'text');
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.parse(text, Year.FROM);
  };
  Year.isLeap = function isLeap(year) {
    return MathUtil.intMod(year, 4) === 0 && (MathUtil.intMod(year, 100) !== 0 || MathUtil.intMod(year, 400) === 0);
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (arguments.length === 1 && fieldOrUnit instanceof TemporalField) {
      return this.isSupportedField(fieldOrUnit);
    } else {
      return this.isSupportedUnit(fieldOrUnit);
    }
  };
  _proto.isSupportedField = function isSupportedField(field) {
    if (field instanceof ChronoField) {
      return field === ChronoField.YEAR || field === ChronoField.YEAR_OF_ERA || field === ChronoField.ERA;
    }
    return field != null && field.isSupportedBy(this);
  };
  _proto.isSupportedUnit = function isSupportedUnit(unit) {
    if (unit instanceof ChronoUnit) {
      return unit === ChronoUnit.YEARS || unit === ChronoUnit.DECADES || unit === ChronoUnit.CENTURIES || unit === ChronoUnit.MILLENNIA || unit === ChronoUnit.ERAS;
    }
    return unit != null && unit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (this.isSupported(field)) {
      return field.range();
    } else if (field instanceof ChronoField) {
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get(field) {
    return this.range(field).checkValidIntValue(this.getLong(field), field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.YEAR_OF_ERA:
          return this._year < 1 ? 1 - this._year : this._year;
        case ChronoField.YEAR:
          return this._year;
        case ChronoField.ERA:
          return this._year < 1 ? 0 : 1;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.isLeap = function isLeap() {
    return Year.isLeap(this._year);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);
      switch (field) {
        case ChronoField.YEAR_OF_ERA:
          return Year.of(this._year < 1 ? 1 - newValue : newValue);
        case ChronoField.YEAR:
          return Year.of(newValue);
        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : Year.of(1 - this._year);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit, 'unit');
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);
        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));
        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    return Year.of(ChronoField.YEAR.checkValidIntValue(MathUtil.safeAdd(this._year, yearsToAdd)));
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return yearsToSubtract === MathUtil.MIN_SAFE_INTEGER ? this.plusYears(MathUtil.MAX_SAFE_INTEGER).plusYears(1) : this.plusYears(-yearsToSubtract);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    return temporal.with(ChronoField.YEAR, this._year);
  };
  _proto.isValidMonthDay = function isValidMonthDay(monthDay) {
    return monthDay != null && monthDay.isValidYear(this._year);
  };
  _proto.length = function length() {
    return this.isLeap() ? 366 : 365;
  };
  _proto.atDay = function atDay(dayOfYear) {
    return LocalDate.ofYearDay(this._year, dayOfYear);
  };
  _proto.atMonth = function atMonth(monthOrNumber) {
    if (arguments.length === 1 && monthOrNumber instanceof Month) {
      return this.atMonthMonth(monthOrNumber);
    } else {
      return this.atMonthNumber(monthOrNumber);
    }
  };
  _proto.atMonthMonth = function atMonthMonth(month) {
    requireNonNull(month, 'month');
    requireInstance(month, Month, 'month');
    return YearMonth.of(this._year, month);
  };
  _proto.atMonthNumber = function atMonthNumber(month) {
    requireNonNull(month, 'month');
    return YearMonth.of(this._year, month);
  };
  _proto.atMonthDay = function atMonthDay(monthDay) {
    requireNonNull(monthDay, 'monthDay');
    requireInstance(monthDay, MonthDay, 'monthDay');
    return monthDay.atYear(this._year);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query()');
    requireInstance(_query, TemporalQuery, 'query()');
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.YEARS;
    } else if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Year, 'other');
    return this._year - other._year;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Year, 'other');
    return this._year > other._year;
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    requireInstance(other, Year, 'other');
    return this._year < other._year;
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return formatter.format(this);
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof Year) {
      return this.value() === other.value();
    }
    return false;
  };
  _proto.toString = function toString() {
    return "" + this._year;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.until = function until(endExclusive, unit) {
    var end = Year.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var yearsUntil = end.value() - this.value();
      switch (unit) {
        case ChronoUnit.YEARS:
          return yearsUntil;
        case ChronoUnit.DECADES:
          return MathUtil.intDiv(yearsUntil, 10);
        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(yearsUntil, 100);
        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(yearsUntil, 1000);
        case ChronoUnit.ERAS:
          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  return Year;
}(Temporal);
var PARSER;
function _init$a() {
  Year.MIN_VALUE = YearConstants.MIN_VALUE;
  Year.MAX_VALUE = YearConstants.MAX_VALUE;
  PARSER = new DateTimeFormatterBuilder().appendValue(ChronoField.YEAR, 4, 10, SignStyle.EXCEEDS_PAD).toFormatter();
  Year.FROM = createTemporalQuery('Year.FROM', function (temporal) {
    return Year.from(temporal);
  });
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var TemporalAdjuster = function () {
  function TemporalAdjuster() {}
  var _proto = TemporalAdjuster.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    abstractMethodFail('adjustInto');
  };
  return TemporalAdjuster;
}();

var TemporalAdjusters = function () {
  function TemporalAdjusters() {}
  TemporalAdjusters.firstDayOfMonth = function firstDayOfMonth() {
    return Impl.FIRST_DAY_OF_MONTH;
  };
  TemporalAdjusters.lastDayOfMonth = function lastDayOfMonth() {
    return Impl.LAST_DAY_OF_MONTH;
  };
  TemporalAdjusters.firstDayOfNextMonth = function firstDayOfNextMonth() {
    return Impl.FIRST_DAY_OF_NEXT_MONTH;
  };
  TemporalAdjusters.firstDayOfYear = function firstDayOfYear() {
    return Impl.FIRST_DAY_OF_YEAR;
  };
  TemporalAdjusters.lastDayOfYear = function lastDayOfYear() {
    return Impl.LAST_DAY_OF_YEAR;
  };
  TemporalAdjusters.firstDayOfNextYear = function firstDayOfNextYear() {
    return Impl.FIRST_DAY_OF_NEXT_YEAR;
  };
  TemporalAdjusters.firstInMonth = function firstInMonth(dayOfWeek) {
    requireNonNull(dayOfWeek, 'dayOfWeek');
    return new DayOfWeekInMonth(1, dayOfWeek);
  };
  TemporalAdjusters.lastInMonth = function lastInMonth(dayOfWeek) {
    requireNonNull(dayOfWeek, 'dayOfWeek');
    return new DayOfWeekInMonth(-1, dayOfWeek);
  };
  TemporalAdjusters.dayOfWeekInMonth = function dayOfWeekInMonth(ordinal, dayOfWeek) {
    requireNonNull(dayOfWeek, 'dayOfWeek');
    return new DayOfWeekInMonth(ordinal, dayOfWeek);
  };
  TemporalAdjusters.next = function next(dayOfWeek) {
    return new RelativeDayOfWeek(2, dayOfWeek);
  };
  TemporalAdjusters.nextOrSame = function nextOrSame(dayOfWeek) {
    return new RelativeDayOfWeek(0, dayOfWeek);
  };
  TemporalAdjusters.previous = function previous(dayOfWeek) {
    return new RelativeDayOfWeek(3, dayOfWeek);
  };
  TemporalAdjusters.previousOrSame = function previousOrSame(dayOfWeek) {
    return new RelativeDayOfWeek(1, dayOfWeek);
  };
  return TemporalAdjusters;
}();
var Impl = function (_TemporalAdjuster) {
  _inheritsLoose(Impl, _TemporalAdjuster);
  function Impl(ordinal) {
    var _this;
    _this = _TemporalAdjuster.call(this) || this;
    _this._ordinal = ordinal;
    return _this;
  }
  var _proto = Impl.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    switch (this._ordinal) {
      case 0:
        return temporal.with(ChronoField.DAY_OF_MONTH, 1);
      case 1:
        return temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
      case 2:
        return temporal.with(ChronoField.DAY_OF_MONTH, 1).plus(1, ChronoUnit.MONTHS);
      case 3:
        return temporal.with(ChronoField.DAY_OF_YEAR, 1);
      case 4:
        return temporal.with(ChronoField.DAY_OF_YEAR, temporal.range(ChronoField.DAY_OF_YEAR).maximum());
      case 5:
        return temporal.with(ChronoField.DAY_OF_YEAR, 1).plus(1, ChronoUnit.YEARS);
    }
    throw new IllegalStateException('Unreachable');
  };
  return Impl;
}(TemporalAdjuster);
Impl.FIRST_DAY_OF_MONTH = new Impl(0);
Impl.LAST_DAY_OF_MONTH = new Impl(1);
Impl.FIRST_DAY_OF_NEXT_MONTH = new Impl(2);
Impl.FIRST_DAY_OF_YEAR = new Impl(3);
Impl.LAST_DAY_OF_YEAR = new Impl(4);
Impl.FIRST_DAY_OF_NEXT_YEAR = new Impl(5);
var DayOfWeekInMonth = function (_TemporalAdjuster2) {
  _inheritsLoose(DayOfWeekInMonth, _TemporalAdjuster2);
  function DayOfWeekInMonth(ordinal, dow) {
    var _this2;
    _this2 = _TemporalAdjuster2.call(this) || this;
    _this2._ordinal = ordinal;
    _this2._dowValue = dow.value();
    return _this2;
  }
  var _proto2 = DayOfWeekInMonth.prototype;
  _proto2.adjustInto = function adjustInto(temporal) {
    if (this._ordinal >= 0) {
      var temp = temporal.with(ChronoField.DAY_OF_MONTH, 1);
      var curDow = temp.get(ChronoField.DAY_OF_WEEK);
      var dowDiff = MathUtil.intMod(this._dowValue - curDow + 7, 7);
      dowDiff += (this._ordinal - 1) * 7;
      return temp.plus(dowDiff, ChronoUnit.DAYS);
    } else {
      var _temp = temporal.with(ChronoField.DAY_OF_MONTH, temporal.range(ChronoField.DAY_OF_MONTH).maximum());
      var _curDow = _temp.get(ChronoField.DAY_OF_WEEK);
      var daysDiff = this._dowValue - _curDow;
      daysDiff = daysDiff === 0 ? 0 : daysDiff > 0 ? daysDiff - 7 : daysDiff;
      daysDiff -= (-this._ordinal - 1) * 7;
      return _temp.plus(daysDiff, ChronoUnit.DAYS);
    }
  };
  return DayOfWeekInMonth;
}(TemporalAdjuster);
var RelativeDayOfWeek = function (_TemporalAdjuster3) {
  _inheritsLoose(RelativeDayOfWeek, _TemporalAdjuster3);
  function RelativeDayOfWeek(relative, dayOfWeek) {
    var _this3;
    _this3 = _TemporalAdjuster3.call(this) || this;
    requireNonNull(dayOfWeek, 'dayOfWeek');
    _this3._relative = relative;
    _this3._dowValue = dayOfWeek.value();
    return _this3;
  }
  var _proto3 = RelativeDayOfWeek.prototype;
  _proto3.adjustInto = function adjustInto(temporal) {
    var calDow = temporal.get(ChronoField.DAY_OF_WEEK);
    if (this._relative < 2 && calDow === this._dowValue) {
      return temporal;
    }
    if ((this._relative & 1) === 0) {
      var daysDiff = calDow - this._dowValue;
      return temporal.plus(daysDiff >= 0 ? 7 - daysDiff : -daysDiff, ChronoUnit.DAYS);
    } else {
      var _daysDiff = this._dowValue - calDow;
      return temporal.minus(_daysDiff >= 0 ? 7 - _daysDiff : -_daysDiff, ChronoUnit.DAYS);
    }
  };
  return RelativeDayOfWeek;
}(TemporalAdjuster);

var IsoChronology = function (_Enum) {
  _inheritsLoose(IsoChronology, _Enum);
  function IsoChronology() {
    return _Enum.apply(this, arguments) || this;
  }
  IsoChronology.isLeapYear = function isLeapYear(prolepticYear) {
    return (prolepticYear & 3) === 0 && (prolepticYear % 100 !== 0 || prolepticYear % 400 === 0);
  };
  var _proto = IsoChronology.prototype;
  _proto._updateResolveMap = function _updateResolveMap(fieldValues, field, value) {
    requireNonNull(fieldValues, 'fieldValues');
    requireNonNull(field, 'field');
    var current = fieldValues.get(field);
    if (current != null && current !== value) {
      throw new DateTimeException("Invalid state, field: " + field + " " + current + " conflicts with " + field + " " + value);
    }
    fieldValues.put(field, value);
  };
  _proto.resolveDate = function resolveDate(fieldValues, resolverStyle) {
    if (fieldValues.containsKey(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(fieldValues.remove(ChronoField.EPOCH_DAY));
    }
    var prolepticMonth = fieldValues.remove(ChronoField.PROLEPTIC_MONTH);
    if (prolepticMonth != null) {
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.PROLEPTIC_MONTH.checkValidValue(prolepticMonth);
      }
      this._updateResolveMap(fieldValues, ChronoField.MONTH_OF_YEAR, MathUtil.floorMod(prolepticMonth, 12) + 1);
      this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.floorDiv(prolepticMonth, 12));
    }
    var yoeLong = fieldValues.remove(ChronoField.YEAR_OF_ERA);
    if (yoeLong != null) {
      if (resolverStyle !== ResolverStyle.LENIENT) {
        ChronoField.YEAR_OF_ERA.checkValidValue(yoeLong);
      }
      var era = fieldValues.remove(ChronoField.ERA);
      if (era == null) {
        var year = fieldValues.get(ChronoField.YEAR);
        if (resolverStyle === ResolverStyle.STRICT) {
          if (year != null) {
            this._updateResolveMap(fieldValues, ChronoField.YEAR, year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
          } else {
            fieldValues.put(ChronoField.YEAR_OF_ERA, yoeLong);
          }
        } else {
          this._updateResolveMap(fieldValues, ChronoField.YEAR, year == null || year > 0 ? yoeLong : MathUtil.safeSubtract(1, yoeLong));
        }
      } else if (era === 1) {
        this._updateResolveMap(fieldValues, ChronoField.YEAR, yoeLong);
      } else if (era === 0) {
        this._updateResolveMap(fieldValues, ChronoField.YEAR, MathUtil.safeSubtract(1, yoeLong));
      } else {
        throw new DateTimeException("Invalid value for era: " + era);
      }
    } else if (fieldValues.containsKey(ChronoField.ERA)) {
      ChronoField.ERA.checkValidValue(fieldValues.get(ChronoField.ERA));
    }
    if (fieldValues.containsKey(ChronoField.YEAR)) {
      if (fieldValues.containsKey(ChronoField.MONTH_OF_YEAR)) {
        if (fieldValues.containsKey(ChronoField.DAY_OF_MONTH)) {
          var y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
          var moy = fieldValues.remove(ChronoField.MONTH_OF_YEAR);
          var dom = fieldValues.remove(ChronoField.DAY_OF_MONTH);
          if (resolverStyle === ResolverStyle.LENIENT) {
            var months = moy - 1;
            var days = dom - 1;
            return LocalDate.of(y, 1, 1).plusMonths(months).plusDays(days);
          } else if (resolverStyle === ResolverStyle.SMART) {
            ChronoField.DAY_OF_MONTH.checkValidValue(dom);
            if (moy === 4 || moy === 6 || moy === 9 || moy === 11) {
              dom = Math.min(dom, 30);
            } else if (moy === 2) {
              dom = Math.min(dom, Month.FEBRUARY.length(Year.isLeap(y)));
            }
            return LocalDate.of(y, moy, dom);
          } else {
            return LocalDate.of(y, moy, dom);
          }
        }
      }
      if (fieldValues.containsKey(ChronoField.DAY_OF_YEAR)) {
        var _y = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
        if (resolverStyle === ResolverStyle.LENIENT) {
          var _days = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_YEAR), 1);
          return LocalDate.ofYearDay(_y, 1).plusDays(_days);
        }
        var doy = ChronoField.DAY_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_YEAR));
        return LocalDate.ofYearDay(_y, doy);
      }
      if (fieldValues.containsKey(ChronoField.ALIGNED_WEEK_OF_YEAR)) {
        if (fieldValues.containsKey(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR)) {
          var _y2 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
          if (resolverStyle === ResolverStyle.LENIENT) {
            var weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
            var _days2 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), 1);
            return LocalDate.of(_y2, 1, 1).plusWeeks(weeks).plusDays(_days2);
          }
          var aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
          var ad = ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
          var date = LocalDate.of(_y2, 1, 1).plusDays((aw - 1) * 7 + (ad - 1));
          if (resolverStyle === ResolverStyle.STRICT && date.get(ChronoField.YEAR) !== _y2) {
            throw new DateTimeException('Strict mode rejected date parsed to a different year');
          }
          return date;
        }
        if (fieldValues.containsKey(ChronoField.DAY_OF_WEEK)) {
          var _y3 = ChronoField.YEAR.checkValidIntValue(fieldValues.remove(ChronoField.YEAR));
          if (resolverStyle === ResolverStyle.LENIENT) {
            var _weeks = MathUtil.safeSubtract(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR), 1);
            var _days3 = MathUtil.safeSubtract(fieldValues.remove(ChronoField.DAY_OF_WEEK), 1);
            return LocalDate.of(_y3, 1, 1).plusWeeks(_weeks).plusDays(_days3);
          }
          var _aw = ChronoField.ALIGNED_WEEK_OF_YEAR.checkValidIntValue(fieldValues.remove(ChronoField.ALIGNED_WEEK_OF_YEAR));
          var dow = ChronoField.DAY_OF_WEEK.checkValidIntValue(fieldValues.remove(ChronoField.DAY_OF_WEEK));
          var _date = LocalDate.of(_y3, 1, 1).plusWeeks(_aw - 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.of(dow)));
          if (resolverStyle === ResolverStyle.STRICT && _date.get(ChronoField.YEAR) !== _y3) {
            throw new DateTimeException('Strict mode rejected date parsed to a different month');
          }
          return _date;
        }
      }
    }
    return null;
  };
  _proto.date = function date(temporal) {
    return LocalDate.from(temporal);
  };
  return IsoChronology;
}(Enum);
function _init$9() {
  IsoChronology.INSTANCE = new IsoChronology('IsoChronology');
}

var OffsetTime = function (_Temporal) {
  _inheritsLoose(OffsetTime, _Temporal);
  OffsetTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    if (temporal instanceof OffsetTime) {
      return temporal;
    } else if (temporal instanceof OffsetDateTime) {
      return temporal.toOffsetTime();
    }
    try {
      var time = LocalTime.from(temporal);
      var offset = ZoneOffset.from(temporal);
      return new OffsetTime(time, offset);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain OffsetTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  OffsetTime.now = function now(clockOrZone) {
    if (arguments.length === 0) {
      return OffsetTime._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return OffsetTime._now(clockOrZone);
    } else {
      return OffsetTime._now(Clock.system(clockOrZone));
    }
  };
  OffsetTime._now = function _now(clock) {
    requireNonNull(clock, 'clock');
    var now = clock.instant();
    return OffsetTime.ofInstant(now, clock.zone().rules().offset(now));
  };
  OffsetTime.of = function of() {
    if (arguments.length <= 2) {
      return OffsetTime.ofTimeAndOffset.apply(this, arguments);
    } else {
      return OffsetTime.ofNumbers.apply(this, arguments);
    }
  };
  OffsetTime.ofNumbers = function ofNumbers(hour, minute, second, nanoOfSecond, offset) {
    var time = LocalTime.of(hour, minute, second, nanoOfSecond);
    return new OffsetTime(time, offset);
  };
  OffsetTime.ofTimeAndOffset = function ofTimeAndOffset(time, offset) {
    return new OffsetTime(time, offset);
  };
  OffsetTime.ofInstant = function ofInstant(instant, zone) {
    requireNonNull(instant, 'instant');
    requireInstance(instant, Instant, 'instant');
    requireNonNull(zone, 'zone');
    requireInstance(zone, ZoneId, 'zone');
    var rules = zone.rules();
    var offset = rules.offset(instant);
    var secsOfDay = instant.epochSecond() % LocalTime.SECONDS_PER_DAY;
    secsOfDay = (secsOfDay + offset.totalSeconds()) % LocalTime.SECONDS_PER_DAY;
    if (secsOfDay < 0) {
      secsOfDay += LocalTime.SECONDS_PER_DAY;
    }
    var time = LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
    return new OffsetTime(time, offset);
  };
  OffsetTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_OFFSET_TIME;
    }
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, OffsetTime.FROM);
  };
  function OffsetTime(time, offset) {
    var _this;
    _this = _Temporal.call(this) || this;
    requireNonNull(time, 'time');
    requireInstance(time, LocalTime, 'time');
    requireNonNull(offset, 'offset');
    requireInstance(offset, ZoneOffset, 'offset');
    _this._time = time;
    _this._offset = offset;
    return _this;
  }
  var _proto = OffsetTime.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.NANO_OF_DAY, this._time.toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
  };
  _proto.atDate = function atDate(date) {
    return OffsetDateTime.of(date, this._time, this._offset);
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this, OffsetTime.FROM);
  };
  _proto.get = function get(field) {
    return _Temporal.prototype.get.call(this, field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return this._offset.totalSeconds();
      }
      return this._time.getLong(field);
    }
    return field.getFrom(this);
  };
  _proto.hour = function hour() {
    return this._time.hour();
  };
  _proto.minute = function minute() {
    return this._time.minute();
  };
  _proto.second = function second() {
    return this._time.second();
  };
  _proto.nano = function nano() {
    return this._time.nano();
  };
  _proto.offset = function offset() {
    return this._offset;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    return this._toEpochNano() > other._toEpochNano();
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    return this._toEpochNano() < other._toEpochNano();
  };
  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, 'other');
    return this._toEpochNano() === other._toEpochNano();
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoField.OFFSET_SECONDS;
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.minusHours = function minusHours(hours) {
    return this._withLocalTimeOffset(this._time.minusHours(hours), this._offset);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._withLocalTimeOffset(this._time.minusMinutes(minutes), this._offset);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._withLocalTimeOffset(this._time.minusSeconds(seconds), this._offset);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this._withLocalTimeOffset(this._time.minusNanos(nanos), this._offset);
  };
  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount);
    return amount.subtractFrom(this);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this.plus(-1 * amountToSubtract, unit);
  };
  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount);
    return amount.addTo(this);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      return this._withLocalTimeOffset(this._time.plus(amountToAdd, unit), this._offset);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusHours = function plusHours(hours) {
    return this._withLocalTimeOffset(this._time.plusHours(hours), this._offset);
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._withLocalTimeOffset(this._time.plusMinutes(minutes), this._offset);
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._withLocalTimeOffset(this._time.plusSeconds(seconds), this._offset);
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._withLocalTimeOffset(this._time.plusNanos(nanos), this._offset);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this.offset();
    } else if (_query === TemporalQueries.localTime()) {
      return this._time;
    } else if (_query === TemporalQueries.chronology() || _query === TemporalQueries.localDate() || _query === TemporalQueries.zoneId()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }
      return this._time.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._time;
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withLocalTimeOffset(this._time.truncatedTo(unit), this._offset);
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = OffsetTime.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var nanosUntil = end._toEpochNano() - this._toEpochNano();
      switch (unit) {
        case ChronoUnit.NANOS:
          return nanosUntil;
        case ChronoUnit.MICROS:
          return MathUtil.intDiv(nanosUntil, 1000);
        case ChronoUnit.MILLIS:
          return MathUtil.intDiv(nanosUntil, 1000000);
        case ChronoUnit.SECONDS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
        case ChronoUnit.HOURS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  _proto.withHour = function withHour(hour) {
    return this._withLocalTimeOffset(this._time.withHour(hour), this._offset);
  };
  _proto.withMinute = function withMinute(minute) {
    return this._withLocalTimeOffset(this._time.withMinute(minute), this._offset);
  };
  _proto.withSecond = function withSecond(second) {
    return this._withLocalTimeOffset(this._time.withSecond(second), this._offset);
  };
  _proto.withNano = function withNano(nano) {
    return this._withLocalTimeOffset(this._time.withNano(nano), this._offset);
  };
  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
    requireNonNull(offset, 'offset');
    if (offset.equals(this._offset)) {
      return this;
    }
    var difference = offset.totalSeconds() - this._offset.totalSeconds();
    var adjusted = this._time.plusSeconds(difference);
    return new OffsetTime(adjusted, offset);
  };
  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
    return offset != null && offset.equals(this._offset) ? this : new OffsetTime(this._time, offset);
  };
  _proto._toEpochNano = function _toEpochNano() {
    var nod = this._time.toNanoOfDay();
    var offsetNanos = this._offset.totalSeconds() * LocalTime.NANOS_PER_SECOND;
    return nod - offsetNanos;
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    if (adjuster instanceof LocalTime) {
      return this._withLocalTimeOffset(adjuster, this._offset);
    } else if (adjuster instanceof ZoneOffset) {
      return this._withLocalTimeOffset(this._time, adjuster);
    } else if (adjuster instanceof OffsetTime) {
      return adjuster;
    }
    return adjuster.adjustInto(this);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      if (field === ChronoField.OFFSET_SECONDS) {
        return this._withLocalTimeOffset(this._time, ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue)));
      }
      return this._withLocalTimeOffset(this._time.with(field, newValue), this._offset);
    }
    return field.adjustInto(this, newValue);
  };
  _proto._withLocalTimeOffset = function _withLocalTimeOffset(time, offset) {
    if (this._time === time && this._offset.equals(offset)) {
      return this;
    }
    return new OffsetTime(time, offset);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, OffsetTime, 'other');
    if (this._offset.equals(other._offset)) {
      return this._time.compareTo(other._time);
    }
    var compare = MathUtil.compareNumbers(this._toEpochNano(), other._toEpochNano());
    if (compare === 0) {
      return this._time.compareTo(other._time);
    }
    return compare;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof OffsetTime) {
      return this._time.equals(other._time) && this._offset.equals(other._offset);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._time.hashCode() ^ this._offset.hashCode();
  };
  _proto.toString = function toString() {
    return this._time.toString() + this._offset.toString();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return OffsetTime;
}(Temporal);
function _init$8() {
  OffsetTime.MIN = OffsetTime.ofNumbers(0, 0, 0, 0, ZoneOffset.MAX);
  OffsetTime.MAX = OffsetTime.ofNumbers(23, 59, 59, 999999999, ZoneOffset.MIN);
  OffsetTime.FROM = createTemporalQuery('OffsetTime.FROM', function (temporal) {
    return OffsetTime.from(temporal);
  });
}

var ChronoZonedDateTime = function (_Temporal) {
  _inheritsLoose(ChronoZonedDateTime, _Temporal);
  function ChronoZonedDateTime() {
    return _Temporal.apply(this, arguments) || this;
  }
  var _proto = ChronoZonedDateTime.prototype;
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.zoneId() || _query === TemporalQueries.zone()) {
      return this.zone();
    } else if (_query === TemporalQueries.chronology()) {
      return this.toLocalDate().chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset()) {
      return this.offset();
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };
  _proto.toInstant = function toInstant() {
    return Instant.ofEpochSecond(this.toEpochSecond(), this.toLocalTime().nano());
  };
  _proto.toEpochSecond = function toEpochSecond() {
    var epochDay = this.toLocalDate().toEpochDay();
    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
    secs -= this.offset().totalSeconds();
    return secs;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
    if (cmp === 0) {
      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
      if (cmp === 0) {
        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
        if (cmp === 0) {
          cmp = strcmp(this.zone().id(), other.zone().id());
        }
      }
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
  };
  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, 'other');
    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof ChronoZonedDateTime) {
      return this.compareTo(other) === 0;
    }
    return false;
  };
  return ChronoZonedDateTime;
}(Temporal);
function strcmp(a, b) {
  if (a < b) {
    return -1;
  }
  if (a > b) {
    return 1;
  }
  return 0;
}

var ZonedDateTime = function (_ChronoZonedDateTime) {
  _inheritsLoose(ZonedDateTime, _ChronoZonedDateTime);
  ZonedDateTime.now = function now(clockOrZone) {
    var clock;
    if (clockOrZone instanceof ZoneId) {
      clock = Clock.system(clockOrZone);
    } else {
      clock = clockOrZone == null ? Clock.systemDefaultZone() : clockOrZone;
    }
    return ZonedDateTime.ofInstant(clock.instant(), clock.zone());
  };
  ZonedDateTime.of = function of() {
    if (arguments.length <= 2) {
      return ZonedDateTime.of2.apply(this, arguments);
    } else if (arguments.length === 3 && arguments[0] instanceof LocalDate) {
      return ZonedDateTime.of3.apply(this, arguments);
    } else {
      return ZonedDateTime.of8.apply(this, arguments);
    }
  };
  ZonedDateTime.of3 = function of3(date, time, zone) {
    return ZonedDateTime.of2(LocalDateTime.of(date, time), zone);
  };
  ZonedDateTime.of2 = function of2(localDateTime, zone) {
    return ZonedDateTime.ofLocal(localDateTime, zone, null);
  };
  ZonedDateTime.of8 = function of8(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, zone) {
    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
    return ZonedDateTime.ofLocal(dt, zone, null);
  };
  ZonedDateTime.ofLocal = function ofLocal(localDateTime, zone, preferredOffset) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(zone, 'zone');
    if (zone instanceof ZoneOffset) {
      return new ZonedDateTime(localDateTime, zone, zone);
    }
    var offset = null;
    var rules = zone.rules();
    var validOffsets = rules.validOffsets(localDateTime);
    if (validOffsets.length === 1) {
      offset = validOffsets[0];
    } else if (validOffsets.length === 0) {
      var trans = rules.transition(localDateTime);
      localDateTime = localDateTime.plusSeconds(trans.duration().seconds());
      offset = trans.offsetAfter();
    } else {
      if (preferredOffset != null && validOffsets.some(function (validOffset) {
        return validOffset.equals(preferredOffset);
      })) {
        offset = preferredOffset;
      } else {
        offset = requireNonNull(validOffsets[0], 'offset');
      }
    }
    return new ZonedDateTime(localDateTime, offset, zone);
  };
  ZonedDateTime.ofInstant = function ofInstant() {
    if (arguments.length === 2) {
      return ZonedDateTime.ofInstant2.apply(this, arguments);
    } else {
      return ZonedDateTime.ofInstant3.apply(this, arguments);
    }
  };
  ZonedDateTime.ofInstant2 = function ofInstant2(instant, zone) {
    requireNonNull(instant, 'instant');
    requireNonNull(zone, 'zone');
    return ZonedDateTime._create(instant.epochSecond(), instant.nano(), zone);
  };
  ZonedDateTime.ofInstant3 = function ofInstant3(localDateTime, offset, zone) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    return ZonedDateTime._create(localDateTime.toEpochSecond(offset), localDateTime.nano(), zone);
  };
  ZonedDateTime._create = function _create(epochSecond, nanoOfSecond, zone) {
    var rules = zone.rules();
    var instant = Instant.ofEpochSecond(epochSecond, nanoOfSecond);
    var offset = rules.offset(instant);
    var ldt = LocalDateTime.ofEpochSecond(epochSecond, nanoOfSecond, offset);
    return new ZonedDateTime(ldt, offset, zone);
  };
  ZonedDateTime.ofStrict = function ofStrict(localDateTime, offset, zone) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    var rules = zone.rules();
    if (rules.isValidOffset(localDateTime, offset) === false) {
      var trans = rules.transition(localDateTime);
      if (trans != null && trans.isGap()) {
        throw new DateTimeException("LocalDateTime " + localDateTime + " does not exist in zone " + zone + " due to a gap in the local time-line, typically caused by daylight savings");
      }
      throw new DateTimeException("ZoneOffset \"" + offset + "\" is not valid for LocalDateTime \"" + localDateTime + "\" in zone \"" + zone + "\"");
    }
    return new ZonedDateTime(localDateTime, offset, zone);
  };
  ZonedDateTime.ofLenient = function ofLenient(localDateTime, offset, zone) {
    requireNonNull(localDateTime, 'localDateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    if (zone instanceof ZoneOffset && offset.equals(zone) === false) {
      throw new IllegalArgumentException('ZoneId must match ZoneOffset');
    }
    return new ZonedDateTime(localDateTime, offset, zone);
  };
  ZonedDateTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    if (temporal instanceof ZonedDateTime) {
      return temporal;
    }
    var zone = ZoneId.from(temporal);
    if (temporal.isSupported(ChronoField.INSTANT_SECONDS)) {
      var zdt = ZonedDateTime._from(temporal, zone);
      if (zdt != null) return zdt;
    }
    var ldt = LocalDateTime.from(temporal);
    return ZonedDateTime.of2(ldt, zone);
  };
  ZonedDateTime._from = function _from(temporal, zone) {
    try {
      return ZonedDateTime.__from(temporal, zone);
    } catch (ex) {
      if (!(ex instanceof DateTimeException)) throw ex;
    }
  };
  ZonedDateTime.__from = function __from(temporal, zone) {
    var epochSecond = temporal.getLong(ChronoField.INSTANT_SECONDS);
    var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
    return ZonedDateTime._create(epochSecond, nanoOfSecond, zone);
  };
  ZonedDateTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_ZONED_DATE_TIME;
    }
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, ZonedDateTime.FROM);
  };
  function ZonedDateTime(dateTime, offset, zone) {
    var _this;
    requireNonNull(dateTime, 'dateTime');
    requireNonNull(offset, 'offset');
    requireNonNull(zone, 'zone');
    _this = _ChronoZonedDateTime.call(this) || this;
    _this._dateTime = dateTime;
    _this._offset = offset;
    _this._zone = zone;
    return _this;
  }
  var _proto = ZonedDateTime.prototype;
  _proto._resolveLocal = function _resolveLocal(newDateTime) {
    requireNonNull(newDateTime, 'newDateTime');
    return ZonedDateTime.ofLocal(newDateTime, this._zone, this._offset);
  };
  _proto._resolveInstant = function _resolveInstant(newDateTime) {
    return ZonedDateTime.ofInstant3(newDateTime, this._offset, this._zone);
  };
  _proto._resolveOffset = function _resolveOffset(offset) {
    if (offset.equals(this._offset) === false && this._zone.rules().isValidOffset(this._dateTime, offset)) {
      return new ZonedDateTime(this._dateTime, offset, this._zone);
    }
    return this;
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return true;
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }
      return this._dateTime.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return this.toEpochSecond();
        case ChronoField.OFFSET_SECONDS:
          return this._offset.totalSeconds();
      }
      return this._dateTime.getLong(field);
    }
    requireNonNull(field, 'field');
    return field.getFrom(this);
  };
  _proto.offset = function offset() {
    return this._offset;
  };
  _proto.withEarlierOffsetAtOverlap = function withEarlierOffsetAtOverlap() {
    var trans = this._zone.rules().transition(this._dateTime);
    if (trans != null && trans.isOverlap()) {
      var earlierOffset = trans.offsetBefore();
      if (earlierOffset.equals(this._offset) === false) {
        return new ZonedDateTime(this._dateTime, earlierOffset, this._zone);
      }
    }
    return this;
  };
  _proto.withLaterOffsetAtOverlap = function withLaterOffsetAtOverlap() {
    var trans = this._zone.rules().transition(this.toLocalDateTime());
    if (trans != null) {
      var laterOffset = trans.offsetAfter();
      if (laterOffset.equals(this._offset) === false) {
        return new ZonedDateTime(this._dateTime, laterOffset, this._zone);
      }
    }
    return this;
  };
  _proto.zone = function zone() {
    return this._zone;
  };
  _proto.withZoneSameLocal = function withZoneSameLocal(zone) {
    requireNonNull(zone, 'zone');
    return this._zone.equals(zone) ? this : ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
  };
  _proto.withZoneSameInstant = function withZoneSameInstant(zone) {
    requireNonNull(zone, 'zone');
    return this._zone.equals(zone) ? this : ZonedDateTime._create(this._dateTime.toEpochSecond(this._offset), this._dateTime.nano(), zone);
  };
  _proto.withFixedOffsetZone = function withFixedOffsetZone() {
    return this._zone.equals(this._offset) ? this : new ZonedDateTime(this._dateTime, this._offset, this._offset);
  };
  _proto.year = function year() {
    return this._dateTime.year();
  };
  _proto.monthValue = function monthValue() {
    return this._dateTime.monthValue();
  };
  _proto.month = function month() {
    return this._dateTime.month();
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._dateTime.dayOfMonth();
  };
  _proto.dayOfYear = function dayOfYear() {
    return this._dateTime.dayOfYear();
  };
  _proto.dayOfWeek = function dayOfWeek() {
    return this._dateTime.dayOfWeek();
  };
  _proto.hour = function hour() {
    return this._dateTime.hour();
  };
  _proto.minute = function minute() {
    return this._dateTime.minute();
  };
  _proto.second = function second() {
    return this._dateTime.second();
  };
  _proto.nano = function nano() {
    return this._dateTime.nano();
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    if (adjuster instanceof LocalDate) {
      return this._resolveLocal(LocalDateTime.of(adjuster, this._dateTime.toLocalTime()));
    } else if (adjuster instanceof LocalTime) {
      return this._resolveLocal(LocalDateTime.of(this._dateTime.toLocalDate(), adjuster));
    } else if (adjuster instanceof LocalDateTime) {
      return this._resolveLocal(adjuster);
    } else if (adjuster instanceof Instant) {
      var instant = adjuster;
      return ZonedDateTime._create(instant.epochSecond(), instant.nano(), this._zone);
    } else if (adjuster instanceof ZoneOffset) {
      return this._resolveOffset(adjuster);
    }
    return _ChronoZonedDateTime.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return ZonedDateTime._create(newValue, this.nano(), this._zone);
        case ChronoField.OFFSET_SECONDS:
          {
            var offset = ZoneOffset.ofTotalSeconds(field.checkValidIntValue(newValue));
            return this._resolveOffset(offset);
          }
      }
      return this._resolveLocal(this._dateTime.with(field, newValue));
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    return this._resolveLocal(this._dateTime.withYear(year));
  };
  _proto.withMonth = function withMonth(month) {
    return this._resolveLocal(this._dateTime.withMonth(month));
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._resolveLocal(this._dateTime.withDayOfMonth(dayOfMonth));
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._resolveLocal(this._dateTime.withDayOfYear(dayOfYear));
  };
  _proto.withHour = function withHour(hour) {
    return this._resolveLocal(this._dateTime.withHour(hour));
  };
  _proto.withMinute = function withMinute(minute) {
    return this._resolveLocal(this._dateTime.withMinute(minute));
  };
  _proto.withSecond = function withSecond(second) {
    return this._resolveLocal(this._dateTime.withSecond(second));
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    return this._resolveLocal(this._dateTime.withNano(nanoOfSecond));
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._resolveLocal(this._dateTime.truncatedTo(unit));
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      if (unit.isDateBased()) {
        return this._resolveLocal(this._dateTime.plus(amountToAdd, unit));
      } else {
        return this._resolveInstant(this._dateTime.plus(amountToAdd, unit));
      }
    }
    requireNonNull(unit, 'unit');
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(years) {
    return this._resolveLocal(this._dateTime.plusYears(years));
  };
  _proto.plusMonths = function plusMonths(months) {
    return this._resolveLocal(this._dateTime.plusMonths(months));
  };
  _proto.plusWeeks = function plusWeeks(weeks) {
    return this._resolveLocal(this._dateTime.plusWeeks(weeks));
  };
  _proto.plusDays = function plusDays(days) {
    return this._resolveLocal(this._dateTime.plusDays(days));
  };
  _proto.plusHours = function plusHours(hours) {
    return this._resolveInstant(this._dateTime.plusHours(hours));
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._resolveInstant(this._dateTime.plusMinutes(minutes));
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._resolveInstant(this._dateTime.plusSeconds(seconds));
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._resolveInstant(this._dateTime.plusNanos(nanos));
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(years) {
    return this.plusYears(-1 * years);
  };
  _proto.minusMonths = function minusMonths(months) {
    return this.plusMonths(-1 * months);
  };
  _proto.minusWeeks = function minusWeeks(weeks) {
    return this.plusWeeks(-1 * weeks);
  };
  _proto.minusDays = function minusDays(days) {
    return this.plusDays(-1 * days);
  };
  _proto.minusHours = function minusHours(hours) {
    return this.plusHours(-1 * hours);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this.plusMinutes(-1 * minutes);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this.plusSeconds(-1 * seconds);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this.plusNanos(-1 * nanos);
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    }
    requireNonNull(_query, 'query');
    return _ChronoZonedDateTime.prototype.query.call(this, _query);
  };
  _proto.until = function until(endExclusive, unit) {
    var end = ZonedDateTime.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      end = end.withZoneSameInstant(this._zone);
      if (unit.isDateBased()) {
        return this._dateTime.until(end._dateTime, unit);
      } else {
        var difference = this._offset.totalSeconds() - end._offset.totalSeconds();
        var adjustedEnd = end._dateTime.plusSeconds(difference);
        return this._dateTime.until(adjustedEnd, unit);
      }
    }
    return unit.between(this, end);
  };
  _proto.toLocalDateTime = function toLocalDateTime() {
    return this._dateTime;
  };
  _proto.toLocalDate = function toLocalDate() {
    return this._dateTime.toLocalDate();
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._dateTime.toLocalTime();
  };
  _proto.toOffsetDateTime = function toOffsetDateTime() {
    return OffsetDateTime.of(this._dateTime, this._offset);
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof ZonedDateTime) {
      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset) && this._zone.equals(other._zone);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._dateTime.hashCode(), this._offset.hashCode(), this._zone.hashCode());
  };
  _proto.toString = function toString() {
    var str = this._dateTime.toString() + this._offset.toString();
    if (this._offset !== this._zone) {
      str += "[" + this._zone.toString() + "]";
    }
    return str;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    return _ChronoZonedDateTime.prototype.format.call(this, formatter);
  };
  return ZonedDateTime;
}(ChronoZonedDateTime);
function _init$7() {
  ZonedDateTime.FROM = createTemporalQuery('ZonedDateTime.FROM', function (temporal) {
    return ZonedDateTime.from(temporal);
  });
}

var OffsetDateTime = function (_Temporal) {
  _inheritsLoose(OffsetDateTime, _Temporal);
  OffsetDateTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    if (temporal instanceof OffsetDateTime) {
      return temporal;
    }
    try {
      var offset = ZoneOffset.from(temporal);
      try {
        var ldt = LocalDateTime.from(temporal);
        return OffsetDateTime.of(ldt, offset);
      } catch (_) {
        var instant = Instant.from(temporal);
        return OffsetDateTime.ofInstant(instant, offset);
      }
    } catch (ex) {
      throw new DateTimeException("Unable to obtain OffsetDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  OffsetDateTime.now = function now(clockOrZone) {
    if (arguments.length === 0) {
      return OffsetDateTime.now(Clock.systemDefaultZone());
    } else {
      requireNonNull(clockOrZone, 'clockOrZone');
      if (clockOrZone instanceof ZoneId) {
        return OffsetDateTime.now(Clock.system(clockOrZone));
      } else if (clockOrZone instanceof Clock) {
        var now = clockOrZone.instant();
        return OffsetDateTime.ofInstant(now, clockOrZone.zone().rules().offset(now));
      } else {
        throw new IllegalArgumentException('clockOrZone must be an instance of ZoneId or Clock');
      }
    }
  };
  OffsetDateTime.of = function of() {
    if (arguments.length <= 2) {
      return OffsetDateTime.ofDateTime.apply(this, arguments);
    } else if (arguments.length === 3) {
      return OffsetDateTime.ofDateAndTime.apply(this, arguments);
    } else {
      return OffsetDateTime.ofNumbers.apply(this, arguments);
    }
  };
  OffsetDateTime.ofDateTime = function ofDateTime(dateTime, offset) {
    return new OffsetDateTime(dateTime, offset);
  };
  OffsetDateTime.ofDateAndTime = function ofDateAndTime(date, time, offset) {
    var dt = LocalDateTime.of(date, time);
    return new OffsetDateTime(dt, offset);
  };
  OffsetDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond, offset) {
    if (hour === void 0) {
      hour = 0;
    }
    if (minute === void 0) {
      minute = 0;
    }
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    var dt = LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nanoOfSecond);
    return new OffsetDateTime(dt, offset);
  };
  OffsetDateTime.ofInstant = function ofInstant(instant, zone) {
    requireNonNull(instant, 'instant');
    requireNonNull(zone, 'zone');
    var rules = zone.rules();
    var offset = rules.offset(instant);
    var ldt = LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
    return new OffsetDateTime(ldt, offset);
  };
  OffsetDateTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
    }
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, OffsetDateTime.FROM);
  };
  function OffsetDateTime(dateTime, offset) {
    var _this;
    _this = _Temporal.call(this) || this;
    requireNonNull(dateTime, 'dateTime');
    requireInstance(dateTime, LocalDateTime, 'dateTime');
    requireNonNull(offset, 'offset');
    requireInstance(offset, ZoneOffset, 'offset');
    _this._dateTime = dateTime;
    _this._offset = offset;
    return _this;
  }
  var _proto = OffsetDateTime.prototype;
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay()).with(ChronoField.OFFSET_SECONDS, this.offset().totalSeconds());
  };
  _proto.until = function until(endExclusive, unit) {
    var end = OffsetDateTime.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      end = end.withOffsetSameInstant(this._offset);
      return this._dateTime.until(end._dateTime, unit);
    }
    return unit.between(this, end);
  };
  _proto.atZoneSameInstant = function atZoneSameInstant(zone) {
    return ZonedDateTime.ofInstant(this._dateTime, this._offset, zone);
  };
  _proto.atZoneSimilarLocal = function atZoneSimilarLocal(zone) {
    return ZonedDateTime.ofLocal(this._dateTime, zone, this._offset);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.chronology()) {
      return IsoChronology.INSTANCE;
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.offset() || _query === TemporalQueries.zone()) {
      return this.offset();
    } else if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    } else if (_query === TemporalQueries.zoneId()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.get = function get(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          throw new DateTimeException("Field too large for an int: " + field);
        case ChronoField.OFFSET_SECONDS:
          return this.offset().totalSeconds();
      }
      return this._dateTime.get(field);
    }
    return _Temporal.prototype.get.call(this, field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.INSTANT_SECONDS:
          return this.toEpochSecond();
        case ChronoField.OFFSET_SECONDS:
          return this.offset().totalSeconds();
      }
      return this._dateTime.getLong(field);
    }
    return field.getFrom(this);
  };
  _proto.offset = function offset() {
    return this._offset;
  };
  _proto.year = function year() {
    return this._dateTime.year();
  };
  _proto.monthValue = function monthValue() {
    return this._dateTime.monthValue();
  };
  _proto.month = function month() {
    return this._dateTime.month();
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._dateTime.dayOfMonth();
  };
  _proto.dayOfYear = function dayOfYear() {
    return this._dateTime.dayOfYear();
  };
  _proto.dayOfWeek = function dayOfWeek() {
    return this._dateTime.dayOfWeek();
  };
  _proto.hour = function hour() {
    return this._dateTime.hour();
  };
  _proto.minute = function minute() {
    return this._dateTime.minute();
  };
  _proto.second = function second() {
    return this._dateTime.second();
  };
  _proto.nano = function nano() {
    return this._dateTime.nano();
  };
  _proto.toLocalDateTime = function toLocalDateTime() {
    return this._dateTime;
  };
  _proto.toLocalDate = function toLocalDate() {
    return this._dateTime.toLocalDate();
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._dateTime.toLocalTime();
  };
  _proto.toOffsetTime = function toOffsetTime() {
    return OffsetTime.of(this._dateTime.toLocalTime(), this._offset);
  };
  _proto.toZonedDateTime = function toZonedDateTime() {
    return ZonedDateTime.of(this._dateTime, this._offset);
  };
  _proto.toInstant = function toInstant() {
    return this._dateTime.toInstant(this._offset);
  };
  _proto.toEpochSecond = function toEpochSecond() {
    return this._dateTime.toEpochSecond(this._offset);
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field === ChronoField.INSTANT_SECONDS || field === ChronoField.OFFSET_SECONDS) {
        return field.range();
      }
      return this._dateTime.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster);
    if (adjuster instanceof LocalDate || adjuster instanceof LocalTime || adjuster instanceof LocalDateTime) {
      return this._withDateTimeOffset(this._dateTime.with(adjuster), this._offset);
    } else if (adjuster instanceof Instant) {
      return OffsetDateTime.ofInstant(adjuster, this._offset);
    } else if (adjuster instanceof ZoneOffset) {
      return this._withDateTimeOffset(this._dateTime, adjuster);
    } else if (adjuster instanceof OffsetDateTime) {
      return adjuster;
    }
    return adjuster.adjustInto(this);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field);
    if (field instanceof ChronoField) {
      var f = field;
      switch (f) {
        case ChronoField.INSTANT_SECONDS:
          return OffsetDateTime.ofInstant(Instant.ofEpochSecond(newValue, this.nano()), this._offset);
        case ChronoField.OFFSET_SECONDS:
          {
            return this._withDateTimeOffset(this._dateTime, ZoneOffset.ofTotalSeconds(f.checkValidIntValue(newValue)));
          }
      }
      return this._withDateTimeOffset(this._dateTime.with(field, newValue), this._offset);
    }
    return field.adjustInto(this, newValue);
  };
  _proto._withDateTimeOffset = function _withDateTimeOffset(dateTime, offset) {
    if (this._dateTime === dateTime && this._offset.equals(offset)) {
      return this;
    }
    return new OffsetDateTime(dateTime, offset);
  };
  _proto.withYear = function withYear(year) {
    return this._withDateTimeOffset(this._dateTime.withYear(year), this._offset);
  };
  _proto.withMonth = function withMonth(month) {
    return this._withDateTimeOffset(this._dateTime.withMonth(month), this._offset);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._withDateTimeOffset(this._dateTime.withDayOfMonth(dayOfMonth), this._offset);
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._withDateTimeOffset(this._dateTime.withDayOfYear(dayOfYear), this._offset);
  };
  _proto.withHour = function withHour(hour) {
    return this._withDateTimeOffset(this._dateTime.withHour(hour), this._offset);
  };
  _proto.withMinute = function withMinute(minute) {
    return this._withDateTimeOffset(this._dateTime.withMinute(minute), this._offset);
  };
  _proto.withSecond = function withSecond(second) {
    return this._withDateTimeOffset(this._dateTime.withSecond(second), this._offset);
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    return this._withDateTimeOffset(this._dateTime.withNano(nanoOfSecond), this._offset);
  };
  _proto.withOffsetSameLocal = function withOffsetSameLocal(offset) {
    requireNonNull(offset, 'offset');
    return this._withDateTimeOffset(this._dateTime, offset);
  };
  _proto.withOffsetSameInstant = function withOffsetSameInstant(offset) {
    requireNonNull(offset, 'offset');
    if (offset.equals(this._offset)) {
      return this;
    }
    var difference = offset.totalSeconds() - this._offset.totalSeconds();
    var adjusted = this._dateTime.plusSeconds(difference);
    return new OffsetDateTime(adjusted, offset);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withDateTimeOffset(this._dateTime.truncatedTo(unit), this._offset);
  };
  _proto._plusAmount = function _plusAmount(amount) {
    requireNonNull(amount, 'amount');
    return amount.addTo(this);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    if (unit instanceof ChronoUnit) {
      return this._withDateTimeOffset(this._dateTime.plus(amountToAdd, unit), this._offset);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(years) {
    return this._withDateTimeOffset(this._dateTime.plusYears(years), this._offset);
  };
  _proto.plusMonths = function plusMonths(months) {
    return this._withDateTimeOffset(this._dateTime.plusMonths(months), this._offset);
  };
  _proto.plusWeeks = function plusWeeks(weeks) {
    return this._withDateTimeOffset(this._dateTime.plusWeeks(weeks), this._offset);
  };
  _proto.plusDays = function plusDays(days) {
    return this._withDateTimeOffset(this._dateTime.plusDays(days), this._offset);
  };
  _proto.plusHours = function plusHours(hours) {
    return this._withDateTimeOffset(this._dateTime.plusHours(hours), this._offset);
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._withDateTimeOffset(this._dateTime.plusMinutes(minutes), this._offset);
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._withDateTimeOffset(this._dateTime.plusSeconds(seconds), this._offset);
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._withDateTimeOffset(this._dateTime.plusNanos(nanos), this._offset);
  };
  _proto._minusAmount = function _minusAmount(amount) {
    requireNonNull(amount);
    return amount.subtractFrom(this);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this.plus(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(years) {
    return this._withDateTimeOffset(this._dateTime.minusYears(years), this._offset);
  };
  _proto.minusMonths = function minusMonths(months) {
    return this._withDateTimeOffset(this._dateTime.minusMonths(months), this._offset);
  };
  _proto.minusWeeks = function minusWeeks(weeks) {
    return this._withDateTimeOffset(this._dateTime.minusWeeks(weeks), this._offset);
  };
  _proto.minusDays = function minusDays(days) {
    return this._withDateTimeOffset(this._dateTime.minusDays(days), this._offset);
  };
  _proto.minusHours = function minusHours(hours) {
    return this._withDateTimeOffset(this._dateTime.minusHours(hours), this._offset);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._withDateTimeOffset(this._dateTime.minusMinutes(minutes), this._offset);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._withDateTimeOffset(this._dateTime.minusSeconds(seconds), this._offset);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this._withDateTimeOffset(this._dateTime.minusNanos(nanos), this._offset);
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, OffsetDateTime, 'other');
    if (this.offset().equals(other.offset())) {
      return this.toLocalDateTime().compareTo(other.toLocalDateTime());
    }
    var cmp = MathUtil.compareNumbers(this.toEpochSecond(), other.toEpochSecond());
    if (cmp === 0) {
      cmp = this.toLocalTime().nano() - other.toLocalTime().nano();
      if (cmp === 0) {
        cmp = this.toLocalDateTime().compareTo(other.toLocalDateTime());
      }
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec > otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() > other.toLocalTime().nano();
  };
  _proto.isBefore = function isBefore(other) {
    requireNonNull(other, 'other');
    var thisEpochSec = this.toEpochSecond();
    var otherEpochSec = other.toEpochSecond();
    return thisEpochSec < otherEpochSec || thisEpochSec === otherEpochSec && this.toLocalTime().nano() < other.toLocalTime().nano();
  };
  _proto.isEqual = function isEqual(other) {
    requireNonNull(other, 'other');
    return this.toEpochSecond() === other.toEpochSecond() && this.toLocalTime().nano() === other.toLocalTime().nano();
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof OffsetDateTime) {
      return this._dateTime.equals(other._dateTime) && this._offset.equals(other._offset);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._dateTime.hashCode() ^ this._offset.hashCode();
  };
  _proto.toString = function toString() {
    return this._dateTime.toString() + this._offset.toString();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };
  return OffsetDateTime;
}(Temporal);
function _init$6() {
  OffsetDateTime.MIN = LocalDateTime.MIN.atOffset(ZoneOffset.MAX);
  OffsetDateTime.MAX = LocalDateTime.MAX.atOffset(ZoneOffset.MIN);
  OffsetDateTime.FROM = createTemporalQuery('OffsetDateTime.FROM', function (temporal) {
    return OffsetDateTime.from(temporal);
  });
}

var DAYS_PER_CYCLE = 146097;
var DAYS_0000_TO_1970 = DAYS_PER_CYCLE * 5 - (30 * 365 + 7);
var LocalDate = function (_ChronoLocalDate) {
  _inheritsLoose(LocalDate, _ChronoLocalDate);
  LocalDate.now = function now(clockOrZone) {
    var clock;
    if (clockOrZone == null) {
      clock = Clock.systemDefaultZone();
    } else if (clockOrZone instanceof ZoneId) {
      clock = Clock.system(clockOrZone);
    } else {
      clock = clockOrZone;
    }
    return LocalDate.ofInstant(clock.instant(), clock.zone());
  };
  LocalDate.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }
    requireNonNull(instant, 'instant');
    var offset = zone.rules().offset(instant);
    var epochSec = instant.epochSecond() + offset.totalSeconds();
    var epochDay = MathUtil.floorDiv(epochSec, LocalTime.SECONDS_PER_DAY);
    return LocalDate.ofEpochDay(epochDay);
  };
  LocalDate.of = function of(year, month, dayOfMonth) {
    return new LocalDate(year, month, dayOfMonth);
  };
  LocalDate.ofYearDay = function ofYearDay(year, dayOfYear) {
    ChronoField.YEAR.checkValidValue(year);
    var leap = IsoChronology.isLeapYear(year);
    if (dayOfYear === 366 && leap === false) {
      assert(false, "Invalid date 'DayOfYear 366' as '" + year + "' is not a leap year", DateTimeException);
    }
    var moy = Month.of(Math.floor((dayOfYear - 1) / 31 + 1));
    var monthEnd = moy.firstDayOfYear(leap) + moy.length(leap) - 1;
    if (dayOfYear > monthEnd) {
      moy = moy.plus(1);
    }
    var dom = dayOfYear - moy.firstDayOfYear(leap) + 1;
    return new LocalDate(year, moy.value(), dom);
  };
  LocalDate.ofEpochDay = function ofEpochDay(epochDay) {
    if (epochDay === void 0) {
      epochDay = 0;
    }
    var adjust, adjustCycles, doyEst, yearEst, zeroDay;
    zeroDay = epochDay + DAYS_0000_TO_1970;
    zeroDay -= 60;
    adjust = 0;
    if (zeroDay < 0) {
      adjustCycles = MathUtil.intDiv(zeroDay + 1, DAYS_PER_CYCLE) - 1;
      adjust = adjustCycles * 400;
      zeroDay += -adjustCycles * DAYS_PER_CYCLE;
    }
    yearEst = MathUtil.intDiv(400 * zeroDay + 591, DAYS_PER_CYCLE);
    doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
    if (doyEst < 0) {
      yearEst--;
      doyEst = zeroDay - (365 * yearEst + MathUtil.intDiv(yearEst, 4) - MathUtil.intDiv(yearEst, 100) + MathUtil.intDiv(yearEst, 400));
    }
    yearEst += adjust;
    var marchDoy0 = doyEst;
    var marchMonth0 = MathUtil.intDiv(marchDoy0 * 5 + 2, 153);
    var month = (marchMonth0 + 2) % 12 + 1;
    var dom = marchDoy0 - MathUtil.intDiv(marchMonth0 * 306 + 5, 10) + 1;
    yearEst += MathUtil.intDiv(marchMonth0, 10);
    var year = yearEst;
    return new LocalDate(year, month, dom);
  };
  LocalDate.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    var date = temporal.query(TemporalQueries.localDate());
    if (date == null) {
      throw new DateTimeException("Unable to obtain LocalDate from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
    return date;
  };
  LocalDate.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_DATE;
    }
    assert(formatter != null, 'formatter', NullPointerException);
    return formatter.parse(text, LocalDate.FROM);
  };
  LocalDate._resolvePreviousValid = function _resolvePreviousValid(year, month, day) {
    switch (month) {
      case 2:
        day = Math.min(day, IsoChronology.isLeapYear(year) ? 29 : 28);
        break;
      case 4:
      case 6:
      case 9:
      case 11:
        day = Math.min(day, 30);
        break;
    }
    return LocalDate.of(year, month, day);
  };
  function LocalDate(year, month, dayOfMonth) {
    var _this;
    _this = _ChronoLocalDate.call(this) || this;
    requireNonNull(year, 'year');
    requireNonNull(month, 'month');
    requireNonNull(dayOfMonth, 'dayOfMonth');
    if (month instanceof Month) {
      month = month.value();
    }
    _this._year = MathUtil.safeToInt(year);
    _this._month = MathUtil.safeToInt(month);
    _this._day = MathUtil.safeToInt(dayOfMonth);
    LocalDate._validate(_this._year, _this._month, _this._day);
    return _this;
  }
  LocalDate._validate = function _validate(year, month, dayOfMonth) {
    var dom;
    ChronoField.YEAR.checkValidValue(year);
    ChronoField.MONTH_OF_YEAR.checkValidValue(month);
    ChronoField.DAY_OF_MONTH.checkValidValue(dayOfMonth);
    if (dayOfMonth > 28) {
      dom = 31;
      switch (month) {
        case 2:
          dom = IsoChronology.isLeapYear(year) ? 29 : 28;
          break;
        case 4:
        case 6:
        case 9:
        case 11:
          dom = 30;
      }
      if (dayOfMonth > dom) {
        if (dayOfMonth === 29) {
          assert(false, "Invalid date 'February 29' as '" + year + "' is not a leap year", DateTimeException);
        } else {
          assert(false, "Invalid date '" + year + "' '" + month + "' '" + dayOfMonth + "'", DateTimeException);
        }
      }
    }
  };
  var _proto = LocalDate.prototype;
  _proto.isSupported = function isSupported(field) {
    return _ChronoLocalDate.prototype.isSupported.call(this, field);
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      if (field.isDateBased()) {
        switch (field) {
          case ChronoField.DAY_OF_MONTH:
            return ValueRange.of(1, this.lengthOfMonth());
          case ChronoField.DAY_OF_YEAR:
            return ValueRange.of(1, this.lengthOfYear());
          case ChronoField.ALIGNED_WEEK_OF_MONTH:
            return ValueRange.of(1, this.month() === Month.FEBRUARY && this.isLeapYear() === false ? 4 : 5);
          case ChronoField.YEAR_OF_ERA:
            return this._year <= 0 ? ValueRange.of(1, Year.MAX_VALUE + 1) : ValueRange.of(1, Year.MAX_VALUE);
        }
        return field.range();
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    assert(field != null, '', NullPointerException);
    if (field instanceof ChronoField) {
      return this._get0(field);
    }
    return field.getFrom(this);
  };
  _proto._get0 = function _get0(field) {
    switch (field) {
      case ChronoField.DAY_OF_WEEK:
        return this.dayOfWeek().value();
      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
        return MathUtil.intMod(this._day - 1, 7) + 1;
      case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
        return MathUtil.intMod(this.dayOfYear() - 1, 7) + 1;
      case ChronoField.DAY_OF_MONTH:
        return this._day;
      case ChronoField.DAY_OF_YEAR:
        return this.dayOfYear();
      case ChronoField.EPOCH_DAY:
        return this.toEpochDay();
      case ChronoField.ALIGNED_WEEK_OF_MONTH:
        return MathUtil.intDiv(this._day - 1, 7) + 1;
      case ChronoField.ALIGNED_WEEK_OF_YEAR:
        return MathUtil.intDiv(this.dayOfYear() - 1, 7) + 1;
      case ChronoField.MONTH_OF_YEAR:
        return this._month;
      case ChronoField.PROLEPTIC_MONTH:
        return this._prolepticMonth();
      case ChronoField.YEAR_OF_ERA:
        return this._year >= 1 ? this._year : 1 - this._year;
      case ChronoField.YEAR:
        return this._year;
      case ChronoField.ERA:
        return this._year >= 1 ? 1 : 0;
    }
    throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
  };
  _proto._prolepticMonth = function _prolepticMonth() {
    return this._year * 12 + (this._month - 1);
  };
  _proto.chronology = function chronology() {
    return IsoChronology.INSTANCE;
  };
  _proto.year = function year() {
    return this._year;
  };
  _proto.monthValue = function monthValue() {
    return this._month;
  };
  _proto.month = function month() {
    return Month.of(this._month);
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._day;
  };
  _proto.dayOfYear = function dayOfYear() {
    return this.month().firstDayOfYear(this.isLeapYear()) + this._day - 1;
  };
  _proto.dayOfWeek = function dayOfWeek() {
    var dow0 = MathUtil.floorMod(this.toEpochDay() + 3, 7);
    return DayOfWeek.of(dow0 + 1);
  };
  _proto.isLeapYear = function isLeapYear() {
    return IsoChronology.isLeapYear(this._year);
  };
  _proto.lengthOfMonth = function lengthOfMonth() {
    switch (this._month) {
      case 2:
        return this.isLeapYear() ? 29 : 28;
      case 4:
      case 6:
      case 9:
      case 11:
        return 30;
      default:
        return 31;
    }
  };
  _proto.lengthOfYear = function lengthOfYear() {
    return this.isLeapYear() ? 366 : 365;
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    if (adjuster instanceof LocalDate) {
      return adjuster;
    }
    return _ChronoLocalDate.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    assert(field != null, 'field', NullPointerException);
    if (field instanceof ChronoField) {
      var f = field;
      f.checkValidValue(newValue);
      switch (f) {
        case ChronoField.DAY_OF_WEEK:
          return this.plusDays(newValue - this.dayOfWeek().value());
        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH:
          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH));
        case ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR:
          return this.plusDays(newValue - this.getLong(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR));
        case ChronoField.DAY_OF_MONTH:
          return this.withDayOfMonth(newValue);
        case ChronoField.DAY_OF_YEAR:
          return this.withDayOfYear(newValue);
        case ChronoField.EPOCH_DAY:
          return LocalDate.ofEpochDay(newValue);
        case ChronoField.ALIGNED_WEEK_OF_MONTH:
          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_MONTH));
        case ChronoField.ALIGNED_WEEK_OF_YEAR:
          return this.plusWeeks(newValue - this.getLong(ChronoField.ALIGNED_WEEK_OF_YEAR));
        case ChronoField.MONTH_OF_YEAR:
          return this.withMonth(newValue);
        case ChronoField.PROLEPTIC_MONTH:
          return this.plusMonths(newValue - this.getLong(ChronoField.PROLEPTIC_MONTH));
        case ChronoField.YEAR_OF_ERA:
          return this.withYear(this._year >= 1 ? newValue : 1 - newValue);
        case ChronoField.YEAR:
          return this.withYear(newValue);
        case ChronoField.ERA:
          return this.getLong(ChronoField.ERA) === newValue ? this : this.withYear(1 - this._year);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    if (this._year === year) {
      return this;
    }
    ChronoField.YEAR.checkValidValue(year);
    return LocalDate._resolvePreviousValid(year, this._month, this._day);
  };
  _proto.withMonth = function withMonth(month) {
    var m = month instanceof Month ? month.value() : month;
    if (this._month === m) {
      return this;
    }
    ChronoField.MONTH_OF_YEAR.checkValidValue(m);
    return LocalDate._resolvePreviousValid(this._year, m, this._day);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    if (this._day === dayOfMonth) {
      return this;
    }
    return LocalDate.of(this._year, this._month, dayOfMonth);
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    if (this.dayOfYear() === dayOfYear) {
      return this;
    }
    return LocalDate.ofYearDay(this._year, dayOfYear);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.DAYS:
          return this.plusDays(amountToAdd);
        case ChronoUnit.WEEKS:
          return this.plusWeeks(amountToAdd);
        case ChronoUnit.MONTHS:
          return this.plusMonths(amountToAdd);
        case ChronoUnit.YEARS:
          return this.plusYears(amountToAdd);
        case ChronoUnit.DECADES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 10));
        case ChronoUnit.CENTURIES:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 100));
        case ChronoUnit.MILLENNIA:
          return this.plusYears(MathUtil.safeMultiply(amountToAdd, 1000));
        case ChronoUnit.ERAS:
          return this.with(ChronoField.ERA, MathUtil.safeAdd(this.getLong(ChronoField.ERA), amountToAdd));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(yearsToAdd) {
    if (yearsToAdd === 0) {
      return this;
    }
    var newYear = ChronoField.YEAR.checkValidIntValue(this._year + yearsToAdd);
    return LocalDate._resolvePreviousValid(newYear, this._month, this._day);
  };
  _proto.plusMonths = function plusMonths(monthsToAdd) {
    if (monthsToAdd === 0) {
      return this;
    }
    var monthCount = this._year * 12 + (this._month - 1);
    var calcMonths = monthCount + monthsToAdd;
    var newYear = ChronoField.YEAR.checkValidIntValue(MathUtil.floorDiv(calcMonths, 12));
    var newMonth = MathUtil.floorMod(calcMonths, 12) + 1;
    return LocalDate._resolvePreviousValid(newYear, newMonth, this._day);
  };
  _proto.plusWeeks = function plusWeeks(weeksToAdd) {
    return this.plusDays(MathUtil.safeMultiply(weeksToAdd, 7));
  };
  _proto.plusDays = function plusDays(daysToAdd) {
    if (daysToAdd === 0) {
      return this;
    }
    var mjDay = MathUtil.safeAdd(this.toEpochDay(), daysToAdd);
    return LocalDate.ofEpochDay(mjDay);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(amountToSubtract, 'amountToSubtract');
    requireNonNull(unit, 'unit');
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(yearsToSubtract) {
    return this.plusYears(yearsToSubtract * -1);
  };
  _proto.minusMonths = function minusMonths(monthsToSubtract) {
    return this.plusMonths(monthsToSubtract * -1);
  };
  _proto.minusWeeks = function minusWeeks(weeksToSubtract) {
    return this.plusWeeks(weeksToSubtract * -1);
  };
  _proto.minusDays = function minusDays(daysToSubtract) {
    return this.plusDays(daysToSubtract * -1);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.localDate()) {
      return this;
    }
    return _ChronoLocalDate.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return _ChronoLocalDate.prototype.adjustInto.call(this, temporal);
  };
  _proto.until = function until(p1, p2) {
    if (arguments.length < 2) {
      return this.until1(p1);
    } else {
      return this.until2(p1, p2);
    }
  };
  _proto.until2 = function until2(endExclusive, unit) {
    var end = LocalDate.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.DAYS:
          return this.daysUntil(end);
        case ChronoUnit.WEEKS:
          return MathUtil.intDiv(this.daysUntil(end), 7);
        case ChronoUnit.MONTHS:
          return this._monthsUntil(end);
        case ChronoUnit.YEARS:
          return MathUtil.intDiv(this._monthsUntil(end), 12);
        case ChronoUnit.DECADES:
          return MathUtil.intDiv(this._monthsUntil(end), 120);
        case ChronoUnit.CENTURIES:
          return MathUtil.intDiv(this._monthsUntil(end), 1200);
        case ChronoUnit.MILLENNIA:
          return MathUtil.intDiv(this._monthsUntil(end), 12000);
        case ChronoUnit.ERAS:
          return end.getLong(ChronoField.ERA) - this.getLong(ChronoField.ERA);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  _proto.daysUntil = function daysUntil(end) {
    return end.toEpochDay() - this.toEpochDay();
  };
  _proto._monthsUntil = function _monthsUntil(end) {
    var packed1 = this._prolepticMonth() * 32 + this.dayOfMonth();
    var packed2 = end._prolepticMonth() * 32 + end.dayOfMonth();
    return MathUtil.intDiv(packed2 - packed1, 32);
  };
  _proto.until1 = function until1(endDate) {
    var end = LocalDate.from(endDate);
    var totalMonths = end._prolepticMonth() - this._prolepticMonth();
    var days = end._day - this._day;
    if (totalMonths > 0 && days < 0) {
      totalMonths--;
      var calcDate = this.plusMonths(totalMonths);
      days = end.toEpochDay() - calcDate.toEpochDay();
    } else if (totalMonths < 0 && days > 0) {
      totalMonths++;
      days -= end.lengthOfMonth();
    }
    var years = MathUtil.intDiv(totalMonths, 12);
    var months = MathUtil.intMod(totalMonths, 12);
    return Period.of(years, months, days);
  };
  _proto.atTime = function atTime() {
    if (arguments.length === 1) {
      return this.atTime1.apply(this, arguments);
    } else {
      return this.atTime4.apply(this, arguments);
    }
  };
  _proto.atTime1 = function atTime1(time) {
    requireNonNull(time, 'time');
    if (time instanceof LocalTime) {
      return LocalDateTime.of(this, time);
    } else if (time instanceof OffsetTime) {
      return this._atTimeOffsetTime(time);
    } else {
      throw new IllegalArgumentException("time must be an instance of LocalTime or OffsetTime" + (time && time.constructor && time.constructor.name ? ", but is " + time.constructor.name : ''));
    }
  };
  _proto.atTime4 = function atTime4(hour, minute, second, nanoOfSecond) {
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    return this.atTime1(LocalTime.of(hour, minute, second, nanoOfSecond));
  };
  _proto._atTimeOffsetTime = function _atTimeOffsetTime(time) {
    return OffsetDateTime.of(LocalDateTime.of(this, time.toLocalTime()), time.offset());
  };
  _proto.atStartOfDay = function atStartOfDay(zone) {
    if (zone != null) {
      return this._atStartOfDayWithZone(zone);
    } else {
      return LocalDateTime.of(this, LocalTime.MIDNIGHT);
    }
  };
  _proto._atStartOfDayWithZone = function _atStartOfDayWithZone(zone) {
    requireNonNull(zone, 'zone');
    var ldt = this.atTime(LocalTime.MIDNIGHT);
    if (zone instanceof ZoneOffset === false) {
      var trans = zone.rules().transition(ldt);
      if (trans != null && trans.isGap()) {
        ldt = trans.dateTimeAfter();
      }
    }
    return ZonedDateTime.of(ldt, zone);
  };
  _proto.toEpochDay = function toEpochDay() {
    var y = this._year;
    var m = this._month;
    var total = 0;
    total += 365 * y;
    if (y >= 0) {
      total += MathUtil.intDiv(y + 3, 4) - MathUtil.intDiv(y + 99, 100) + MathUtil.intDiv(y + 399, 400);
    } else {
      total -= MathUtil.intDiv(y, -4) - MathUtil.intDiv(y, -100) + MathUtil.intDiv(y, -400);
    }
    total += MathUtil.intDiv(367 * m - 362, 12);
    total += this.dayOfMonth() - 1;
    if (m > 2) {
      total--;
      if (!IsoChronology.isLeapYear(y)) {
        total--;
      }
    }
    return total - DAYS_0000_TO_1970;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, LocalDate, 'other');
    return this._compareTo0(other);
  };
  _proto._compareTo0 = function _compareTo0(otherDate) {
    var cmp = this._year - otherDate._year;
    if (cmp === 0) {
      cmp = this._month - otherDate._month;
      if (cmp === 0) {
        cmp = this._day - otherDate._day;
      }
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.isEqual = function isEqual(other) {
    return this.compareTo(other) === 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof LocalDate) {
      return this._compareTo0(other) === 0;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    var yearValue = this._year;
    var monthValue = this._month;
    var dayValue = this._day;
    return MathUtil.hash(yearValue & 0xFFFFF800 ^ (yearValue << 11) + (monthValue << 6) + dayValue);
  };
  _proto.toString = function toString() {
    var dayString, monthString, yearString;
    var yearValue = this._year;
    var monthValue = this._month;
    var dayValue = this._day;
    var absYear = Math.abs(yearValue);
    if (absYear < 1000) {
      if (yearValue < 0) {
        yearString = "-" + ("" + (yearValue - 10000)).slice(-4);
      } else {
        yearString = ("" + (yearValue + 10000)).slice(-4);
      }
    } else {
      if (yearValue > 9999) {
        yearString = "+" + yearValue;
      } else {
        yearString = "" + yearValue;
      }
    }
    if (monthValue < 10) {
      monthString = "-0" + monthValue;
    } else {
      monthString = "-" + monthValue;
    }
    if (dayValue < 10) {
      dayString = "-0" + dayValue;
    } else {
      dayString = "-" + dayValue;
    }
    return yearString + monthString + dayString;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    requireInstance(formatter, DateTimeFormatter, 'formatter');
    return _ChronoLocalDate.prototype.format.call(this, formatter);
  };
  return LocalDate;
}(ChronoLocalDate);
function _init$5() {
  LocalDate.MIN = LocalDate.of(YearConstants.MIN_VALUE, 1, 1);
  LocalDate.MAX = LocalDate.of(YearConstants.MAX_VALUE, 12, 31);
  LocalDate.EPOCH_0 = LocalDate.ofEpochDay(0);
  LocalDate.FROM = createTemporalQuery('LocalDate.FROM', function (temporal) {
    return LocalDate.from(temporal);
  });
}

var ChronoLocalDateTime = function (_Temporal) {
  _inheritsLoose(ChronoLocalDateTime, _Temporal);
  function ChronoLocalDateTime() {
    return _Temporal.apply(this, arguments) || this;
  }
  var _proto = ChronoLocalDateTime.prototype;
  _proto.chronology = function chronology() {
    return this.toLocalDate().chronology();
  };
  _proto.query = function query(_query) {
    if (_query === TemporalQueries.chronology()) {
      return this.chronology();
    } else if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.localDate()) {
      return LocalDate.ofEpochDay(this.toLocalDate().toEpochDay());
    } else if (_query === TemporalQueries.localTime()) {
      return this.toLocalTime();
    } else if (_query === TemporalQueries.zone() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _Temporal.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(ChronoField.EPOCH_DAY, this.toLocalDate().toEpochDay()).with(ChronoField.NANO_OF_DAY, this.toLocalTime().toNanoOfDay());
  };
  _proto.toInstant = function toInstant(offset) {
    requireInstance(offset, ZoneOffset, 'zoneId');
    return Instant.ofEpochSecond(this.toEpochSecond(offset), this.toLocalTime().nano());
  };
  _proto.toEpochSecond = function toEpochSecond(offset) {
    requireNonNull(offset, 'offset');
    var epochDay = this.toLocalDate().toEpochDay();
    var secs = epochDay * 86400 + this.toLocalTime().toSecondOfDay();
    secs -= offset.totalSeconds();
    return MathUtil.safeToInt(secs);
  };
  return ChronoLocalDateTime;
}(Temporal);

var LocalDateTime = function (_ChronoLocalDateTime) {
  _inheritsLoose(LocalDateTime, _ChronoLocalDateTime);
  LocalDateTime.now = function now(clockOrZone) {
    if (clockOrZone == null) {
      return LocalDateTime._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return LocalDateTime._now(clockOrZone);
    } else {
      return LocalDateTime._now(Clock.system(clockOrZone));
    }
  };
  LocalDateTime._now = function _now(clock) {
    requireNonNull(clock, 'clock');
    return LocalDateTime.ofInstant(clock.instant(), clock.zone());
  };
  LocalDateTime._ofEpochMillis = function _ofEpochMillis(epochMilli, offset) {
    var localSecond = MathUtil.floorDiv(epochMilli, 1000) + offset.totalSeconds();
    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
    var nanoOfSecond = MathUtil.floorMod(epochMilli, 1000) * 1000000;
    var date = LocalDate.ofEpochDay(localEpochDay);
    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
    return new LocalDateTime(date, time);
  };
  LocalDateTime.of = function of() {
    if (arguments.length <= 2) {
      return LocalDateTime.ofDateAndTime.apply(this, arguments);
    } else {
      return LocalDateTime.ofNumbers.apply(this, arguments);
    }
  };
  LocalDateTime.ofNumbers = function ofNumbers(year, month, dayOfMonth, hour, minute, second, nanoOfSecond) {
    if (hour === void 0) {
      hour = 0;
    }
    if (minute === void 0) {
      minute = 0;
    }
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    var date = LocalDate.of(year, month, dayOfMonth);
    var time = LocalTime.of(hour, minute, second, nanoOfSecond);
    return new LocalDateTime(date, time);
  };
  LocalDateTime.ofDateAndTime = function ofDateAndTime(date, time) {
    requireNonNull(date, 'date');
    requireNonNull(time, 'time');
    return new LocalDateTime(date, time);
  };
  LocalDateTime.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }
    requireNonNull(instant, 'instant');
    requireInstance(instant, Instant, 'instant');
    requireNonNull(zone, 'zone');
    var offset = zone.rules().offset(instant);
    return LocalDateTime.ofEpochSecond(instant.epochSecond(), instant.nano(), offset);
  };
  LocalDateTime.ofEpochSecond = function ofEpochSecond(epochSecond, nanoOfSecond, offset) {
    if (epochSecond === void 0) {
      epochSecond = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    if (arguments.length === 2 && nanoOfSecond instanceof ZoneOffset) {
      offset = nanoOfSecond;
      nanoOfSecond = 0;
    }
    requireNonNull(offset, 'offset');
    var localSecond = epochSecond + offset.totalSeconds();
    var localEpochDay = MathUtil.floorDiv(localSecond, LocalTime.SECONDS_PER_DAY);
    var secsOfDay = MathUtil.floorMod(localSecond, LocalTime.SECONDS_PER_DAY);
    var date = LocalDate.ofEpochDay(localEpochDay);
    var time = LocalTime.ofSecondOfDay(secsOfDay, nanoOfSecond);
    return new LocalDateTime(date, time);
  };
  LocalDateTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    if (temporal instanceof LocalDateTime) {
      return temporal;
    } else if (temporal instanceof ZonedDateTime) {
      return temporal.toLocalDateTime();
    }
    try {
      var date = LocalDate.from(temporal);
      var time = LocalTime.from(temporal);
      return new LocalDateTime(date, time);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain LocalDateTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
  };
  LocalDateTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
    }
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, LocalDateTime.FROM);
  };
  function LocalDateTime(date, time) {
    var _this;
    _this = _ChronoLocalDateTime.call(this) || this;
    requireInstance(date, LocalDate, 'date');
    requireInstance(time, LocalTime, 'time');
    _this._date = date;
    _this._time = time;
    return _this;
  }
  var _proto = LocalDateTime.prototype;
  _proto._withDateTime = function _withDateTime(newDate, newTime) {
    if (this._date.equals(newDate) && this._time.equals(newTime)) {
      return this;
    }
    return new LocalDateTime(newDate, newTime);
  };
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isDateBased() || fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.range(field) : this._date.range(field);
    }
    return field.rangeRefinedBy(this);
  };
  _proto.get = function get(field) {
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.get(field) : this._date.get(field);
    }
    return _ChronoLocalDateTime.prototype.get.call(this, field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      return field.isTimeBased() ? this._time.getLong(field) : this._date.getLong(field);
    }
    return field.getFrom(this);
  };
  _proto.year = function year() {
    return this._date.year();
  };
  _proto.monthValue = function monthValue() {
    return this._date.monthValue();
  };
  _proto.month = function month() {
    return this._date.month();
  };
  _proto.dayOfMonth = function dayOfMonth() {
    return this._date.dayOfMonth();
  };
  _proto.dayOfYear = function dayOfYear() {
    return this._date.dayOfYear();
  };
  _proto.dayOfWeek = function dayOfWeek() {
    return this._date.dayOfWeek();
  };
  _proto.hour = function hour() {
    return this._time.hour();
  };
  _proto.minute = function minute() {
    return this._time.minute();
  };
  _proto.second = function second() {
    return this._time.second();
  };
  _proto.nano = function nano() {
    return this._time.nano();
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    if (adjuster instanceof LocalDate) {
      return this._withDateTime(adjuster, this._time);
    } else if (adjuster instanceof LocalTime) {
      return this._withDateTime(this._date, adjuster);
    } else if (adjuster instanceof LocalDateTime) {
      return adjuster;
    }
    return _ChronoLocalDateTime.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      if (field.isTimeBased()) {
        return this._withDateTime(this._date, this._time.with(field, newValue));
      } else {
        return this._withDateTime(this._date.with(field, newValue), this._time);
      }
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withYear = function withYear(year) {
    return this._withDateTime(this._date.withYear(year), this._time);
  };
  _proto.withMonth = function withMonth(month) {
    return this._withDateTime(this._date.withMonth(month), this._time);
  };
  _proto.withDayOfMonth = function withDayOfMonth(dayOfMonth) {
    return this._withDateTime(this._date.withDayOfMonth(dayOfMonth), this._time);
  };
  _proto.withDayOfYear = function withDayOfYear(dayOfYear) {
    return this._withDateTime(this._date.withDayOfYear(dayOfYear), this._time);
  };
  _proto.withHour = function withHour(hour) {
    var newTime = this._time.withHour(hour);
    return this._withDateTime(this._date, newTime);
  };
  _proto.withMinute = function withMinute(minute) {
    var newTime = this._time.withMinute(minute);
    return this._withDateTime(this._date, newTime);
  };
  _proto.withSecond = function withSecond(second) {
    var newTime = this._time.withSecond(second);
    return this._withDateTime(this._date, newTime);
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    var newTime = this._time.withNano(nanoOfSecond);
    return this._withDateTime(this._date, newTime);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    return this._withDateTime(this._date, this._time.truncatedTo(unit));
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, 'unit');
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MICROS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);
        case ChronoUnit.MILLIS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, LocalTime.MILLIS_PER_DAY)).plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
        case ChronoUnit.MINUTES:
          return this.plusMinutes(amountToAdd);
        case ChronoUnit.HOURS:
          return this.plusHours(amountToAdd);
        case ChronoUnit.HALF_DAYS:
          return this.plusDays(MathUtil.intDiv(amountToAdd, 256)).plusHours(MathUtil.intMod(amountToAdd, 256) * 12);
      }
      return this._withDateTime(this._date.plus(amountToAdd, unit), this._time);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusYears = function plusYears(years) {
    var newDate = this._date.plusYears(years);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusMonths = function plusMonths(months) {
    var newDate = this._date.plusMonths(months);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusWeeks = function plusWeeks(weeks) {
    var newDate = this._date.plusWeeks(weeks);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusDays = function plusDays(days) {
    var newDate = this._date.plusDays(days);
    return this._withDateTime(newDate, this._time);
  };
  _proto.plusHours = function plusHours(hours) {
    return this._plusWithOverflow(this._date, hours, 0, 0, 0, 1);
  };
  _proto.plusMinutes = function plusMinutes(minutes) {
    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, 1);
  };
  _proto.plusSeconds = function plusSeconds(seconds) {
    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, 1);
  };
  _proto.plusNanos = function plusNanos(nanos) {
    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, 1);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(unit, 'unit');
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusYears = function minusYears(years) {
    return this.plusYears(-1 * years);
  };
  _proto.minusMonths = function minusMonths(months) {
    return this.plusMonths(-1 * months);
  };
  _proto.minusWeeks = function minusWeeks(weeks) {
    return this.plusWeeks(-1 * weeks);
  };
  _proto.minusDays = function minusDays(days) {
    return this.plusDays(-1 * days);
  };
  _proto.minusHours = function minusHours(hours) {
    return this._plusWithOverflow(this._date, hours, 0, 0, 0, -1);
  };
  _proto.minusMinutes = function minusMinutes(minutes) {
    return this._plusWithOverflow(this._date, 0, minutes, 0, 0, -1);
  };
  _proto.minusSeconds = function minusSeconds(seconds) {
    return this._plusWithOverflow(this._date, 0, 0, seconds, 0, -1);
  };
  _proto.minusNanos = function minusNanos(nanos) {
    return this._plusWithOverflow(this._date, 0, 0, 0, nanos, -1);
  };
  _proto._plusWithOverflow = function _plusWithOverflow(newDate, hours, minutes, seconds, nanos, sign) {
    if (hours === 0 && minutes === 0 && seconds === 0 && nanos === 0) {
      return this._withDateTime(newDate, this._time);
    }
    var totDays = MathUtil.intDiv(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intDiv(seconds, LocalTime.SECONDS_PER_DAY) + MathUtil.intDiv(minutes, LocalTime.MINUTES_PER_DAY) + MathUtil.intDiv(hours, LocalTime.HOURS_PER_DAY);
    totDays *= sign;
    var totNanos = MathUtil.intMod(nanos, LocalTime.NANOS_PER_DAY) + MathUtil.intMod(seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + MathUtil.intMod(minutes, LocalTime.MINUTES_PER_DAY) * LocalTime.NANOS_PER_MINUTE + MathUtil.intMod(hours, LocalTime.HOURS_PER_DAY) * LocalTime.NANOS_PER_HOUR;
    var curNoD = this._time.toNanoOfDay();
    totNanos = totNanos * sign + curNoD;
    totDays += MathUtil.floorDiv(totNanos, LocalTime.NANOS_PER_DAY);
    var newNoD = MathUtil.floorMod(totNanos, LocalTime.NANOS_PER_DAY);
    var newTime = newNoD === curNoD ? this._time : LocalTime.ofNanoOfDay(newNoD);
    return this._withDateTime(newDate.plusDays(totDays), newTime);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.localDate()) {
      return this.toLocalDate();
    }
    return _ChronoLocalDateTime.prototype.query.call(this, _query);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return _ChronoLocalDateTime.prototype.adjustInto.call(this, temporal);
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = LocalDateTime.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      if (unit.isTimeBased()) {
        var daysUntil = this._date.daysUntil(end._date);
        var timeUntil = end._time.toNanoOfDay() - this._time.toNanoOfDay();
        if (daysUntil > 0 && timeUntil < 0) {
          daysUntil--;
          timeUntil += LocalTime.NANOS_PER_DAY;
        } else if (daysUntil < 0 && timeUntil > 0) {
          daysUntil++;
          timeUntil -= LocalTime.NANOS_PER_DAY;
        }
        var amount = daysUntil;
        switch (unit) {
          case ChronoUnit.NANOS:
            amount = MathUtil.safeMultiply(amount, LocalTime.NANOS_PER_DAY);
            return MathUtil.safeAdd(amount, timeUntil);
          case ChronoUnit.MICROS:
            amount = MathUtil.safeMultiply(amount, LocalTime.MICROS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000));
          case ChronoUnit.MILLIS:
            amount = MathUtil.safeMultiply(amount, LocalTime.MILLIS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, 1000000));
          case ChronoUnit.SECONDS:
            amount = MathUtil.safeMultiply(amount, LocalTime.SECONDS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_SECOND));
          case ChronoUnit.MINUTES:
            amount = MathUtil.safeMultiply(amount, LocalTime.MINUTES_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_MINUTE));
          case ChronoUnit.HOURS:
            amount = MathUtil.safeMultiply(amount, LocalTime.HOURS_PER_DAY);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR));
          case ChronoUnit.HALF_DAYS:
            amount = MathUtil.safeMultiply(amount, 2);
            return MathUtil.safeAdd(amount, MathUtil.intDiv(timeUntil, LocalTime.NANOS_PER_HOUR * 12));
        }
        throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
      }
      var endDate = end._date;
      var endTime = end._time;
      if (endDate.isAfter(this._date) && endTime.isBefore(this._time)) {
        endDate = endDate.minusDays(1);
      } else if (endDate.isBefore(this._date) && endTime.isAfter(this._time)) {
        endDate = endDate.plusDays(1);
      }
      return this._date.until(endDate, unit);
    }
    return unit.between(this, end);
  };
  _proto.atOffset = function atOffset(offset) {
    return OffsetDateTime.of(this, offset);
  };
  _proto.atZone = function atZone(zone) {
    return ZonedDateTime.of(this, zone);
  };
  _proto.toLocalDate = function toLocalDate() {
    return this._date;
  };
  _proto.toLocalTime = function toLocalTime() {
    return this._time;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, LocalDateTime, 'other');
    return this._compareTo0(other);
  };
  _proto._compareTo0 = function _compareTo0(other) {
    var cmp = this._date.compareTo(other.toLocalDate());
    if (cmp === 0) {
      cmp = this._time.compareTo(other.toLocalTime());
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.isEqual = function isEqual(other) {
    return this.compareTo(other) === 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof LocalDateTime) {
      return this._date.equals(other._date) && this._time.equals(other._time);
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._date.hashCode() ^ this._time.hashCode();
  };
  _proto.toString = function toString() {
    return this._date.toString() + "T" + this._time.toString();
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };
  return LocalDateTime;
}(ChronoLocalDateTime);
function _init$4() {
  LocalDateTime.MIN = LocalDateTime.of(LocalDate.MIN, LocalTime.MIN);
  LocalDateTime.MAX = LocalDateTime.of(LocalDate.MAX, LocalTime.MAX);
  LocalDateTime.FROM = createTemporalQuery('LocalDateTime.FROM', function (temporal) {
    return LocalDateTime.from(temporal);
  });
}

var LocalTime = function (_Temporal) {
  _inheritsLoose(LocalTime, _Temporal);
  LocalTime.now = function now(clockOrZone) {
    if (clockOrZone == null) {
      return LocalTime._now(Clock.systemDefaultZone());
    } else if (clockOrZone instanceof Clock) {
      return LocalTime._now(clockOrZone);
    } else {
      return LocalTime._now(Clock.system(clockOrZone));
    }
  };
  LocalTime._now = function _now(clock) {
    if (clock === void 0) {
      clock = Clock.systemDefaultZone();
    }
    requireNonNull(clock, 'clock');
    return LocalTime.ofInstant(clock.instant(), clock.zone());
  };
  LocalTime.ofInstant = function ofInstant(instant, zone) {
    if (zone === void 0) {
      zone = ZoneId.systemDefault();
    }
    var offset = zone.rules().offset(instant);
    var secsOfDay = MathUtil.intMod(instant.epochSecond(), LocalTime.SECONDS_PER_DAY);
    secsOfDay = MathUtil.intMod(secsOfDay + offset.totalSeconds(), LocalTime.SECONDS_PER_DAY);
    if (secsOfDay < 0) {
      secsOfDay += LocalTime.SECONDS_PER_DAY;
    }
    return LocalTime.ofSecondOfDay(secsOfDay, instant.nano());
  };
  LocalTime.of = function of(hour, minute, second, nanoOfSecond) {
    return new LocalTime(hour, minute, second, nanoOfSecond);
  };
  LocalTime.ofSecondOfDay = function ofSecondOfDay(secondOfDay, nanoOfSecond) {
    if (secondOfDay === void 0) {
      secondOfDay = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    ChronoField.SECOND_OF_DAY.checkValidValue(secondOfDay);
    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
    var hours = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_HOUR);
    secondOfDay -= hours * LocalTime.SECONDS_PER_HOUR;
    var minutes = MathUtil.intDiv(secondOfDay, LocalTime.SECONDS_PER_MINUTE);
    secondOfDay -= minutes * LocalTime.SECONDS_PER_MINUTE;
    return new LocalTime(hours, minutes, secondOfDay, nanoOfSecond);
  };
  LocalTime.ofNanoOfDay = function ofNanoOfDay(nanoOfDay) {
    if (nanoOfDay === void 0) {
      nanoOfDay = 0;
    }
    ChronoField.NANO_OF_DAY.checkValidValue(nanoOfDay);
    var hours = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_HOUR);
    nanoOfDay -= hours * LocalTime.NANOS_PER_HOUR;
    var minutes = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_MINUTE);
    nanoOfDay -= minutes * LocalTime.NANOS_PER_MINUTE;
    var seconds = MathUtil.intDiv(nanoOfDay, LocalTime.NANOS_PER_SECOND);
    nanoOfDay -= seconds * LocalTime.NANOS_PER_SECOND;
    return new LocalTime(hours, minutes, seconds, nanoOfDay);
  };
  LocalTime.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    var time = temporal.query(TemporalQueries.localTime());
    if (time == null) {
      throw new DateTimeException("Unable to obtain LocalTime TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
    return time;
  };
  LocalTime.parse = function parse(text, formatter) {
    if (formatter === void 0) {
      formatter = DateTimeFormatter.ISO_LOCAL_TIME;
    }
    requireNonNull(formatter, 'formatter');
    return formatter.parse(text, LocalTime.FROM);
  };
  function LocalTime(hour, minute, second, nanoOfSecond) {
    var _this;
    if (hour === void 0) {
      hour = 0;
    }
    if (minute === void 0) {
      minute = 0;
    }
    if (second === void 0) {
      second = 0;
    }
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    _this = _Temporal.call(this) || this;
    var _hour = MathUtil.safeToInt(hour);
    var _minute = MathUtil.safeToInt(minute);
    var _second = MathUtil.safeToInt(second);
    var _nanoOfSecond = MathUtil.safeToInt(nanoOfSecond);
    LocalTime._validate(_hour, _minute, _second, _nanoOfSecond);
    if (_minute === 0 && _second === 0 && _nanoOfSecond === 0) {
      if (!LocalTime.HOURS[_hour]) {
        _this._hour = _hour;
        _this._minute = _minute;
        _this._second = _second;
        _this._nano = _nanoOfSecond;
        LocalTime.HOURS[_hour] = _assertThisInitialized(_this);
      }
      return LocalTime.HOURS[_hour] || _assertThisInitialized(_this);
    }
    _this._hour = _hour;
    _this._minute = _minute;
    _this._second = _second;
    _this._nano = _nanoOfSecond;
    return _this;
  }
  LocalTime._validate = function _validate(hour, minute, second, nanoOfSecond) {
    ChronoField.HOUR_OF_DAY.checkValidValue(hour);
    ChronoField.MINUTE_OF_HOUR.checkValidValue(minute);
    ChronoField.SECOND_OF_MINUTE.checkValidValue(second);
    ChronoField.NANO_OF_SECOND.checkValidValue(nanoOfSecond);
  };
  var _proto = LocalTime.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit.isTimeBased();
    } else if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased();
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    requireNonNull(field);
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      return this._get0(field);
    }
    return field.getFrom(this);
  };
  _proto._get0 = function _get0(field) {
    switch (field) {
      case ChronoField.NANO_OF_SECOND:
        return this._nano;
      case ChronoField.NANO_OF_DAY:
        return this.toNanoOfDay();
      case ChronoField.MICRO_OF_SECOND:
        return MathUtil.intDiv(this._nano, 1000);
      case ChronoField.MICRO_OF_DAY:
        return MathUtil.intDiv(this.toNanoOfDay(), 1000);
      case ChronoField.MILLI_OF_SECOND:
        return MathUtil.intDiv(this._nano, 1000000);
      case ChronoField.MILLI_OF_DAY:
        return MathUtil.intDiv(this.toNanoOfDay(), 1000000);
      case ChronoField.SECOND_OF_MINUTE:
        return this._second;
      case ChronoField.SECOND_OF_DAY:
        return this.toSecondOfDay();
      case ChronoField.MINUTE_OF_HOUR:
        return this._minute;
      case ChronoField.MINUTE_OF_DAY:
        return this._hour * 60 + this._minute;
      case ChronoField.HOUR_OF_AMPM:
        return MathUtil.intMod(this._hour, 12);
      case ChronoField.CLOCK_HOUR_OF_AMPM:
        {
          var ham = MathUtil.intMod(this._hour, 12);
          return ham % 12 === 0 ? 12 : ham;
        }
      case ChronoField.HOUR_OF_DAY:
        return this._hour;
      case ChronoField.CLOCK_HOUR_OF_DAY:
        return this._hour === 0 ? 24 : this._hour;
      case ChronoField.AMPM_OF_DAY:
        return MathUtil.intDiv(this._hour, 12);
    }
    throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
  };
  _proto.hour = function hour() {
    return this._hour;
  };
  _proto.minute = function minute() {
    return this._minute;
  };
  _proto.second = function second() {
    return this._second;
  };
  _proto.nano = function nano() {
    return this._nano;
  };
  _proto._withAdjuster = function _withAdjuster(adjuster) {
    requireNonNull(adjuster, 'adjuster');
    if (adjuster instanceof LocalTime) {
      return adjuster;
    }
    return _Temporal.prototype._withAdjuster.call(this, adjuster);
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    requireInstance(field, TemporalField, 'field');
    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);
      switch (field) {
        case ChronoField.NANO_OF_SECOND:
          return this.withNano(newValue);
        case ChronoField.NANO_OF_DAY:
          return LocalTime.ofNanoOfDay(newValue);
        case ChronoField.MICRO_OF_SECOND:
          return this.withNano(newValue * 1000);
        case ChronoField.MICRO_OF_DAY:
          return LocalTime.ofNanoOfDay(newValue * 1000);
        case ChronoField.MILLI_OF_SECOND:
          return this.withNano(newValue * 1000000);
        case ChronoField.MILLI_OF_DAY:
          return LocalTime.ofNanoOfDay(newValue * 1000000);
        case ChronoField.SECOND_OF_MINUTE:
          return this.withSecond(newValue);
        case ChronoField.SECOND_OF_DAY:
          return this.plusSeconds(newValue - this.toSecondOfDay());
        case ChronoField.MINUTE_OF_HOUR:
          return this.withMinute(newValue);
        case ChronoField.MINUTE_OF_DAY:
          return this.plusMinutes(newValue - (this._hour * 60 + this._minute));
        case ChronoField.HOUR_OF_AMPM:
          return this.plusHours(newValue - MathUtil.intMod(this._hour, 12));
        case ChronoField.CLOCK_HOUR_OF_AMPM:
          return this.plusHours((newValue === 12 ? 0 : newValue) - MathUtil.intMod(this._hour, 12));
        case ChronoField.HOUR_OF_DAY:
          return this.withHour(newValue);
        case ChronoField.CLOCK_HOUR_OF_DAY:
          return this.withHour(newValue === 24 ? 0 : newValue);
        case ChronoField.AMPM_OF_DAY:
          return this.plusHours((newValue - MathUtil.intDiv(this._hour, 12)) * 12);
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.withHour = function withHour(hour) {
    if (hour === void 0) {
      hour = 0;
    }
    if (this._hour === hour) {
      return this;
    }
    return new LocalTime(hour, this._minute, this._second, this._nano);
  };
  _proto.withMinute = function withMinute(minute) {
    if (minute === void 0) {
      minute = 0;
    }
    if (this._minute === minute) {
      return this;
    }
    return new LocalTime(this._hour, minute, this._second, this._nano);
  };
  _proto.withSecond = function withSecond(second) {
    if (second === void 0) {
      second = 0;
    }
    if (this._second === second) {
      return this;
    }
    return new LocalTime(this._hour, this._minute, second, this._nano);
  };
  _proto.withNano = function withNano(nanoOfSecond) {
    if (nanoOfSecond === void 0) {
      nanoOfSecond = 0;
    }
    if (this._nano === nanoOfSecond) {
      return this;
    }
    return new LocalTime(this._hour, this._minute, this._second, nanoOfSecond);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    requireNonNull(unit, 'unit');
    if (unit === ChronoUnit.NANOS) {
      return this;
    }
    var unitDur = unit.duration();
    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
      throw new DateTimeException('Unit is too large to be used for truncation');
    }
    var dur = unitDur.toNanos();
    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
      throw new DateTimeException('Unit must divide into a standard day without remainder');
    }
    var nod = this.toNanoOfDay();
    return LocalTime.ofNanoOfDay(MathUtil.intDiv(nod, dur) * dur);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(unit, 'unit');
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MICROS_PER_DAY) * 1000);
        case ChronoUnit.MILLIS:
          return this.plusNanos(MathUtil.intMod(amountToAdd, LocalTime.MILLIS_PER_DAY) * 1000000);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
        case ChronoUnit.MINUTES:
          return this.plusMinutes(amountToAdd);
        case ChronoUnit.HOURS:
          return this.plusHours(amountToAdd);
        case ChronoUnit.HALF_DAYS:
          return this.plusHours(MathUtil.intMod(amountToAdd, 2) * 12);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusHours = function plusHours(hoursToAdd) {
    if (hoursToAdd === 0) {
      return this;
    }
    var newHour = MathUtil.intMod(MathUtil.intMod(hoursToAdd, LocalTime.HOURS_PER_DAY) + this._hour + LocalTime.HOURS_PER_DAY, LocalTime.HOURS_PER_DAY);
    return new LocalTime(newHour, this._minute, this._second, this._nano);
  };
  _proto.plusMinutes = function plusMinutes(minutesToAdd) {
    if (minutesToAdd === 0) {
      return this;
    }
    var mofd = this._hour * LocalTime.MINUTES_PER_HOUR + this._minute;
    var newMofd = MathUtil.intMod(MathUtil.intMod(minutesToAdd, LocalTime.MINUTES_PER_DAY) + mofd + LocalTime.MINUTES_PER_DAY, LocalTime.MINUTES_PER_DAY);
    if (mofd === newMofd) {
      return this;
    }
    var newHour = MathUtil.intDiv(newMofd, LocalTime.MINUTES_PER_HOUR);
    var newMinute = MathUtil.intMod(newMofd, LocalTime.MINUTES_PER_HOUR);
    return new LocalTime(newHour, newMinute, this._second, this._nano);
  };
  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    if (secondsToAdd === 0) {
      return this;
    }
    var sofd = this._hour * LocalTime.SECONDS_PER_HOUR + this._minute * LocalTime.SECONDS_PER_MINUTE + this._second;
    var newSofd = MathUtil.intMod(MathUtil.intMod(secondsToAdd, LocalTime.SECONDS_PER_DAY) + sofd + LocalTime.SECONDS_PER_DAY, LocalTime.SECONDS_PER_DAY);
    if (sofd === newSofd) {
      return this;
    }
    var newHour = MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_HOUR);
    var newMinute = MathUtil.intMod(MathUtil.intDiv(newSofd, LocalTime.SECONDS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
    var newSecond = MathUtil.intMod(newSofd, LocalTime.SECONDS_PER_MINUTE);
    return new LocalTime(newHour, newMinute, newSecond, this._nano);
  };
  _proto.plusNanos = function plusNanos(nanosToAdd) {
    if (nanosToAdd === 0) {
      return this;
    }
    var nofd = this.toNanoOfDay();
    var newNofd = MathUtil.intMod(MathUtil.intMod(nanosToAdd, LocalTime.NANOS_PER_DAY) + nofd + LocalTime.NANOS_PER_DAY, LocalTime.NANOS_PER_DAY);
    if (nofd === newNofd) {
      return this;
    }
    var newHour = MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_HOUR);
    var newMinute = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_MINUTE), LocalTime.MINUTES_PER_HOUR);
    var newSecond = MathUtil.intMod(MathUtil.intDiv(newNofd, LocalTime.NANOS_PER_SECOND), LocalTime.SECONDS_PER_MINUTE);
    var newNano = MathUtil.intMod(newNofd, LocalTime.NANOS_PER_SECOND);
    return new LocalTime(newHour, newMinute, newSecond, newNano);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    requireNonNull(unit, 'unit');
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusHours = function minusHours(hoursToSubtract) {
    return this.plusHours(-1 * MathUtil.intMod(hoursToSubtract, LocalTime.HOURS_PER_DAY));
  };
  _proto.minusMinutes = function minusMinutes(minutesToSubtract) {
    return this.plusMinutes(-1 * MathUtil.intMod(minutesToSubtract, LocalTime.MINUTES_PER_DAY));
  };
  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return this.plusSeconds(-1 * MathUtil.intMod(secondsToSubtract, LocalTime.SECONDS_PER_DAY));
  };
  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return this.plusNanos(-1 * MathUtil.intMod(nanosToSubtract, LocalTime.NANOS_PER_DAY));
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    } else if (_query === TemporalQueries.localTime()) {
      return this;
    }
    if (_query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset() || _query === TemporalQueries.localDate()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    return temporal.with(LocalTime.NANO_OF_DAY, this.toNanoOfDay());
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = LocalTime.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      var nanosUntil = end.toNanoOfDay() - this.toNanoOfDay();
      switch (unit) {
        case ChronoUnit.NANOS:
          return nanosUntil;
        case ChronoUnit.MICROS:
          return MathUtil.intDiv(nanosUntil, 1000);
        case ChronoUnit.MILLIS:
          return MathUtil.intDiv(nanosUntil, 1000000);
        case ChronoUnit.SECONDS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_SECOND);
        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_MINUTE);
        case ChronoUnit.HOURS:
          return MathUtil.intDiv(nanosUntil, LocalTime.NANOS_PER_HOUR);
        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(nanosUntil, 12 * LocalTime.NANOS_PER_HOUR);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  _proto.atDate = function atDate(date) {
    return LocalDateTime.of(date, this);
  };
  _proto.atOffset = function atOffset(offset) {
    return OffsetTime.of(this, offset);
  };
  _proto.toSecondOfDay = function toSecondOfDay() {
    var total = this._hour * LocalTime.SECONDS_PER_HOUR;
    total += this._minute * LocalTime.SECONDS_PER_MINUTE;
    total += this._second;
    return total;
  };
  _proto.toNanoOfDay = function toNanoOfDay() {
    var total = this._hour * LocalTime.NANOS_PER_HOUR;
    total += this._minute * LocalTime.NANOS_PER_MINUTE;
    total += this._second * LocalTime.NANOS_PER_SECOND;
    total += this._nano;
    return total;
  };
  _proto.compareTo = function compareTo(other) {
    requireNonNull(other, 'other');
    requireInstance(other, LocalTime, 'other');
    var cmp = MathUtil.compareNumbers(this._hour, other._hour);
    if (cmp === 0) {
      cmp = MathUtil.compareNumbers(this._minute, other._minute);
      if (cmp === 0) {
        cmp = MathUtil.compareNumbers(this._second, other._second);
        if (cmp === 0) {
          cmp = MathUtil.compareNumbers(this._nano, other._nano);
        }
      }
    }
    return cmp;
  };
  _proto.isAfter = function isAfter(other) {
    return this.compareTo(other) > 0;
  };
  _proto.isBefore = function isBefore(other) {
    return this.compareTo(other) < 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof LocalTime) {
      return this._hour === other._hour && this._minute === other._minute && this._second === other._second && this._nano === other._nano;
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    var nod = this.toNanoOfDay();
    return MathUtil.hash(nod);
  };
  _proto.toString = function toString() {
    var buf = '';
    var hourValue = this._hour;
    var minuteValue = this._minute;
    var secondValue = this._second;
    var nanoValue = this._nano;
    buf += hourValue < 10 ? '0' : '';
    buf += hourValue;
    buf += minuteValue < 10 ? ':0' : ':';
    buf += minuteValue;
    if (secondValue > 0 || nanoValue > 0) {
      buf += secondValue < 10 ? ':0' : ':';
      buf += secondValue;
      if (nanoValue > 0) {
        buf += '.';
        if (MathUtil.intMod(nanoValue, 1000000) === 0) {
          buf += ("" + (MathUtil.intDiv(nanoValue, 1000000) + 1000)).substring(1);
        } else if (MathUtil.intMod(nanoValue, 1000) === 0) {
          buf += ("" + (MathUtil.intDiv(nanoValue, 1000) + 1000000)).substring(1);
        } else {
          buf += ("" + (nanoValue + 1000000000)).substring(1);
        }
      }
    }
    return buf;
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  _proto.format = function format(formatter) {
    requireNonNull(formatter, 'formatter');
    return formatter.format(this);
  };
  return LocalTime;
}(Temporal);
function _init$3() {
  LocalTime.HOURS = [];
  for (var hour = 0; hour < 24; hour++) {
    LocalTime.of(hour, 0, 0, 0);
  }
  LocalTime.MIN = LocalTime.HOURS[0];
  LocalTime.MAX = new LocalTime(23, 59, 59, 999999999);
  LocalTime.MIDNIGHT = LocalTime.HOURS[0];
  LocalTime.NOON = LocalTime.HOURS[12];
  LocalTime.FROM = createTemporalQuery('LocalTime.FROM', function (temporal) {
    return LocalTime.from(temporal);
  });
}
LocalTime.HOURS_PER_DAY = 24;
LocalTime.MINUTES_PER_HOUR = 60;
LocalTime.MINUTES_PER_DAY = LocalTime.MINUTES_PER_HOUR * LocalTime.HOURS_PER_DAY;
LocalTime.SECONDS_PER_MINUTE = 60;
LocalTime.SECONDS_PER_HOUR = LocalTime.SECONDS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
LocalTime.SECONDS_PER_DAY = LocalTime.SECONDS_PER_HOUR * LocalTime.HOURS_PER_DAY;
LocalTime.MILLIS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000;
LocalTime.MICROS_PER_DAY = LocalTime.SECONDS_PER_DAY * 1000000;
LocalTime.NANOS_PER_SECOND = 1000000000;
LocalTime.NANOS_PER_MINUTE = LocalTime.NANOS_PER_SECOND * LocalTime.SECONDS_PER_MINUTE;
LocalTime.NANOS_PER_HOUR = LocalTime.NANOS_PER_MINUTE * LocalTime.MINUTES_PER_HOUR;
LocalTime.NANOS_PER_DAY = LocalTime.NANOS_PER_HOUR * LocalTime.HOURS_PER_DAY;

var NANOS_PER_MILLI = 1000000;
var Instant = function (_Temporal) {
  _inheritsLoose(Instant, _Temporal);
  Instant.now = function now(clock) {
    if (clock === void 0) {
      clock = Clock.systemUTC();
    }
    return clock.instant();
  };
  Instant.ofEpochSecond = function ofEpochSecond(epochSecond, nanoAdjustment) {
    if (nanoAdjustment === void 0) {
      nanoAdjustment = 0;
    }
    var secs = epochSecond + MathUtil.floorDiv(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    var nos = MathUtil.floorMod(nanoAdjustment, LocalTime.NANOS_PER_SECOND);
    return Instant._create(secs, nos);
  };
  Instant.ofEpochMilli = function ofEpochMilli(epochMilli) {
    var secs = MathUtil.floorDiv(epochMilli, 1000);
    var mos = MathUtil.floorMod(epochMilli, 1000);
    return Instant._create(secs, mos * 1000000);
  };
  Instant.ofEpochMicro = function ofEpochMicro(epochMicro) {
    var secs = MathUtil.floorDiv(epochMicro, 1000000);
    var mos = MathUtil.floorMod(epochMicro, 1000000);
    return Instant._create(secs, mos * 1000);
  };
  Instant.from = function from(temporal) {
    try {
      var instantSecs = temporal.getLong(ChronoField.INSTANT_SECONDS);
      var nanoOfSecond = temporal.get(ChronoField.NANO_OF_SECOND);
      return Instant.ofEpochSecond(instantSecs, nanoOfSecond);
    } catch (ex) {
      throw new DateTimeException("Unable to obtain Instant from TemporalAccessor: " + temporal + ", type " + typeof temporal, ex);
    }
  };
  Instant.parse = function parse(text) {
    return DateTimeFormatter.ISO_INSTANT.parse(text, Instant.FROM);
  };
  Instant._create = function _create(seconds, nanoOfSecond) {
    if (seconds === 0 && nanoOfSecond === 0) {
      return Instant.EPOCH;
    }
    return new Instant(seconds, nanoOfSecond);
  };
  Instant._validate = function _validate(seconds, nanoOfSecond) {
    if (seconds < Instant.MIN_SECONDS || seconds > Instant.MAX_SECONDS) {
      throw new DateTimeException('Instant exceeds minimum or maximum instant');
    }
    if (nanoOfSecond < 0 || nanoOfSecond > LocalTime.NANOS_PER_SECOND) {
      throw new DateTimeException('Instant exceeds minimum or maximum instant');
    }
  };
  function Instant(seconds, nanoOfSecond) {
    var _this;
    _this = _Temporal.call(this) || this;
    Instant._validate(seconds, nanoOfSecond);
    _this._seconds = MathUtil.safeToInt(seconds);
    _this._nanos = MathUtil.safeToInt(nanoOfSecond);
    return _this;
  }
  var _proto = Instant.prototype;
  _proto.isSupported = function isSupported(fieldOrUnit) {
    if (fieldOrUnit instanceof ChronoField) {
      return fieldOrUnit === ChronoField.INSTANT_SECONDS || fieldOrUnit === ChronoField.NANO_OF_SECOND || fieldOrUnit === ChronoField.MICRO_OF_SECOND || fieldOrUnit === ChronoField.MILLI_OF_SECOND;
    }
    if (fieldOrUnit instanceof ChronoUnit) {
      return fieldOrUnit.isTimeBased() || fieldOrUnit === ChronoUnit.DAYS;
    }
    return fieldOrUnit != null && fieldOrUnit.isSupportedBy(this);
  };
  _proto.range = function range(field) {
    return _Temporal.prototype.range.call(this, field);
  };
  _proto.get = function get(field) {
    return this.getLong(field);
  };
  _proto.getLong = function getLong(field) {
    if (field instanceof ChronoField) {
      switch (field) {
        case ChronoField.NANO_OF_SECOND:
          return this._nanos;
        case ChronoField.MICRO_OF_SECOND:
          return MathUtil.intDiv(this._nanos, 1000);
        case ChronoField.MILLI_OF_SECOND:
          return MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
        case ChronoField.INSTANT_SECONDS:
          return this._seconds;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.getFrom(this);
  };
  _proto.epochSecond = function epochSecond() {
    return this._seconds;
  };
  _proto.nano = function nano() {
    return this._nanos;
  };
  _proto._withField = function _withField(field, newValue) {
    requireNonNull(field, 'field');
    if (field instanceof ChronoField) {
      field.checkValidValue(newValue);
      switch (field) {
        case ChronoField.MILLI_OF_SECOND:
          {
            var nval = newValue * NANOS_PER_MILLI;
            return nval !== this._nanos ? Instant._create(this._seconds, nval) : this;
          }
        case ChronoField.MICRO_OF_SECOND:
          {
            var _nval = newValue * 1000;
            return _nval !== this._nanos ? Instant._create(this._seconds, _nval) : this;
          }
        case ChronoField.NANO_OF_SECOND:
          return newValue !== this._nanos ? Instant._create(this._seconds, newValue) : this;
        case ChronoField.INSTANT_SECONDS:
          return newValue !== this._seconds ? Instant._create(newValue, this._nanos) : this;
      }
      throw new UnsupportedTemporalTypeException("Unsupported field: " + field);
    }
    return field.adjustInto(this, newValue);
  };
  _proto.truncatedTo = function truncatedTo(unit) {
    requireNonNull(unit, 'unit');
    if (unit === ChronoUnit.NANOS) {
      return this;
    }
    var unitDur = unit.duration();
    if (unitDur.seconds() > LocalTime.SECONDS_PER_DAY) {
      throw new DateTimeException('Unit is too large to be used for truncation');
    }
    var dur = unitDur.toNanos();
    if (MathUtil.intMod(LocalTime.NANOS_PER_DAY, dur) !== 0) {
      throw new DateTimeException('Unit must divide into a standard day without remainder');
    }
    var nod = MathUtil.intMod(this._seconds, LocalTime.SECONDS_PER_DAY) * LocalTime.NANOS_PER_SECOND + this._nanos;
    var result = MathUtil.intDiv(nod, dur) * dur;
    return this.plusNanos(result - nod);
  };
  _proto._plusUnit = function _plusUnit(amountToAdd, unit) {
    requireNonNull(amountToAdd, 'amountToAdd');
    requireNonNull(unit, 'unit');
    requireInstance(unit, TemporalUnit);
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this.plusNanos(amountToAdd);
        case ChronoUnit.MICROS:
          return this.plusMicros(amountToAdd);
        case ChronoUnit.MILLIS:
          return this.plusMillis(amountToAdd);
        case ChronoUnit.SECONDS:
          return this.plusSeconds(amountToAdd);
        case ChronoUnit.MINUTES:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_MINUTE));
        case ChronoUnit.HOURS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_HOUR));
        case ChronoUnit.HALF_DAYS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY / 2));
        case ChronoUnit.DAYS:
          return this.plusSeconds(MathUtil.safeMultiply(amountToAdd, LocalTime.SECONDS_PER_DAY));
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.addTo(this, amountToAdd);
  };
  _proto.plusSeconds = function plusSeconds(secondsToAdd) {
    return this._plus(secondsToAdd, 0);
  };
  _proto.plusMillis = function plusMillis(millisToAdd) {
    return this._plus(MathUtil.intDiv(millisToAdd, 1000), MathUtil.intMod(millisToAdd, 1000) * NANOS_PER_MILLI);
  };
  _proto.plusNanos = function plusNanos(nanosToAdd) {
    return this._plus(0, nanosToAdd);
  };
  _proto.plusMicros = function plusMicros(microsToAdd) {
    return this._plus(MathUtil.intDiv(microsToAdd, 1000000), MathUtil.intMod(microsToAdd, 1000000) * 1000);
  };
  _proto._plus = function _plus(secondsToAdd, nanosToAdd) {
    if (secondsToAdd === 0 && nanosToAdd === 0) {
      return this;
    }
    var epochSec = this._seconds + secondsToAdd;
    epochSec = epochSec + MathUtil.intDiv(nanosToAdd, LocalTime.NANOS_PER_SECOND);
    var nanoAdjustment = this._nanos + nanosToAdd % LocalTime.NANOS_PER_SECOND;
    return Instant.ofEpochSecond(epochSec, nanoAdjustment);
  };
  _proto._minusUnit = function _minusUnit(amountToSubtract, unit) {
    return this._plusUnit(-1 * amountToSubtract, unit);
  };
  _proto.minusSeconds = function minusSeconds(secondsToSubtract) {
    return this.plusSeconds(secondsToSubtract * -1);
  };
  _proto.minusMillis = function minusMillis(millisToSubtract) {
    return this.plusMillis(-1 * millisToSubtract);
  };
  _proto.minusNanos = function minusNanos(nanosToSubtract) {
    return this.plusNanos(-1 * nanosToSubtract);
  };
  _proto.minusMicros = function minusMicros(microsToSubtract) {
    return this.plusMicros(-1 * microsToSubtract);
  };
  _proto.query = function query(_query) {
    requireNonNull(_query, 'query');
    if (_query === TemporalQueries.precision()) {
      return ChronoUnit.NANOS;
    }
    if (_query === TemporalQueries.localDate() || _query === TemporalQueries.localTime() || _query === TemporalQueries.chronology() || _query === TemporalQueries.zoneId() || _query === TemporalQueries.zone() || _query === TemporalQueries.offset()) {
      return null;
    }
    return _query.queryFrom(this);
  };
  _proto.adjustInto = function adjustInto(temporal) {
    requireNonNull(temporal, 'temporal');
    return temporal.with(ChronoField.INSTANT_SECONDS, this._seconds).with(ChronoField.NANO_OF_SECOND, this._nanos);
  };
  _proto.until = function until(endExclusive, unit) {
    requireNonNull(endExclusive, 'endExclusive');
    requireNonNull(unit, 'unit');
    var end = Instant.from(endExclusive);
    if (unit instanceof ChronoUnit) {
      switch (unit) {
        case ChronoUnit.NANOS:
          return this._nanosUntil(end);
        case ChronoUnit.MICROS:
          return this._microsUntil(end);
        case ChronoUnit.MILLIS:
          return MathUtil.safeSubtract(end.toEpochMilli(), this.toEpochMilli());
        case ChronoUnit.SECONDS:
          return this._secondsUntil(end);
        case ChronoUnit.MINUTES:
          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_MINUTE);
        case ChronoUnit.HOURS:
          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_HOUR);
        case ChronoUnit.HALF_DAYS:
          return MathUtil.intDiv(this._secondsUntil(end), 12 * LocalTime.SECONDS_PER_HOUR);
        case ChronoUnit.DAYS:
          return MathUtil.intDiv(this._secondsUntil(end), LocalTime.SECONDS_PER_DAY);
      }
      throw new UnsupportedTemporalTypeException("Unsupported unit: " + unit);
    }
    return unit.between(this, end);
  };
  _proto._microsUntil = function _microsUntil(end) {
    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
    var totalMicros = MathUtil.safeMultiply(secsDiff, 1000000);
    return MathUtil.safeAdd(totalMicros, MathUtil.intDiv(end.nano() - this.nano(), 1000));
  };
  _proto._nanosUntil = function _nanosUntil(end) {
    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
    var totalNanos = MathUtil.safeMultiply(secsDiff, LocalTime.NANOS_PER_SECOND);
    return MathUtil.safeAdd(totalNanos, end.nano() - this.nano());
  };
  _proto._secondsUntil = function _secondsUntil(end) {
    var secsDiff = MathUtil.safeSubtract(end.epochSecond(), this.epochSecond());
    var nanosDiff = end.nano() - this.nano();
    if (secsDiff > 0 && nanosDiff < 0) {
      secsDiff--;
    } else if (secsDiff < 0 && nanosDiff > 0) {
      secsDiff++;
    }
    return secsDiff;
  };
  _proto.atOffset = function atOffset(offset) {
    return OffsetDateTime.ofInstant(this, offset);
  };
  _proto.atZone = function atZone(zone) {
    return ZonedDateTime.ofInstant(this, zone);
  };
  _proto.toEpochMilli = function toEpochMilli() {
    var millis = MathUtil.safeMultiply(this._seconds, 1000);
    return millis + MathUtil.intDiv(this._nanos, NANOS_PER_MILLI);
  };
  _proto.compareTo = function compareTo(otherInstant) {
    requireNonNull(otherInstant, 'otherInstant');
    requireInstance(otherInstant, Instant, 'otherInstant');
    var cmp = MathUtil.compareNumbers(this._seconds, otherInstant._seconds);
    if (cmp !== 0) {
      return cmp;
    }
    return this._nanos - otherInstant._nanos;
  };
  _proto.isAfter = function isAfter(otherInstant) {
    return this.compareTo(otherInstant) > 0;
  };
  _proto.isBefore = function isBefore(otherInstant) {
    return this.compareTo(otherInstant) < 0;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    if (other instanceof Instant) {
      return this.epochSecond() === other.epochSecond() && this.nano() === other.nano();
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return MathUtil.hashCode(this._seconds, this._nanos);
  };
  _proto.toString = function toString() {
    return DateTimeFormatter.ISO_INSTANT.format(this);
  };
  _proto.toJSON = function toJSON() {
    return this.toString();
  };
  return Instant;
}(Temporal);
function _init$2() {
  Instant.MIN_SECONDS = -31619119219200;
  Instant.MAX_SECONDS = 31494816403199;
  Instant.EPOCH = new Instant(0, 0);
  Instant.MIN = Instant.ofEpochSecond(Instant.MIN_SECONDS, 0);
  Instant.MAX = Instant.ofEpochSecond(Instant.MAX_SECONDS, 999999999);
  Instant.FROM = createTemporalQuery('Instant.FROM', function (temporal) {
    return Instant.from(temporal);
  });
}

var Clock = function () {
  function Clock() {}
  Clock.systemUTC = function systemUTC() {
    return new SystemClock(ZoneOffset.UTC);
  };
  Clock.systemDefaultZone = function systemDefaultZone() {
    return new SystemClock(ZoneId.systemDefault());
  };
  Clock.system = function system(zone) {
    return new SystemClock(zone);
  };
  Clock.fixed = function fixed(fixedInstant, zoneId) {
    return new FixedClock(fixedInstant, zoneId);
  };
  Clock.offset = function offset(baseClock, duration) {
    return new OffsetClock(baseClock, duration);
  };
  var _proto = Clock.prototype;
  _proto.millis = function millis() {
    abstractMethodFail('Clock.millis');
  };
  _proto.instant = function instant() {
    abstractMethodFail('Clock.instant');
  };
  _proto.zone = function zone() {
    abstractMethodFail('Clock.zone');
  };
  _proto.withZone = function withZone() {
    abstractMethodFail('Clock.withZone');
  };
  return Clock;
}();
var SystemClock = function (_Clock) {
  _inheritsLoose(SystemClock, _Clock);
  function SystemClock(zone) {
    var _this;
    requireNonNull(zone, 'zone');
    _this = _Clock.call(this) || this;
    _this._zone = zone;
    return _this;
  }
  var _proto2 = SystemClock.prototype;
  _proto2.zone = function zone() {
    return this._zone;
  };
  _proto2.millis = function millis() {
    return new Date().getTime();
  };
  _proto2.instant = function instant() {
    return Instant.ofEpochMilli(this.millis());
  };
  _proto2.equals = function equals(obj) {
    if (obj instanceof SystemClock) {
      return this._zone.equals(obj._zone);
    }
    return false;
  };
  _proto2.withZone = function withZone(zone) {
    if (zone.equals(this._zone)) {
      return this;
    }
    return new SystemClock(zone);
  };
  _proto2.toString = function toString() {
    return "SystemClock[" + this._zone.toString() + "]";
  };
  return SystemClock;
}(Clock);
var FixedClock = function (_Clock2) {
  _inheritsLoose(FixedClock, _Clock2);
  function FixedClock(fixedInstant, zoneId) {
    var _this2;
    _this2 = _Clock2.call(this) || this;
    _this2._instant = fixedInstant;
    _this2._zoneId = zoneId;
    return _this2;
  }
  var _proto3 = FixedClock.prototype;
  _proto3.instant = function instant() {
    return this._instant;
  };
  _proto3.millis = function millis() {
    return this._instant.toEpochMilli();
  };
  _proto3.zone = function zone() {
    return this._zoneId;
  };
  _proto3.toString = function toString() {
    return 'FixedClock[]';
  };
  _proto3.equals = function equals(obj) {
    if (obj instanceof FixedClock) {
      return this._instant.equals(obj._instant) && this._zoneId.equals(obj._zoneId);
    }
    return false;
  };
  _proto3.withZone = function withZone(zone) {
    if (zone.equals(this._zoneId)) {
      return this;
    }
    return new FixedClock(this._instant, zone);
  };
  return FixedClock;
}(Clock);
var OffsetClock = function (_Clock3) {
  _inheritsLoose(OffsetClock, _Clock3);
  function OffsetClock(baseClock, offset) {
    var _this3;
    _this3 = _Clock3.call(this) || this;
    _this3._baseClock = baseClock;
    _this3._offset = offset;
    return _this3;
  }
  var _proto4 = OffsetClock.prototype;
  _proto4.zone = function zone() {
    return this._baseClock.zone();
  };
  _proto4.withZone = function withZone(zone) {
    if (zone.equals(this._baseClock.zone())) {
      return this;
    }
    return new OffsetClock(this._baseClock.withZone(zone), this._offset);
  };
  _proto4.millis = function millis() {
    return this._baseClock.millis() + this._offset.toMillis();
  };
  _proto4.instant = function instant() {
    return this._baseClock.instant().plus(this._offset);
  };
  _proto4.equals = function equals(obj) {
    if (obj instanceof OffsetClock) {
      return this._baseClock.equals(obj._baseClock) && this._offset.equals(obj._offset);
    }
    return false;
  };
  _proto4.toString = function toString() {
    return "OffsetClock[" + this._baseClock + "," + this._offset + "]";
  };
  return OffsetClock;
}(Clock);

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var ZoneOffsetTransition = function () {
  ZoneOffsetTransition.of = function of(transition, offsetBefore, offsetAfter) {
    return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);
  };
  function ZoneOffsetTransition(transition, offsetBefore, offsetAfter) {
    requireNonNull(transition, 'transition');
    requireNonNull(offsetBefore, 'offsetBefore');
    requireNonNull(offsetAfter, 'offsetAfter');
    if (offsetBefore.equals(offsetAfter)) {
      throw new IllegalArgumentException('Offsets must not be equal');
    }
    if (transition.nano() !== 0) {
      throw new IllegalArgumentException('Nano-of-second must be zero');
    }
    if (transition instanceof LocalDateTime) {
      this._transition = transition;
    } else {
      this._transition = LocalDateTime.ofEpochSecond(transition, 0, offsetBefore);
    }
    this._offsetBefore = offsetBefore;
    this._offsetAfter = offsetAfter;
  }
  var _proto = ZoneOffsetTransition.prototype;
  _proto.instant = function instant() {
    return this._transition.toInstant(this._offsetBefore);
  };
  _proto.toEpochSecond = function toEpochSecond() {
    return this._transition.toEpochSecond(this._offsetBefore);
  };
  _proto.dateTimeBefore = function dateTimeBefore() {
    return this._transition;
  };
  _proto.dateTimeAfter = function dateTimeAfter() {
    return this._transition.plusSeconds(this.durationSeconds());
  };
  _proto.offsetBefore = function offsetBefore() {
    return this._offsetBefore;
  };
  _proto.offsetAfter = function offsetAfter() {
    return this._offsetAfter;
  };
  _proto.duration = function duration() {
    return Duration.ofSeconds(this.durationSeconds());
  };
  _proto.durationSeconds = function durationSeconds() {
    return this._offsetAfter.totalSeconds() - this._offsetBefore.totalSeconds();
  };
  _proto.isGap = function isGap() {
    return this._offsetAfter.totalSeconds() > this._offsetBefore.totalSeconds();
  };
  _proto.isOverlap = function isOverlap() {
    return this._offsetAfter.totalSeconds() < this._offsetBefore.totalSeconds();
  };
  _proto.isValidOffset = function isValidOffset(offset) {
    return this.isGap() ? false : this._offsetBefore.equals(offset) || this._offsetAfter.equals(offset);
  };
  _proto.validOffsets = function validOffsets() {
    if (this.isGap()) {
      return [];
    } else {
      return [this._offsetBefore, this._offsetAfter];
    }
  };
  _proto.compareTo = function compareTo(transition) {
    return this.instant().compareTo(transition.instant());
  };
  _proto.equals = function equals(other) {
    if (other === this) {
      return true;
    }
    if (other instanceof ZoneOffsetTransition) {
      var d = other;
      return this._transition.equals(d._transition) && this._offsetBefore.equals(d.offsetBefore()) && this._offsetAfter.equals(d.offsetAfter());
    }
    return false;
  };
  _proto.hashCode = function hashCode() {
    return this._transition.hashCode() ^ this._offsetBefore.hashCode() ^ this._offsetAfter.hashCode() >>> 16;
  };
  _proto.toString = function toString() {
    return "Transition[" + (this.isGap() ? 'Gap' : 'Overlap') + " at " + this._transition.toString() + this._offsetBefore.toString() + " to " + this._offsetAfter + "]";
  };
  return ZoneOffsetTransition;
}();

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

function _init$1() {
  TemporalQueries.ZONE_ID = createTemporalQuery('ZONE_ID', function (temporal) {
    return temporal.query(TemporalQueries.ZONE_ID);
  });
  TemporalQueries.CHRONO = createTemporalQuery('CHRONO', function (temporal) {
    return temporal.query(TemporalQueries.CHRONO);
  });
  TemporalQueries.PRECISION = createTemporalQuery('PRECISION', function (temporal) {
    return temporal.query(TemporalQueries.PRECISION);
  });
  TemporalQueries.OFFSET = createTemporalQuery('OFFSET', function (temporal) {
    if (temporal.isSupported(ChronoField.OFFSET_SECONDS)) {
      return ZoneOffset.ofTotalSeconds(temporal.get(ChronoField.OFFSET_SECONDS));
    }
    return null;
  });
  TemporalQueries.ZONE = createTemporalQuery('ZONE', function (temporal) {
    var zone = temporal.query(TemporalQueries.ZONE_ID);
    return zone != null ? zone : temporal.query(TemporalQueries.OFFSET);
  });
  TemporalQueries.LOCAL_DATE = createTemporalQuery('LOCAL_DATE', function (temporal) {
    if (temporal.isSupported(ChronoField.EPOCH_DAY)) {
      return LocalDate.ofEpochDay(temporal.getLong(ChronoField.EPOCH_DAY));
    }
    return null;
  });
  TemporalQueries.LOCAL_TIME = createTemporalQuery('LOCAL_TIME', function (temporal) {
    if (temporal.isSupported(ChronoField.NANO_OF_DAY)) {
      return LocalTime.ofNanoOfDay(temporal.getLong(ChronoField.NANO_OF_DAY));
    }
    return null;
  });
}

var SystemDefaultZoneRules = function (_ZoneRules) {
  _inheritsLoose(SystemDefaultZoneRules, _ZoneRules);
  function SystemDefaultZoneRules() {
    return _ZoneRules.apply(this, arguments) || this;
  }
  var _proto = SystemDefaultZoneRules.prototype;
  _proto.isFixedOffset = function isFixedOffset() {
    return false;
  };
  _proto.offsetOfInstant = function offsetOfInstant(instant) {
    var offsetInMinutes = new Date(instant.toEpochMilli()).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
  };
  _proto.offsetOfEpochMilli = function offsetOfEpochMilli(epochMilli) {
    var offsetInMinutes = new Date(epochMilli).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutes * -1);
  };
  _proto.offsetOfLocalDateTime = function offsetOfLocalDateTime(localDateTime) {
    var epochMilli = localDateTime.toEpochSecond(ZoneOffset.UTC) * 1000;
    var offsetInMinutesBeforePossibleTransition = new Date(epochMilli).getTimezoneOffset();
    var epochMilliSystemZone = epochMilli + offsetInMinutesBeforePossibleTransition * 60000;
    var offsetInMinutesAfterPossibleTransition = new Date(epochMilliSystemZone).getTimezoneOffset();
    return ZoneOffset.ofTotalMinutes(offsetInMinutesAfterPossibleTransition * -1);
  };
  _proto.validOffsets = function validOffsets(localDateTime) {
    return [this.offsetOfLocalDateTime(localDateTime)];
  };
  _proto.transition = function transition() {
    return null;
  };
  _proto.standardOffset = function standardOffset(instant) {
    return this.offsetOfInstant(instant);
  };
  _proto.daylightSavings = function daylightSavings() {
    this._throwNotSupported();
  };
  _proto.isDaylightSavings = function isDaylightSavings() {
    this._throwNotSupported();
  };
  _proto.isValidOffset = function isValidOffset(dateTime, offset) {
    return this.offsetOfLocalDateTime(dateTime).equals(offset);
  };
  _proto.nextTransition = function nextTransition() {
    this._throwNotSupported();
  };
  _proto.previousTransition = function previousTransition() {
    this._throwNotSupported();
  };
  _proto.transitions = function transitions() {
    this._throwNotSupported();
  };
  _proto.transitionRules = function transitionRules() {
    this._throwNotSupported();
  };
  _proto._throwNotSupported = function _throwNotSupported() {
    throw new DateTimeException('not supported operation');
  };
  _proto.equals = function equals(other) {
    if (this === other || other instanceof SystemDefaultZoneRules) {
      return true;
    } else {
      return false;
    }
  };
  _proto.toString = function toString() {
    return 'SYSTEM';
  };
  return SystemDefaultZoneRules;
}(ZoneRules);

var SystemDefaultZoneId = function (_ZoneId) {
  _inheritsLoose(SystemDefaultZoneId, _ZoneId);
  function SystemDefaultZoneId() {
    var _this;
    _this = _ZoneId.call(this) || this;
    _this._rules = new SystemDefaultZoneRules();
    return _this;
  }
  var _proto = SystemDefaultZoneId.prototype;
  _proto.rules = function rules() {
    return this._rules;
  };
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    return false;
  };
  _proto.id = function id() {
    return 'SYSTEM';
  };
  return SystemDefaultZoneId;
}(ZoneId);

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @copyright (c) 2007-present, Stephen Colebourne & Michael Nascimento Santos
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var ZoneIdFactory = function () {
  function ZoneIdFactory() {}
  ZoneIdFactory.systemDefault = function systemDefault() {
    return SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  };
  ZoneIdFactory.getAvailableZoneIds = function getAvailableZoneIds() {
    return ZoneRulesProvider.getAvailableZoneIds();
  };
  ZoneIdFactory.of = function of(zoneId) {
    requireNonNull(zoneId, 'zoneId');
    if (zoneId === 'Z') {
      return ZoneOffset.UTC;
    }
    if (zoneId.length === 1) {
      throw new DateTimeException("Invalid zone: " + zoneId);
    }
    if (StringUtil.startsWith(zoneId, '+') || StringUtil.startsWith(zoneId, '-')) {
      return ZoneOffset.of(zoneId);
    }
    if (zoneId === 'UTC' || zoneId === 'GMT' || zoneId === 'GMT0' || zoneId === 'UT') {
      return new ZoneRegion(zoneId, ZoneOffset.UTC.rules());
    }
    if (StringUtil.startsWith(zoneId, 'UTC+') || StringUtil.startsWith(zoneId, 'GMT+') || StringUtil.startsWith(zoneId, 'UTC-') || StringUtil.startsWith(zoneId, 'GMT-')) {
      var offset = ZoneOffset.of(zoneId.substring(3));
      if (offset.totalSeconds() === 0) {
        return new ZoneRegion(zoneId.substring(0, 3), offset.rules());
      }
      return new ZoneRegion(zoneId.substring(0, 3) + offset.id(), offset.rules());
    }
    if (StringUtil.startsWith(zoneId, 'UT+') || StringUtil.startsWith(zoneId, 'UT-')) {
      var _offset = ZoneOffset.of(zoneId.substring(2));
      if (_offset.totalSeconds() === 0) {
        return new ZoneRegion('UT', _offset.rules());
      }
      return new ZoneRegion("UT" + _offset.id(), _offset.rules());
    }
    if (zoneId === 'SYSTEM') {
      return ZoneId.systemDefault();
    }
    return ZoneRegion.ofId(zoneId);
  };
  ZoneIdFactory.ofOffset = function ofOffset(prefix, offset) {
    requireNonNull(prefix, 'prefix');
    requireNonNull(offset, 'offset');
    if (prefix.length === 0) {
      return offset;
    }
    if (prefix === 'GMT' || prefix === 'UTC' || prefix === 'UT') {
      if (offset.totalSeconds() === 0) {
        return new ZoneRegion(prefix, offset.rules());
      }
      return new ZoneRegion(prefix + offset.id(), offset.rules());
    }
    throw new IllegalArgumentException("Invalid prefix, must be GMT, UTC or UT: " + prefix);
  };
  ZoneIdFactory.from = function from(temporal) {
    requireNonNull(temporal, 'temporal');
    var obj = temporal.query(TemporalQueries.zone());
    if (obj == null) {
      throw new DateTimeException("Unable to obtain ZoneId from TemporalAccessor: " + temporal + ", type " + (temporal.constructor != null ? temporal.constructor.name : ''));
    }
    return obj;
  };
  return ZoneIdFactory;
}();
var SYSTEM_DEFAULT_ZONE_ID_INSTANCE = null;
function _init() {
  SYSTEM_DEFAULT_ZONE_ID_INSTANCE = new SystemDefaultZoneId();
  ZoneId.systemDefault = ZoneIdFactory.systemDefault;
  ZoneId.getAvailableZoneIds = ZoneIdFactory.getAvailableZoneIds;
  ZoneId.of = ZoneIdFactory.of;
  ZoneId.ofOffset = ZoneIdFactory.ofOffset;
  ZoneId.from = ZoneIdFactory.from;
  ZoneOffset.from = ZoneIdFactory.from;
  ZoneId.SYSTEM = SYSTEM_DEFAULT_ZONE_ID_INSTANCE;
  ZoneId.UTC = ZoneOffset.ofTotalSeconds(0);
}

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var isInit = false;
function init() {
  if (isInit) {
    return;
  }
  isInit = true;
  _init$m();
  _init$n();
  _init$l();
  _init$k();
  _init$3();
  _init$f();
  _init$1();
  _init$j();
  _init$2();
  _init$5();
  _init$4();
  _init$a();
  _init$i();
  _init$b();
  _init$c();
  _init$h();
  _init$g();
  _init$7();
  _init();
  _init$9();
  _init$d();
  _init$e();
  _init$6();
  _init$8();
}
init();

/*
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var ToNativeJsConverter = function () {
  function ToNativeJsConverter(temporal, zone) {
    var zonedDateTime;
    if (temporal instanceof Instant) {
      this.instant = temporal;
      return;
    } else if (temporal instanceof LocalDate) {
      zone = zone == null ? ZoneId.systemDefault() : zone;
      zonedDateTime = temporal.atStartOfDay(zone);
    } else if (temporal instanceof LocalDateTime) {
      zone = zone == null ? ZoneId.systemDefault() : zone;
      zonedDateTime = temporal.atZone(zone);
    } else if (temporal instanceof ZonedDateTime) {
      if (zone == null) {
        zonedDateTime = temporal;
      } else {
        zonedDateTime = temporal.withZoneSameInstant(zone);
      }
    } else {
      throw new IllegalArgumentException("unsupported instance for convert operation:" + temporal);
    }
    this.instant = zonedDateTime.toInstant();
  }
  var _proto = ToNativeJsConverter.prototype;
  _proto.toDate = function toDate() {
    return new Date(this.instant.toEpochMilli());
  };
  _proto.toEpochMilli = function toEpochMilli() {
    return this.instant.toEpochMilli();
  };
  return ToNativeJsConverter;
}();
function convert(temporal, zone) {
  return new ToNativeJsConverter(temporal, zone);
}

/*
 * @copyright (c) 2015-present, Philipp Thrwchter, Pattrick Hper & js-joda contributors
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

function nativeJs(date, zone) {
  if (zone === void 0) {
    zone = ZoneId.systemDefault();
  }
  requireNonNull(date, 'date');
  requireNonNull(zone, 'zone');
  if (date instanceof Date) {
    return Instant.ofEpochMilli(date.getTime()).atZone(zone);
  } else if (typeof date.toDate === 'function' && date.toDate() instanceof Date) {
    return Instant.ofEpochMilli(date.toDate().getTime()).atZone(zone);
  }
  throw new IllegalArgumentException('date must be a javascript Date or a moment instance');
}

function bindUse(jsJoda) {
  var used = [];
  return function use(fn) {
    if (!~used.indexOf(fn)) {
      fn(jsJoda);
      used.push(fn);
    }
    return jsJoda;
  };
}

/**
 * @copyright (c) 2016, Philipp Thrwchter & Pattrick Hper
 * @license BSD-3-Clause (see LICENSE in the root directory of this source tree)
 */

var _ = {
  assert: assert$1,
  DateTimeBuilder: DateTimeBuilder,
  DateTimeParseContext: DateTimeParseContext,
  DateTimePrintContext: DateTimePrintContext,
  MathUtil: MathUtil,
  StringUtil: StringUtil,
  StringBuilder: StringBuilder
};
var jsJodaExports = {
  _: _,
  convert: convert,
  nativeJs: nativeJs,
  ArithmeticException: ArithmeticException,
  DateTimeException: DateTimeException,
  DateTimeParseException: DateTimeParseException,
  IllegalArgumentException: IllegalArgumentException,
  IllegalStateException: IllegalStateException,
  UnsupportedTemporalTypeException: UnsupportedTemporalTypeException,
  NullPointerException: NullPointerException,
  Clock: Clock,
  DayOfWeek: DayOfWeek,
  Duration: Duration,
  Instant: Instant,
  LocalDate: LocalDate,
  LocalTime: LocalTime,
  LocalDateTime: LocalDateTime,
  OffsetTime: OffsetTime,
  OffsetDateTime: OffsetDateTime,
  Month: Month,
  MonthDay: MonthDay,
  ParsePosition: ParsePosition,
  Period: Period,
  Year: Year,
  YearConstants: YearConstants,
  YearMonth: YearMonth,
  ZonedDateTime: ZonedDateTime,
  ZoneOffset: ZoneOffset,
  ZoneId: ZoneId,
  ZoneRegion: ZoneRegion,
  ZoneOffsetTransition: ZoneOffsetTransition,
  ZoneRules: ZoneRules,
  ZoneRulesProvider: ZoneRulesProvider,
  ChronoLocalDate: ChronoLocalDate,
  ChronoLocalDateTime: ChronoLocalDateTime,
  ChronoZonedDateTime: ChronoZonedDateTime,
  IsoChronology: IsoChronology,
  ChronoField: ChronoField,
  ChronoUnit: ChronoUnit,
  IsoFields: IsoFields,
  Temporal: Temporal,
  TemporalAccessor: TemporalAccessor,
  TemporalAdjuster: TemporalAdjuster,
  TemporalAdjusters: TemporalAdjusters,
  TemporalAmount: TemporalAmount,
  TemporalField: TemporalField,
  TemporalQueries: TemporalQueries,
  TemporalQuery: TemporalQuery,
  TemporalUnit: TemporalUnit,
  ValueRange: ValueRange,
  DateTimeFormatter: DateTimeFormatter,
  DateTimeFormatterBuilder: DateTimeFormatterBuilder,
  DecimalStyle: DecimalStyle,
  ResolverStyle: ResolverStyle,
  SignStyle: SignStyle,
  TextStyle: TextStyle
};
var use = bindUse(jsJodaExports);
jsJodaExports.use = use;

var jsJoda_esm = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ArithmeticException: ArithmeticException,
  ChronoField: ChronoField,
  ChronoLocalDate: ChronoLocalDate,
  ChronoLocalDateTime: ChronoLocalDateTime,
  ChronoUnit: ChronoUnit,
  ChronoZonedDateTime: ChronoZonedDateTime,
  Clock: Clock,
  DateTimeException: DateTimeException,
  DateTimeFormatter: DateTimeFormatter,
  DateTimeFormatterBuilder: DateTimeFormatterBuilder,
  DateTimeParseException: DateTimeParseException,
  DayOfWeek: DayOfWeek,
  DecimalStyle: DecimalStyle,
  Duration: Duration,
  IllegalArgumentException: IllegalArgumentException,
  IllegalStateException: IllegalStateException,
  Instant: Instant,
  IsoChronology: IsoChronology,
  IsoFields: IsoFields,
  LocalDate: LocalDate,
  LocalDateTime: LocalDateTime,
  LocalTime: LocalTime,
  Month: Month,
  MonthDay: MonthDay,
  NullPointerException: NullPointerException,
  OffsetDateTime: OffsetDateTime,
  OffsetTime: OffsetTime,
  ParsePosition: ParsePosition,
  Period: Period,
  ResolverStyle: ResolverStyle,
  SignStyle: SignStyle,
  Temporal: Temporal,
  TemporalAccessor: TemporalAccessor,
  TemporalAdjuster: TemporalAdjuster,
  TemporalAdjusters: TemporalAdjusters,
  TemporalAmount: TemporalAmount,
  TemporalField: TemporalField,
  TemporalQueries: TemporalQueries,
  TemporalQuery: TemporalQuery,
  TemporalUnit: TemporalUnit,
  TextStyle: TextStyle,
  UnsupportedTemporalTypeException: UnsupportedTemporalTypeException,
  ValueRange: ValueRange,
  Year: Year,
  YearConstants: YearConstants,
  YearMonth: YearMonth,
  ZoneId: ZoneId,
  ZoneOffset: ZoneOffset,
  ZoneOffsetTransition: ZoneOffsetTransition,
  ZoneRegion: ZoneRegion,
  ZoneRules: ZoneRules,
  ZoneRulesProvider: ZoneRulesProvider,
  ZonedDateTime: ZonedDateTime,
  _: _,
  convert: convert,
  nativeJs: nativeJs,
  use: use
});

var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(jsJoda_esm);

var hasRequiredDatetime;

function requireDatetime () {
	if (hasRequiredDatetime) return datetime.exports;
	hasRequiredDatetime = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _datetimen = _interopRequireDefault(requireDatetimen());
		var _core = require$$0$1;
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const EPOCH_DATE = _core.LocalDate.ofYearDay(1900, 1);
		const NULL_LENGTH = Buffer.from([0x00]);
		const DATA_LENGTH = Buffer.from([0x08]);
		const DateTime = {
		  id: 0x3D,
		  type: 'DATETIME',
		  name: 'DateTime',
		  declaration: function () {
		    return 'datetime';
		  },
		  generateTypeInfo() {
		    return Buffer.from([_datetimen.default.id, 0x08]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  generateParameterData: function* (parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const value = parameter.value; // Temporary solution. Remove 'any' later.

		    let date;
		    if (options.useUTC) {
		      date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
		    } else {
		      date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
		    }
		    let days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
		    let milliseconds, threeHundredthsOfSecond;
		    if (options.useUTC) {
		      let seconds = value.getUTCHours() * 60 * 60;
		      seconds += value.getUTCMinutes() * 60;
		      seconds += value.getUTCSeconds();
		      milliseconds = seconds * 1000 + value.getUTCMilliseconds();
		    } else {
		      let seconds = value.getHours() * 60 * 60;
		      seconds += value.getMinutes() * 60;
		      seconds += value.getSeconds();
		      milliseconds = seconds * 1000 + value.getMilliseconds();
		    }
		    threeHundredthsOfSecond = milliseconds / (3 + 1 / 3);
		    threeHundredthsOfSecond = Math.round(threeHundredthsOfSecond);

		    // 25920000 equals one day
		    if (threeHundredthsOfSecond === 25920000) {
		      days += 1;
		      threeHundredthsOfSecond = 0;
		    }
		    const buffer = Buffer.alloc(8);
		    buffer.writeInt32LE(days, 0);
		    buffer.writeUInt32LE(threeHundredthsOfSecond, 4);
		    yield buffer;
		  },
		  // TODO: type 'any' needs to be revisited.
		  validate: function (value, collation, options) {
		    if (value == null) {
		      return null;
		    }
		    if (!(value instanceof Date)) {
		      value = new Date(Date.parse(value));
		    }
		    value = value;
		    let year;
		    if (options && options.useUTC) {
		      year = value.getUTCFullYear();
		    } else {
		      year = value.getFullYear();
		    }
		    if (year < 1753 || year > 9999) {
		      throw new TypeError('Out of range.');
		    }
		    if (isNaN(value)) {
		      throw new TypeError('Invalid date.');
		    }
		    return value;
		  }
		};
		exports$1.default = DateTime;
		module.exports = DateTime;
		
	} (datetime, datetime.exports));
	return datetime.exports;
}

var float = {exports: {}};

var hasRequiredFloat;

function requireFloat () {
	if (hasRequiredFloat) return float.exports;
	hasRequiredFloat = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _floatn = _interopRequireDefault(requireFloatn());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const NULL_LENGTH = Buffer.from([0x00]);
		const Float = {
		  id: 0x3E,
		  type: 'FLT8',
		  name: 'Float',
		  declaration: function () {
		    return 'float';
		  },
		  generateTypeInfo() {
		    return Buffer.from([_floatn.default.id, 0x08]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return Buffer.from([0x08]);
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const buffer = Buffer.alloc(8);
		    buffer.writeDoubleLE(parseFloat(parameter.value), 0);
		    yield buffer;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    value = parseFloat(value);
		    if (isNaN(value)) {
		      throw new TypeError('Invalid number.');
		    }
		    return value;
		  }
		};
		exports$1.default = Float;
		module.exports = Float;
		
	} (float, float.exports));
	return float.exports;
}

var decimal = {exports: {}};

var decimaln = {exports: {}};

var hasRequiredDecimaln;

function requireDecimaln () {
	if (hasRequiredDecimaln) return decimaln.exports;
	hasRequiredDecimaln = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const DecimalN = {
		  id: 0x6A,
		  type: 'DECIMALN',
		  name: 'DecimalN',
		  declaration() {
		    throw new Error('not implemented');
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = DecimalN;
		module.exports = DecimalN;
		
	} (decimaln, decimaln.exports));
	return decimaln.exports;
}

var hasRequiredDecimal;

function requireDecimal () {
	if (hasRequiredDecimal) return decimal.exports;
	hasRequiredDecimal = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _decimaln = _interopRequireDefault(requireDecimaln());
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const NULL_LENGTH = Buffer.from([0x00]);
		const Decimal = {
		  id: 0x37,
		  type: 'DECIMAL',
		  name: 'Decimal',
		  declaration: function (parameter) {
		    return 'decimal(' + this.resolvePrecision(parameter) + ', ' + this.resolveScale(parameter) + ')';
		  },
		  resolvePrecision: function (parameter) {
		    if (parameter.precision != null) {
		      return parameter.precision;
		    } else if (parameter.value === null) {
		      return 1;
		    } else {
		      return 18;
		    }
		  },
		  resolveScale: function (parameter) {
		    if (parameter.scale != null) {
		      return parameter.scale;
		    } else {
		      return 0;
		    }
		  },
		  generateTypeInfo(parameter, _options) {
		    let precision;
		    if (parameter.precision <= 9) {
		      precision = 0x05;
		    } else if (parameter.precision <= 19) {
		      precision = 0x09;
		    } else if (parameter.precision <= 28) {
		      precision = 0x0D;
		    } else {
		      precision = 0x11;
		    }
		    return Buffer.from([_decimaln.default.id, precision, parameter.precision, parameter.scale]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    const precision = parameter.precision;
		    if (precision <= 9) {
		      return Buffer.from([0x05]);
		    } else if (precision <= 19) {
		      return Buffer.from([0x09]);
		    } else if (precision <= 28) {
		      return Buffer.from([0x0D]);
		    } else {
		      return Buffer.from([0x11]);
		    }
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const sign = parameter.value < 0 ? 0 : 1;
		    const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
		    const precision = parameter.precision;
		    if (precision <= 9) {
		      const buffer = Buffer.alloc(5);
		      buffer.writeUInt8(sign, 0);
		      buffer.writeUInt32LE(value, 1);
		      yield buffer;
		    } else if (precision <= 19) {
		      const buffer = new _writableTrackingBuffer.default(9);
		      buffer.writeUInt8(sign);
		      buffer.writeUInt64LE(value);
		      yield buffer.data;
		    } else if (precision <= 28) {
		      const buffer = new _writableTrackingBuffer.default(13);
		      buffer.writeUInt8(sign);
		      buffer.writeUInt64LE(value);
		      buffer.writeUInt32LE(0x00000000);
		      yield buffer.data;
		    } else {
		      const buffer = new _writableTrackingBuffer.default(17);
		      buffer.writeUInt8(sign);
		      buffer.writeUInt64LE(value);
		      buffer.writeUInt32LE(0x00000000);
		      buffer.writeUInt32LE(0x00000000);
		      yield buffer.data;
		    }
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    value = parseFloat(value);
		    if (isNaN(value)) {
		      throw new TypeError('Invalid number.');
		    }
		    return value;
		  }
		};
		exports$1.default = Decimal;
		module.exports = Decimal;
		
	} (decimal, decimal.exports));
	return decimal.exports;
}

var numeric = {exports: {}};

var numericn = {exports: {}};

var hasRequiredNumericn;

function requireNumericn () {
	if (hasRequiredNumericn) return numericn.exports;
	hasRequiredNumericn = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const NumericN = {
		  id: 0x6C,
		  type: 'NUMERICN',
		  name: 'NumericN',
		  declaration() {
		    throw new Error('not implemented');
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = NumericN;
		module.exports = NumericN;
		
	} (numericn, numericn.exports));
	return numericn.exports;
}

var hasRequiredNumeric;

function requireNumeric () {
	if (hasRequiredNumeric) return numeric.exports;
	hasRequiredNumeric = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _numericn = _interopRequireDefault(requireNumericn());
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const NULL_LENGTH = Buffer.from([0x00]);
		const Numeric = {
		  id: 0x3F,
		  type: 'NUMERIC',
		  name: 'Numeric',
		  declaration: function (parameter) {
		    return 'numeric(' + this.resolvePrecision(parameter) + ', ' + this.resolveScale(parameter) + ')';
		  },
		  resolvePrecision: function (parameter) {
		    if (parameter.precision != null) {
		      return parameter.precision;
		    } else if (parameter.value === null) {
		      return 1;
		    } else {
		      return 18;
		    }
		  },
		  resolveScale: function (parameter) {
		    if (parameter.scale != null) {
		      return parameter.scale;
		    } else {
		      return 0;
		    }
		  },
		  generateTypeInfo(parameter) {
		    let precision;
		    if (parameter.precision <= 9) {
		      precision = 0x05;
		    } else if (parameter.precision <= 19) {
		      precision = 0x09;
		    } else if (parameter.precision <= 28) {
		      precision = 0x0D;
		    } else {
		      precision = 0x11;
		    }
		    return Buffer.from([_numericn.default.id, precision, parameter.precision, parameter.scale]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    const precision = parameter.precision;
		    if (precision <= 9) {
		      return Buffer.from([0x05]);
		    } else if (precision <= 19) {
		      return Buffer.from([0x09]);
		    } else if (precision <= 28) {
		      return Buffer.from([0x0D]);
		    } else {
		      return Buffer.from([0x11]);
		    }
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const sign = parameter.value < 0 ? 0 : 1;
		    const value = Math.round(Math.abs(parameter.value * Math.pow(10, parameter.scale)));
		    if (parameter.precision <= 9) {
		      const buffer = Buffer.alloc(5);
		      buffer.writeUInt8(sign, 0);
		      buffer.writeUInt32LE(value, 1);
		      yield buffer;
		    } else if (parameter.precision <= 19) {
		      const buffer = new _writableTrackingBuffer.default(10);
		      buffer.writeUInt8(sign);
		      buffer.writeUInt64LE(value);
		      yield buffer.data;
		    } else if (parameter.precision <= 28) {
		      const buffer = new _writableTrackingBuffer.default(14);
		      buffer.writeUInt8(sign);
		      buffer.writeUInt64LE(value);
		      buffer.writeUInt32LE(0x00000000);
		      yield buffer.data;
		    } else {
		      const buffer = new _writableTrackingBuffer.default(18);
		      buffer.writeUInt8(sign);
		      buffer.writeUInt64LE(value);
		      buffer.writeUInt32LE(0x00000000);
		      buffer.writeUInt32LE(0x00000000);
		      yield buffer.data;
		    }
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    value = parseFloat(value);
		    if (isNaN(value)) {
		      throw new TypeError('Invalid number.');
		    }
		    return value;
		  }
		};
		exports$1.default = Numeric;
		module.exports = Numeric;
		
	} (numeric, numeric.exports));
	return numeric.exports;
}

var smallmoney = {exports: {}};

var hasRequiredSmallmoney;

function requireSmallmoney () {
	if (hasRequiredSmallmoney) return smallmoney.exports;
	hasRequiredSmallmoney = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _moneyn = _interopRequireDefault(requireMoneyn());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const DATA_LENGTH = Buffer.from([0x04]);
		const NULL_LENGTH = Buffer.from([0x00]);
		const SmallMoney = {
		  id: 0x7A,
		  type: 'MONEY4',
		  name: 'SmallMoney',
		  declaration: function () {
		    return 'smallmoney';
		  },
		  generateTypeInfo: function () {
		    return Buffer.from([_moneyn.default.id, 0x04]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const buffer = Buffer.alloc(4);
		    buffer.writeInt32LE(parameter.value * 10000, 0);
		    yield buffer;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    value = parseFloat(value);
		    if (isNaN(value)) {
		      throw new TypeError('Invalid number.');
		    }
		    if (value < -214748.3648 || value > 214748.3647) {
		      throw new TypeError('Value must be between -214748.3648 and 214748.3647.');
		    }
		    return value;
		  }
		};
		exports$1.default = SmallMoney;
		module.exports = SmallMoney;
		
	} (smallmoney, smallmoney.exports));
	return smallmoney.exports;
}

var bigint = {exports: {}};

var hasRequiredBigint;

function requireBigint () {
	if (hasRequiredBigint) return bigint.exports;
	hasRequiredBigint = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _intn = _interopRequireDefault(requireIntn());
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const DATA_LENGTH = Buffer.from([0x08]);
		const NULL_LENGTH = Buffer.from([0x00]);
		const MAX_SAFE_BIGINT = 9223372036854775807n;
		const MIN_SAFE_BIGINT = -9223372036854775808n;
		const BigInt = {
		  id: 0x7F,
		  type: 'INT8',
		  name: 'BigInt',
		  declaration: function () {
		    return 'bigint';
		  },
		  generateTypeInfo() {
		    return Buffer.from([_intn.default.id, 0x08]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const buffer = new _writableTrackingBuffer.default(8);
		    buffer.writeBigInt64LE(typeof parameter.value === 'bigint' ? parameter.value : globalThis.BigInt(parameter.value));
		    yield buffer.data;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'bigint') {
		      value = globalThis.BigInt(value);
		    }
		    if (value < MIN_SAFE_BIGINT || value > MAX_SAFE_BIGINT) {
		      throw new TypeError(`Value must be between ${MIN_SAFE_BIGINT} and ${MAX_SAFE_BIGINT}, inclusive.`);
		    }
		    return value;
		  }
		};
		exports$1.default = BigInt;
		module.exports = BigInt;
		
	} (bigint, bigint.exports));
	return bigint.exports;
}

var image = {exports: {}};

var hasRequiredImage;

function requireImage () {
	if (hasRequiredImage) return image.exports;
	hasRequiredImage = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const NULL_LENGTH = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF]);
		const Image = {
		  id: 0x22,
		  type: 'IMAGE',
		  name: 'Image',
		  hasTableName: true,
		  declaration: function () {
		    return 'image';
		  },
		  resolveLength: function (parameter) {
		    if (parameter.value != null) {
		      const value = parameter.value; // TODO: Temporary solution. Replace 'any' more with specific type;
		      return value.length;
		    } else {
		      return -1;
		    }
		  },
		  generateTypeInfo(parameter) {
		    const buffer = Buffer.alloc(5);
		    buffer.writeUInt8(this.id, 0);
		    buffer.writeInt32LE(parameter.length, 1);
		    return buffer;
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    const buffer = Buffer.alloc(4);
		    buffer.writeInt32LE(parameter.value.length, 0);
		    return buffer;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    yield parameter.value;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (!Buffer.isBuffer(value)) {
		      throw new TypeError('Invalid buffer.');
		    }
		    return value;
		  }
		};
		exports$1.default = Image;
		module.exports = Image;
		
	} (image, image.exports));
	return image.exports;
}

var text = {exports: {}};

var lib = {exports: {}};

/* eslint-disable node/no-deprecated-api */

var safer_1;
var hasRequiredSafer;

function requireSafer () {
	if (hasRequiredSafer) return safer_1;
	hasRequiredSafer = 1;

	var buffer = require$$0$7;
	var Buffer = buffer.Buffer;

	var safer = {};

	var key;

	for (key in buffer) {
	  if (!buffer.hasOwnProperty(key)) continue
	  if (key === 'SlowBuffer' || key === 'Buffer') continue
	  safer[key] = buffer[key];
	}

	var Safer = safer.Buffer = {};
	for (key in Buffer) {
	  if (!Buffer.hasOwnProperty(key)) continue
	  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
	  Safer[key] = Buffer[key];
	}

	safer.Buffer.prototype = Buffer.prototype;

	if (!Safer.from || Safer.from === Uint8Array.from) {
	  Safer.from = function (value, encodingOrOffset, length) {
	    if (typeof value === 'number') {
	      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
	    }
	    if (value && typeof value.length === 'undefined') {
	      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
	    }
	    return Buffer(value, encodingOrOffset, length)
	  };
	}

	if (!Safer.alloc) {
	  Safer.alloc = function (size, fill, encoding) {
	    if (typeof size !== 'number') {
	      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
	    }
	    if (size < 0 || size >= 2 * (1 << 30)) {
	      throw new RangeError('The value "' + size + '" is invalid for option "size"')
	    }
	    var buf = Buffer(size);
	    if (!fill || fill.length === 0) {
	      buf.fill(0);
	    } else if (typeof encoding === 'string') {
	      buf.fill(fill, encoding);
	    } else {
	      buf.fill(fill);
	    }
	    return buf
	  };
	}

	if (!safer.kStringMaxLength) {
	  try {
	    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
	  } catch (e) {
	    // we can't determine kStringMaxLength in environments where process.binding
	    // is unsupported, so let's not set it
	  }
	}

	if (!safer.constants) {
	  safer.constants = {
	    MAX_LENGTH: safer.kMaxLength
	  };
	  if (safer.kStringMaxLength) {
	    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
	  }
	}

	safer_1 = safer;
	return safer_1;
}

var bomHandling = {};

var hasRequiredBomHandling;

function requireBomHandling () {
	if (hasRequiredBomHandling) return bomHandling;
	hasRequiredBomHandling = 1;

	var BOMChar = '\uFEFF';

	bomHandling.PrependBOM = PrependBOMWrapper;
	function PrependBOMWrapper(encoder, options) {
	    this.encoder = encoder;
	    this.addBOM = true;
	}

	PrependBOMWrapper.prototype.write = function(str) {
	    if (this.addBOM) {
	        str = BOMChar + str;
	        this.addBOM = false;
	    }

	    return this.encoder.write(str);
	};

	PrependBOMWrapper.prototype.end = function() {
	    return this.encoder.end();
	};


	//------------------------------------------------------------------------------

	bomHandling.StripBOM = StripBOMWrapper;
	function StripBOMWrapper(decoder, options) {
	    this.decoder = decoder;
	    this.pass = false;
	    this.options = options || {};
	}

	StripBOMWrapper.prototype.write = function(buf) {
	    var res = this.decoder.write(buf);
	    if (this.pass || !res)
	        return res;

	    if (res[0] === BOMChar) {
	        res = res.slice(1);
	        if (typeof this.options.stripBOM === 'function')
	            this.options.stripBOM();
	    }

	    this.pass = true;
	    return res;
	};

	StripBOMWrapper.prototype.end = function() {
	    return this.decoder.end();
	};
	return bomHandling;
}

var encodings = {};

var internal;
var hasRequiredInternal;

function requireInternal () {
	if (hasRequiredInternal) return internal;
	hasRequiredInternal = 1;
	var Buffer = requireSafer().Buffer;

	// Export Node.js internal encodings.

	internal = {
	    // Encodings
	    utf8:   { type: "_internal", bomAware: true},
	    cesu8:  { type: "_internal", bomAware: true},
	    unicode11utf8: "utf8",

	    ucs2:   { type: "_internal", bomAware: true},
	    utf16le: "ucs2",

	    binary: { type: "_internal" },
	    base64: { type: "_internal" },
	    hex:    { type: "_internal" },

	    // Codec.
	    _internal: InternalCodec,
	};

	//------------------------------------------------------------------------------

	function InternalCodec(codecOptions, iconv) {
	    this.enc = codecOptions.encodingName;
	    this.bomAware = codecOptions.bomAware;

	    if (this.enc === "base64")
	        this.encoder = InternalEncoderBase64;
	    else if (this.enc === "cesu8") {
	        this.enc = "utf8"; // Use utf8 for decoding.
	        this.encoder = InternalEncoderCesu8;

	        // Add decoder for versions of Node not supporting CESU-8
	        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
	            this.decoder = InternalDecoderCesu8;
	            this.defaultCharUnicode = iconv.defaultCharUnicode;
	        }
	    }
	}

	InternalCodec.prototype.encoder = InternalEncoder;
	InternalCodec.prototype.decoder = InternalDecoder;

	//------------------------------------------------------------------------------

	// We use node.js internal decoder. Its signature is the same as ours.
	var StringDecoder = require$$1$4.StringDecoder;

	if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
	    StringDecoder.prototype.end = function() {};


	function InternalDecoder(options, codec) {
	    this.decoder = new StringDecoder(codec.enc);
	}

	InternalDecoder.prototype.write = function(buf) {
	    if (!Buffer.isBuffer(buf)) {
	        buf = Buffer.from(buf);
	    }

	    return this.decoder.write(buf);
	};

	InternalDecoder.prototype.end = function() {
	    return this.decoder.end();
	};


	//------------------------------------------------------------------------------
	// Encoder is mostly trivial

	function InternalEncoder(options, codec) {
	    this.enc = codec.enc;
	}

	InternalEncoder.prototype.write = function(str) {
	    return Buffer.from(str, this.enc);
	};

	InternalEncoder.prototype.end = function() {
	};


	//------------------------------------------------------------------------------
	// Except base64 encoder, which must keep its state.

	function InternalEncoderBase64(options, codec) {
	    this.prevStr = '';
	}

	InternalEncoderBase64.prototype.write = function(str) {
	    str = this.prevStr + str;
	    var completeQuads = str.length - (str.length % 4);
	    this.prevStr = str.slice(completeQuads);
	    str = str.slice(0, completeQuads);

	    return Buffer.from(str, "base64");
	};

	InternalEncoderBase64.prototype.end = function() {
	    return Buffer.from(this.prevStr, "base64");
	};


	//------------------------------------------------------------------------------
	// CESU-8 encoder is also special.

	function InternalEncoderCesu8(options, codec) {
	}

	InternalEncoderCesu8.prototype.write = function(str) {
	    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
	    for (var i = 0; i < str.length; i++) {
	        var charCode = str.charCodeAt(i);
	        // Naive implementation, but it works because CESU-8 is especially easy
	        // to convert from UTF-16 (which all JS strings are encoded in).
	        if (charCode < 0x80)
	            buf[bufIdx++] = charCode;
	        else if (charCode < 0x800) {
	            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	        }
	        else { // charCode will always be < 0x10000 in javascript.
	            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
	            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
	            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
	        }
	    }
	    return buf.slice(0, bufIdx);
	};

	InternalEncoderCesu8.prototype.end = function() {
	};

	//------------------------------------------------------------------------------
	// CESU-8 decoder is not implemented in Node v4.0+

	function InternalDecoderCesu8(options, codec) {
	    this.acc = 0;
	    this.contBytes = 0;
	    this.accBytes = 0;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	}

	InternalDecoderCesu8.prototype.write = function(buf) {
	    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
	        res = '';
	    for (var i = 0; i < buf.length; i++) {
	        var curByte = buf[i];
	        if ((curByte & 0xC0) !== 0x80) { // Leading byte
	            if (contBytes > 0) { // Previous code is invalid
	                res += this.defaultCharUnicode;
	                contBytes = 0;
	            }

	            if (curByte < 0x80) { // Single-byte code
	                res += String.fromCharCode(curByte);
	            } else if (curByte < 0xE0) { // Two-byte code
	                acc = curByte & 0x1F;
	                contBytes = 1; accBytes = 1;
	            } else if (curByte < 0xF0) { // Three-byte code
	                acc = curByte & 0x0F;
	                contBytes = 2; accBytes = 1;
	            } else { // Four or more are not supported for CESU-8.
	                res += this.defaultCharUnicode;
	            }
	        } else { // Continuation byte
	            if (contBytes > 0) { // We're waiting for it.
	                acc = (acc << 6) | (curByte & 0x3f);
	                contBytes--; accBytes++;
	                if (contBytes === 0) {
	                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
	                    if (accBytes === 2 && acc < 0x80 && acc > 0)
	                        res += this.defaultCharUnicode;
	                    else if (accBytes === 3 && acc < 0x800)
	                        res += this.defaultCharUnicode;
	                    else
	                        // Actually add character.
	                        res += String.fromCharCode(acc);
	                }
	            } else { // Unexpected continuation byte
	                res += this.defaultCharUnicode;
	            }
	        }
	    }
	    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
	    return res;
	};

	InternalDecoderCesu8.prototype.end = function() {
	    var res = 0;
	    if (this.contBytes > 0)
	        res += this.defaultCharUnicode;
	    return res;
	};
	return internal;
}

var utf32 = {};

var hasRequiredUtf32;

function requireUtf32 () {
	if (hasRequiredUtf32) return utf32;
	hasRequiredUtf32 = 1;

	var Buffer = requireSafer().Buffer;

	// == UTF32-LE/BE codec. ==========================================================

	utf32._utf32 = Utf32Codec;

	function Utf32Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	    this.bomAware = true;
	    this.isLE = codecOptions.isLE;
	}

	utf32.utf32le = { type: '_utf32', isLE: true };
	utf32.utf32be = { type: '_utf32', isLE: false };

	// Aliases
	utf32.ucs4le = 'utf32le';
	utf32.ucs4be = 'utf32be';

	Utf32Codec.prototype.encoder = Utf32Encoder;
	Utf32Codec.prototype.decoder = Utf32Decoder;

	// -- Encoding

	function Utf32Encoder(options, codec) {
	    this.isLE = codec.isLE;
	    this.highSurrogate = 0;
	}

	Utf32Encoder.prototype.write = function(str) {
	    var src = Buffer.from(str, 'ucs2');
	    var dst = Buffer.alloc(src.length * 2);
	    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
	    var offset = 0;

	    for (var i = 0; i < src.length; i += 2) {
	        var code = src.readUInt16LE(i);
	        var isHighSurrogate = (0xD800 <= code && code < 0xDC00);
	        var isLowSurrogate = (0xDC00 <= code && code < 0xE000);

	        if (this.highSurrogate) {
	            if (isHighSurrogate || !isLowSurrogate) {
	                // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
	                // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
	                // (technically wrong, but expected by some applications, like Windows file names).
	                write32.call(dst, this.highSurrogate, offset);
	                offset += 4;
	            }
	            else {
	                // Create 32-bit value from high and low surrogates;
	                var codepoint = (((this.highSurrogate - 0xD800) << 10) | (code - 0xDC00)) + 0x10000;

	                write32.call(dst, codepoint, offset);
	                offset += 4;
	                this.highSurrogate = 0;

	                continue;
	            }
	        }

	        if (isHighSurrogate)
	            this.highSurrogate = code;
	        else {
	            // Even if the current character is a low surrogate, with no previous high surrogate, we'll
	            // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
	            // unpaired high surrogates.
	            write32.call(dst, code, offset);
	            offset += 4;
	            this.highSurrogate = 0;
	        }
	    }

	    if (offset < dst.length)
	        dst = dst.slice(0, offset);

	    return dst;
	};

	Utf32Encoder.prototype.end = function() {
	    // Treat any leftover high surrogate as a semi-valid independent character.
	    if (!this.highSurrogate)
	        return;

	    var buf = Buffer.alloc(4);

	    if (this.isLE)
	        buf.writeUInt32LE(this.highSurrogate, 0);
	    else
	        buf.writeUInt32BE(this.highSurrogate, 0);

	    this.highSurrogate = 0;

	    return buf;
	};

	// -- Decoding

	function Utf32Decoder(options, codec) {
	    this.isLE = codec.isLE;
	    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
	    this.overflow = [];
	}

	Utf32Decoder.prototype.write = function(src) {
	    if (src.length === 0)
	        return '';

	    var i = 0;
	    var codepoint = 0;
	    var dst = Buffer.alloc(src.length + 4);
	    var offset = 0;
	    var isLE = this.isLE;
	    var overflow = this.overflow;
	    var badChar = this.badChar;

	    if (overflow.length > 0) {
	        for (; i < src.length && overflow.length < 4; i++)
	            overflow.push(src[i]);
	        
	        if (overflow.length === 4) {
	            // NOTE: codepoint is a signed int32 and can be negative.
	            // NOTE: We copied this block from below to help V8 optimize it (it works with array, not buffer).
	            if (isLE) {
	                codepoint = overflow[i] | (overflow[i+1] << 8) | (overflow[i+2] << 16) | (overflow[i+3] << 24);
	            } else {
	                codepoint = overflow[i+3] | (overflow[i+2] << 8) | (overflow[i+1] << 16) | (overflow[i] << 24);
	            }
	            overflow.length = 0;

	            offset = _writeCodepoint(dst, offset, codepoint, badChar);
	        }
	    }

	    // Main loop. Should be as optimized as possible.
	    for (; i < src.length - 3; i += 4) {
	        // NOTE: codepoint is a signed int32 and can be negative.
	        if (isLE) {
	            codepoint = src[i] | (src[i+1] << 8) | (src[i+2] << 16) | (src[i+3] << 24);
	        } else {
	            codepoint = src[i+3] | (src[i+2] << 8) | (src[i+1] << 16) | (src[i] << 24);
	        }
	        offset = _writeCodepoint(dst, offset, codepoint, badChar);
	    }

	    // Keep overflowing bytes.
	    for (; i < src.length; i++) {
	        overflow.push(src[i]);
	    }

	    return dst.slice(0, offset).toString('ucs2');
	};

	function _writeCodepoint(dst, offset, codepoint, badChar) {
	    // NOTE: codepoint is signed int32 and can be negative. We keep it that way to help V8 with optimizations.
	    if (codepoint < 0 || codepoint > 0x10FFFF) {
	        // Not a valid Unicode codepoint
	        codepoint = badChar;
	    } 

	    // Ephemeral Planes: Write high surrogate.
	    if (codepoint >= 0x10000) {
	        codepoint -= 0x10000;

	        var high = 0xD800 | (codepoint >> 10);
	        dst[offset++] = high & 0xff;
	        dst[offset++] = high >> 8;

	        // Low surrogate is written below.
	        var codepoint = 0xDC00 | (codepoint & 0x3FF);
	    }

	    // Write BMP char or low surrogate.
	    dst[offset++] = codepoint & 0xff;
	    dst[offset++] = codepoint >> 8;

	    return offset;
	}
	Utf32Decoder.prototype.end = function() {
	    this.overflow.length = 0;
	};

	// == UTF-32 Auto codec =============================================================
	// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
	// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
	// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

	// Encoder prepends BOM (which can be overridden with (addBOM: false}).

	utf32.utf32 = Utf32AutoCodec;
	utf32.ucs4 = 'utf32';

	function Utf32AutoCodec(options, iconv) {
	    this.iconv = iconv;
	}

	Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
	Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;

	// -- Encoding

	function Utf32AutoEncoder(options, codec) {
	    options = options || {};

	    if (options.addBOM === undefined)
	        options.addBOM = true;

	    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);
	}

	Utf32AutoEncoder.prototype.write = function(str) {
	    return this.encoder.write(str);
	};

	Utf32AutoEncoder.prototype.end = function() {
	    return this.encoder.end();
	};

	// -- Decoding

	function Utf32AutoDecoder(options, codec) {
	    this.decoder = null;
	    this.initialBufs = [];
	    this.initialBufsLen = 0;
	    this.options = options || {};
	    this.iconv = codec.iconv;
	}

	Utf32AutoDecoder.prototype.write = function(buf) {
	    if (!this.decoder) { 
	        // Codec is not chosen yet. Accumulate initial bytes.
	        this.initialBufs.push(buf);
	        this.initialBufsLen += buf.length;

	        if (this.initialBufsLen < 32) // We need more bytes to use space heuristic (see below)
	            return '';

	        // We have enough bytes -> detect endianness.
	        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);

	        var resStr = '';
	        for (var i = 0; i < this.initialBufs.length; i++)
	            resStr += this.decoder.write(this.initialBufs[i]);

	        this.initialBufs.length = this.initialBufsLen = 0;
	        return resStr;
	    }

	    return this.decoder.write(buf);
	};

	Utf32AutoDecoder.prototype.end = function() {
	    if (!this.decoder) {
	        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);

	        var resStr = '';
	        for (var i = 0; i < this.initialBufs.length; i++)
	            resStr += this.decoder.write(this.initialBufs[i]);

	        var trail = this.decoder.end();
	        if (trail)
	            resStr += trail;

	        this.initialBufs.length = this.initialBufsLen = 0;
	        return resStr;
	    }

	    return this.decoder.end();
	};

	function detectEncoding(bufs, defaultEncoding) {
	    var b = [];
	    var charsProcessed = 0;
	    var invalidLE = 0, invalidBE = 0;   // Number of invalid chars when decoded as LE or BE.
	    var bmpCharsLE = 0, bmpCharsBE = 0; // Number of BMP chars when decoded as LE or BE.

	    outer_loop:
	    for (var i = 0; i < bufs.length; i++) {
	        var buf = bufs[i];
	        for (var j = 0; j < buf.length; j++) {
	            b.push(buf[j]);
	            if (b.length === 4) {
	                if (charsProcessed === 0) {
	                    // Check BOM first.
	                    if (b[0] === 0xFF && b[1] === 0xFE && b[2] === 0 && b[3] === 0) {
	                        return 'utf-32le';
	                    }
	                    if (b[0] === 0 && b[1] === 0 && b[2] === 0xFE && b[3] === 0xFF) {
	                        return 'utf-32be';
	                    }
	                }

	                if (b[0] !== 0 || b[1] > 0x10) invalidBE++;
	                if (b[3] !== 0 || b[2] > 0x10) invalidLE++;

	                if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
	                if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;

	                b.length = 0;
	                charsProcessed++;

	                if (charsProcessed >= 100) {
	                    break outer_loop;
	                }
	            }
	        }
	    }

	    // Make decisions.
	    if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE)  return 'utf-32be';
	    if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE)  return 'utf-32le';

	    // Couldn't decide (likely all zeros or not enough data).
	    return defaultEncoding || 'utf-32le';
	}
	return utf32;
}

var utf16 = {};

var hasRequiredUtf16;

function requireUtf16 () {
	if (hasRequiredUtf16) return utf16;
	hasRequiredUtf16 = 1;
	var Buffer = requireSafer().Buffer;

	// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

	// == UTF16-BE codec. ==========================================================

	utf16.utf16be = Utf16BECodec;
	function Utf16BECodec() {
	}

	Utf16BECodec.prototype.encoder = Utf16BEEncoder;
	Utf16BECodec.prototype.decoder = Utf16BEDecoder;
	Utf16BECodec.prototype.bomAware = true;


	// -- Encoding

	function Utf16BEEncoder() {
	}

	Utf16BEEncoder.prototype.write = function(str) {
	    var buf = Buffer.from(str, 'ucs2');
	    for (var i = 0; i < buf.length; i += 2) {
	        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
	    }
	    return buf;
	};

	Utf16BEEncoder.prototype.end = function() {
	};


	// -- Decoding

	function Utf16BEDecoder() {
	    this.overflowByte = -1;
	}

	Utf16BEDecoder.prototype.write = function(buf) {
	    if (buf.length == 0)
	        return '';

	    var buf2 = Buffer.alloc(buf.length + 1),
	        i = 0, j = 0;

	    if (this.overflowByte !== -1) {
	        buf2[0] = buf[0];
	        buf2[1] = this.overflowByte;
	        i = 1; j = 2;
	    }

	    for (; i < buf.length-1; i += 2, j+= 2) {
	        buf2[j] = buf[i+1];
	        buf2[j+1] = buf[i];
	    }

	    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

	    return buf2.slice(0, j).toString('ucs2');
	};

	Utf16BEDecoder.prototype.end = function() {
	    this.overflowByte = -1;
	};


	// == UTF-16 codec =============================================================
	// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
	// Defaults to UTF-16LE, as it's prevalent and default in Node.
	// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
	// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

	// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

	utf16.utf16 = Utf16Codec;
	function Utf16Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	}

	Utf16Codec.prototype.encoder = Utf16Encoder;
	Utf16Codec.prototype.decoder = Utf16Decoder;


	// -- Encoding (pass-through)

	function Utf16Encoder(options, codec) {
	    options = options || {};
	    if (options.addBOM === undefined)
	        options.addBOM = true;
	    this.encoder = codec.iconv.getEncoder('utf-16le', options);
	}

	Utf16Encoder.prototype.write = function(str) {
	    return this.encoder.write(str);
	};

	Utf16Encoder.prototype.end = function() {
	    return this.encoder.end();
	};


	// -- Decoding

	function Utf16Decoder(options, codec) {
	    this.decoder = null;
	    this.initialBufs = [];
	    this.initialBufsLen = 0;

	    this.options = options || {};
	    this.iconv = codec.iconv;
	}

	Utf16Decoder.prototype.write = function(buf) {
	    if (!this.decoder) {
	        // Codec is not chosen yet. Accumulate initial bytes.
	        this.initialBufs.push(buf);
	        this.initialBufsLen += buf.length;
	        
	        if (this.initialBufsLen < 16) // We need more bytes to use space heuristic (see below)
	            return '';

	        // We have enough bytes -> detect endianness.
	        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);

	        var resStr = '';
	        for (var i = 0; i < this.initialBufs.length; i++)
	            resStr += this.decoder.write(this.initialBufs[i]);

	        this.initialBufs.length = this.initialBufsLen = 0;
	        return resStr;
	    }

	    return this.decoder.write(buf);
	};

	Utf16Decoder.prototype.end = function() {
	    if (!this.decoder) {
	        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
	        this.decoder = this.iconv.getDecoder(encoding, this.options);

	        var resStr = '';
	        for (var i = 0; i < this.initialBufs.length; i++)
	            resStr += this.decoder.write(this.initialBufs[i]);

	        var trail = this.decoder.end();
	        if (trail)
	            resStr += trail;

	        this.initialBufs.length = this.initialBufsLen = 0;
	        return resStr;
	    }
	    return this.decoder.end();
	};

	function detectEncoding(bufs, defaultEncoding) {
	    var b = [];
	    var charsProcessed = 0;
	    var asciiCharsLE = 0, asciiCharsBE = 0; // Number of ASCII chars when decoded as LE or BE.

	    outer_loop:
	    for (var i = 0; i < bufs.length; i++) {
	        var buf = bufs[i];
	        for (var j = 0; j < buf.length; j++) {
	            b.push(buf[j]);
	            if (b.length === 2) {
	                if (charsProcessed === 0) {
	                    // Check BOM first.
	                    if (b[0] === 0xFF && b[1] === 0xFE) return 'utf-16le';
	                    if (b[0] === 0xFE && b[1] === 0xFF) return 'utf-16be';
	                }

	                if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
	                if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;

	                b.length = 0;
	                charsProcessed++;

	                if (charsProcessed >= 100) {
	                    break outer_loop;
	                }
	            }
	        }
	    }

	    // Make decisions.
	    // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
	    // So, we count ASCII as if it was LE or BE, and decide from that.
	    if (asciiCharsBE > asciiCharsLE) return 'utf-16be';
	    if (asciiCharsBE < asciiCharsLE) return 'utf-16le';

	    // Couldn't decide (likely all zeros or not enough data).
	    return defaultEncoding || 'utf-16le';
	}
	return utf16;
}

var utf7 = {};

var hasRequiredUtf7;

function requireUtf7 () {
	if (hasRequiredUtf7) return utf7;
	hasRequiredUtf7 = 1;
	var Buffer = requireSafer().Buffer;

	// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
	// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

	utf7.utf7 = Utf7Codec;
	utf7.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
	function Utf7Codec(codecOptions, iconv) {
	    this.iconv = iconv;
	}
	Utf7Codec.prototype.encoder = Utf7Encoder;
	Utf7Codec.prototype.decoder = Utf7Decoder;
	Utf7Codec.prototype.bomAware = true;


	// -- Encoding

	var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

	function Utf7Encoder(options, codec) {
	    this.iconv = codec.iconv;
	}

	Utf7Encoder.prototype.write = function(str) {
	    // Naive implementation.
	    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
	    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
	        return "+" + (chunk === '+' ? '' : 
	            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
	            + "-";
	    }.bind(this)));
	};

	Utf7Encoder.prototype.end = function() {
	};


	// -- Decoding

	function Utf7Decoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	}

	var base64Regex = /[A-Za-z0-9\/+]/;
	var base64Chars = [];
	for (var i = 0; i < 256; i++)
	    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

	var plusChar = '+'.charCodeAt(0), 
	    minusChar = '-'.charCodeAt(0),
	    andChar = '&'.charCodeAt(0);

	Utf7Decoder.prototype.write = function(buf) {
	    var res = "", lastI = 0,
	        inBase64 = this.inBase64,
	        base64Accum = this.base64Accum;

	    // The decoder is more involved as we must handle chunks in stream.

	    for (var i = 0; i < buf.length; i++) {
	        if (!inBase64) { // We're in direct mode.
	            // Write direct chars until '+'
	            if (buf[i] == plusChar) {
	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	                lastI = i+1;
	                inBase64 = true;
	            }
	        } else { // We decode base64.
	            if (!base64Chars[buf[i]]) { // Base64 ended.
	                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
	                    res += "+";
	                } else {
	                    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
	                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	                }

	                if (buf[i] != minusChar) // Minus is absorbed after base64.
	                    i--;

	                lastI = i+1;
	                inBase64 = false;
	                base64Accum = '';
	            }
	        }
	    }

	    if (!inBase64) {
	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");

	        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	        b64str = b64str.slice(0, canBeDecoded);

	        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	    }

	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;

	    return res;
	};

	Utf7Decoder.prototype.end = function() {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0)
	        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	};


	// UTF-7-IMAP codec.
	// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
	// Differences:
	//  * Base64 part is started by "&" instead of "+"
	//  * Direct characters are 0x20-0x7E, except "&" (0x26)
	//  * In Base64, "," is used instead of "/"
	//  * Base64 must not be used to represent direct characters.
	//  * No implicit shift back from Base64 (should always end with '-')
	//  * String must end in non-shifted position.
	//  * "-&" while in base64 is not allowed.


	utf7.utf7imap = Utf7IMAPCodec;
	function Utf7IMAPCodec(codecOptions, iconv) {
	    this.iconv = iconv;
	}
	Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
	Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
	Utf7IMAPCodec.prototype.bomAware = true;


	// -- Encoding

	function Utf7IMAPEncoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = Buffer.alloc(6);
	    this.base64AccumIdx = 0;
	}

	Utf7IMAPEncoder.prototype.write = function(str) {
	    var inBase64 = this.inBase64,
	        base64Accum = this.base64Accum,
	        base64AccumIdx = this.base64AccumIdx,
	        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

	    for (var i = 0; i < str.length; i++) {
	        var uChar = str.charCodeAt(i);
	        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
	            if (inBase64) {
	                if (base64AccumIdx > 0) {
	                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	                    base64AccumIdx = 0;
	                }

	                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	                inBase64 = false;
	            }

	            if (!inBase64) {
	                buf[bufIdx++] = uChar; // Write direct character

	                if (uChar === andChar)  // Ampersand -> '&-'
	                    buf[bufIdx++] = minusChar;
	            }

	        } else { // Non-direct character
	            if (!inBase64) {
	                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
	                inBase64 = true;
	            }
	            if (inBase64) {
	                base64Accum[base64AccumIdx++] = uChar >> 8;
	                base64Accum[base64AccumIdx++] = uChar & 0xFF;

	                if (base64AccumIdx == base64Accum.length) {
	                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
	                    base64AccumIdx = 0;
	                }
	            }
	        }
	    }

	    this.inBase64 = inBase64;
	    this.base64AccumIdx = base64AccumIdx;

	    return buf.slice(0, bufIdx);
	};

	Utf7IMAPEncoder.prototype.end = function() {
	    var buf = Buffer.alloc(10), bufIdx = 0;
	    if (this.inBase64) {
	        if (this.base64AccumIdx > 0) {
	            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
	            this.base64AccumIdx = 0;
	        }

	        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
	        this.inBase64 = false;
	    }

	    return buf.slice(0, bufIdx);
	};


	// -- Decoding

	function Utf7IMAPDecoder(options, codec) {
	    this.iconv = codec.iconv;
	    this.inBase64 = false;
	    this.base64Accum = '';
	}

	var base64IMAPChars = base64Chars.slice();
	base64IMAPChars[','.charCodeAt(0)] = true;

	Utf7IMAPDecoder.prototype.write = function(buf) {
	    var res = "", lastI = 0,
	        inBase64 = this.inBase64,
	        base64Accum = this.base64Accum;

	    // The decoder is more involved as we must handle chunks in stream.
	    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

	    for (var i = 0; i < buf.length; i++) {
	        if (!inBase64) { // We're in direct mode.
	            // Write direct chars until '&'
	            if (buf[i] == andChar) {
	                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
	                lastI = i+1;
	                inBase64 = true;
	            }
	        } else { // We decode base64.
	            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
	                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
	                    res += "&";
	                } else {
	                    var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii").replace(/,/g, '/');
	                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	                }

	                if (buf[i] != minusChar) // Minus may be absorbed after base64.
	                    i--;

	                lastI = i+1;
	                inBase64 = false;
	                base64Accum = '';
	            }
	        }
	    }

	    if (!inBase64) {
	        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
	    } else {
	        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, '/');

	        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
	        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
	        b64str = b64str.slice(0, canBeDecoded);

	        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
	    }

	    this.inBase64 = inBase64;
	    this.base64Accum = base64Accum;

	    return res;
	};

	Utf7IMAPDecoder.prototype.end = function() {
	    var res = "";
	    if (this.inBase64 && this.base64Accum.length > 0)
	        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

	    this.inBase64 = false;
	    this.base64Accum = '';
	    return res;
	};
	return utf7;
}

var sbcsCodec = {};

var hasRequiredSbcsCodec;

function requireSbcsCodec () {
	if (hasRequiredSbcsCodec) return sbcsCodec;
	hasRequiredSbcsCodec = 1;
	var Buffer = requireSafer().Buffer;

	// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
	// correspond to encoded bytes (if 128 - then lower half is ASCII). 

	sbcsCodec._sbcs = SBCSCodec;
	function SBCSCodec(codecOptions, iconv) {
	    if (!codecOptions)
	        throw new Error("SBCS codec is called without the data.")
	    
	    // Prepare char buffer for decoding.
	    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
	        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
	    
	    if (codecOptions.chars.length === 128) {
	        var asciiString = "";
	        for (var i = 0; i < 128; i++)
	            asciiString += String.fromCharCode(i);
	        codecOptions.chars = asciiString + codecOptions.chars;
	    }

	    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
	    
	    // Encoding buffer.
	    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

	    for (var i = 0; i < codecOptions.chars.length; i++)
	        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

	    this.encodeBuf = encodeBuf;
	}

	SBCSCodec.prototype.encoder = SBCSEncoder;
	SBCSCodec.prototype.decoder = SBCSDecoder;


	function SBCSEncoder(options, codec) {
	    this.encodeBuf = codec.encodeBuf;
	}

	SBCSEncoder.prototype.write = function(str) {
	    var buf = Buffer.alloc(str.length);
	    for (var i = 0; i < str.length; i++)
	        buf[i] = this.encodeBuf[str.charCodeAt(i)];
	    
	    return buf;
	};

	SBCSEncoder.prototype.end = function() {
	};


	function SBCSDecoder(options, codec) {
	    this.decodeBuf = codec.decodeBuf;
	}

	SBCSDecoder.prototype.write = function(buf) {
	    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
	    var decodeBuf = this.decodeBuf;
	    var newBuf = Buffer.alloc(buf.length*2);
	    var idx1 = 0, idx2 = 0;
	    for (var i = 0; i < buf.length; i++) {
	        idx1 = buf[i]*2; idx2 = i*2;
	        newBuf[idx2] = decodeBuf[idx1];
	        newBuf[idx2+1] = decodeBuf[idx1+1];
	    }
	    return newBuf.toString('ucs2');
	};

	SBCSDecoder.prototype.end = function() {
	};
	return sbcsCodec;
}

var sbcsData;
var hasRequiredSbcsData;

function requireSbcsData () {
	if (hasRequiredSbcsData) return sbcsData;
	hasRequiredSbcsData = 1;

	// Manually added data to be used by sbcs codec in addition to generated one.

	sbcsData = {
	    // Not supported by iconv, not sure why.
	    "10029": "maccenteuro",
	    "maccenteuro": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    "808": "cp808",
	    "ibm808": "cp808",
	    "cp808": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    "mik": {
	        "type": "_sbcs",
	        "chars": ""
	    },

	    "cp720": {
	        "type": "_sbcs",
	        "chars": "\x80\x81\x84\x86\x8d\x8e\x8f\x90\u0651\u0652\u064b\u064c\u064d\u064e\u064f\u0650\u00a0"
	    },

	    // Aliases of generated encodings.
	    "ascii8bit": "ascii",
	    "usascii": "ascii",
	    "ansix34": "ascii",
	    "ansix341968": "ascii",
	    "ansix341986": "ascii",
	    "csascii": "ascii",
	    "cp367": "ascii",
	    "ibm367": "ascii",
	    "isoir6": "ascii",
	    "iso646us": "ascii",
	    "iso646irv": "ascii",
	    "us": "ascii",

	    "latin1": "iso88591",
	    "latin2": "iso88592",
	    "latin3": "iso88593",
	    "latin4": "iso88594",
	    "latin5": "iso88599",
	    "latin6": "iso885910",
	    "latin7": "iso885913",
	    "latin8": "iso885914",
	    "latin9": "iso885915",
	    "latin10": "iso885916",

	    "csisolatin1": "iso88591",
	    "csisolatin2": "iso88592",
	    "csisolatin3": "iso88593",
	    "csisolatin4": "iso88594",
	    "csisolatincyrillic": "iso88595",
	    "csisolatinarabic": "iso88596",
	    "csisolatingreek" : "iso88597",
	    "csisolatinhebrew": "iso88598",
	    "csisolatin5": "iso88599",
	    "csisolatin6": "iso885910",

	    "l1": "iso88591",
	    "l2": "iso88592",
	    "l3": "iso88593",
	    "l4": "iso88594",
	    "l5": "iso88599",
	    "l6": "iso885910",
	    "l7": "iso885913",
	    "l8": "iso885914",
	    "l9": "iso885915",
	    "l10": "iso885916",

	    "isoir14": "iso646jp",
	    "isoir57": "iso646cn",
	    "isoir100": "iso88591",
	    "isoir101": "iso88592",
	    "isoir109": "iso88593",
	    "isoir110": "iso88594",
	    "isoir144": "iso88595",
	    "isoir127": "iso88596",
	    "isoir126": "iso88597",
	    "isoir138": "iso88598",
	    "isoir148": "iso88599",
	    "isoir157": "iso885910",
	    "isoir166": "tis620",
	    "isoir179": "iso885913",
	    "isoir199": "iso885914",
	    "isoir203": "iso885915",
	    "isoir226": "iso885916",

	    "cp819": "iso88591",
	    "ibm819": "iso88591",

	    "cyrillic": "iso88595",

	    "arabic": "iso88596",
	    "arabic8": "iso88596",
	    "ecma114": "iso88596",
	    "asmo708": "iso88596",

	    "greek" : "iso88597",
	    "greek8" : "iso88597",
	    "ecma118" : "iso88597",
	    "elot928" : "iso88597",

	    "hebrew": "iso88598",
	    "hebrew8": "iso88598",

	    "turkish": "iso88599",
	    "turkish8": "iso88599",

	    "thai": "iso885911",
	    "thai8": "iso885911",

	    "celtic": "iso885914",
	    "celtic8": "iso885914",
	    "isoceltic": "iso885914",

	    "tis6200": "tis620",
	    "tis62025291": "tis620",
	    "tis62025330": "tis620",

	    "10000": "macroman",
	    "10006": "macgreek",
	    "10007": "maccyrillic",
	    "10079": "maciceland",
	    "10081": "macturkish",

	    "cspc8codepage437": "cp437",
	    "cspc775baltic": "cp775",
	    "cspc850multilingual": "cp850",
	    "cspcp852": "cp852",
	    "cspc862latinhebrew": "cp862",
	    "cpgr": "cp869",

	    "msee": "cp1250",
	    "mscyrl": "cp1251",
	    "msansi": "cp1252",
	    "msgreek": "cp1253",
	    "msturk": "cp1254",
	    "mshebr": "cp1255",
	    "msarab": "cp1256",
	    "winbaltrim": "cp1257",

	    "cp20866": "koi8r",
	    "20866": "koi8r",
	    "ibm878": "koi8r",
	    "cskoi8r": "koi8r",

	    "cp21866": "koi8u",
	    "21866": "koi8u",
	    "ibm1168": "koi8u",

	    "strk10482002": "rk1048",

	    "tcvn5712": "tcvn",
	    "tcvn57121": "tcvn",

	    "gb198880": "iso646cn",
	    "cn": "iso646cn",

	    "csiso14jisc6220ro": "iso646jp",
	    "jisc62201969ro": "iso646jp",
	    "jp": "iso646jp",

	    "cshproman8": "hproman8",
	    "r8": "hproman8",
	    "roman8": "hproman8",
	    "xroman8": "hproman8",
	    "ibm1051": "hproman8",

	    "mac": "macintosh",
	    "csmacintosh": "macintosh",
	};
	return sbcsData;
}

var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;

function requireSbcsDataGenerated () {
	if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
	hasRequiredSbcsDataGenerated = 1;

	// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
	sbcsDataGenerated = {
	  "437": "cp437",
	  "737": "cp737",
	  "775": "cp775",
	  "850": "cp850",
	  "852": "cp852",
	  "855": "cp855",
	  "856": "cp856",
	  "857": "cp857",
	  "858": "cp858",
	  "860": "cp860",
	  "861": "cp861",
	  "862": "cp862",
	  "863": "cp863",
	  "864": "cp864",
	  "865": "cp865",
	  "866": "cp866",
	  "869": "cp869",
	  "874": "windows874",
	  "922": "cp922",
	  "1046": "cp1046",
	  "1124": "cp1124",
	  "1125": "cp1125",
	  "1129": "cp1129",
	  "1133": "cp1133",
	  "1161": "cp1161",
	  "1162": "cp1162",
	  "1163": "cp1163",
	  "1250": "windows1250",
	  "1251": "windows1251",
	  "1252": "windows1252",
	  "1253": "windows1253",
	  "1254": "windows1254",
	  "1255": "windows1255",
	  "1256": "windows1256",
	  "1257": "windows1257",
	  "1258": "windows1258",
	  "28591": "iso88591",
	  "28592": "iso88592",
	  "28593": "iso88593",
	  "28594": "iso88594",
	  "28595": "iso88595",
	  "28596": "iso88596",
	  "28597": "iso88597",
	  "28598": "iso88598",
	  "28599": "iso88599",
	  "28600": "iso885910",
	  "28601": "iso885911",
	  "28603": "iso885913",
	  "28604": "iso885914",
	  "28605": "iso885915",
	  "28606": "iso885916",
	  "windows874": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win874": "windows874",
	  "cp874": "windows874",
	  "windows1250": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1250": "windows1250",
	  "cp1250": "windows1250",
	  "windows1251": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1251": "windows1251",
	  "cp1251": "windows1251",
	  "windows1252": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1252": "windows1252",
	  "cp1252": "windows1252",
	  "windows1253": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1253": "windows1253",
	  "cp1253": "windows1253",
	  "windows1254": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1254": "windows1254",
	  "cp1254": "windows1254",
	  "windows1255": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1255": "windows1255",
	  "cp1255": "windows1255",
	  "windows1256": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1256": "windows1256",
	  "cp1256": "windows1256",
	  "windows1257": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1257": "windows1257",
	  "cp1257": "windows1257",
	  "windows1258": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "win1258": "windows1258",
	  "cp1258": "windows1258",
	  "iso88591": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28591": "iso88591",
	  "iso88592": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28592": "iso88592",
	  "iso88593": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28593": "iso88593",
	  "iso88594": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28594": "iso88594",
	  "iso88595": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28595": "iso88595",
	  "iso88596": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28596": "iso88596",
	  "iso88597": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28597": "iso88597",
	  "iso88598": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28598": "iso88598",
	  "iso88599": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28599": "iso88599",
	  "iso885910": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28600": "iso885910",
	  "iso885911": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28601": "iso885911",
	  "iso885913": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28603": "iso885913",
	  "iso885914": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28604": "iso885914",
	  "iso885915": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28605": "iso885915",
	  "iso885916": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "cp28606": "iso885916",
	  "cp437": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm437": "cp437",
	  "csibm437": "cp437",
	  "cp737": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm737": "cp737",
	  "csibm737": "cp737",
	  "cp775": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm775": "cp775",
	  "csibm775": "cp775",
	  "cp850": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm850": "cp850",
	  "csibm850": "cp850",
	  "cp852": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm852": "cp852",
	  "csibm852": "cp852",
	  "cp855": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm855": "cp855",
	  "csibm855": "cp855",
	  "cp856": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm856": "cp856",
	  "csibm856": "cp856",
	  "cp857": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm857": "cp857",
	  "csibm857": "cp857",
	  "cp858": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm858": "cp858",
	  "csibm858": "cp858",
	  "cp860": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm860": "cp860",
	  "csibm860": "cp860",
	  "cp861": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm861": "cp861",
	  "csibm861": "cp861",
	  "cp862": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm862": "cp862",
	  "csibm862": "cp862",
	  "cp863": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm863": "cp863",
	  "csibm863": "cp863",
	  "cp864": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "ibm864": "cp864",
	  "csibm864": "cp864",
	  "cp865": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm865": "cp865",
	  "csibm865": "cp865",
	  "cp866": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm866": "cp866",
	  "csibm866": "cp866",
	  "cp869": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm869": "cp869",
	  "csibm869": "cp869",
	  "cp922": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm922": "cp922",
	  "csibm922": "cp922",
	  "cp1046": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1046": "cp1046",
	  "csibm1046": "cp1046",
	  "cp1124": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1124": "cp1124",
	  "csibm1124": "cp1124",
	  "cp1125": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1125": "cp1125",
	  "csibm1125": "cp1125",
	  "cp1129": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1129": "cp1129",
	  "csibm1129": "cp1129",
	  "cp1133": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1133": "cp1133",
	  "csibm1133": "cp1133",
	  "cp1161": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1161": "cp1161",
	  "csibm1161": "cp1161",
	  "cp1162": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1162": "cp1162",
	  "csibm1162": "cp1162",
	  "cp1163": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ibm1163": "cp1163",
	  "csibm1163": "cp1163",
	  "maccroatian": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maccyrillic": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macgreek": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "maciceland": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macroman": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macromania": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macthai": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macturkish": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macukraine": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8r": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8u": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8ru": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "koi8t": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "armscii8": {
	    "type": "_sbcs",
	    "chars": ")(.,-"
	  },
	  "rk1048": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tcvn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "georgianacademy": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "georgianps": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "pt154": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "viscii": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
	  },
	  "iso646cn": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "iso646jp": {
	    "type": "_sbcs",
	    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
	  },
	  "hproman8": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "macintosh": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "ascii": {
	    "type": "_sbcs",
	    "chars": ""
	  },
	  "tis620": {
	    "type": "_sbcs",
	    "chars": ""
	  }
	};
	return sbcsDataGenerated;
}

var dbcsCodec = {};

var hasRequiredDbcsCodec;

function requireDbcsCodec () {
	if (hasRequiredDbcsCodec) return dbcsCodec;
	hasRequiredDbcsCodec = 1;
	var Buffer = requireSafer().Buffer;

	// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
	// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
	// To save memory and loading time, we read table files only when requested.

	dbcsCodec._dbcs = DBCSCodec;

	var UNASSIGNED = -1,
	    GB18030_CODE = -2,
	    SEQ_START  = -10,
	    NODE_START = -1e3,
	    UNASSIGNED_NODE = new Array(0x100),
	    DEF_CHAR = -1;

	for (var i = 0; i < 0x100; i++)
	    UNASSIGNED_NODE[i] = UNASSIGNED;


	// Class DBCSCodec reads and initializes mapping tables.
	function DBCSCodec(codecOptions, iconv) {
	    this.encodingName = codecOptions.encodingName;
	    if (!codecOptions)
	        throw new Error("DBCS codec is called without the data.")
	    if (!codecOptions.table)
	        throw new Error("Encoding '" + this.encodingName + "' has no data.");

	    // Load tables.
	    var mappingTable = codecOptions.table();


	    // Decode tables: MBCS -> Unicode.

	    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
	    // Trie root is decodeTables[0].
	    // Values: >=  0 -> unicode character code. can be > 0xFFFF
	    //         == UNASSIGNED -> unknown/unassigned sequence.
	    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
	    //         <= NODE_START -> index of the next node in our trie to process next byte.
	    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
	    this.decodeTables = [];
	    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

	    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
	    this.decodeTableSeq = [];

	    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
	    for (var i = 0; i < mappingTable.length; i++)
	        this._addDecodeChunk(mappingTable[i]);

	    // Load & create GB18030 tables when needed.
	    if (typeof codecOptions.gb18030 === 'function') {
	        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

	        // Add GB18030 common decode nodes.
	        var commonThirdByteNodeIdx = this.decodeTables.length;
	        this.decodeTables.push(UNASSIGNED_NODE.slice(0));

	        var commonFourthByteNodeIdx = this.decodeTables.length;
	        this.decodeTables.push(UNASSIGNED_NODE.slice(0));

	        // Fill out the tree
	        var firstByteNode = this.decodeTables[0];
	        for (var i = 0x81; i <= 0xFE; i++) {
	            var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];
	            for (var j = 0x30; j <= 0x39; j++) {
	                if (secondByteNode[j] === UNASSIGNED) {
	                    secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
	                } else if (secondByteNode[j] > NODE_START) {
	                    throw new Error("gb18030 decode tables conflict at byte 2");
	                }

	                var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
	                for (var k = 0x81; k <= 0xFE; k++) {
	                    if (thirdByteNode[k] === UNASSIGNED) {
	                        thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
	                    } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
	                        continue;
	                    } else if (thirdByteNode[k] > NODE_START) {
	                        throw new Error("gb18030 decode tables conflict at byte 3");
	                    }

	                    var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
	                    for (var l = 0x30; l <= 0x39; l++) {
	                        if (fourthByteNode[l] === UNASSIGNED)
	                            fourthByteNode[l] = GB18030_CODE;
	                    }
	                }
	            }
	        }
	    }

	    this.defaultCharUnicode = iconv.defaultCharUnicode;

	    
	    // Encode tables: Unicode -> DBCS.

	    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
	    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
	    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
	    //         == UNASSIGNED -> no conversion found. Output a default char.
	    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
	    this.encodeTable = [];
	    
	    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
	    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
	    // means end of sequence (needed when one sequence is a strict subsequence of another).
	    // Objects are kept separately from encodeTable to increase performance.
	    this.encodeTableSeq = [];

	    // Some chars can be decoded, but need not be encoded.
	    var skipEncodeChars = {};
	    if (codecOptions.encodeSkipVals)
	        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
	            var val = codecOptions.encodeSkipVals[i];
	            if (typeof val === 'number')
	                skipEncodeChars[val] = true;
	            else
	                for (var j = val.from; j <= val.to; j++)
	                    skipEncodeChars[j] = true;
	        }
	        
	    // Use decode trie to recursively fill out encode tables.
	    this._fillEncodeTable(0, 0, skipEncodeChars);

	    // Add more encoding pairs when needed.
	    if (codecOptions.encodeAdd) {
	        for (var uChar in codecOptions.encodeAdd)
	            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
	                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
	    }

	    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
	    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
	}

	DBCSCodec.prototype.encoder = DBCSEncoder;
	DBCSCodec.prototype.decoder = DBCSDecoder;

	// Decoder helpers
	DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
	    var bytes = [];
	    for (; addr > 0; addr >>>= 8)
	        bytes.push(addr & 0xFF);
	    if (bytes.length == 0)
	        bytes.push(0);

	    var node = this.decodeTables[0];
	    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
	        var val = node[bytes[i]];

	        if (val == UNASSIGNED) { // Create new node.
	            node[bytes[i]] = NODE_START - this.decodeTables.length;
	            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
	        }
	        else if (val <= NODE_START) { // Existing node.
	            node = this.decodeTables[NODE_START - val];
	        }
	        else
	            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
	    }
	    return node;
	};


	DBCSCodec.prototype._addDecodeChunk = function(chunk) {
	    // First element of chunk is the hex mbcs code where we start.
	    var curAddr = parseInt(chunk[0], 16);

	    // Choose the decoding node where we'll write our chars.
	    var writeTable = this._getDecodeTrieNode(curAddr);
	    curAddr = curAddr & 0xFF;

	    // Write all other elements of the chunk to the table.
	    for (var k = 1; k < chunk.length; k++) {
	        var part = chunk[k];
	        if (typeof part === "string") { // String, write as-is.
	            for (var l = 0; l < part.length;) {
	                var code = part.charCodeAt(l++);
	                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
	                    var codeTrail = part.charCodeAt(l++);
	                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
	                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
	                    else
	                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
	                }
	                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
	                    var len = 0xFFF - code + 2;
	                    var seq = [];
	                    for (var m = 0; m < len; m++)
	                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

	                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
	                    this.decodeTableSeq.push(seq);
	                }
	                else
	                    writeTable[curAddr++] = code; // Basic char
	            }
	        } 
	        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
	            var charCode = writeTable[curAddr - 1] + 1;
	            for (var l = 0; l < part; l++)
	                writeTable[curAddr++] = charCode++;
	        }
	        else
	            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
	    }
	    if (curAddr > 0xFF)
	        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
	};

	// Encoder helpers
	DBCSCodec.prototype._getEncodeBucket = function(uCode) {
	    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
	    if (this.encodeTable[high] === undefined)
	        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
	    return this.encodeTable[high];
	};

	DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;
	    if (bucket[low] <= SEQ_START)
	        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
	    else if (bucket[low] == UNASSIGNED)
	        bucket[low] = dbcsCode;
	};

	DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
	    
	    // Get the root of character tree according to first character of the sequence.
	    var uCode = seq[0];
	    var bucket = this._getEncodeBucket(uCode);
	    var low = uCode & 0xFF;

	    var node;
	    if (bucket[low] <= SEQ_START) {
	        // There's already a sequence with  - use it.
	        node = this.encodeTableSeq[SEQ_START-bucket[low]];
	    }
	    else {
	        // There was no sequence object - allocate a new one.
	        node = {};
	        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
	        bucket[low] = SEQ_START - this.encodeTableSeq.length;
	        this.encodeTableSeq.push(node);
	    }

	    // Traverse the character tree, allocating new nodes as needed.
	    for (var j = 1; j < seq.length-1; j++) {
	        var oldVal = node[uCode];
	        if (typeof oldVal === 'object')
	            node = oldVal;
	        else {
	            node = node[uCode] = {};
	            if (oldVal !== undefined)
	                node[DEF_CHAR] = oldVal;
	        }
	    }

	    // Set the leaf to given dbcsCode.
	    uCode = seq[seq.length-1];
	    node[uCode] = dbcsCode;
	};

	DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
	    var node = this.decodeTables[nodeIdx];
	    var hasValues = false;
	    var subNodeEmpty = {};
	    for (var i = 0; i < 0x100; i++) {
	        var uCode = node[i];
	        var mbCode = prefix + i;
	        if (skipEncodeChars[mbCode])
	            continue;

	        if (uCode >= 0) {
	            this._setEncodeChar(uCode, mbCode);
	            hasValues = true;
	        } else if (uCode <= NODE_START) {
	            var subNodeIdx = NODE_START - uCode;
	            if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).
	                var newPrefix = (mbCode << 8) >>> 0;  // NOTE: '>>> 0' keeps 32-bit num positive.
	                if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
	                    hasValues = true;
	                else
	                    subNodeEmpty[subNodeIdx] = true;
	            }
	        } else if (uCode <= SEQ_START) {
	            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
	            hasValues = true;
	        }
	    }
	    return hasValues;
	};



	// == Encoder ==================================================================

	function DBCSEncoder(options, codec) {
	    // Encoder state
	    this.leadSurrogate = -1;
	    this.seqObj = undefined;
	    
	    // Static data
	    this.encodeTable = codec.encodeTable;
	    this.encodeTableSeq = codec.encodeTableSeq;
	    this.defaultCharSingleByte = codec.defCharSB;
	    this.gb18030 = codec.gb18030;
	}

	DBCSEncoder.prototype.write = function(str) {
	    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
	        leadSurrogate = this.leadSurrogate,
	        seqObj = this.seqObj, nextChar = -1,
	        i = 0, j = 0;

	    while (true) {
	        // 0. Get next character.
	        if (nextChar === -1) {
	            if (i == str.length) break;
	            var uCode = str.charCodeAt(i++);
	        }
	        else {
	            var uCode = nextChar;
	            nextChar = -1;    
	        }

	        // 1. Handle surrogates.
	        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
	            if (uCode < 0xDC00) { // We've got lead surrogate.
	                if (leadSurrogate === -1) {
	                    leadSurrogate = uCode;
	                    continue;
	                } else {
	                    leadSurrogate = uCode;
	                    // Double lead surrogate found.
	                    uCode = UNASSIGNED;
	                }
	            } else { // We've got trail surrogate.
	                if (leadSurrogate !== -1) {
	                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
	                    leadSurrogate = -1;
	                } else {
	                    // Incomplete surrogate pair - only trail surrogate found.
	                    uCode = UNASSIGNED;
	                }
	                
	            }
	        }
	        else if (leadSurrogate !== -1) {
	            // Incomplete surrogate pair - only lead surrogate found.
	            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
	            leadSurrogate = -1;
	        }

	        // 2. Convert uCode character.
	        var dbcsCode = UNASSIGNED;
	        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
	            var resCode = seqObj[uCode];
	            if (typeof resCode === 'object') { // Sequence continues.
	                seqObj = resCode;
	                continue;

	            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
	                dbcsCode = resCode;

	            } else if (resCode == undefined) { // Current character is not part of the sequence.

	                // Try default character for this sequence
	                resCode = seqObj[DEF_CHAR];
	                if (resCode !== undefined) {
	                    dbcsCode = resCode; // Found. Write it.
	                    nextChar = uCode; // Current character will be written too in the next iteration.

	                }
	            }
	            seqObj = undefined;
	        }
	        else if (uCode >= 0) {  // Regular character
	            var subtable = this.encodeTable[uCode >> 8];
	            if (subtable !== undefined)
	                dbcsCode = subtable[uCode & 0xFF];
	            
	            if (dbcsCode <= SEQ_START) { // Sequence start
	                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
	                continue;
	            }

	            if (dbcsCode == UNASSIGNED && this.gb18030) {
	                // Use GB18030 algorithm to find character(s) to write.
	                var idx = findIdx(this.gb18030.uChars, uCode);
	                if (idx != -1) {
	                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
	                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
	                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
	                    newBuf[j++] = 0x30 + dbcsCode;
	                    continue;
	                }
	            }
	        }

	        // 3. Write dbcsCode character.
	        if (dbcsCode === UNASSIGNED)
	            dbcsCode = this.defaultCharSingleByte;
	        
	        if (dbcsCode < 0x100) {
	            newBuf[j++] = dbcsCode;
	        }
	        else if (dbcsCode < 0x10000) {
	            newBuf[j++] = dbcsCode >> 8;   // high byte
	            newBuf[j++] = dbcsCode & 0xFF; // low byte
	        }
	        else if (dbcsCode < 0x1000000) {
	            newBuf[j++] = dbcsCode >> 16;
	            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
	            newBuf[j++] = dbcsCode & 0xFF;
	        } else {
	            newBuf[j++] = dbcsCode >>> 24;
	            newBuf[j++] = (dbcsCode >>> 16) & 0xFF;
	            newBuf[j++] = (dbcsCode >>> 8) & 0xFF;
	            newBuf[j++] = dbcsCode & 0xFF;
	        }
	    }

	    this.seqObj = seqObj;
	    this.leadSurrogate = leadSurrogate;
	    return newBuf.slice(0, j);
	};

	DBCSEncoder.prototype.end = function() {
	    if (this.leadSurrogate === -1 && this.seqObj === undefined)
	        return; // All clean. Most often case.

	    var newBuf = Buffer.alloc(10), j = 0;

	    if (this.seqObj) { // We're in the sequence.
	        var dbcsCode = this.seqObj[DEF_CHAR];
	        if (dbcsCode !== undefined) { // Write beginning of the sequence.
	            if (dbcsCode < 0x100) {
	                newBuf[j++] = dbcsCode;
	            }
	            else {
	                newBuf[j++] = dbcsCode >> 8;   // high byte
	                newBuf[j++] = dbcsCode & 0xFF; // low byte
	            }
	        }
	        this.seqObj = undefined;
	    }

	    if (this.leadSurrogate !== -1) {
	        // Incomplete surrogate pair - only lead surrogate found.
	        newBuf[j++] = this.defaultCharSingleByte;
	        this.leadSurrogate = -1;
	    }
	    
	    return newBuf.slice(0, j);
	};

	// Export for testing
	DBCSEncoder.prototype.findIdx = findIdx;


	// == Decoder ==================================================================

	function DBCSDecoder(options, codec) {
	    // Decoder state
	    this.nodeIdx = 0;
	    this.prevBytes = [];

	    // Static data
	    this.decodeTables = codec.decodeTables;
	    this.decodeTableSeq = codec.decodeTableSeq;
	    this.defaultCharUnicode = codec.defaultCharUnicode;
	    this.gb18030 = codec.gb18030;
	}

	DBCSDecoder.prototype.write = function(buf) {
	    var newBuf = Buffer.alloc(buf.length*2),
	        nodeIdx = this.nodeIdx, 
	        prevBytes = this.prevBytes, prevOffset = this.prevBytes.length,
	        seqStart = -this.prevBytes.length, // idx of the start of current parsed sequence.
	        uCode;

	    for (var i = 0, j = 0; i < buf.length; i++) {
	        var curByte = (i >= 0) ? buf[i] : prevBytes[i + prevOffset];

	        // Lookup in current trie node.
	        var uCode = this.decodeTables[nodeIdx][curByte];

	        if (uCode >= 0) ;
	        else if (uCode === UNASSIGNED) { // Unknown char.
	            // TODO: Callback with seq.
	            uCode = this.defaultCharUnicode.charCodeAt(0);
	            i = seqStart; // Skip one byte ('i' will be incremented by the for loop) and try to parse again.
	        }
	        else if (uCode === GB18030_CODE) {
	            if (i >= 3) {
	                var ptr = (buf[i-3]-0x81)*12600 + (buf[i-2]-0x30)*1260 + (buf[i-1]-0x81)*10 + (curByte-0x30);
	            } else {
	                var ptr = (prevBytes[i-3+prevOffset]-0x81)*12600 + 
	                          (((i-2 >= 0) ? buf[i-2] : prevBytes[i-2+prevOffset])-0x30)*1260 + 
	                          (((i-1 >= 0) ? buf[i-1] : prevBytes[i-1+prevOffset])-0x81)*10 + 
	                          (curByte-0x30);
	            }
	            var idx = findIdx(this.gb18030.gbChars, ptr);
	            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
	        }
	        else if (uCode <= NODE_START) { // Go to next trie node.
	            nodeIdx = NODE_START - uCode;
	            continue;
	        }
	        else if (uCode <= SEQ_START) { // Output a sequence of chars.
	            var seq = this.decodeTableSeq[SEQ_START - uCode];
	            for (var k = 0; k < seq.length - 1; k++) {
	                uCode = seq[k];
	                newBuf[j++] = uCode & 0xFF;
	                newBuf[j++] = uCode >> 8;
	            }
	            uCode = seq[seq.length-1];
	        }
	        else
	            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

	        // Write the character to buffer, handling higher planes using surrogate pair.
	        if (uCode >= 0x10000) { 
	            uCode -= 0x10000;
	            var uCodeLead = 0xD800 | (uCode >> 10);
	            newBuf[j++] = uCodeLead & 0xFF;
	            newBuf[j++] = uCodeLead >> 8;

	            uCode = 0xDC00 | (uCode & 0x3FF);
	        }
	        newBuf[j++] = uCode & 0xFF;
	        newBuf[j++] = uCode >> 8;

	        // Reset trie node.
	        nodeIdx = 0; seqStart = i+1;
	    }

	    this.nodeIdx = nodeIdx;
	    this.prevBytes = (seqStart >= 0)
	        ? Array.prototype.slice.call(buf, seqStart)
	        : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));

	    return newBuf.slice(0, j).toString('ucs2');
	};

	DBCSDecoder.prototype.end = function() {
	    var ret = '';

	    // Try to parse all remaining chars.
	    while (this.prevBytes.length > 0) {
	        // Skip 1 character in the buffer.
	        ret += this.defaultCharUnicode;
	        var bytesArr = this.prevBytes.slice(1);

	        // Parse remaining as usual.
	        this.prevBytes = [];
	        this.nodeIdx = 0;
	        if (bytesArr.length > 0)
	            ret += this.write(bytesArr);
	    }

	    this.prevBytes = [];
	    this.nodeIdx = 0;
	    return ret;
	};

	// Binary search for GB18030. Returns largest i such that table[i] <= val.
	function findIdx(table, val) {
	    if (table[0] > val)
	        return -1;

	    var l = 0, r = table.length;
	    while (l < r-1) { // always table[l] <= val < table[r]
	        var mid = l + ((r-l+1) >> 1);
	        if (table[mid] <= val)
	            l = mid;
	        else
	            r = mid;
	    }
	    return l;
	}
	return dbcsCodec;
}

var require$$0 = [
	[
		"0",
		"\u0000",
		128
	],
	[
		"a1",
		"",
		62
	],
	[
		"8140",
		"",
		9,
		""
	],
	[
		"8180",
		""
	],
	[
		"81b8",
		""
	],
	[
		"81c8",
		""
	],
	[
		"81da",
		""
	],
	[
		"81f0",
		""
	],
	[
		"81fc",
		""
	],
	[
		"824f",
		"",
		9
	],
	[
		"8260",
		"",
		25
	],
	[
		"8281",
		"",
		25
	],
	[
		"829f",
		"",
		82
	],
	[
		"8340",
		"",
		62
	],
	[
		"8380",
		"",
		22
	],
	[
		"839f",
		"",
		16,
		"",
		6
	],
	[
		"83bf",
		"",
		16,
		"",
		6
	],
	[
		"8440",
		"",
		5,
		"",
		25
	],
	[
		"8470",
		"",
		5,
		"",
		7
	],
	[
		"8480",
		"",
		17
	],
	[
		"849f",
		""
	],
	[
		"8740",
		"",
		19,
		"",
		9
	],
	[
		"875f",
		""
	],
	[
		"877e",
		""
	],
	[
		"8780",
		"",
		4,
		""
	],
	[
		"889f",
		""
	],
	[
		"8940",
		""
	],
	[
		"8980",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a80",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b80",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8c80",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d80",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8e80",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8f80",
		""
	],
	[
		"9040",
		""
	],
	[
		"9080",
		""
	],
	[
		"9140",
		""
	],
	[
		"9180",
		""
	],
	[
		"9240",
		""
	],
	[
		"9280",
		""
	],
	[
		"9340",
		""
	],
	[
		"9380",
		""
	],
	[
		"9440",
		""
	],
	[
		"9480",
		""
	],
	[
		"9540",
		""
	],
	[
		"9580",
		""
	],
	[
		"9640",
		""
	],
	[
		"9680",
		""
	],
	[
		"9740",
		""
	],
	[
		"9780",
		""
	],
	[
		"9840",
		""
	],
	[
		"989f",
		""
	],
	[
		"9940",
		""
	],
	[
		"9980",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9a80",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b80",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9c80",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9d80",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9e80",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f80",
		""
	],
	[
		"e040",
		""
	],
	[
		"e080",
		""
	],
	[
		"e140",
		""
	],
	[
		"e180",
		""
	],
	[
		"e240",
		""
	],
	[
		"e280",
		""
	],
	[
		"e340",
		""
	],
	[
		"e380",
		""
	],
	[
		"e440",
		""
	],
	[
		"e480",
		""
	],
	[
		"e540",
		""
	],
	[
		"e580",
		""
	],
	[
		"e640",
		""
	],
	[
		"e680",
		""
	],
	[
		"e740",
		""
	],
	[
		"e780",
		""
	],
	[
		"e840",
		""
	],
	[
		"e880",
		""
	],
	[
		"e940",
		""
	],
	[
		"e980",
		""
	],
	[
		"ea40",
		""
	],
	[
		"ea80",
		""
	],
	[
		"ed40",
		""
	],
	[
		"ed80",
		""
	],
	[
		"ee40",
		""
	],
	[
		"ee80",
		""
	],
	[
		"eeef",
		"",
		9,
		""
	],
	[
		"f040",
		"",
		62
	],
	[
		"f080",
		"",
		124
	],
	[
		"f140",
		"",
		62
	],
	[
		"f180",
		"",
		124
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		124
	],
	[
		"f340",
		"",
		62
	],
	[
		"f380",
		"",
		124
	],
	[
		"f440",
		"",
		62
	],
	[
		"f480",
		"",
		124
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		124
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		124
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		124
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		124
	],
	[
		"f940",
		""
	],
	[
		"fa40",
		"",
		9,
		"",
		9,
		""
	],
	[
		"fa80",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fb80",
		""
	],
	[
		"fc40",
		""
	]
];

var require$$1 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8ea1",
		"",
		62
	],
	[
		"a1a1",
		"",
		9,
		""
	],
	[
		"a2a1",
		""
	],
	[
		"a2ba",
		""
	],
	[
		"a2ca",
		""
	],
	[
		"a2dc",
		""
	],
	[
		"a2f2",
		""
	],
	[
		"a2fe",
		""
	],
	[
		"a3b0",
		"",
		9
	],
	[
		"a3c1",
		"",
		25
	],
	[
		"a3e1",
		"",
		25
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a8a1",
		""
	],
	[
		"ada1",
		"",
		19,
		"",
		9
	],
	[
		"adc0",
		""
	],
	[
		"addf",
		"",
		4,
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bda1",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fcf1",
		"",
		9,
		""
	],
	[
		"8fa2af",
		""
	],
	[
		"8fa2c2",
		""
	],
	[
		"8fa2eb",
		""
	],
	[
		"8fa6e1",
		""
	],
	[
		"8fa6e7",
		""
	],
	[
		"8fa6e9",
		""
	],
	[
		"8fa6ec",
		""
	],
	[
		"8fa6f1",
		""
	],
	[
		"8fa7c2",
		"",
		10,
		""
	],
	[
		"8fa7f2",
		"",
		10,
		""
	],
	[
		"8fa9a1",
		""
	],
	[
		"8fa9a4",
		""
	],
	[
		"8fa9a6",
		""
	],
	[
		"8fa9a8",
		""
	],
	[
		"8fa9ab",
		""
	],
	[
		"8fa9af",
		""
	],
	[
		"8fa9c1",
		""
	],
	[
		"8faaa1",
		""
	],
	[
		"8faaba",
		""
	],
	[
		"8faba1",
		""
	],
	[
		"8fabbd",
		""
	],
	[
		"8fabc5",
		""
	],
	[
		"8fb0a1",
		""
	],
	[
		"8fb1a1",
		""
	],
	[
		"8fb2a1",
		"",
		4,
		""
	],
	[
		"8fb3a1",
		""
	],
	[
		"8fb4a1",
		""
	],
	[
		"8fb5a1",
		""
	],
	[
		"8fb6a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fb7a1",
		"",
		4,
		""
	],
	[
		"8fb8a1",
		""
	],
	[
		"8fb9a1",
		""
	],
	[
		"8fbaa1",
		"",
		4,
		""
	],
	[
		"8fbba1",
		""
	],
	[
		"8fbca1",
		"",
		4,
		""
	],
	[
		"8fbda1",
		"",
		4,
		""
	],
	[
		"8fbea1",
		"",
		4,
		""
	],
	[
		"8fbfa1",
		""
	],
	[
		"8fc0a1",
		""
	],
	[
		"8fc1a1",
		""
	],
	[
		"8fc2a1",
		""
	],
	[
		"8fc3a1",
		"",
		4,
		""
	],
	[
		"8fc4a1",
		""
	],
	[
		"8fc5a1",
		""
	],
	[
		"8fc6a1",
		""
	],
	[
		"8fc7a1",
		""
	],
	[
		"8fc8a1",
		""
	],
	[
		"8fc9a1",
		"",
		4,
		"",
		4,
		""
	],
	[
		"8fcaa1",
		""
	],
	[
		"8fcba1",
		""
	],
	[
		"8fcca1",
		"",
		9,
		""
	],
	[
		"8fcda1",
		"",
		5,
		""
	],
	[
		"8fcea1",
		"",
		6,
		""
	],
	[
		"8fcfa1",
		""
	],
	[
		"8fd0a1",
		""
	],
	[
		"8fd1a1",
		""
	],
	[
		"8fd2a1",
		"",
		5
	],
	[
		"8fd3a1",
		""
	],
	[
		"8fd4a1",
		"",
		4,
		""
	],
	[
		"8fd5a1",
		""
	],
	[
		"8fd6a1",
		""
	],
	[
		"8fd7a1",
		""
	],
	[
		"8fd8a1",
		""
	],
	[
		"8fd9a1",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8fdaa1",
		"",
		4,
		""
	],
	[
		"8fdba1",
		"",
		6,
		""
	],
	[
		"8fdca1",
		"",
		4,
		""
	],
	[
		"8fdda1",
		"",
		4,
		""
	],
	[
		"8fdea1",
		"",
		4,
		""
	],
	[
		"8fdfa1",
		""
	],
	[
		"8fe0a1",
		""
	],
	[
		"8fe1a1",
		"",
		4,
		""
	],
	[
		"8fe2a1",
		""
	],
	[
		"8fe3a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"8fe4a1",
		"",
		4,
		""
	],
	[
		"8fe5a1",
		"",
		4,
		""
	],
	[
		"8fe6a1",
		""
	],
	[
		"8fe7a1",
		""
	],
	[
		"8fe8a1",
		"",
		4,
		""
	],
	[
		"8fe9a1",
		"",
		4
	],
	[
		"8feaa1",
		"",
		4,
		""
	],
	[
		"8feba1",
		"",
		4,
		""
	],
	[
		"8feca1",
		""
	],
	[
		"8feda1",
		"",
		4,
		"",
		4,
		""
	]
];

var require$$2 = [
	[
		"0",
		"\u0000",
		127,
		""
	],
	[
		"8140",
		"",
		5,
		"",
		9,
		"",
		6,
		""
	],
	[
		"8180",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8240",
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		11
	],
	[
		"8280",
		"",
		10,
		"",
		4,
		"",
		7,
		"",
		5,
		"",
		8,
		"",
		20,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8340",
		"",
		17,
		"",
		5,
		"",
		10,
		"",
		4,
		"",
		9,
		""
	],
	[
		"8380",
		"",
		5,
		"",
		13,
		"",
		28,
		"",
		4,
		"",
		4,
		"",
		5
	],
	[
		"8440",
		"",
		5,
		"",
		5,
		""
	],
	[
		"8480",
		"",
		9,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		5,
		"",
		10,
		"",
		7,
		""
	],
	[
		"8540",
		"",
		9,
		""
	],
	[
		"8580",
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		""
	],
	[
		"8640",
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"8680",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8740",
		"",
		7,
		"",
		11,
		"",
		4,
		"",
		4
	],
	[
		"8780",
		"",
		7,
		"",
		6,
		"",
		14,
		"",
		10,
		"",
		6,
		"",
		12,
		"",
		8,
		"",
		5,
		"",
		6
	],
	[
		"8840",
		"",
		9,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8880",
		"",
		4,
		"",
		6,
		"",
		8,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		7
	],
	[
		"8940",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		16,
		""
	],
	[
		"8980",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		17,
		"",
		10,
		"",
		13,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"8a40",
		"",
		4,
		"",
		12,
		""
	],
	[
		"8a80",
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		9,
		"",
		5
	],
	[
		"8b40",
		"",
		8,
		"",
		17,
		"",
		6,
		"",
		13,
		""
	],
	[
		"8b80",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		22,
		"",
		11,
		"",
		25,
		"",
		7,
		"",
		6
	],
	[
		"8c40",
		"",
		7,
		""
	],
	[
		"8c80",
		"",
		8,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		4
	],
	[
		"8d40",
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		9,
		"",
		4
	],
	[
		"8d80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		10,
		"",
		12,
		"",
		21,
		""
	],
	[
		"8e40",
		"",
		21,
		"",
		12,
		"",
		6,
		"",
		12,
		""
	],
	[
		"8e80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		4,
		"",
		6
	],
	[
		"8f40",
		"",
		5,
		"",
		11,
		"",
		8,
		""
	],
	[
		"8f80",
		"",
		6,
		"",
		14,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9040",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9080",
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		18,
		"",
		6
	],
	[
		"9140",
		"",
		6,
		"",
		6,
		"",
		18,
		"",
		4,
		""
	],
	[
		"9180",
		"",
		6,
		"",
		8,
		"",
		9,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		16,
		"",
		13,
		"",
		8,
		"",
		5,
		"",
		4,
		""
	],
	[
		"9240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9280",
		"",
		5,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9340",
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9380",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		9,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9440",
		"",
		24,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		8
	],
	[
		"9480",
		"",
		4,
		"",
		4,
		"",
		14,
		"",
		7,
		"",
		7,
		""
	],
	[
		"9540",
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"9580",
		"",
		4,
		"",
		4,
		"",
		8,
		"",
		4,
		"",
		4,
		"",
		25,
		"",
		7,
		"",
		5,
		""
	],
	[
		"9640",
		"",
		5,
		"",
		4,
		""
	],
	[
		"9680",
		"",
		7,
		"",
		9,
		"",
		7,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		5
	],
	[
		"9740",
		"",
		7,
		"",
		8,
		"",
		7,
		"",
		9,
		""
	],
	[
		"9780",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		9,
		"",
		4,
		"",
		11,
		"",
		7,
		"",
		16,
		""
	],
	[
		"9840",
		"",
		4,
		"",
		5,
		"",
		9,
		""
	],
	[
		"9880",
		"",
		7,
		"",
		5,
		"",
		11,
		"",
		9,
		"",
		9,
		"",
		11,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		7,
		"",
		6,
		""
	],
	[
		"9940",
		"",
		4,
		"",
		10,
		"",
		6,
		"",
		8,
		"",
		4,
		"",
		7,
		"",
		5
	],
	[
		"9980",
		"",
		114,
		"",
		6
	],
	[
		"9a40",
		"",
		11,
		"",
		7,
		"",
		13,
		""
	],
	[
		"9a80",
		"",
		4,
		"",
		7,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"9b40",
		"",
		4,
		""
	],
	[
		"9b80",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9c40",
		"",
		7,
		""
	],
	[
		"9c80",
		"",
		7,
		"",
		7,
		"",
		10,
		"",
		14,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"9d40",
		"",
		7,
		"",
		4,
		"",
		9,
		"",
		6,
		""
	],
	[
		"9d80",
		"",
		9,
		"",
		5,
		"",
		6,
		"",
		12,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		10,
		""
	],
	[
		"9e40",
		"",
		7,
		"",
		32,
		"",
		7,
		"",
		6,
		"",
		6
	],
	[
		"9e80",
		"",
		9,
		"",
		17,
		"",
		13,
		"",
		11,
		"",
		12,
		"",
		12,
		""
	],
	[
		"9f40",
		"",
		6,
		"",
		10,
		"",
		4,
		"",
		10,
		"",
		7,
		""
	],
	[
		"9f80",
		"",
		13,
		"",
		12,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		8,
		"",
		9,
		"",
		4
	],
	[
		"a040",
		"",
		9,
		"",
		5,
		"",
		9,
		"",
		11,
		"",
		19
	],
	[
		"a080",
		"",
		9,
		"",
		6,
		"",
		4,
		"",
		11,
		"",
		11,
		"",
		6,
		""
	],
	[
		"a1a1",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9
	],
	[
		"a2b1",
		"",
		19,
		"",
		19,
		"",
		9
	],
	[
		"a2e5",
		"",
		9
	],
	[
		"a2f1",
		"",
		11
	],
	[
		"a3a1",
		"",
		88,
		""
	],
	[
		"a4a1",
		"",
		82
	],
	[
		"a5a1",
		"",
		85
	],
	[
		"a6a1",
		"",
		16,
		"",
		6
	],
	[
		"a6c1",
		"",
		16,
		"",
		6
	],
	[
		"a6e0",
		""
	],
	[
		"a6ee",
		""
	],
	[
		"a6f4",
		""
	],
	[
		"a7a1",
		"",
		5,
		"",
		25
	],
	[
		"a7d1",
		"",
		5,
		"",
		25
	],
	[
		"a840",
		"",
		35,
		"",
		6
	],
	[
		"a880",
		"",
		7,
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a8bd",
		""
	],
	[
		"a8c0",
		""
	],
	[
		"a8c5",
		"",
		36
	],
	[
		"a940",
		"",
		8,
		""
	],
	[
		"a959",
		""
	],
	[
		"a95c",
		""
	],
	[
		"a960",
		"",
		9,
		"",
		8
	],
	[
		"a980",
		"",
		4,
		""
	],
	[
		"a996",
		""
	],
	[
		"a9a4",
		"",
		75
	],
	[
		"aa40",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"aa80",
		"",
		7,
		"",
		10,
		""
	],
	[
		"ab40",
		"",
		11,
		"",
		4,
		"",
		5,
		"",
		4
	],
	[
		"ab80",
		"",
		6,
		"",
		4
	],
	[
		"ac40",
		"",
		10,
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11
	],
	[
		"ac80",
		"",
		6,
		"",
		12,
		"",
		4,
		""
	],
	[
		"ad40",
		"",
		10,
		"",
		7,
		"",
		15,
		"",
		12
	],
	[
		"ad80",
		"",
		9,
		"",
		8,
		"",
		6,
		""
	],
	[
		"ae40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"ae80",
		"",
		7,
		"",
		6,
		"",
		4,
		""
	],
	[
		"af40",
		"",
		4,
		""
	],
	[
		"af80",
		""
	],
	[
		"b040",
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		7,
		""
	],
	[
		"b080",
		"",
		7,
		"",
		8,
		"",
		9,
		""
	],
	[
		"b140",
		"",
		4,
		"",
		7,
		"",
		10,
		""
	],
	[
		"b180",
		"",
		4,
		"",
		7,
		"",
		7,
		""
	],
	[
		"b240",
		"",
		11,
		"",
		5,
		"",
		11,
		"",
		4
	],
	[
		"b280",
		"",
		12,
		"",
		8,
		"",
		4,
		""
	],
	[
		"b340",
		"",
		5,
		""
	],
	[
		"b380",
		"",
		11,
		"",
		7,
		"",
		6,
		""
	],
	[
		"b440",
		"",
		7,
		"",
		9
	],
	[
		"b480",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"b540",
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		14,
		"",
		4,
		"",
		8,
		""
	],
	[
		"b580",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b640",
		"",
		6,
		"",
		11,
		"",
		10,
		"",
		4,
		"",
		5,
		""
	],
	[
		"b680",
		"",
		6,
		"",
		4,
		""
	],
	[
		"b740",
		"",
		14,
		"",
		5,
		"",
		9,
		"",
		4,
		"",
		16
	],
	[
		"b780",
		"",
		6,
		""
	],
	[
		"b840",
		"",
		4,
		"",
		10,
		"",
		10,
		"",
		9,
		"",
		5,
		""
	],
	[
		"b880",
		"",
		4,
		""
	],
	[
		"b940",
		"",
		5,
		"",
		10,
		"",
		6,
		""
	],
	[
		"b980",
		"",
		7,
		""
	],
	[
		"ba40",
		"",
		4,
		"",
		4,
		"",
		7,
		"",
		5,
		""
	],
	[
		"ba80",
		"",
		4,
		"",
		5,
		"",
		12,
		"",
		5,
		""
	],
	[
		"bb40",
		"",
		9,
		"",
		36,
		"",
		5,
		"",
		9
	],
	[
		"bb80",
		"",
		6,
		"",
		4,
		""
	],
	[
		"bc40",
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		13,
		"",
		5
	],
	[
		"bc80",
		"",
		14,
		"",
		6,
		""
	],
	[
		"bd40",
		"",
		54,
		"",
		7
	],
	[
		"bd80",
		"",
		32,
		""
	],
	[
		"be40",
		"",
		12,
		"",
		6,
		"",
		42
	],
	[
		"be80",
		"",
		32,
		""
	],
	[
		"bf40",
		"",
		62
	],
	[
		"bf80",
		"",
		4,
		"",
		4,
		"",
		21,
		""
	],
	[
		"c040",
		"",
		35,
		"",
		23,
		""
	],
	[
		"c080",
		"",
		6,
		"",
		9,
		""
	],
	[
		"c140",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c180",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c240",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c280",
		"",
		13,
		"",
		5,
		"",
		11,
		""
	],
	[
		"c340",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"c380",
		"",
		12,
		"",
		4,
		""
	],
	[
		"c440",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"c480",
		"",
		7,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c540",
		"",
		14,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"c580",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c640",
		""
	],
	[
		"c680",
		"",
		4,
		"",
		9,
		""
	],
	[
		"c740",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"c780",
		""
	],
	[
		"c840",
		"",
		4,
		"",
		5,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c880",
		"",
		6,
		"",
		4,
		"",
		4,
		""
	],
	[
		"c940",
		"",
		4,
		"",
		7,
		"",
		12,
		""
	],
	[
		"c980",
		"",
		4,
		"",
		4,
		"",
		10,
		""
	],
	[
		"ca40",
		"",
		8,
		"",
		8,
		"",
		9,
		"",
		4,
		"",
		10
	],
	[
		"ca80",
		"",
		4,
		"",
		8,
		""
	],
	[
		"cb40",
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cb80",
		"",
		5,
		"",
		6,
		"",
		14,
		""
	],
	[
		"cc40",
		"",
		4,
		"",
		10,
		"",
		15,
		"",
		13,
		""
	],
	[
		"cc80",
		"",
		11,
		"",
		4,
		"",
		7,
		""
	],
	[
		"cd40",
		"",
		6,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		4,
		""
	],
	[
		"cd80",
		""
	],
	[
		"ce40",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"ce80",
		"",
		4,
		"",
		6,
		"",
		4,
		""
	],
	[
		"cf40",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		9
	],
	[
		"cf80",
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"d040",
		"",
		13,
		"",
		5,
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"d080",
		"",
		4,
		"",
		4,
		"",
		5,
		""
	],
	[
		"d140",
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5
	],
	[
		"d180",
		"",
		4,
		"",
		4,
		"",
		4,
		""
	],
	[
		"d240",
		"",
		8,
		"",
		24,
		"",
		5,
		"",
		19,
		""
	],
	[
		"d280",
		"",
		26,
		""
	],
	[
		"d340",
		"",
		30,
		"",
		6
	],
	[
		"d380",
		"",
		4,
		"",
		5,
		"",
		21,
		""
	],
	[
		"d440",
		"",
		31,
		"",
		8,
		"",
		21
	],
	[
		"d480",
		"",
		25,
		"",
		6,
		""
	],
	[
		"d540",
		"",
		7,
		"",
		7,
		"",
		46
	],
	[
		"d580",
		"",
		32,
		""
	],
	[
		"d640",
		"",
		34,
		"",
		27
	],
	[
		"d680",
		"",
		30,
		""
	],
	[
		"d740",
		"",
		31,
		"",
		4,
		"",
		25
	],
	[
		"d780",
		"",
		24,
		""
	],
	[
		"d840",
		"",
		8,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		""
	],
	[
		"d880",
		"",
		6,
		"",
		20,
		""
	],
	[
		"d940",
		"",
		62
	],
	[
		"d980",
		"",
		32,
		""
	],
	[
		"da40",
		"",
		14,
		"",
		8,
		"",
		4,
		"",
		9,
		""
	],
	[
		"da80",
		"",
		12,
		""
	],
	[
		"db40",
		"",
		6,
		"",
		7,
		"",
		4,
		""
	],
	[
		"db80",
		"",
		4,
		"",
		5,
		"",
		11,
		""
	],
	[
		"dc40",
		"",
		4,
		"",
		6,
		"",
		6,
		"",
		11,
		"",
		6,
		"",
		7
	],
	[
		"dc80",
		"",
		10,
		"",
		21,
		""
	],
	[
		"dd40",
		"",
		62
	],
	[
		"dd80",
		"",
		32,
		""
	],
	[
		"de40",
		"",
		32,
		""
	],
	[
		"de80",
		"",
		4,
		""
	],
	[
		"df40",
		"",
		5,
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"df80",
		"",
		4,
		""
	],
	[
		"e040",
		"",
		19,
		""
	],
	[
		"e080",
		"",
		10,
		"",
		6,
		"",
		8,
		""
	],
	[
		"e140",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		""
	],
	[
		"e180",
		"",
		10,
		"",
		9,
		"",
		8,
		""
	],
	[
		"e240",
		"",
		62
	],
	[
		"e280",
		"",
		32,
		"",
		5,
		""
	],
	[
		"e340",
		"",
		45,
		"",
		16
	],
	[
		"e380",
		"",
		7,
		"",
		24,
		""
	],
	[
		"e440",
		"",
		5,
		"",
		24,
		"",
		31
	],
	[
		"e480",
		"",
		32,
		""
	],
	[
		"e540",
		"",
		51,
		"",
		10
	],
	[
		"e580",
		"",
		31,
		""
	],
	[
		"e640",
		"",
		34,
		"",
		27
	],
	[
		"e680",
		"",
		29,
		""
	],
	[
		"e740",
		"",
		7,
		"",
		54
	],
	[
		"e780",
		"",
		32,
		"",
		6,
		"",
		4,
		""
	],
	[
		"e840",
		"",
		14,
		"",
		43,
		""
	],
	[
		"e880",
		"",
		20,
		""
	],
	[
		"e940",
		"",
		7,
		"",
		42
	],
	[
		"e980",
		"",
		32,
		""
	],
	[
		"ea40",
		"",
		27,
		"",
		6,
		""
	],
	[
		"ea80",
		"",
		4,
		"",
		12,
		""
	],
	[
		"eb40",
		"",
		9,
		"",
		7,
		"",
		9,
		"",
		6,
		""
	],
	[
		"eb80",
		"",
		4,
		""
	],
	[
		"ec40",
		"",
		8,
		"",
		4,
		"",
		18,
		"",
		7
	],
	[
		"ec80",
		"",
		4,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ed40",
		"",
		6,
		"",
		46
	],
	[
		"ed80",
		"",
		4,
		"",
		23,
		""
	],
	[
		"ee40",
		"",
		62
	],
	[
		"ee80",
		"",
		32,
		"",
		4,
		"",
		6,
		""
	],
	[
		"ef40",
		"",
		5,
		"",
		37,
		"",
		4
	],
	[
		"ef80",
		"",
		30,
		"",
		4,
		"",
		8,
		""
	],
	[
		"f040",
		"",
		4,
		"",
		28,
		"",
		26
	],
	[
		"f080",
		"",
		9,
		"",
		12,
		"",
		4,
		"",
		6,
		""
	],
	[
		"f140",
		"",
		10,
		"",
		47
	],
	[
		"f180",
		"",
		32,
		""
	],
	[
		"f240",
		"",
		62
	],
	[
		"f280",
		"",
		32,
		""
	],
	[
		"f340",
		"",
		17,
		"",
		6,
		"",
		4,
		""
	],
	[
		"f380",
		"",
		8,
		"",
		6,
		""
	],
	[
		"f440",
		"",
		5,
		"",
		10,
		"",
		10,
		"",
		7,
		"",
		5
	],
	[
		"f480",
		"",
		32,
		""
	],
	[
		"f540",
		"",
		62
	],
	[
		"f580",
		"",
		32,
		""
	],
	[
		"f640",
		"",
		62
	],
	[
		"f680",
		"",
		32,
		"",
		5,
		"",
		5,
		"",
		4,
		"",
		7,
		""
	],
	[
		"f740",
		"",
		62
	],
	[
		"f780",
		"",
		4,
		"",
		4,
		""
	],
	[
		"f840",
		"",
		62
	],
	[
		"f880",
		"",
		32
	],
	[
		"f940",
		"",
		62
	],
	[
		"f980",
		"",
		32
	],
	[
		"fa40",
		"",
		62
	],
	[
		"fa80",
		"",
		32
	],
	[
		"fb40",
		"",
		27,
		"",
		9,
		""
	],
	[
		"fb80",
		"",
		5,
		"",
		8,
		"",
		5,
		""
	],
	[
		"fc40",
		"",
		8,
		"",
		4,
		"",
		8,
		"",
		6
	],
	[
		"fc80",
		"",
		4,
		"",
		5,
		"",
		8,
		""
	],
	[
		"fd40",
		"",
		4,
		"",
		4,
		"",
		10,
		"",
		38
	],
	[
		"fd80",
		"",
		5,
		"",
		11,
		"",
		4,
		""
	],
	[
		"fe40",
		""
	]
];

var require$$3 = [
	[
		"a140",
		"",
		62
	],
	[
		"a180",
		"",
		32
	],
	[
		"a240",
		"",
		62
	],
	[
		"a280",
		"",
		32
	],
	[
		"a2ab",
		"",
		5
	],
	[
		"a2e3",
		""
	],
	[
		"a2ef",
		""
	],
	[
		"a2fd",
		""
	],
	[
		"a340",
		"",
		62
	],
	[
		"a380",
		"",
		31,
		""
	],
	[
		"a440",
		"",
		62
	],
	[
		"a480",
		"",
		32
	],
	[
		"a4f4",
		"",
		10
	],
	[
		"a540",
		"",
		62
	],
	[
		"a580",
		"",
		32
	],
	[
		"a5f7",
		"",
		7
	],
	[
		"a640",
		"",
		62
	],
	[
		"a680",
		"",
		32
	],
	[
		"a6b9",
		"",
		7
	],
	[
		"a6d9",
		"",
		6
	],
	[
		"a6ec",
		""
	],
	[
		"a6f3",
		""
	],
	[
		"a6f6",
		"",
		8
	],
	[
		"a740",
		"",
		62
	],
	[
		"a780",
		"",
		32
	],
	[
		"a7c2",
		"",
		14
	],
	[
		"a7f2",
		"",
		12
	],
	[
		"a896",
		"",
		10
	],
	[
		"a8bc",
		""
	],
	[
		"a8bf",
		""
	],
	[
		"a8c1",
		""
	],
	[
		"a8ea",
		"",
		20
	],
	[
		"a958",
		""
	],
	[
		"a95b",
		""
	],
	[
		"a95d",
		""
	],
	[
		"a989",
		"",
		11
	],
	[
		"a997",
		"",
		12
	],
	[
		"a9f0",
		"",
		14
	],
	[
		"aaa1",
		"",
		93
	],
	[
		"aba1",
		"",
		93
	],
	[
		"aca1",
		"",
		93
	],
	[
		"ada1",
		"",
		93
	],
	[
		"aea1",
		"",
		93
	],
	[
		"afa1",
		"",
		93
	],
	[
		"d7fa",
		"",
		4
	],
	[
		"f8a1",
		"",
		93
	],
	[
		"f9a1",
		"",
		93
	],
	[
		"faa1",
		"",
		93
	],
	[
		"fba1",
		"",
		93
	],
	[
		"fca1",
		"",
		93
	],
	[
		"fda1",
		"",
		93
	],
	[
		"fe50",
		""
	],
	[
		"fe80",
		"",
		6,
		"",
		93
	],
	[
		"8135f437",
		""
	]
];

var uChars = [
	128,
	165,
	169,
	178,
	184,
	216,
	226,
	235,
	238,
	244,
	248,
	251,
	253,
	258,
	276,
	284,
	300,
	325,
	329,
	334,
	364,
	463,
	465,
	467,
	469,
	471,
	473,
	475,
	477,
	506,
	594,
	610,
	712,
	716,
	730,
	930,
	938,
	962,
	970,
	1026,
	1104,
	1106,
	8209,
	8215,
	8218,
	8222,
	8231,
	8241,
	8244,
	8246,
	8252,
	8365,
	8452,
	8454,
	8458,
	8471,
	8482,
	8556,
	8570,
	8596,
	8602,
	8713,
	8720,
	8722,
	8726,
	8731,
	8737,
	8740,
	8742,
	8748,
	8751,
	8760,
	8766,
	8777,
	8781,
	8787,
	8802,
	8808,
	8816,
	8854,
	8858,
	8870,
	8896,
	8979,
	9322,
	9372,
	9548,
	9588,
	9616,
	9622,
	9634,
	9652,
	9662,
	9672,
	9676,
	9680,
	9702,
	9735,
	9738,
	9793,
	9795,
	11906,
	11909,
	11913,
	11917,
	11928,
	11944,
	11947,
	11951,
	11956,
	11960,
	11964,
	11979,
	12284,
	12292,
	12312,
	12319,
	12330,
	12351,
	12436,
	12447,
	12535,
	12543,
	12586,
	12842,
	12850,
	12964,
	13200,
	13215,
	13218,
	13253,
	13263,
	13267,
	13270,
	13384,
	13428,
	13727,
	13839,
	13851,
	14617,
	14703,
	14801,
	14816,
	14964,
	15183,
	15471,
	15585,
	16471,
	16736,
	17208,
	17325,
	17330,
	17374,
	17623,
	17997,
	18018,
	18212,
	18218,
	18301,
	18318,
	18760,
	18811,
	18814,
	18820,
	18823,
	18844,
	18848,
	18872,
	19576,
	19620,
	19738,
	19887,
	40870,
	59244,
	59336,
	59367,
	59413,
	59417,
	59423,
	59431,
	59437,
	59443,
	59452,
	59460,
	59478,
	59493,
	63789,
	63866,
	63894,
	63976,
	63986,
	64016,
	64018,
	64021,
	64025,
	64034,
	64037,
	64042,
	65074,
	65093,
	65107,
	65112,
	65127,
	65132,
	65375,
	65510,
	65536
];
var gbChars = [
	0,
	36,
	38,
	45,
	50,
	81,
	89,
	95,
	96,
	100,
	103,
	104,
	105,
	109,
	126,
	133,
	148,
	172,
	175,
	179,
	208,
	306,
	307,
	308,
	309,
	310,
	311,
	312,
	313,
	341,
	428,
	443,
	544,
	545,
	558,
	741,
	742,
	749,
	750,
	805,
	819,
	820,
	7922,
	7924,
	7925,
	7927,
	7934,
	7943,
	7944,
	7945,
	7950,
	8062,
	8148,
	8149,
	8152,
	8164,
	8174,
	8236,
	8240,
	8262,
	8264,
	8374,
	8380,
	8381,
	8384,
	8388,
	8390,
	8392,
	8393,
	8394,
	8396,
	8401,
	8406,
	8416,
	8419,
	8424,
	8437,
	8439,
	8445,
	8482,
	8485,
	8496,
	8521,
	8603,
	8936,
	8946,
	9046,
	9050,
	9063,
	9066,
	9076,
	9092,
	9100,
	9108,
	9111,
	9113,
	9131,
	9162,
	9164,
	9218,
	9219,
	11329,
	11331,
	11334,
	11336,
	11346,
	11361,
	11363,
	11366,
	11370,
	11372,
	11375,
	11389,
	11682,
	11686,
	11687,
	11692,
	11694,
	11714,
	11716,
	11723,
	11725,
	11730,
	11736,
	11982,
	11989,
	12102,
	12336,
	12348,
	12350,
	12384,
	12393,
	12395,
	12397,
	12510,
	12553,
	12851,
	12962,
	12973,
	13738,
	13823,
	13919,
	13933,
	14080,
	14298,
	14585,
	14698,
	15583,
	15847,
	16318,
	16434,
	16438,
	16481,
	16729,
	17102,
	17122,
	17315,
	17320,
	17402,
	17418,
	17859,
	17909,
	17911,
	17915,
	17916,
	17936,
	17939,
	17961,
	18664,
	18703,
	18814,
	18962,
	19043,
	33469,
	33470,
	33471,
	33484,
	33485,
	33490,
	33497,
	33501,
	33505,
	33513,
	33520,
	33536,
	33550,
	37845,
	37921,
	37948,
	38029,
	38038,
	38064,
	38065,
	38066,
	38069,
	38075,
	38076,
	38078,
	39108,
	39109,
	39113,
	39114,
	39115,
	39116,
	39265,
	39394,
	189000
];
var require$$4 = {
	uChars: uChars,
	gbChars: gbChars
};

var require$$5 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"8141",
		"",
		4,
		"",
		6,
		""
	],
	[
		"8161",
		"",
		9,
		"",
		5,
		""
	],
	[
		"8181",
		"",
		18,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"8241",
		"",
		7,
		"",
		5
	],
	[
		"8261",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8281",
		"",
		7,
		"",
		7,
		"",
		4,
		"",
		10,
		"",
		5,
		"",
		17,
		"",
		7,
		"",
		6,
		"",
		7,
		"",
		18
	],
	[
		"8341",
		"",
		5,
		"",
		5,
		"",
		7
	],
	[
		"8361",
		"",
		18,
		""
	],
	[
		"8381",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		46,
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8441",
		"",
		5,
		"",
		8
	],
	[
		"8461",
		"",
		18
	],
	[
		"8481",
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		18,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8541",
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4
	],
	[
		"8561",
		"",
		5,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8581",
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		29,
		"",
		6,
		"",
		5,
		""
	],
	[
		"8641",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8661",
		"",
		6,
		"",
		10
	],
	[
		"8681",
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		22,
		"",
		4,
		""
	],
	[
		"8741",
		"",
		9,
		"",
		15
	],
	[
		"8761",
		"",
		18,
		""
	],
	[
		"8781",
		"",
		5,
		"",
		7,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		4
	],
	[
		"8841",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"8861",
		"",
		4,
		""
	],
	[
		"8881",
		"",
		15,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		54,
		""
	],
	[
		"8941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"8961",
		"",
		10,
		"",
		5,
		""
	],
	[
		"8981",
		"",
		21,
		"",
		18,
		"",
		18,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		15
	],
	[
		"8a41",
		"",
		10,
		"",
		6,
		""
	],
	[
		"8a61",
		"",
		4,
		"",
		18,
		""
	],
	[
		"8a81",
		"",
		4,
		"",
		19,
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		5,
		"",
		26,
		""
	],
	[
		"8b41",
		"",
		5,
		"",
		4,
		"",
		6,
		""
	],
	[
		"8b61",
		"",
		6,
		"",
		8
	],
	[
		"8b81",
		"",
		52,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		18
	],
	[
		"8c41",
		"",
		15,
		"",
		4
	],
	[
		"8c61",
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"8c81",
		"",
		12,
		"",
		26,
		"",
		50,
		"",
		5,
		"",
		16
	],
	[
		"8d41",
		"",
		16,
		"",
		8
	],
	[
		"8d61",
		"",
		17,
		""
	],
	[
		"8d81",
		"",
		4,
		"",
		33,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		9,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"8e41",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"8e61",
		"",
		4,
		"",
		19
	],
	[
		"8e81",
		"",
		13,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		11,
		"",
		7,
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"8f41",
		"",
		7,
		"",
		17
	],
	[
		"8f61",
		"",
		7,
		"",
		6,
		"",
		4
	],
	[
		"8f81",
		"",
		5,
		"",
		7,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		26,
		"",
		6,
		"",
		5
	],
	[
		"9041",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9061",
		"",
		5,
		"",
		15
	],
	[
		"9081",
		"",
		12,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		4,
		"",
		5,
		"",
		11,
		"",
		33,
		""
	],
	[
		"9141",
		"",
		6,
		"",
		5
	],
	[
		"9161",
		"",
		9,
		"",
		5
	],
	[
		"9181",
		"",
		20,
		"",
		4,
		"",
		5,
		"",
		14,
		"",
		33,
		"",
		7,
		"",
		5,
		"",
		6
	],
	[
		"9241",
		"",
		7,
		"",
		4,
		""
	],
	[
		"9261",
		"",
		7,
		"",
		7,
		"",
		4
	],
	[
		"9281",
		"",
		21,
		"",
		18,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		35,
		""
	],
	[
		"9341",
		"",
		4,
		""
	],
	[
		"9361",
		"",
		6,
		"",
		8
	],
	[
		"9381",
		"",
		37,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		22,
		""
	],
	[
		"9441",
		"",
		5,
		"",
		5,
		"",
		8
	],
	[
		"9461",
		"",
		5,
		"",
		6,
		"",
		12
	],
	[
		"9481",
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		22,
		"",
		4,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		24
	],
	[
		"9541",
		"",
		11,
		"",
		5,
		""
	],
	[
		"9561",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9581",
		"",
		6,
		"",
		35,
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		13,
		"",
		14
	],
	[
		"9641",
		"",
		23,
		""
	],
	[
		"9661",
		"",
		6,
		"",
		5,
		"",
		8
	],
	[
		"9681",
		"",
		10,
		"",
		5,
		"",
		13,
		"",
		33,
		"",
		6,
		"",
		44
	],
	[
		"9741",
		"",
		16,
		"",
		8
	],
	[
		"9761",
		"",
		17,
		"",
		7
	],
	[
		"9781",
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		89,
		""
	],
	[
		"9841",
		"",
		16,
		"",
		5,
		""
	],
	[
		"9861",
		"",
		6,
		"",
		15
	],
	[
		"9881",
		"",
		21,
		"",
		6,
		"",
		5,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9961",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9981",
		"",
		8,
		"",
		5,
		"",
		4,
		"",
		11,
		"",
		5,
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9a41",
		"",
		16
	],
	[
		"9a61",
		"",
		6,
		"",
		6,
		""
	],
	[
		"9a81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		33,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9b41",
		"",
		6,
		"",
		8
	],
	[
		"9b61",
		"",
		17,
		"",
		7
	],
	[
		"9b81",
		"",
		25,
		"",
		4,
		"",
		5,
		"",
		50,
		"",
		22,
		""
	],
	[
		"9c41",
		"",
		4,
		"",
		5,
		"",
		5
	],
	[
		"9c61",
		"",
		8,
		"",
		6,
		"",
		9
	],
	[
		"9c81",
		"",
		8,
		"",
		6,
		"",
		6,
		"",
		9,
		"",
		26,
		"",
		6,
		"",
		5,
		"",
		18,
		"",
		6,
		"",
		12
	],
	[
		"9d41",
		"",
		13,
		"",
		8
	],
	[
		"9d61",
		"",
		25
	],
	[
		"9d81",
		"",
		8,
		"",
		5,
		"",
		9,
		"",
		6,
		"",
		10,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"9e41",
		"",
		7,
		"",
		9,
		""
	],
	[
		"9e61",
		"",
		4,
		"",
		6,
		""
	],
	[
		"9e81",
		"",
		6,
		"",
		6,
		"",
		6,
		"",
		5,
		"",
		10,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		""
	],
	[
		"9f41",
		"",
		5,
		"",
		4,
		"",
		5,
		""
	],
	[
		"9f61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"9f81",
		"",
		4,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		4,
		"",
		6,
		"",
		7,
		"",
		4,
		"",
		4,
		""
	],
	[
		"a041",
		"",
		5,
		"",
		6,
		""
	],
	[
		"a061",
		"",
		5,
		"",
		13
	],
	[
		"a081",
		"",
		4,
		"",
		4,
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		6,
		"",
		5,
		"",
		26,
		"",
		4,
		"",
		5,
		"",
		7,
		""
	],
	[
		"a141",
		"",
		18,
		""
	],
	[
		"a161",
		"",
		6,
		"",
		5,
		""
	],
	[
		"a181",
		"",
		14,
		"",
		5,
		"",
		4,
		"",
		9,
		""
	],
	[
		"a241",
		"",
		5,
		"",
		18
	],
	[
		"a261",
		"",
		6,
		"",
		18
	],
	[
		"a281",
		"",
		7,
		"",
		6,
		"",
		7,
		""
	],
	[
		"a341",
		"",
		6,
		"",
		10,
		""
	],
	[
		"a361",
		"",
		6,
		"",
		16
	],
	[
		"a381",
		"",
		16,
		"",
		4,
		"",
		58,
		"",
		32,
		""
	],
	[
		"a441",
		"",
		5,
		""
	],
	[
		"a461",
		"",
		5,
		"",
		12
	],
	[
		"a481",
		"",
		28,
		"",
		93
	],
	[
		"a541",
		"",
		4,
		"",
		6,
		"",
		5,
		""
	],
	[
		"a561",
		"",
		17,
		"",
		5,
		""
	],
	[
		"a581",
		"",
		16,
		"",
		14,
		"",
		9
	],
	[
		"a5b0",
		"",
		9
	],
	[
		"a5c1",
		"",
		16,
		"",
		6
	],
	[
		"a5e1",
		"",
		16,
		"",
		6
	],
	[
		"a641",
		"",
		19,
		""
	],
	[
		"a661",
		"",
		5,
		"",
		5,
		"",
		6
	],
	[
		"a681",
		"",
		6,
		"",
		18,
		"",
		7
	],
	[
		"a741",
		"",
		4,
		"",
		6,
		"",
		7
	],
	[
		"a761",
		"",
		22,
		""
	],
	[
		"a781",
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		9,
		"",
		9,
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"a841",
		"",
		10,
		"",
		14
	],
	[
		"a861",
		"",
		18,
		"",
		6
	],
	[
		"a881",
		"",
		19,
		"",
		11,
		""
	],
	[
		"a8a6",
		""
	],
	[
		"a8a8",
		""
	],
	[
		"a8b1",
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"a941",
		"",
		14,
		"",
		10
	],
	[
		"a961",
		"",
		18
	],
	[
		"a981",
		"",
		14,
		"",
		6,
		"",
		27,
		"",
		25,
		"",
		14,
		""
	],
	[
		"aa41",
		"",
		6,
		"",
		4,
		""
	],
	[
		"aa61",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"aa81",
		"",
		29,
		"",
		82
	],
	[
		"ab41",
		"",
		6,
		"",
		5,
		""
	],
	[
		"ab61",
		"",
		6,
		"",
		5,
		"",
		5
	],
	[
		"ab81",
		"",
		8,
		"",
		6,
		"",
		12,
		"",
		85
	],
	[
		"ac41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ac61",
		"",
		11,
		"",
		4
	],
	[
		"ac81",
		"",
		28,
		"",
		5,
		"",
		25
	],
	[
		"acd1",
		"",
		5,
		"",
		25
	],
	[
		"ad41",
		"",
		6,
		"",
		5,
		"",
		7
	],
	[
		"ad61",
		"",
		6,
		"",
		10,
		""
	],
	[
		"ad81",
		"",
		5,
		"",
		18,
		""
	],
	[
		"ae41",
		"",
		5,
		"",
		16
	],
	[
		"ae61",
		"",
		5,
		"",
		6,
		"",
		4
	],
	[
		"ae81",
		"",
		6,
		"",
		5,
		""
	],
	[
		"af41",
		"",
		19
	],
	[
		"af61",
		"",
		13,
		"",
		5,
		""
	],
	[
		"af81",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b041",
		"",
		5,
		"",
		5,
		"",
		12
	],
	[
		"b061",
		"",
		5,
		"",
		19
	],
	[
		"b081",
		"",
		13,
		"",
		6,
		"",
		5,
		"",
		7,
		"",
		4,
		""
	],
	[
		"b141",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b161",
		"",
		6,
		"",
		5,
		"",
		11
	],
	[
		"b181",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b241",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b261",
		"",
		18,
		"",
		5,
		""
	],
	[
		"b281",
		"",
		5,
		"",
		18,
		"",
		6,
		""
	],
	[
		"b341",
		"",
		19,
		""
	],
	[
		"b361",
		"",
		5,
		"",
		5,
		"",
		5
	],
	[
		"b381",
		"",
		5,
		"",
		5,
		"",
		19,
		"",
		4,
		""
	],
	[
		"b441",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"b461",
		"",
		6,
		"",
		10,
		""
	],
	[
		"b481",
		"",
		6,
		"",
		18,
		"",
		4,
		"",
		4,
		""
	],
	[
		"b541",
		"",
		14,
		"",
		5
	],
	[
		"b561",
		"",
		5,
		"",
		5,
		"",
		4
	],
	[
		"b581",
		"",
		6,
		"",
		5,
		"",
		11,
		""
	],
	[
		"b641",
		"",
		7,
		"",
		17
	],
	[
		"b661",
		"",
		15,
		""
	],
	[
		"b681",
		"",
		5,
		"",
		6,
		"",
		5,
		""
	],
	[
		"b741",
		"",
		13,
		"",
		6,
		""
	],
	[
		"b761",
		"",
		20,
		""
	],
	[
		"b781",
		"",
		6,
		"",
		14,
		""
	],
	[
		"b841",
		"",
		7,
		"",
		17
	],
	[
		"b861",
		"",
		8,
		"",
		13
	],
	[
		"b881",
		"",
		5,
		"",
		24,
		"",
		4,
		""
	],
	[
		"b941",
		"",
		6,
		"",
		5,
		""
	],
	[
		"b961",
		"",
		14,
		"",
		6,
		""
	],
	[
		"b981",
		"",
		22,
		"",
		4,
		"",
		4,
		""
	],
	[
		"ba41",
		"",
		5,
		"",
		6,
		""
	],
	[
		"ba61",
		"",
		5,
		"",
		4,
		"",
		5
	],
	[
		"ba81",
		"",
		6,
		"",
		9,
		""
	],
	[
		"bb41",
		"",
		4,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bb61",
		"",
		6,
		"",
		5,
		""
	],
	[
		"bb81",
		"",
		31,
		""
	],
	[
		"bc41",
		"",
		17,
		""
	],
	[
		"bc61",
		"",
		5,
		"",
		6,
		""
	],
	[
		"bc81",
		"",
		4,
		"",
		6,
		"",
		5,
		"",
		5,
		"",
		4,
		""
	],
	[
		"bd41",
		"",
		7,
		"",
		7,
		""
	],
	[
		"bd61",
		"",
		5,
		"",
		13
	],
	[
		"bd81",
		"",
		5,
		"",
		25,
		""
	],
	[
		"be41",
		"",
		7,
		"",
		14
	],
	[
		"be61",
		"",
		7,
		"",
		7,
		""
	],
	[
		"be81",
		"",
		4,
		"",
		4,
		"",
		5,
		"",
		8,
		"",
		6,
		""
	],
	[
		"bf41",
		"",
		10,
		"",
		14
	],
	[
		"bf61",
		"",
		18,
		""
	],
	[
		"bf81",
		"",
		5,
		"",
		7,
		"",
		6,
		"",
		5,
		""
	],
	[
		"c041",
		"",
		5,
		"",
		6,
		"",
		5
	],
	[
		"c061",
		"",
		25
	],
	[
		"c081",
		"",
		6,
		"",
		5,
		"",
		7,
		""
	],
	[
		"c141",
		"",
		5,
		"",
		6,
		""
	],
	[
		"c161",
		"",
		19,
		""
	],
	[
		"c181",
		"",
		31,
		""
	],
	[
		"c241",
		"",
		4,
		"",
		5,
		""
	],
	[
		"c261",
		"",
		4,
		"",
		5,
		"",
		6,
		""
	],
	[
		"c281",
		"",
		5,
		"",
		7,
		"",
		9,
		""
	],
	[
		"c341",
		"",
		4
	],
	[
		"c361",
		"",
		4,
		"",
		5,
		"",
		11
	],
	[
		"c381",
		"",
		5,
		"",
		7,
		"",
		5,
		""
	],
	[
		"c441",
		"",
		7,
		"",
		7,
		""
	],
	[
		"c461",
		"",
		5,
		"",
		4
	],
	[
		"c481",
		"",
		5,
		"",
		11,
		""
	],
	[
		"c541",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c561",
		"",
		6,
		"",
		5,
		"",
		4
	],
	[
		"c581",
		"",
		6,
		"",
		5,
		""
	],
	[
		"c641",
		"",
		6,
		"",
		5
	],
	[
		"c6a1",
		""
	],
	[
		"c7a1",
		""
	],
	[
		"c8a1",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cda1",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d1a1",
		"",
		5,
		"",
		4,
		""
	],
	[
		"d2a1",
		"",
		4,
		"",
		5,
		"",
		10,
		"",
		7,
		"",
		5,
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"daa1",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dda1",
		""
	],
	[
		"dea1",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eba1",
		""
	],
	[
		"eca1",
		""
	],
	[
		"eda1",
		""
	],
	[
		"eea1",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f9a1",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fda1",
		""
	]
];

var require$$6 = [
	[
		"0",
		"\u0000",
		127
	],
	[
		"a140",
		""
	],
	[
		"a1a1",
		"",
		4,
		""
	],
	[
		"a240",
		"",
		7,
		""
	],
	[
		"a2a1",
		"",
		9,
		"",
		9,
		"",
		8,
		"",
		25,
		"",
		21
	],
	[
		"a340",
		"",
		16,
		"",
		6,
		"",
		16,
		"",
		6,
		"",
		10
	],
	[
		"a3a1",
		"",
		25,
		""
	],
	[
		"a3e1",
		""
	],
	[
		"a440",
		""
	],
	[
		"a4a1",
		""
	],
	[
		"a540",
		""
	],
	[
		"a5a1",
		""
	],
	[
		"a640",
		""
	],
	[
		"a6a1",
		""
	],
	[
		"a740",
		""
	],
	[
		"a7a1",
		""
	],
	[
		"a840",
		""
	],
	[
		"a8a1",
		""
	],
	[
		"a940",
		""
	],
	[
		"a9a1",
		""
	],
	[
		"aa40",
		""
	],
	[
		"aaa1",
		""
	],
	[
		"ab40",
		""
	],
	[
		"aba1",
		""
	],
	[
		"ac40",
		""
	],
	[
		"aca1",
		""
	],
	[
		"ad40",
		""
	],
	[
		"ada1",
		""
	],
	[
		"ae40",
		""
	],
	[
		"aea1",
		""
	],
	[
		"af40",
		""
	],
	[
		"afa1",
		""
	],
	[
		"b040",
		""
	],
	[
		"b0a1",
		""
	],
	[
		"b140",
		""
	],
	[
		"b1a1",
		""
	],
	[
		"b240",
		""
	],
	[
		"b2a1",
		""
	],
	[
		"b340",
		""
	],
	[
		"b3a1",
		""
	],
	[
		"b440",
		""
	],
	[
		"b4a1",
		""
	],
	[
		"b540",
		""
	],
	[
		"b5a1",
		""
	],
	[
		"b640",
		""
	],
	[
		"b6a1",
		""
	],
	[
		"b740",
		""
	],
	[
		"b7a1",
		""
	],
	[
		"b840",
		""
	],
	[
		"b8a1",
		""
	],
	[
		"b940",
		""
	],
	[
		"b9a1",
		""
	],
	[
		"ba40",
		""
	],
	[
		"baa1",
		""
	],
	[
		"bb40",
		""
	],
	[
		"bba1",
		""
	],
	[
		"bc40",
		""
	],
	[
		"bca1",
		""
	],
	[
		"bd40",
		""
	],
	[
		"bda1",
		""
	],
	[
		"be40",
		""
	],
	[
		"bea1",
		""
	],
	[
		"bf40",
		""
	],
	[
		"bfa1",
		""
	],
	[
		"c040",
		""
	],
	[
		"c0a1",
		""
	],
	[
		"c140",
		""
	],
	[
		"c1a1",
		""
	],
	[
		"c240",
		""
	],
	[
		"c2a1",
		""
	],
	[
		"c340",
		""
	],
	[
		"c3a1",
		""
	],
	[
		"c440",
		""
	],
	[
		"c4a1",
		""
	],
	[
		"c540",
		""
	],
	[
		"c5a1",
		""
	],
	[
		"c640",
		""
	],
	[
		"c940",
		""
	],
	[
		"c9a1",
		""
	],
	[
		"ca40",
		""
	],
	[
		"caa1",
		""
	],
	[
		"cb40",
		""
	],
	[
		"cba1",
		""
	],
	[
		"cc40",
		""
	],
	[
		"cca1",
		""
	],
	[
		"cd40",
		""
	],
	[
		"cda1",
		""
	],
	[
		"ce40",
		""
	],
	[
		"cea1",
		""
	],
	[
		"cf40",
		""
	],
	[
		"cfa1",
		""
	],
	[
		"d040",
		""
	],
	[
		"d0a1",
		""
	],
	[
		"d140",
		""
	],
	[
		"d1a1",
		""
	],
	[
		"d240",
		""
	],
	[
		"d2a1",
		""
	],
	[
		"d340",
		""
	],
	[
		"d3a1",
		""
	],
	[
		"d440",
		""
	],
	[
		"d4a1",
		""
	],
	[
		"d540",
		""
	],
	[
		"d5a1",
		""
	],
	[
		"d640",
		""
	],
	[
		"d6a1",
		""
	],
	[
		"d740",
		""
	],
	[
		"d7a1",
		""
	],
	[
		"d840",
		""
	],
	[
		"d8a1",
		""
	],
	[
		"d940",
		""
	],
	[
		"d9a1",
		""
	],
	[
		"da40",
		""
	],
	[
		"daa1",
		""
	],
	[
		"db40",
		""
	],
	[
		"dba1",
		""
	],
	[
		"dc40",
		""
	],
	[
		"dca1",
		""
	],
	[
		"dd40",
		""
	],
	[
		"dda1",
		""
	],
	[
		"de40",
		""
	],
	[
		"dea1",
		""
	],
	[
		"df40",
		""
	],
	[
		"dfa1",
		""
	],
	[
		"e040",
		""
	],
	[
		"e0a1",
		""
	],
	[
		"e140",
		""
	],
	[
		"e1a1",
		""
	],
	[
		"e240",
		""
	],
	[
		"e2a1",
		""
	],
	[
		"e340",
		""
	],
	[
		"e3a1",
		""
	],
	[
		"e440",
		""
	],
	[
		"e4a1",
		""
	],
	[
		"e540",
		""
	],
	[
		"e5a1",
		""
	],
	[
		"e640",
		""
	],
	[
		"e6a1",
		""
	],
	[
		"e740",
		""
	],
	[
		"e7a1",
		""
	],
	[
		"e840",
		""
	],
	[
		"e8a1",
		""
	],
	[
		"e940",
		""
	],
	[
		"e9a1",
		""
	],
	[
		"ea40",
		""
	],
	[
		"eaa1",
		""
	],
	[
		"eb40",
		""
	],
	[
		"eba1",
		""
	],
	[
		"ec40",
		""
	],
	[
		"eca1",
		""
	],
	[
		"ed40",
		""
	],
	[
		"eda1",
		""
	],
	[
		"ee40",
		""
	],
	[
		"eea1",
		""
	],
	[
		"ef40",
		""
	],
	[
		"efa1",
		""
	],
	[
		"f040",
		""
	],
	[
		"f0a1",
		""
	],
	[
		"f140",
		""
	],
	[
		"f1a1",
		""
	],
	[
		"f240",
		""
	],
	[
		"f2a1",
		""
	],
	[
		"f340",
		""
	],
	[
		"f3a1",
		""
	],
	[
		"f440",
		""
	],
	[
		"f4a1",
		""
	],
	[
		"f540",
		""
	],
	[
		"f5a1",
		""
	],
	[
		"f640",
		""
	],
	[
		"f6a1",
		""
	],
	[
		"f740",
		""
	],
	[
		"f7a1",
		""
	],
	[
		"f840",
		""
	],
	[
		"f8a1",
		""
	],
	[
		"f940",
		""
	],
	[
		"f9a1",
		""
	]
];

var require$$7 = [
	[
		"8740",
		""
	],
	[
		"8767",
		""
	],
	[
		"87a1",
		""
	],
	[
		"8840",
		"",
		4,
		""
	],
	[
		"88a1",
		""
	],
	[
		"8940",
		""
	],
	[
		"8943",
		""
	],
	[
		"8946",
		""
	],
	[
		"894c",
		""
	],
	[
		"89a1",
		""
	],
	[
		"89ab",
		""
	],
	[
		"89b0",
		""
	],
	[
		"89b5",
		""
	],
	[
		"89c1",
		""
	],
	[
		"89c5",
		""
	],
	[
		"8a40",
		""
	],
	[
		"8a43",
		""
	],
	[
		"8a64",
		""
	],
	[
		"8a76",
		""
	],
	[
		"8aa1",
		""
	],
	[
		"8aac",
		""
	],
	[
		"8ab2",
		""
	],
	[
		"8abb",
		""
	],
	[
		"8ac9",
		""
	],
	[
		"8ace",
		""
	],
	[
		"8adf",
		""
	],
	[
		"8af6",
		""
	],
	[
		"8b40",
		""
	],
	[
		"8b55",
		""
	],
	[
		"8ba1",
		""
	],
	[
		"8bde",
		""
	],
	[
		"8c40",
		""
	],
	[
		"8ca1",
		""
	],
	[
		"8ca7",
		""
	],
	[
		"8cc9",
		""
	],
	[
		"8cce",
		""
	],
	[
		"8ce6",
		""
	],
	[
		"8d40",
		""
	],
	[
		"8d42",
		""
	],
	[
		"8da1",
		""
	],
	[
		"8e40",
		""
	],
	[
		"8ea1",
		""
	],
	[
		"8f40",
		""
	],
	[
		"8fa1",
		""
	],
	[
		"9040",
		""
	],
	[
		"90a1",
		""
	],
	[
		"9140",
		""
	],
	[
		"91a1",
		""
	],
	[
		"9240",
		""
	],
	[
		"92a1",
		""
	],
	[
		"9340",
		""
	],
	[
		"93a1",
		""
	],
	[
		"9440",
		""
	],
	[
		"94a1",
		""
	],
	[
		"9540",
		""
	],
	[
		"95a1",
		""
	],
	[
		"9640",
		""
	],
	[
		"96a1",
		""
	],
	[
		"9740",
		""
	],
	[
		"97a1",
		""
	],
	[
		"9840",
		""
	],
	[
		"98a1",
		""
	],
	[
		"9940",
		""
	],
	[
		"99a1",
		""
	],
	[
		"9a40",
		""
	],
	[
		"9aa1",
		""
	],
	[
		"9b40",
		""
	],
	[
		"9b62",
		""
	],
	[
		"9ba1",
		""
	],
	[
		"9c40",
		""
	],
	[
		"9ca1",
		""
	],
	[
		"9d40",
		""
	],
	[
		"9da1",
		""
	],
	[
		"9e40",
		""
	],
	[
		"9ea1",
		""
	],
	[
		"9ead",
		""
	],
	[
		"9ec5",
		""
	],
	[
		"9ef5",
		""
	],
	[
		"9f40",
		""
	],
	[
		"9f4f",
		""
	],
	[
		"9fa1",
		""
	],
	[
		"9fae",
		""
	],
	[
		"9fb2",
		""
	],
	[
		"9fc1",
		""
	],
	[
		"9fc9",
		""
	],
	[
		"9fdb",
		""
	],
	[
		"9fe7",
		""
	],
	[
		"9feb",
		""
	],
	[
		"9ff0",
		""
	],
	[
		"a040",
		""
	],
	[
		"a055",
		""
	],
	[
		"a058",
		""
	],
	[
		"a05b",
		""
	],
	[
		"a063",
		""
	],
	[
		"a073",
		""
	],
	[
		"a0a1",
		""
	],
	[
		"a0a6",
		""
	],
	[
		"a0ae",
		""
	],
	[
		"a0b0",
		""
	],
	[
		"a0d4",
		""
	],
	[
		"a0e2",
		""
	],
	[
		"a3c0",
		"",
		31,
		""
	],
	[
		"c6a1",
		"",
		9,
		"",
		9,
		"",
		9,
		"",
		23
	],
	[
		"c740",
		"",
		58,
		""
	],
	[
		"c7a1",
		"",
		81,
		"",
		5,
		"",
		4
	],
	[
		"c840",
		"",
		26,
		"",
		25,
		""
	],
	[
		"c8a1",
		""
	],
	[
		"c8cd",
		""
	],
	[
		"c8f5",
		""
	],
	[
		"f9fe",
		""
	],
	[
		"fa40",
		""
	],
	[
		"faa1",
		""
	],
	[
		"fb40",
		""
	],
	[
		"fba1",
		""
	],
	[
		"fc40",
		""
	],
	[
		"fca1",
		""
	],
	[
		"fd40",
		""
	],
	[
		"fda1",
		""
	],
	[
		"fe40",
		""
	],
	[
		"fea1",
		""
	]
];

var dbcsData;
var hasRequiredDbcsData;

function requireDbcsData () {
	if (hasRequiredDbcsData) return dbcsData;
	hasRequiredDbcsData = 1;

	// Description of supported double byte encodings and aliases.
	// Tables are not require()-d until they are needed to speed up library load.
	// require()-s are direct to support Browserify.

	dbcsData = {
	    
	    // == Japanese/ShiftJIS ====================================================
	    // All japanese encodings are based on JIS X set of standards:
	    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
	    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
	    //              Has several variations in 1978, 1983, 1990 and 1997.
	    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
	    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
	    //              2 planes, first is superset of 0208, second - revised 0212.
	    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

	    // Byte encodings are:
	    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
	    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
	    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
	    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
	    //               0x00-0x7F       - lower part of 0201
	    //               0x8E, 0xA1-0xDF - upper part of 0201
	    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
	    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
	    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
	    //               Used as-is in ISO2022 family.
	    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
	    //                0201-1976 Roman, 0208-1978, 0208-1983.
	    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
	    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
	    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
	    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
	    //
	    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
	    //
	    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

	    'shiftjis': {
	        type: '_dbcs',
	        table: function() { return require$$0 },
	        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
	        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
	    },
	    'csshiftjis': 'shiftjis',
	    'mskanji': 'shiftjis',
	    'sjis': 'shiftjis',
	    'windows31j': 'shiftjis',
	    'ms31j': 'shiftjis',
	    'xsjis': 'shiftjis',
	    'windows932': 'shiftjis',
	    'ms932': 'shiftjis',
	    '932': 'shiftjis',
	    'cp932': 'shiftjis',

	    'eucjp': {
	        type: '_dbcs',
	        table: function() { return require$$1 },
	        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
	    },

	    // TODO: KDDI extension to Shift_JIS
	    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
	    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


	    // == Chinese/GBK ==========================================================
	    // http://en.wikipedia.org/wiki/GBK
	    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

	    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
	    'gb2312': 'cp936',
	    'gb231280': 'cp936',
	    'gb23121980': 'cp936',
	    'csgb2312': 'cp936',
	    'csiso58gb231280': 'cp936',
	    'euccn': 'cp936',

	    // Microsoft's CP936 is a subset and approximation of GBK.
	    'windows936': 'cp936',
	    'ms936': 'cp936',
	    '936': 'cp936',
	    'cp936': {
	        type: '_dbcs',
	        table: function() { return require$$2 },
	    },

	    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
	    'gbk': {
	        type: '_dbcs',
	        table: function() { return require$$2.concat(require$$3) },
	    },
	    'xgbk': 'gbk',
	    'isoir58': 'gbk',

	    // GB18030 is an algorithmic extension of GBK.
	    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
	    // http://icu-project.org/docs/papers/gb18030.html
	    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
	    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
	    'gb18030': {
	        type: '_dbcs',
	        table: function() { return require$$2.concat(require$$3) },
	        gb18030: function() { return require$$4 },
	        encodeSkipVals: [0x80],
	        encodeAdd: {'': 0xA2E3},
	    },

	    'chinese': 'gb18030',


	    // == Korean ===============================================================
	    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
	    'windows949': 'cp949',
	    'ms949': 'cp949',
	    '949': 'cp949',
	    'cp949': {
	        type: '_dbcs',
	        table: function() { return require$$5 },
	    },

	    'cseuckr': 'cp949',
	    'csksc56011987': 'cp949',
	    'euckr': 'cp949',
	    'isoir149': 'cp949',
	    'korean': 'cp949',
	    'ksc56011987': 'cp949',
	    'ksc56011989': 'cp949',
	    'ksc5601': 'cp949',


	    // == Big5/Taiwan/Hong Kong ================================================
	    // There are lots of tables for Big5 and cp950. Please see the following links for history:
	    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
	    // Variations, in roughly number of defined chars:
	    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
	    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
	    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
	    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
	    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
	    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
	    //    Plus, it has 4 combining sequences.
	    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
	    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
	    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
	    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
	    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
	    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
	    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
	    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
	    // 
	    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
	    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

	    'windows950': 'cp950',
	    'ms950': 'cp950',
	    '950': 'cp950',
	    'cp950': {
	        type: '_dbcs',
	        table: function() { return require$$6 },
	    },

	    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
	    'big5': 'big5hkscs',
	    'big5hkscs': {
	        type: '_dbcs',
	        table: function() { return require$$6.concat(require$$7) },
	        encodeSkipVals: [
	            // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
	            // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
	            // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
	            0x8e69, 0x8e6f, 0x8e7e, 0x8eab, 0x8eb4, 0x8ecd, 0x8ed0, 0x8f57, 0x8f69, 0x8f6e, 0x8fcb, 0x8ffe,
	            0x906d, 0x907a, 0x90c4, 0x90dc, 0x90f1, 0x91bf, 0x92af, 0x92b0, 0x92b1, 0x92b2, 0x92d1, 0x9447, 0x94ca,
	            0x95d9, 0x96fc, 0x9975, 0x9b76, 0x9b78, 0x9b7b, 0x9bc6, 0x9bde, 0x9bec, 0x9bf6, 0x9c42, 0x9c53, 0x9c62,
	            0x9c68, 0x9c6b, 0x9c77, 0x9cbc, 0x9cbd, 0x9cd0, 0x9d57, 0x9d5a, 0x9dc4, 0x9def, 0x9dfb, 0x9ea9, 0x9eef,
	            0x9efd, 0x9f60, 0x9fcb, 0xa077, 0xa0dc, 0xa0df, 0x8fcc, 0x92c8, 0x9644, 0x96ed,

	            // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
	            0xa2a4, 0xa2a5, 0xa2a7, 0xa2a6, 0xa2cc, 0xa2ce,
	        ],
	    },

	    'cnbig5': 'big5hkscs',
	    'csbig5': 'big5hkscs',
	    'xxbig5': 'big5hkscs',
	};
	return dbcsData;
}

var hasRequiredEncodings;

function requireEncodings () {
	if (hasRequiredEncodings) return encodings;
	hasRequiredEncodings = 1;
	(function (exports$1) {

		// Update this array if you add/rename/remove files in this directory.
		// We support Browserify by skipping automatic module discovery and requiring modules directly.
		var modules = [
		    requireInternal(),
		    requireUtf32(),
		    requireUtf16(),
		    requireUtf7(),
		    requireSbcsCodec(),
		    requireSbcsData(),
		    requireSbcsDataGenerated(),
		    requireDbcsCodec(),
		    requireDbcsData(),
		];

		// Put all encoding/alias/codec definitions to single object and export it.
		for (var i = 0; i < modules.length; i++) {
		    var module = modules[i];
		    for (var enc in module)
		        if (Object.prototype.hasOwnProperty.call(module, enc))
		            exports$1[enc] = module[enc];
		} 
	} (encodings));
	return encodings;
}

var streams;
var hasRequiredStreams;

function requireStreams () {
	if (hasRequiredStreams) return streams;
	hasRequiredStreams = 1;

	var Buffer = requireSafer().Buffer;

	// NOTE: Due to 'stream' module being pretty large (~100Kb, significant in browser environments), 
	// we opt to dependency-inject it instead of creating a hard dependency.
	streams = function(stream_module) {
	    var Transform = stream_module.Transform;

	    // == Encoder stream =======================================================

	    function IconvLiteEncoderStream(conv, options) {
	        this.conv = conv;
	        options = options || {};
	        options.decodeStrings = false; // We accept only strings, so we don't need to decode them.
	        Transform.call(this, options);
	    }

	    IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
	        constructor: { value: IconvLiteEncoderStream }
	    });

	    IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
	        if (typeof chunk != 'string')
	            return done(new Error("Iconv encoding stream needs strings as its input."));
	        try {
	            var res = this.conv.write(chunk);
	            if (res && res.length) this.push(res);
	            done();
	        }
	        catch (e) {
	            done(e);
	        }
	    };

	    IconvLiteEncoderStream.prototype._flush = function(done) {
	        try {
	            var res = this.conv.end();
	            if (res && res.length) this.push(res);
	            done();
	        }
	        catch (e) {
	            done(e);
	        }
	    };

	    IconvLiteEncoderStream.prototype.collect = function(cb) {
	        var chunks = [];
	        this.on('error', cb);
	        this.on('data', function(chunk) { chunks.push(chunk); });
	        this.on('end', function() {
	            cb(null, Buffer.concat(chunks));
	        });
	        return this;
	    };


	    // == Decoder stream =======================================================

	    function IconvLiteDecoderStream(conv, options) {
	        this.conv = conv;
	        options = options || {};
	        options.encoding = this.encoding = 'utf8'; // We output strings.
	        Transform.call(this, options);
	    }

	    IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
	        constructor: { value: IconvLiteDecoderStream }
	    });

	    IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
	        if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array))
	            return done(new Error("Iconv decoding stream needs buffers as its input."));
	        try {
	            var res = this.conv.write(chunk);
	            if (res && res.length) this.push(res, this.encoding);
	            done();
	        }
	        catch (e) {
	            done(e);
	        }
	    };

	    IconvLiteDecoderStream.prototype._flush = function(done) {
	        try {
	            var res = this.conv.end();
	            if (res && res.length) this.push(res, this.encoding);                
	            done();
	        }
	        catch (e) {
	            done(e);
	        }
	    };

	    IconvLiteDecoderStream.prototype.collect = function(cb) {
	        var res = '';
	        this.on('error', cb);
	        this.on('data', function(chunk) { res += chunk; });
	        this.on('end', function() {
	            cb(null, res);
	        });
	        return this;
	    };

	    return {
	        IconvLiteEncoderStream: IconvLiteEncoderStream,
	        IconvLiteDecoderStream: IconvLiteDecoderStream,
	    };
	};
	return streams;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib.exports;
	hasRequiredLib = 1;
	(function (module) {

		var Buffer = requireSafer().Buffer;

		var bomHandling = requireBomHandling(),
		    iconv = module.exports;

		// All codecs and aliases are kept here, keyed by encoding name/alias.
		// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
		iconv.encodings = null;

		// Characters emitted in case of error.
		iconv.defaultCharUnicode = '';
		iconv.defaultCharSingleByte = '?';

		// Public API.
		iconv.encode = function encode(str, encoding, options) {
		    str = "" + (str || ""); // Ensure string.

		    var encoder = iconv.getEncoder(encoding, options);

		    var res = encoder.write(str);
		    var trail = encoder.end();
		    
		    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
		};

		iconv.decode = function decode(buf, encoding, options) {
		    if (typeof buf === 'string') {
		        if (!iconv.skipDecodeWarning) {
		            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
		            iconv.skipDecodeWarning = true;
		        }

		        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
		    }

		    var decoder = iconv.getDecoder(encoding, options);

		    var res = decoder.write(buf);
		    var trail = decoder.end();

		    return trail ? (res + trail) : res;
		};

		iconv.encodingExists = function encodingExists(enc) {
		    try {
		        iconv.getCodec(enc);
		        return true;
		    } catch (e) {
		        return false;
		    }
		};

		// Legacy aliases to convert functions
		iconv.toEncoding = iconv.encode;
		iconv.fromEncoding = iconv.decode;

		// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
		iconv._codecDataCache = {};
		iconv.getCodec = function getCodec(encoding) {
		    if (!iconv.encodings)
		        iconv.encodings = requireEncodings(); // Lazy load all encoding definitions.
		    
		    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
		    var enc = iconv._canonicalizeEncoding(encoding);

		    // Traverse iconv.encodings to find actual codec.
		    var codecOptions = {};
		    while (true) {
		        var codec = iconv._codecDataCache[enc];
		        if (codec)
		            return codec;

		        var codecDef = iconv.encodings[enc];

		        switch (typeof codecDef) {
		            case "string": // Direct alias to other encoding.
		                enc = codecDef;
		                break;

		            case "object": // Alias with options. Can be layered.
		                for (var key in codecDef)
		                    codecOptions[key] = codecDef[key];

		                if (!codecOptions.encodingName)
		                    codecOptions.encodingName = enc;
		                
		                enc = codecDef.type;
		                break;

		            case "function": // Codec itself.
		                if (!codecOptions.encodingName)
		                    codecOptions.encodingName = enc;

		                // The codec function must load all tables and return object with .encoder and .decoder methods.
		                // It'll be called only once (for each different options object).
		                codec = new codecDef(codecOptions, iconv);

		                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
		                return codec;

		            default:
		                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
		        }
		    }
		};

		iconv._canonicalizeEncoding = function(encoding) {
		    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
		    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
		};

		iconv.getEncoder = function getEncoder(encoding, options) {
		    var codec = iconv.getCodec(encoding),
		        encoder = new codec.encoder(options, codec);

		    if (codec.bomAware && options && options.addBOM)
		        encoder = new bomHandling.PrependBOM(encoder, options);

		    return encoder;
		};

		iconv.getDecoder = function getDecoder(encoding, options) {
		    var codec = iconv.getCodec(encoding),
		        decoder = new codec.decoder(options, codec);

		    if (codec.bomAware && !(options && options.stripBOM === false))
		        decoder = new bomHandling.StripBOM(decoder, options);

		    return decoder;
		};

		// Streaming API
		// NOTE: Streaming API naturally depends on 'stream' module from Node.js. Unfortunately in browser environments this module can add
		// up to 100Kb to the output bundle. To avoid unnecessary code bloat, we don't enable Streaming API in browser by default.
		// If you would like to enable it explicitly, please add the following code to your app:
		// > iconv.enableStreamingAPI(require('stream'));
		iconv.enableStreamingAPI = function enableStreamingAPI(stream_module) {
		    if (iconv.supportsStreams)
		        return;

		    // Dependency-inject stream module to create IconvLite stream classes.
		    var streams = requireStreams()(stream_module);

		    // Not public API yet, but expose the stream classes.
		    iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
		    iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;

		    // Streaming API.
		    iconv.encodeStream = function encodeStream(encoding, options) {
		        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
		    };

		    iconv.decodeStream = function decodeStream(encoding, options) {
		        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
		    };

		    iconv.supportsStreams = true;
		};

		// Enable Streaming API automatically if 'stream' module is available and non-empty (the majority of environments).
		var stream_module;
		try {
		    stream_module = require("stream");
		} catch (e) {}

		if (stream_module && stream_module.Transform) {
		    iconv.enableStreamingAPI(stream_module);

		} else {
		    // In rare cases where 'stream' module is not available by default, throw a helpful exception.
		    iconv.encodeStream = iconv.decodeStream = function() {
		        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
		    };
		}
	} (lib));
	return lib.exports;
}

var hasRequiredText;

function requireText () {
	if (hasRequiredText) return text.exports;
	hasRequiredText = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _iconvLite = _interopRequireDefault(requireLib());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const NULL_LENGTH = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF]);
		const Text = {
		  id: 0x23,
		  type: 'TEXT',
		  name: 'Text',
		  hasTableName: true,
		  declaration: function () {
		    return 'text';
		  },
		  resolveLength: function (parameter) {
		    const value = parameter.value;
		    if (value != null) {
		      return value.length;
		    } else {
		      return -1;
		    }
		  },
		  generateTypeInfo(parameter, _options) {
		    const buffer = Buffer.alloc(10);
		    buffer.writeUInt8(this.id, 0);
		    buffer.writeInt32LE(parameter.length, 1);
		    if (parameter.collation) {
		      parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
		    }
		    return buffer;
		  },
		  generateParameterLength(parameter, options) {
		    const value = parameter.value;
		    if (value == null) {
		      return NULL_LENGTH;
		    }
		    const buffer = Buffer.alloc(4);
		    buffer.writeInt32LE(value.length, 0);
		    return buffer;
		  },
		  generateParameterData: function* (parameter, options) {
		    const value = parameter.value;
		    if (value == null) {
		      return;
		    }
		    yield value;
		  },
		  validate: function (value, collation) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'string') {
		      throw new TypeError('Invalid string.');
		    }
		    if (!collation) {
		      throw new Error('No collation was set by the server for the current connection.');
		    }
		    if (!collation.codepage) {
		      throw new Error('The collation set by the server has no associated encoding.');
		    }
		    return _iconvLite.default.encode(value, collation.codepage);
		  }
		};
		exports$1.default = Text;
		module.exports = Text;
		
	} (text, text.exports));
	return text.exports;
}

var uniqueidentifier = {exports: {}};

var guidParser = {};

var hasRequiredGuidParser;

function requireGuidParser () {
	if (hasRequiredGuidParser) return guidParser;
	hasRequiredGuidParser = 1;

	Object.defineProperty(guidParser, "__esModule", {
	  value: true
	});
	guidParser.bufferToLowerCaseGuid = bufferToLowerCaseGuid;
	guidParser.bufferToUpperCaseGuid = bufferToUpperCaseGuid;
	guidParser.guidToArray = guidToArray;
	const UPPER_CASE_MAP = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0A', '0B', '0C', '0D', '0E', '0F', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1A', '1B', '1C', '1D', '1E', '1F', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2A', '2B', '2C', '2D', '2E', '2F', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3A', '3B', '3C', '3D', '3E', '3F', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4A', '4B', '4C', '4D', '4E', '4F', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5A', '5B', '5C', '5D', '5E', '5F', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6A', '6B', '6C', '6D', '6E', '6F', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7A', '7B', '7C', '7D', '7E', '7F', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8A', '8B', '8C', '8D', '8E', '8F', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9A', '9B', '9C', '9D', '9E', '9F', 'A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9', 'AA', 'AB', 'AC', 'AD', 'AE', 'AF', 'B0', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9', 'BA', 'BB', 'BC', 'BD', 'BE', 'BF', 'C0', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9', 'CA', 'CB', 'CC', 'CD', 'CE', 'CF', 'D0', 'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9', 'DA', 'DB', 'DC', 'DD', 'DE', 'DF', 'E0', 'E1', 'E2', 'E3', 'E4', 'E5', 'E6', 'E7', 'E8', 'E9', 'EA', 'EB', 'EC', 'ED', 'EE', 'EF', 'F0', 'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'FA', 'FB', 'FC', 'FD', 'FE', 'FF'];
	const LOWER_CASE_MAP = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
	function bufferToUpperCaseGuid(buffer) {
	  return UPPER_CASE_MAP[buffer[3]] + UPPER_CASE_MAP[buffer[2]] + UPPER_CASE_MAP[buffer[1]] + UPPER_CASE_MAP[buffer[0]] + '-' + UPPER_CASE_MAP[buffer[5]] + UPPER_CASE_MAP[buffer[4]] + '-' + UPPER_CASE_MAP[buffer[7]] + UPPER_CASE_MAP[buffer[6]] + '-' + UPPER_CASE_MAP[buffer[8]] + UPPER_CASE_MAP[buffer[9]] + '-' + UPPER_CASE_MAP[buffer[10]] + UPPER_CASE_MAP[buffer[11]] + UPPER_CASE_MAP[buffer[12]] + UPPER_CASE_MAP[buffer[13]] + UPPER_CASE_MAP[buffer[14]] + UPPER_CASE_MAP[buffer[15]];
	}
	function bufferToLowerCaseGuid(buffer) {
	  return LOWER_CASE_MAP[buffer[3]] + LOWER_CASE_MAP[buffer[2]] + LOWER_CASE_MAP[buffer[1]] + LOWER_CASE_MAP[buffer[0]] + '-' + LOWER_CASE_MAP[buffer[5]] + LOWER_CASE_MAP[buffer[4]] + '-' + LOWER_CASE_MAP[buffer[7]] + LOWER_CASE_MAP[buffer[6]] + '-' + LOWER_CASE_MAP[buffer[8]] + LOWER_CASE_MAP[buffer[9]] + '-' + LOWER_CASE_MAP[buffer[10]] + LOWER_CASE_MAP[buffer[11]] + LOWER_CASE_MAP[buffer[12]] + LOWER_CASE_MAP[buffer[13]] + LOWER_CASE_MAP[buffer[14]] + LOWER_CASE_MAP[buffer[15]];
	}
	const CHARCODEMAP = {};
	const hexDigits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F'].map(d => d.charCodeAt(0));
	for (let i = 0; i < hexDigits.length; i++) {
	  const map = CHARCODEMAP[hexDigits[i]] = {};
	  for (let j = 0; j < hexDigits.length; j++) {
	    const hex = String.fromCharCode(hexDigits[i], hexDigits[j]);
	    const value = parseInt(hex, 16);
	    map[hexDigits[j]] = value;
	  }
	}
	function guidToArray(guid) {
	  return [CHARCODEMAP[guid.charCodeAt(6)][guid.charCodeAt(7)], CHARCODEMAP[guid.charCodeAt(4)][guid.charCodeAt(5)], CHARCODEMAP[guid.charCodeAt(2)][guid.charCodeAt(3)], CHARCODEMAP[guid.charCodeAt(0)][guid.charCodeAt(1)], CHARCODEMAP[guid.charCodeAt(11)][guid.charCodeAt(12)], CHARCODEMAP[guid.charCodeAt(9)][guid.charCodeAt(10)], CHARCODEMAP[guid.charCodeAt(16)][guid.charCodeAt(17)], CHARCODEMAP[guid.charCodeAt(14)][guid.charCodeAt(15)], CHARCODEMAP[guid.charCodeAt(19)][guid.charCodeAt(20)], CHARCODEMAP[guid.charCodeAt(21)][guid.charCodeAt(22)], CHARCODEMAP[guid.charCodeAt(24)][guid.charCodeAt(25)], CHARCODEMAP[guid.charCodeAt(26)][guid.charCodeAt(27)], CHARCODEMAP[guid.charCodeAt(28)][guid.charCodeAt(29)], CHARCODEMAP[guid.charCodeAt(30)][guid.charCodeAt(31)], CHARCODEMAP[guid.charCodeAt(32)][guid.charCodeAt(33)], CHARCODEMAP[guid.charCodeAt(34)][guid.charCodeAt(35)]];
	}
	
	return guidParser;
}

var hasRequiredUniqueidentifier;

function requireUniqueidentifier () {
	if (hasRequiredUniqueidentifier) return uniqueidentifier.exports;
	hasRequiredUniqueidentifier = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _guidParser = requireGuidParser();
		const NULL_LENGTH = Buffer.from([0x00]);
		const DATA_LENGTH = Buffer.from([0x10]);
		const UniqueIdentifier = {
		  id: 0x24,
		  type: 'GUIDN',
		  name: 'UniqueIdentifier',
		  declaration: function () {
		    return 'uniqueidentifier';
		  },
		  resolveLength: function () {
		    return 16;
		  },
		  generateTypeInfo() {
		    return Buffer.from([this.id, 0x10]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  generateParameterData: function* (parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    yield Buffer.from((0, _guidParser.guidToArray)(parameter.value));
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'string') {
		      throw new TypeError('Invalid string.');
		    }
		    if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
		      throw new TypeError('Invalid GUID.');
		    }
		    return value;
		  }
		};
		exports$1.default = UniqueIdentifier;
		module.exports = UniqueIdentifier;
		
	} (uniqueidentifier, uniqueidentifier.exports));
	return uniqueidentifier.exports;
}

var ntext = {exports: {}};

var hasRequiredNtext;

function requireNtext () {
	if (hasRequiredNtext) return ntext.exports;
	hasRequiredNtext = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const NULL_LENGTH = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF]);
		const NText = {
		  id: 0x63,
		  type: 'NTEXT',
		  name: 'NText',
		  hasTableName: true,
		  declaration: function () {
		    return 'ntext';
		  },
		  resolveLength: function (parameter) {
		    const value = parameter.value; // Temporary solution. Remove 'any' later.

		    if (value != null) {
		      return value.length;
		    } else {
		      return -1;
		    }
		  },
		  generateTypeInfo(parameter, _options) {
		    const buffer = Buffer.alloc(10);
		    buffer.writeUInt8(this.id, 0);
		    buffer.writeInt32LE(parameter.length, 1);
		    if (parameter.collation) {
		      parameter.collation.toBuffer().copy(buffer, 5, 0, 5);
		    }
		    return buffer;
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    const buffer = Buffer.alloc(4);
		    buffer.writeInt32LE(Buffer.byteLength(parameter.value, 'ucs2'), 0);
		    return buffer;
		  },
		  generateParameterData: function* (parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    yield Buffer.from(parameter.value.toString(), 'ucs2');
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'string') {
		      throw new TypeError('Invalid string.');
		    }
		    return value;
		  }
		};
		exports$1.default = NText;
		module.exports = NText;
		
	} (ntext, ntext.exports));
	return ntext.exports;
}

var varbinary = {exports: {}};

var hasRequiredVarbinary;

function requireVarbinary () {
	if (hasRequiredVarbinary) return varbinary.exports;
	hasRequiredVarbinary = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const MAX = (1 << 16) - 1;
		const UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
		const PLP_TERMINATOR = Buffer.from([0x00, 0x00, 0x00, 0x00]);
		const NULL_LENGTH = Buffer.from([0xFF, 0xFF]);
		const MAX_NULL_LENGTH = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
		const VarBinary = {
		  id: 0xA5,
		  type: 'BIGVARBIN',
		  name: 'VarBinary',
		  maximumLength: 8000,
		  declaration: function (parameter) {
		    const value = parameter.value; // Temporary solution. Remove 'any' later.
		    let length;
		    if (parameter.length) {
		      length = parameter.length;
		    } else if (value != null) {
		      length = value.length || 1;
		    } else if (value === null && !parameter.output) {
		      length = 1;
		    } else {
		      length = this.maximumLength;
		    }
		    if (length <= this.maximumLength) {
		      return 'varbinary(' + length + ')';
		    } else {
		      return 'varbinary(max)';
		    }
		  },
		  resolveLength: function (parameter) {
		    const value = parameter.value; // Temporary solution. Remove 'any' later.
		    if (parameter.length != null) {
		      return parameter.length;
		    } else if (value != null) {
		      return value.length;
		    } else {
		      return this.maximumLength;
		    }
		  },
		  generateTypeInfo: function (parameter) {
		    const buffer = Buffer.alloc(3);
		    buffer.writeUInt8(this.id, 0);
		    if (parameter.length <= this.maximumLength) {
		      buffer.writeUInt16LE(parameter.length, 1);
		    } else {
		      buffer.writeUInt16LE(MAX, 1);
		    }
		    return buffer;
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      if (parameter.length <= this.maximumLength) {
		        return NULL_LENGTH;
		      } else {
		        return MAX_NULL_LENGTH;
		      }
		    }
		    let value = parameter.value;
		    if (!Buffer.isBuffer(value)) {
		      value = value.toString();
		    }
		    const length = Buffer.byteLength(value, 'ucs2');
		    if (parameter.length <= this.maximumLength) {
		      const buffer = Buffer.alloc(2);
		      buffer.writeUInt16LE(length, 0);
		      return buffer;
		    } else {
		      // writePLPBody
		      return UNKNOWN_PLP_LEN;
		    }
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    let value = parameter.value;
		    if (parameter.length <= this.maximumLength) {
		      if (Buffer.isBuffer(value)) {
		        yield value;
		      } else {
		        yield Buffer.from(value.toString(), 'ucs2');
		      }
		    } else {
		      // writePLPBody
		      if (!Buffer.isBuffer(value)) {
		        value = value.toString();
		      }
		      const length = Buffer.byteLength(value, 'ucs2');
		      if (length > 0) {
		        const buffer = Buffer.alloc(4);
		        buffer.writeUInt32LE(length, 0);
		        yield buffer;
		        if (Buffer.isBuffer(value)) {
		          yield value;
		        } else {
		          yield Buffer.from(value, 'ucs2');
		        }
		      }
		      yield PLP_TERMINATOR;
		    }
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (!Buffer.isBuffer(value)) {
		      throw new TypeError('Invalid buffer.');
		    }
		    return value;
		  }
		};
		exports$1.default = VarBinary;
		module.exports = VarBinary;
		
	} (varbinary, varbinary.exports));
	return varbinary.exports;
}

var varchar = {exports: {}};

var hasRequiredVarchar;

function requireVarchar () {
	if (hasRequiredVarchar) return varchar.exports;
	hasRequiredVarchar = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _iconvLite = _interopRequireDefault(requireLib());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const MAX = (1 << 16) - 1;
		const UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
		const PLP_TERMINATOR = Buffer.from([0x00, 0x00, 0x00, 0x00]);
		const NULL_LENGTH = Buffer.from([0xFF, 0xFF]);
		const MAX_NULL_LENGTH = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
		const VarChar = {
		  id: 0xA7,
		  type: 'BIGVARCHR',
		  name: 'VarChar',
		  maximumLength: 8000,
		  declaration: function (parameter) {
		    const value = parameter.value;
		    let length;
		    if (parameter.length) {
		      length = parameter.length;
		    } else if (value != null) {
		      length = value.length || 1;
		    } else if (value === null && !parameter.output) {
		      length = 1;
		    } else {
		      length = this.maximumLength;
		    }
		    if (length <= this.maximumLength) {
		      return 'varchar(' + length + ')';
		    } else {
		      return 'varchar(max)';
		    }
		  },
		  resolveLength: function (parameter) {
		    const value = parameter.value;
		    if (parameter.length != null) {
		      return parameter.length;
		    } else if (value != null) {
		      return value.length || 1;
		    } else {
		      return this.maximumLength;
		    }
		  },
		  generateTypeInfo(parameter) {
		    const buffer = Buffer.alloc(8);
		    buffer.writeUInt8(this.id, 0);
		    if (parameter.length <= this.maximumLength) {
		      buffer.writeUInt16LE(parameter.length, 1);
		    } else {
		      buffer.writeUInt16LE(MAX, 1);
		    }
		    if (parameter.collation) {
		      parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
		    }
		    return buffer;
		  },
		  generateParameterLength(parameter, options) {
		    const value = parameter.value;
		    if (value == null) {
		      if (parameter.length <= this.maximumLength) {
		        return NULL_LENGTH;
		      } else {
		        return MAX_NULL_LENGTH;
		      }
		    }
		    if (parameter.length <= this.maximumLength) {
		      const buffer = Buffer.alloc(2);
		      buffer.writeUInt16LE(value.length, 0);
		      return buffer;
		    } else {
		      return UNKNOWN_PLP_LEN;
		    }
		  },
		  *generateParameterData(parameter, options) {
		    const value = parameter.value;
		    if (value == null) {
		      return;
		    }
		    if (parameter.length <= this.maximumLength) {
		      yield value;
		    } else {
		      if (value.length > 0) {
		        const buffer = Buffer.alloc(4);
		        buffer.writeUInt32LE(value.length, 0);
		        yield buffer;
		        yield value;
		      }
		      yield PLP_TERMINATOR;
		    }
		  },
		  validate: function (value, collation) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'string') {
		      throw new TypeError('Invalid string.');
		    }
		    if (!collation) {
		      throw new Error('No collation was set by the server for the current connection.');
		    }
		    if (!collation.codepage) {
		      throw new Error('The collation set by the server has no associated encoding.');
		    }
		    return _iconvLite.default.encode(value, collation.codepage);
		  }
		};
		exports$1.default = VarChar;
		module.exports = VarChar;
		
	} (varchar, varchar.exports));
	return varchar.exports;
}

var binary = {exports: {}};

var hasRequiredBinary;

function requireBinary () {
	if (hasRequiredBinary) return binary.exports;
	hasRequiredBinary = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const NULL_LENGTH = Buffer.from([0xFF, 0xFF]);
		const Binary = {
		  id: 0xAD,
		  type: 'BIGBinary',
		  name: 'Binary',
		  maximumLength: 8000,
		  declaration: function (parameter) {
		    const value = parameter.value;
		    let length;
		    if (parameter.length) {
		      length = parameter.length;
		    } else if (value != null) {
		      length = value.length || 1;
		    } else if (value === null && !parameter.output) {
		      length = 1;
		    } else {
		      length = this.maximumLength;
		    }
		    return 'binary(' + length + ')';
		  },
		  resolveLength: function (parameter) {
		    const value = parameter.value;
		    if (value != null) {
		      return value.length;
		    } else {
		      return this.maximumLength;
		    }
		  },
		  generateTypeInfo(parameter) {
		    const buffer = Buffer.alloc(3);
		    buffer.writeUInt8(this.id, 0);
		    buffer.writeUInt16LE(parameter.length, 1);
		    return buffer;
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    const buffer = Buffer.alloc(2);
		    buffer.writeUInt16LE(parameter.length, 0);
		    return buffer;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    yield parameter.value.slice(0, parameter.length !== undefined ? Math.min(parameter.length, this.maximumLength) : this.maximumLength);
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (!Buffer.isBuffer(value)) {
		      throw new TypeError('Invalid buffer.');
		    }
		    return value;
		  }
		};
		exports$1.default = Binary;
		module.exports = Binary;
		
	} (binary, binary.exports));
	return binary.exports;
}

var char = {exports: {}};

var hasRequiredChar;

function requireChar () {
	if (hasRequiredChar) return char.exports;
	hasRequiredChar = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _iconvLite = _interopRequireDefault(requireLib());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const NULL_LENGTH = Buffer.from([0xFF, 0xFF]);
		const Char = {
		  id: 0xAF,
		  type: 'BIGCHAR',
		  name: 'Char',
		  maximumLength: 8000,
		  declaration: function (parameter) {
		    const value = parameter.value;
		    let length;
		    if (parameter.length) {
		      length = parameter.length;
		    } else if (value != null) {
		      length = value.length || 1;
		    } else if (value === null && !parameter.output) {
		      length = 1;
		    } else {
		      length = this.maximumLength;
		    }
		    if (length < this.maximumLength) {
		      return 'char(' + length + ')';
		    } else {
		      return 'char(' + this.maximumLength + ')';
		    }
		  },
		  // ParameterData<any> is temporary solution. TODO: need to understand what type ParameterData<...> can be.
		  resolveLength: function (parameter) {
		    const value = parameter.value;
		    if (parameter.length != null) {
		      return parameter.length;
		    } else if (value != null) {
		      return value.length || 1;
		    } else {
		      return this.maximumLength;
		    }
		  },
		  generateTypeInfo(parameter) {
		    const buffer = Buffer.alloc(8);
		    buffer.writeUInt8(this.id, 0);
		    buffer.writeUInt16LE(parameter.length, 1);
		    if (parameter.collation) {
		      parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
		    }
		    return buffer;
		  },
		  generateParameterLength(parameter, options) {
		    const value = parameter.value;
		    if (value == null) {
		      return NULL_LENGTH;
		    }
		    const buffer = Buffer.alloc(2);
		    buffer.writeUInt16LE(value.length, 0);
		    return buffer;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    yield Buffer.from(parameter.value, 'ascii');
		  },
		  validate: function (value, collation) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'string') {
		      throw new TypeError('Invalid string.');
		    }
		    if (!collation) {
		      throw new Error('No collation was set by the server for the current connection.');
		    }
		    if (!collation.codepage) {
		      throw new Error('The collation set by the server has no associated encoding.');
		    }
		    return _iconvLite.default.encode(value, collation.codepage);
		  }
		};
		exports$1.default = Char;
		module.exports = Char;
		
	} (char, char.exports));
	return char.exports;
}

var nvarchar = {exports: {}};

var hasRequiredNvarchar;

function requireNvarchar () {
	if (hasRequiredNvarchar) return nvarchar.exports;
	hasRequiredNvarchar = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const MAX = (1 << 16) - 1;
		const UNKNOWN_PLP_LEN = Buffer.from([0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);
		const PLP_TERMINATOR = Buffer.from([0x00, 0x00, 0x00, 0x00]);
		const NULL_LENGTH = Buffer.from([0xFF, 0xFF]);
		const MAX_NULL_LENGTH = Buffer.from([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]);
		const NVarChar = {
		  id: 0xE7,
		  type: 'NVARCHAR',
		  name: 'NVarChar',
		  maximumLength: 4000,
		  declaration: function (parameter) {
		    const value = parameter.value; // Temporary solution. Remove 'any' later.

		    let length;
		    if (parameter.length) {
		      length = parameter.length;
		    } else if (value != null) {
		      length = value.toString().length || 1;
		    } else if (value === null && !parameter.output) {
		      length = 1;
		    } else {
		      length = this.maximumLength;
		    }
		    if (length <= this.maximumLength) {
		      return 'nvarchar(' + length + ')';
		    } else {
		      return 'nvarchar(max)';
		    }
		  },
		  resolveLength: function (parameter) {
		    const value = parameter.value; // Temporary solution. Remove 'any' later.
		    if (parameter.length != null) {
		      return parameter.length;
		    } else if (value != null) {
		      if (Buffer.isBuffer(value)) {
		        return value.length / 2 || 1;
		      } else {
		        return value.toString().length || 1;
		      }
		    } else {
		      return this.maximumLength;
		    }
		  },
		  generateTypeInfo(parameter) {
		    const buffer = Buffer.alloc(8);
		    buffer.writeUInt8(this.id, 0);
		    if (parameter.length <= this.maximumLength) {
		      buffer.writeUInt16LE(parameter.length * 2, 1);
		    } else {
		      buffer.writeUInt16LE(MAX, 1);
		    }
		    if (parameter.collation) {
		      parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
		    }
		    return buffer;
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      if (parameter.length <= this.maximumLength) {
		        return NULL_LENGTH;
		      } else {
		        return MAX_NULL_LENGTH;
		      }
		    }
		    let value = parameter.value;
		    if (parameter.length <= this.maximumLength) {
		      let length;
		      if (value instanceof Buffer) {
		        length = value.length;
		      } else {
		        value = value.toString();
		        length = Buffer.byteLength(value, 'ucs2');
		      }
		      const buffer = Buffer.alloc(2);
		      buffer.writeUInt16LE(length, 0);
		      return buffer;
		    } else {
		      return UNKNOWN_PLP_LEN;
		    }
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    let value = parameter.value;
		    if (parameter.length <= this.maximumLength) {
		      if (value instanceof Buffer) {
		        yield value;
		      } else {
		        value = value.toString();
		        yield Buffer.from(value, 'ucs2');
		      }
		    } else {
		      if (value instanceof Buffer) {
		        const length = value.length;
		        if (length > 0) {
		          const buffer = Buffer.alloc(4);
		          buffer.writeUInt32LE(length, 0);
		          yield buffer;
		          yield value;
		        }
		      } else {
		        value = value.toString();
		        const length = Buffer.byteLength(value, 'ucs2');
		        if (length > 0) {
		          const buffer = Buffer.alloc(4);
		          buffer.writeUInt32LE(length, 0);
		          yield buffer;
		          yield Buffer.from(value, 'ucs2');
		        }
		      }
		      yield PLP_TERMINATOR;
		    }
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'string') {
		      throw new TypeError('Invalid string.');
		    }
		    return value;
		  }
		};
		exports$1.default = NVarChar;
		module.exports = NVarChar;
		
	} (nvarchar, nvarchar.exports));
	return nvarchar.exports;
}

var nchar = {exports: {}};

var hasRequiredNchar;

function requireNchar () {
	if (hasRequiredNchar) return nchar.exports;
	hasRequiredNchar = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const NULL_LENGTH = Buffer.from([0xFF, 0xFF]);
		const NChar = {
		  id: 0xEF,
		  type: 'NCHAR',
		  name: 'NChar',
		  maximumLength: 4000,
		  declaration: function (parameter) {
		    // const value = parameter.value as null | string | { toString(): string };
		    const value = parameter.value; // Temporary solution. Remove 'any' later.

		    let length;
		    if (parameter.length) {
		      length = parameter.length;
		    } else if (parameter.value != null) {
		      length = value.toString().length || 1;
		    } else if (parameter.value === null && !parameter.output) {
		      length = 1;
		    } else {
		      length = this.maximumLength;
		    }
		    if (length < this.maximumLength) {
		      return 'nchar(' + length + ')';
		    } else {
		      return 'nchar(' + this.maximumLength + ')';
		    }
		  },
		  resolveLength: function (parameter) {
		    // const value = parameter.value as null | string | { toString(): string };
		    const value = parameter.value; // Temporary solution. Remove 'any' later.

		    if (parameter.length != null) {
		      return parameter.length;
		    } else if (parameter.value != null) {
		      if (Buffer.isBuffer(parameter.value)) {
		        return parameter.value.length / 2 || 1;
		      } else {
		        return value.toString().length || 1;
		      }
		    } else {
		      return this.maximumLength;
		    }
		  },
		  generateTypeInfo: function (parameter) {
		    const buffer = Buffer.alloc(8);
		    buffer.writeUInt8(this.id, 0);
		    buffer.writeUInt16LE(parameter.length * 2, 1);
		    if (parameter.collation) {
		      parameter.collation.toBuffer().copy(buffer, 3, 0, 5);
		    }
		    return buffer;
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    const {
		      value
		    } = parameter;
		    if (value instanceof Buffer) {
		      const length = value.length;
		      const buffer = Buffer.alloc(2);
		      buffer.writeUInt16LE(length, 0);
		      return buffer;
		    } else {
		      const length = Buffer.byteLength(value.toString(), 'ucs2');
		      const buffer = Buffer.alloc(2);
		      buffer.writeUInt16LE(length, 0);
		      return buffer;
		    }
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const value = parameter.value;
		    if (value instanceof Buffer) {
		      yield value;
		    } else {
		      yield Buffer.from(value, 'ucs2');
		    }
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'string') {
		      throw new TypeError('Invalid string.');
		    }
		    return value;
		  }
		};
		exports$1.default = NChar;
		module.exports = NChar;
		
	} (nchar, nchar.exports));
	return nchar.exports;
}

var xml = {exports: {}};

var hasRequiredXml;

function requireXml () {
	if (hasRequiredXml) return xml.exports;
	hasRequiredXml = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const XML = {
		  id: 0xF1,
		  type: 'XML',
		  name: 'Xml',
		  declaration() {
		    throw new Error('not implemented');
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = XML;
		module.exports = XML;
		
	} (xml, xml.exports));
	return xml.exports;
}

var time = {exports: {}};

var hasRequiredTime;

function requireTime () {
	if (hasRequiredTime) return time.exports;
	hasRequiredTime = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const NULL_LENGTH = Buffer.from([0x00]);
		const Time = {
		  id: 0x29,
		  type: 'TIMEN',
		  name: 'Time',
		  declaration: function (parameter) {
		    return 'time(' + this.resolveScale(parameter) + ')';
		  },
		  resolveScale: function (parameter) {
		    if (parameter.scale != null) {
		      return parameter.scale;
		    } else if (parameter.value === null) {
		      return 0;
		    } else {
		      return 7;
		    }
		  },
		  generateTypeInfo(parameter) {
		    return Buffer.from([this.id, parameter.scale]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    switch (parameter.scale) {
		      case 0:
		      case 1:
		      case 2:
		        return Buffer.from([0x03]);
		      case 3:
		      case 4:
		        return Buffer.from([0x04]);
		      case 5:
		      case 6:
		      case 7:
		        return Buffer.from([0x05]);
		      default:
		        throw new Error('invalid scale');
		    }
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const buffer = new _writableTrackingBuffer.default(16);
		    const time = parameter.value;
		    let timestamp;
		    if (options.useUTC) {
		      timestamp = ((time.getUTCHours() * 60 + time.getUTCMinutes()) * 60 + time.getUTCSeconds()) * 1000 + time.getUTCMilliseconds();
		    } else {
		      timestamp = ((time.getHours() * 60 + time.getMinutes()) * 60 + time.getSeconds()) * 1000 + time.getMilliseconds();
		    }
		    timestamp = timestamp * Math.pow(10, parameter.scale - 3);
		    timestamp += (parameter.value.nanosecondDelta != null ? parameter.value.nanosecondDelta : 0) * Math.pow(10, parameter.scale);
		    timestamp = Math.round(timestamp);
		    switch (parameter.scale) {
		      case 0:
		      case 1:
		      case 2:
		        buffer.writeUInt24LE(timestamp);
		        break;
		      case 3:
		      case 4:
		        buffer.writeUInt32LE(timestamp);
		        break;
		      case 5:
		      case 6:
		      case 7:
		        buffer.writeUInt40LE(timestamp);
		    }
		    yield buffer.data;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (!(value instanceof Date)) {
		      value = new Date(Date.parse(value));
		    }
		    if (isNaN(value)) {
		      throw new TypeError('Invalid time.');
		    }
		    return value;
		  }
		};
		exports$1.default = Time;
		module.exports = Time;
		
	} (time, time.exports));
	return time.exports;
}

var date = {exports: {}};

var hasRequiredDate;

function requireDate () {
	if (hasRequiredDate) return date.exports;
	hasRequiredDate = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _core = require$$0$1;
		// globalDate is to be used for JavaScript's global 'Date' object to avoid name clashing with the 'Date' constant below
		const globalDate = commonjsGlobal.Date;
		const EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
		const NULL_LENGTH = Buffer.from([0x00]);
		const DATA_LENGTH = Buffer.from([0x03]);
		const Date = {
		  id: 0x28,
		  type: 'DATEN',
		  name: 'Date',
		  declaration: function () {
		    return 'date';
		  },
		  generateTypeInfo: function () {
		    return Buffer.from([this.id]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    return DATA_LENGTH;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const value = parameter.value; // Temporary solution. Remove 'any' later.

		    let date;
		    if (options.useUTC) {
		      date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
		    } else {
		      date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
		    }
		    const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
		    const buffer = Buffer.alloc(3);
		    buffer.writeUIntLE(days, 0, 3);
		    yield buffer;
		  },
		  // TODO: value is technically of type 'unknown'.
		  validate: function (value, collation, options) {
		    if (value == null) {
		      return null;
		    }
		    if (!(value instanceof globalDate)) {
		      value = new globalDate(globalDate.parse(value));
		    }
		    value = value;
		    let year;
		    if (options && options.useUTC) {
		      year = value.getUTCFullYear();
		    } else {
		      year = value.getFullYear();
		    }
		    if (year < 1 || year > 9999) {
		      throw new TypeError('Out of range.');
		    }
		    if (isNaN(value)) {
		      throw new TypeError('Invalid date.');
		    }
		    return value;
		  }
		};
		exports$1.default = Date;
		module.exports = Date;
		
	} (date, date.exports));
	return date.exports;
}

var datetime2 = {exports: {}};

var hasRequiredDatetime2;

function requireDatetime2 () {
	if (hasRequiredDatetime2) return datetime2.exports;
	hasRequiredDatetime2 = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _core = require$$0$1;
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
		const NULL_LENGTH = Buffer.from([0x00]);
		const DateTime2 = {
		  id: 0x2A,
		  type: 'DATETIME2N',
		  name: 'DateTime2',
		  declaration: function (parameter) {
		    return 'datetime2(' + this.resolveScale(parameter) + ')';
		  },
		  resolveScale: function (parameter) {
		    if (parameter.scale != null) {
		      return parameter.scale;
		    } else if (parameter.value === null) {
		      return 0;
		    } else {
		      return 7;
		    }
		  },
		  generateTypeInfo(parameter, _options) {
		    return Buffer.from([this.id, parameter.scale]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    switch (parameter.scale) {
		      case 0:
		      case 1:
		      case 2:
		        return Buffer.from([0x06]);
		      case 3:
		      case 4:
		        return Buffer.from([0x07]);
		      case 5:
		      case 6:
		      case 7:
		        return Buffer.from([0x08]);
		      default:
		        throw new Error('invalid scale');
		    }
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const value = parameter.value;
		    let scale = parameter.scale;
		    const buffer = new _writableTrackingBuffer.default(16);
		    scale = scale;
		    let timestamp;
		    if (options.useUTC) {
		      timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1000 + value.getUTCMilliseconds();
		    } else {
		      timestamp = ((value.getHours() * 60 + value.getMinutes()) * 60 + value.getSeconds()) * 1000 + value.getMilliseconds();
		    }
		    timestamp = timestamp * Math.pow(10, scale - 3);
		    timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
		    timestamp = Math.round(timestamp);
		    switch (scale) {
		      case 0:
		      case 1:
		      case 2:
		        buffer.writeUInt24LE(timestamp);
		        break;
		      case 3:
		      case 4:
		        buffer.writeUInt32LE(timestamp);
		        break;
		      case 5:
		      case 6:
		      case 7:
		        buffer.writeUInt40LE(timestamp);
		    }
		    let date;
		    if (options.useUTC) {
		      date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
		    } else {
		      date = _core.LocalDate.of(value.getFullYear(), value.getMonth() + 1, value.getDate());
		    }
		    const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
		    buffer.writeUInt24LE(days);
		    yield buffer.data;
		  },
		  validate: function (value, collation, options) {
		    if (value == null) {
		      return null;
		    }
		    if (!(value instanceof Date)) {
		      value = new Date(Date.parse(value));
		    }
		    value = value;
		    let year;
		    if (options && options.useUTC) {
		      year = value.getUTCFullYear();
		    } else {
		      year = value.getFullYear();
		    }
		    if (year < 1 || year > 9999) {
		      throw new TypeError('Out of range.');
		    }
		    if (isNaN(value)) {
		      throw new TypeError('Invalid date.');
		    }
		    return value;
		  }
		};
		exports$1.default = DateTime2;
		module.exports = DateTime2;
		
	} (datetime2, datetime2.exports));
	return datetime2.exports;
}

var datetimeoffset = {exports: {}};

var hasRequiredDatetimeoffset;

function requireDatetimeoffset () {
	if (hasRequiredDatetimeoffset) return datetimeoffset.exports;
	hasRequiredDatetimeoffset = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _core = require$$0$1;
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const EPOCH_DATE = _core.LocalDate.ofYearDay(1, 1);
		const NULL_LENGTH = Buffer.from([0x00]);
		const DateTimeOffset = {
		  id: 0x2B,
		  type: 'DATETIMEOFFSETN',
		  name: 'DateTimeOffset',
		  declaration: function (parameter) {
		    return 'datetimeoffset(' + this.resolveScale(parameter) + ')';
		  },
		  resolveScale: function (parameter) {
		    if (parameter.scale != null) {
		      return parameter.scale;
		    } else if (parameter.value === null) {
		      return 0;
		    } else {
		      return 7;
		    }
		  },
		  generateTypeInfo(parameter) {
		    return Buffer.from([this.id, parameter.scale]);
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    switch (parameter.scale) {
		      case 0:
		      case 1:
		      case 2:
		        return Buffer.from([0x08]);
		      case 3:
		      case 4:
		        return Buffer.from([0x09]);
		      case 5:
		      case 6:
		      case 7:
		        return Buffer.from([0x0A]);
		      default:
		        throw new Error('invalid scale');
		    }
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      return;
		    }
		    const value = parameter.value;
		    let scale = parameter.scale;
		    const buffer = new _writableTrackingBuffer.default(16);
		    scale = scale;
		    let timestamp;
		    timestamp = ((value.getUTCHours() * 60 + value.getUTCMinutes()) * 60 + value.getUTCSeconds()) * 1000 + value.getMilliseconds();
		    timestamp = timestamp * Math.pow(10, scale - 3);
		    timestamp += (value.nanosecondDelta != null ? value.nanosecondDelta : 0) * Math.pow(10, scale);
		    timestamp = Math.round(timestamp);
		    switch (scale) {
		      case 0:
		      case 1:
		      case 2:
		        buffer.writeUInt24LE(timestamp);
		        break;
		      case 3:
		      case 4:
		        buffer.writeUInt32LE(timestamp);
		        break;
		      case 5:
		      case 6:
		      case 7:
		        buffer.writeUInt40LE(timestamp);
		    }
		    const date = _core.LocalDate.of(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
		    const days = EPOCH_DATE.until(date, _core.ChronoUnit.DAYS);
		    buffer.writeUInt24LE(days);
		    const offset = -value.getTimezoneOffset();
		    buffer.writeInt16LE(offset);
		    yield buffer.data;
		  },
		  validate: function (value, collation, options) {
		    if (value == null) {
		      return null;
		    }
		    if (!(value instanceof Date)) {
		      value = new Date(Date.parse(value));
		    }
		    value = value;
		    let year;
		    if (options && options.useUTC) {
		      year = value.getUTCFullYear();
		    } else {
		      year = value.getFullYear();
		    }
		    if (year < 1 || year > 9999) {
		      throw new TypeError('Out of range.');
		    }
		    if (isNaN(value)) {
		      throw new TypeError('Invalid date.');
		    }
		    return value;
		  }
		};
		exports$1.default = DateTimeOffset;
		module.exports = DateTimeOffset;
		
	} (datetimeoffset, datetimeoffset.exports));
	return datetimeoffset.exports;
}

var udt$1 = {exports: {}};

var hasRequiredUdt$1;

function requireUdt$1 () {
	if (hasRequiredUdt$1) return udt$1.exports;
	hasRequiredUdt$1 = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const UDT = {
		  id: 0xF0,
		  type: 'UDTTYPE',
		  name: 'UDT',
		  declaration() {
		    throw new Error('not implemented');
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = UDT;
		module.exports = UDT;
		
	} (udt$1, udt$1.exports));
	return udt$1.exports;
}

var tvp = {exports: {}};

var hasRequiredTvp;

function requireTvp () {
	if (hasRequiredTvp) return tvp.exports;
	hasRequiredTvp = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _errors = requireErrors$1();
		var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		const TVP_ROW_TOKEN = Buffer.from([0x01]);
		const TVP_END_TOKEN = Buffer.from([0x00]);
		const NULL_LENGTH = Buffer.from([0xFF, 0xFF]);
		const TVP = {
		  id: 0xF3,
		  type: 'TVPTYPE',
		  name: 'TVP',
		  declaration: function (parameter) {
		    const value = parameter.value; // Temporary solution. Remove 'any' later.
		    return value.name + ' readonly';
		  },
		  generateTypeInfo(parameter) {
		    const databaseName = '';
		    const schema = parameter.value?.schema ?? '';
		    const typeName = parameter.value?.name ?? '';
		    const bufferLength = 1 + 1 + Buffer.byteLength(databaseName, 'ucs2') + 1 + Buffer.byteLength(schema, 'ucs2') + 1 + Buffer.byteLength(typeName, 'ucs2');
		    const buffer = new _writableTrackingBuffer.default(bufferLength, 'ucs2');
		    buffer.writeUInt8(this.id);
		    buffer.writeBVarchar(databaseName);
		    buffer.writeBVarchar(schema);
		    buffer.writeBVarchar(typeName);
		    return buffer.data;
		  },
		  generateParameterLength(parameter, options) {
		    if (parameter.value == null) {
		      return NULL_LENGTH;
		    }
		    const {
		      columns
		    } = parameter.value;
		    const buffer = Buffer.alloc(2);
		    buffer.writeUInt16LE(columns.length, 0);
		    return buffer;
		  },
		  *generateParameterData(parameter, options) {
		    if (parameter.value == null) {
		      yield TVP_END_TOKEN;
		      yield TVP_END_TOKEN;
		      return;
		    }
		    const {
		      columns,
		      rows
		    } = parameter.value;
		    for (let i = 0, len = columns.length; i < len; i++) {
		      const column = columns[i];
		      const buff = Buffer.alloc(6);
		      // UserType
		      buff.writeUInt32LE(0x00000000, 0);

		      // Flags
		      buff.writeUInt16LE(0x0000, 4);
		      yield buff;

		      // TYPE_INFO
		      yield column.type.generateTypeInfo(column);

		      // ColName
		      yield Buffer.from([0x00]);
		    }
		    yield TVP_END_TOKEN;
		    for (let i = 0, length = rows.length; i < length; i++) {
		      yield TVP_ROW_TOKEN;
		      const row = rows[i];
		      for (let k = 0, len2 = row.length; k < len2; k++) {
		        const column = columns[k];
		        const value = row[k];
		        let paramValue;
		        try {
		          paramValue = column.type.validate(value, parameter.collation);
		        } catch (error) {
		          throw new _errors.InputError(`TVP column '${column.name}' has invalid data at row index ${i}`, {
		            cause: error
		          });
		        }
		        const param = {
		          value: paramValue,
		          length: column.length,
		          scale: column.scale,
		          precision: column.precision
		        };

		        // TvpColumnData
		        yield column.type.generateParameterLength(param, options);
		        yield* column.type.generateParameterData(param, options);
		      }
		    }
		    yield TVP_END_TOKEN;
		  },
		  validate: function (value) {
		    if (value == null) {
		      return null;
		    }
		    if (typeof value !== 'object') {
		      throw new TypeError('Invalid table.');
		    }
		    if (!Array.isArray(value.columns)) {
		      throw new TypeError('Invalid table.');
		    }
		    if (!Array.isArray(value.rows)) {
		      throw new TypeError('Invalid table.');
		    }
		    return value;
		  }
		};
		exports$1.default = TVP;
		module.exports = TVP;
		
	} (tvp, tvp.exports));
	return tvp.exports;
}

var sqlVariant = {exports: {}};

var hasRequiredSqlVariant;

function requireSqlVariant () {
	if (hasRequiredSqlVariant) return sqlVariant.exports;
	hasRequiredSqlVariant = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const Variant = {
		  id: 0x62,
		  type: 'SSVARIANTTYPE',
		  name: 'Variant',
		  declaration: function () {
		    return 'sql_variant';
		  },
		  generateTypeInfo() {
		    throw new Error('not implemented');
		  },
		  generateParameterLength() {
		    throw new Error('not implemented');
		  },
		  generateParameterData() {
		    throw new Error('not implemented');
		  },
		  validate() {
		    throw new Error('not implemented');
		  }
		};
		exports$1.default = Variant;
		module.exports = Variant;
		
	} (sqlVariant, sqlVariant.exports));
	return sqlVariant.exports;
}

var hasRequiredDataType;

function requireDataType () {
	if (hasRequiredDataType) return dataType;
	hasRequiredDataType = 1;

	Object.defineProperty(dataType, "__esModule", {
	  value: true
	});
	dataType.typeByName = dataType.TYPES = dataType.TYPE = void 0;
	var _null = _interopRequireDefault(require_null());
	var _tinyint = _interopRequireDefault(requireTinyint());
	var _bit = _interopRequireDefault(requireBit());
	var _smallint = _interopRequireDefault(requireSmallint());
	var _int = _interopRequireDefault(requireInt());
	var _smalldatetime = _interopRequireDefault(requireSmalldatetime());
	var _real = _interopRequireDefault(requireReal());
	var _money = _interopRequireDefault(requireMoney());
	var _datetime = _interopRequireDefault(requireDatetime());
	var _float = _interopRequireDefault(requireFloat());
	var _decimal = _interopRequireDefault(requireDecimal());
	var _numeric = _interopRequireDefault(requireNumeric());
	var _smallmoney = _interopRequireDefault(requireSmallmoney());
	var _bigint = _interopRequireDefault(requireBigint());
	var _image = _interopRequireDefault(requireImage());
	var _text = _interopRequireDefault(requireText());
	var _uniqueidentifier = _interopRequireDefault(requireUniqueidentifier());
	var _intn = _interopRequireDefault(requireIntn());
	var _ntext = _interopRequireDefault(requireNtext());
	var _bitn = _interopRequireDefault(requireBitn());
	var _decimaln = _interopRequireDefault(requireDecimaln());
	var _numericn = _interopRequireDefault(requireNumericn());
	var _floatn = _interopRequireDefault(requireFloatn());
	var _moneyn = _interopRequireDefault(requireMoneyn());
	var _datetimen = _interopRequireDefault(requireDatetimen());
	var _varbinary = _interopRequireDefault(requireVarbinary());
	var _varchar = _interopRequireDefault(requireVarchar());
	var _binary = _interopRequireDefault(requireBinary());
	var _char = _interopRequireDefault(requireChar());
	var _nvarchar = _interopRequireDefault(requireNvarchar());
	var _nchar = _interopRequireDefault(requireNchar());
	var _xml = _interopRequireDefault(requireXml());
	var _time = _interopRequireDefault(requireTime());
	var _date = _interopRequireDefault(requireDate());
	var _datetime2 = _interopRequireDefault(requireDatetime2());
	var _datetimeoffset = _interopRequireDefault(requireDatetimeoffset());
	var _udt = _interopRequireDefault(requireUdt$1());
	var _tvp = _interopRequireDefault(requireTvp());
	var _sqlVariant = _interopRequireDefault(requireSqlVariant());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	dataType.TYPE = {
	  [_null.default.id]: _null.default,
	  [_tinyint.default.id]: _tinyint.default,
	  [_bit.default.id]: _bit.default,
	  [_smallint.default.id]: _smallint.default,
	  [_int.default.id]: _int.default,
	  [_smalldatetime.default.id]: _smalldatetime.default,
	  [_real.default.id]: _real.default,
	  [_money.default.id]: _money.default,
	  [_datetime.default.id]: _datetime.default,
	  [_float.default.id]: _float.default,
	  [_decimal.default.id]: _decimal.default,
	  [_numeric.default.id]: _numeric.default,
	  [_smallmoney.default.id]: _smallmoney.default,
	  [_bigint.default.id]: _bigint.default,
	  [_image.default.id]: _image.default,
	  [_text.default.id]: _text.default,
	  [_uniqueidentifier.default.id]: _uniqueidentifier.default,
	  [_intn.default.id]: _intn.default,
	  [_ntext.default.id]: _ntext.default,
	  [_bitn.default.id]: _bitn.default,
	  [_decimaln.default.id]: _decimaln.default,
	  [_numericn.default.id]: _numericn.default,
	  [_floatn.default.id]: _floatn.default,
	  [_moneyn.default.id]: _moneyn.default,
	  [_datetimen.default.id]: _datetimen.default,
	  [_varbinary.default.id]: _varbinary.default,
	  [_varchar.default.id]: _varchar.default,
	  [_binary.default.id]: _binary.default,
	  [_char.default.id]: _char.default,
	  [_nvarchar.default.id]: _nvarchar.default,
	  [_nchar.default.id]: _nchar.default,
	  [_xml.default.id]: _xml.default,
	  [_time.default.id]: _time.default,
	  [_date.default.id]: _date.default,
	  [_datetime2.default.id]: _datetime2.default,
	  [_datetimeoffset.default.id]: _datetimeoffset.default,
	  [_udt.default.id]: _udt.default,
	  [_tvp.default.id]: _tvp.default,
	  [_sqlVariant.default.id]: _sqlVariant.default
	};

	/**
	 * <table>
	 * <thead>
	 *   <tr>
	 *     <th>Type</th>
	 *     <th>Constant</th>
	 *     <th>JavaScript</th>
	 *     <th>Result set</th>
	 *     <th>Parameter</th>
	 *   </tr>
	 * </thead>
	 *
	 * <tbody>
	 *   <tr class="group-heading">
	 *     <th colspan="5">Exact numerics</th>
	 *   </tr>
	 *   <tr>
	 *     <td><code>bit</code></td>
	 *     <td><code>[[TYPES.Bit]]</code></td>
	 *     <td><code>boolean</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>tinyint</code></td>
	 *     <td><code>[[TYPES.TinyInt]]</code></td>
	 *     <td><code>number</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>smallint</code></td>
	 *     <td><code>[[TYPES.SmallInt]]</code></td>
	 *     <td><code>number</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>int</code></td>
	 *     <td><code>[[TYPES.Int]]</code></td>
	 *     <td><code>number</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>bigint</code><sup>1</sup></td>
	 *     <td><code>[[TYPES.BigInt]]</code></td>
	 *     <td><code>string</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>numeric</code><sup>2</sup></td>
	 *     <td><code>[[TYPES.Numeric]]</code></td>
	 *     <td><code>number</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>decimal</code><sup>2</sup></td>
	 *     <td><code>[[TYPES.Decimal]]</code></td>
	 *     <td><code>number</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>smallmoney</code></td>
	 *     <td><code>[[TYPES.SmallMoney]]</code></td>
	 *     <td><code>number</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>money</code></td>
	 *     <td><code>[[TYPES.Money]]</code></td>
	 *     <td><code>number</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 * </tbody>
	 *
	 * <tbody>
	 *   <tr class="group-heading">
	 *     <th colspan="5">Approximate numerics</th>
	 *   </tr>
	 *   <tr>
	 *     <td><code>float</code></td>
	 *     <td><code>[[TYPES.Float]]</code></td>
	 *     <td><code>number</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>real</code></td>
	 *     <td><code>[[TYPES.Real]]</code></td>
	 *     <td><code>number</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 * </tbody>
	 *
	 * <tbody>
	 *   <tr class="group-heading">
	 *     <th colspan="4">Date and Time</th>
	 *   </tr>
	 *   <tr>
	 *     <td><code>smalldatetime</code></td>
	 *     <td><code>[[TYPES.SmallDateTime]]</code></td>
	 *     <td><code>Date</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>datetime</code></td>
	 *     <td><code>[[TYPES.DateTime]]</code></td>
	 *     <td><code>Date</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>datetime2</code></td>
	 *     <td><code>[[TYPES.DateTime2]]</code></td>
	 *     <td><code>Date</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>datetimeoffset</code></td>
	 *     <td><code>[[TYPES.DateTimeOffset]]</code></td>
	 *     <td><code>Date</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>time</code></td>
	 *     <td><code>[[TYPES.Time]]</code></td>
	 *     <td><code>Date</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>date</code></td>
	 *     <td><code>[[TYPES.Date]]</code></td>
	 *     <td><code>Date</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 * </tbody>
	 *
	 * <tbody>
	 *   <tr class="group-heading">
	 *     <th colspan="4">Character Strings</th>
	 *   </tr>
	 *   <tr>
	 *     <td><code>char</code></td>
	 *     <td><code>[[TYPES.Char]]</code></td>
	 *     <td><code>string</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>varchar</code><sup>3</sup></td>
	 *     <td><code>[[TYPES.VarChar]]</code></td>
	 *     <td><code>string</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>text</code></td>
	 *     <td><code>[[TYPES.Text]]</code></td>
	 *     <td><code>string</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 * </tbody>
	 *
	 * <tbody>
	 *   <tr class="group-heading">
	 *     <th colspan="4">Unicode Strings</th>
	 *   </tr>
	 *   <tr>
	 *     <td><code>nchar</code></td>
	 *     <td><code>[[TYPES.NChar]]</code></td>
	 *     <td><code>string</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>nvarchar</code><sup>3</sup></td>
	 *     <td><code>[[TYPES.NVarChar]]</code></td>
	 *     <td><code>string</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>ntext</code></td>
	 *     <td><code>[[TYPES.NText]]</code></td>
	 *     <td><code>string</code></td>
	 *     <td></td>
	 *     <td>-</td>
	 *   </tr>
	 * </tbody>
	 *
	 * <tbody>
	 *   <tr class="group-heading">
	 *     <th colspan="5">Binary Strings<sup>4</sup></th>
	 *   </tr>
	 *   <tr>
	 *     <td><code>binary</code></td>
	 *     <td><code>[[TYPES.Binary]]</code></td>
	 *     <td><code>Buffer</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>varbinary</code></td>
	 *     <td><code>[[TYPES.VarBinary]]</code></td>
	 *     <td><code>Buffer</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>image</code></td>
	 *     <td><code>[[TYPES.Image]]</code></td>
	 *     <td><code>Buffer</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 * </tbody>
	 *
	 * <tbody>
	 *   <tr class="group-heading">
	 *     <th colspan="5">Other Data Types</th>
	 *   </tr>
	 *   <tr>
	 *     <td><code>TVP</code></td>
	 *     <td><code>[[TYPES.TVP]]</code></td>
	 *     <td><code>Object</code></td>
	 *     <td>-</td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>UDT</code></td>
	 *     <td><code>[[TYPES.UDT]]</code></td>
	 *     <td><code>Buffer</code></td>
	 *     <td></td>
	 *     <td>-</td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>uniqueidentifier</code><sup>4</sup></td>
	 *     <td><code>[[TYPES.UniqueIdentifier]]</code></td>
	 *     <td><code>string</code></td>
	 *     <td></td>
	 *     <td></td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>variant</code></td>
	 *     <td><code>[[TYPES.Variant]]</code></td>
	 *     <td><code>any</code></td>
	 *     <td></td>
	 *     <td>-</td>
	 *   </tr>
	 *   <tr>
	 *     <td><code>xml</code></td>
	 *     <td><code>[[TYPES.Xml]]</code></td>
	 *     <td><code>string</code></td>
	 *     <td></td>
	 *     <td>-</td>
	 *   </tr>
	 * </tbody>
	 * </table>
	 *
	 * <ol>
	 *   <li>
	 *     <h4>BigInt</h4>
	 *     <p>
	 *       Values are returned as a string. This is because values can exceed 53 bits of significant data, which is greater than a
	 *       Javascript <code>number</code> type can represent as an integer.
	 *     </p>
	 *   </li>
	 *   <li>
	 *     <h4>Numerical, Decimal</h4>
	 *     <p>
	 *       For input parameters, default precision is 18 and default scale is 0. Maximum supported precision is 19.
	 *     </p>
	 *   </li>
	 *   <li>
	 *     <h4>VarChar, NVarChar</h4>
	 *     <p>
	 *       <code>varchar(max)</code> and <code>nvarchar(max)</code> are also supported.
	 *     </p>
	 *   </li>
	 *   <li>
	 *     <h4>UniqueIdentifier</h4>
	 *     <p>
	 *       Values are returned as a 16 byte hexadecimal string.
	 *     </p>
	 *     <p>
	 *       Note that the order of bytes is not the same as the character representation. See
	 *       <a href="http://msdn.microsoft.com/en-us/library/ms190215.aspx">Using uniqueidentifier Data</a>
	 *       for an example of the different ordering of bytes.
	 *     </p>
	 *   </li>
	 * </ol>
	 */
	const TYPES = dataType.TYPES = {
	  TinyInt: _tinyint.default,
	  Bit: _bit.default,
	  SmallInt: _smallint.default,
	  Int: _int.default,
	  SmallDateTime: _smalldatetime.default,
	  Real: _real.default,
	  Money: _money.default,
	  DateTime: _datetime.default,
	  Float: _float.default,
	  Decimal: _decimal.default,
	  Numeric: _numeric.default,
	  SmallMoney: _smallmoney.default,
	  BigInt: _bigint.default,
	  Image: _image.default,
	  Text: _text.default,
	  UniqueIdentifier: _uniqueidentifier.default,
	  NText: _ntext.default,
	  VarBinary: _varbinary.default,
	  VarChar: _varchar.default,
	  Binary: _binary.default,
	  Char: _char.default,
	  NVarChar: _nvarchar.default,
	  NChar: _nchar.default,
	  Xml: _xml.default,
	  Time: _time.default,
	  Date: _date.default,
	  DateTime2: _datetime2.default,
	  DateTimeOffset: _datetimeoffset.default,
	  UDT: _udt.default,
	  TVP: _tvp.default,
	  Variant: _sqlVariant.default
	};
	dataType.typeByName = TYPES;
	
	return dataType;
}

var helpers = {};

var hasRequiredHelpers;

function requireHelpers () {
	if (hasRequiredHelpers) return helpers;
	hasRequiredHelpers = 1;

	Object.defineProperty(helpers, "__esModule", {
	  value: true
	});
	helpers.Result = helpers.NotEnoughDataError = void 0;
	helpers.readBVarByte = readBVarByte;
	helpers.readBVarChar = readBVarChar;
	helpers.readBigInt64LE = readBigInt64LE;
	helpers.readBigUInt64LE = readBigUInt64LE;
	helpers.readDoubleLE = readDoubleLE;
	helpers.readFloatLE = readFloatLE;
	helpers.readInt16LE = readInt16LE;
	helpers.readInt32LE = readInt32LE;
	helpers.readUInt16LE = readUInt16LE;
	helpers.readUInt24LE = readUInt24LE;
	helpers.readUInt32BE = readUInt32BE;
	helpers.readUInt32LE = readUInt32LE;
	helpers.readUInt40LE = readUInt40LE;
	helpers.readUInt8 = readUInt8;
	helpers.readUNumeric128LE = readUNumeric128LE;
	helpers.readUNumeric64LE = readUNumeric64LE;
	helpers.readUNumeric96LE = readUNumeric96LE;
	helpers.readUsVarByte = readUsVarByte;
	helpers.readUsVarChar = readUsVarChar;
	class Result {
	  constructor(value, offset) {
	    this.value = value;
	    this.offset = offset;
	  }
	}
	helpers.Result = Result;
	class NotEnoughDataError extends Error {
	  byteCount;
	  constructor(byteCount) {
	    super();
	    this.byteCount = byteCount;
	  }
	}
	helpers.NotEnoughDataError = NotEnoughDataError;
	function readUInt8(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 1) {
	    throw new NotEnoughDataError(offset + 1);
	  }
	  return new Result(buf.readUInt8(offset), offset + 1);
	}
	function readUInt16LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 2) {
	    throw new NotEnoughDataError(offset + 2);
	  }
	  return new Result(buf.readUInt16LE(offset), offset + 2);
	}
	function readInt16LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 2) {
	    throw new NotEnoughDataError(offset + 2);
	  }
	  return new Result(buf.readInt16LE(offset), offset + 2);
	}
	function readUInt24LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 3) {
	    throw new NotEnoughDataError(offset + 3);
	  }
	  return new Result(buf.readUIntLE(offset, 3), offset + 3);
	}
	function readUInt32LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 4) {
	    throw new NotEnoughDataError(offset + 4);
	  }
	  return new Result(buf.readUInt32LE(offset), offset + 4);
	}
	function readUInt32BE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 4) {
	    throw new NotEnoughDataError(offset + 4);
	  }
	  return new Result(buf.readUInt32BE(offset), offset + 4);
	}
	function readUInt40LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 5) {
	    throw new NotEnoughDataError(offset + 5);
	  }
	  return new Result(buf.readUIntLE(offset, 5), offset + 5);
	}
	function readInt32LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 4) {
	    throw new NotEnoughDataError(offset + 4);
	  }
	  return new Result(buf.readInt32LE(offset), offset + 4);
	}
	function readBigUInt64LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 8) {
	    throw new NotEnoughDataError(offset + 8);
	  }
	  return new Result(buf.readBigUInt64LE(offset), offset + 8);
	}
	function readBigInt64LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 8) {
	    throw new NotEnoughDataError(offset + 8);
	  }
	  return new Result(buf.readBigInt64LE(offset), offset + 8);
	}
	function readFloatLE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 4) {
	    throw new NotEnoughDataError(offset + 4);
	  }
	  return new Result(buf.readFloatLE(offset), offset + 4);
	}
	function readDoubleLE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 8) {
	    throw new NotEnoughDataError(offset + 8);
	  }
	  return new Result(buf.readDoubleLE(offset), offset + 8);
	}
	function readBVarChar(buf, offset) {
	  offset = +offset;
	  let charCount;
	  ({
	    offset,
	    value: charCount
	  } = readUInt8(buf, offset));
	  const byteLength = charCount * 2;
	  if (buf.length < offset + byteLength) {
	    throw new NotEnoughDataError(offset + byteLength);
	  }
	  return new Result(buf.toString('ucs2', offset, offset + byteLength), offset + byteLength);
	}
	function readBVarByte(buf, offset) {
	  offset = +offset;
	  let byteLength;
	  ({
	    offset,
	    value: byteLength
	  } = readUInt8(buf, offset));
	  if (buf.length < offset + byteLength) {
	    throw new NotEnoughDataError(offset + byteLength);
	  }
	  return new Result(buf.slice(offset, offset + byteLength), offset + byteLength);
	}
	function readUsVarChar(buf, offset) {
	  offset = +offset;
	  let charCount;
	  ({
	    offset,
	    value: charCount
	  } = readUInt16LE(buf, offset));
	  const byteLength = charCount * 2;
	  if (buf.length < offset + byteLength) {
	    throw new NotEnoughDataError(offset + byteLength);
	  }
	  return new Result(buf.toString('ucs2', offset, offset + byteLength), offset + byteLength);
	}
	function readUsVarByte(buf, offset) {
	  offset = +offset;
	  let byteLength;
	  ({
	    offset,
	    value: byteLength
	  } = readUInt16LE(buf, offset));
	  if (buf.length < offset + byteLength) {
	    throw new NotEnoughDataError(offset + byteLength);
	  }
	  return new Result(buf.slice(offset, offset + byteLength), offset + byteLength);
	}
	function readUNumeric64LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 8) {
	    throw new NotEnoughDataError(offset + 8);
	  }
	  const low = buf.readUInt32LE(offset);
	  const high = buf.readUInt32LE(offset + 4);
	  return new Result(0x100000000 * high + low, offset + 8);
	}
	function readUNumeric96LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 12) {
	    throw new NotEnoughDataError(offset + 12);
	  }
	  const dword1 = buf.readUInt32LE(offset);
	  const dword2 = buf.readUInt32LE(offset + 4);
	  const dword3 = buf.readUInt32LE(offset + 8);
	  return new Result(dword1 + 0x100000000 * dword2 + 0x100000000 * 0x100000000 * dword3, offset + 12);
	}
	function readUNumeric128LE(buf, offset) {
	  offset = +offset;
	  if (buf.length < offset + 16) {
	    throw new NotEnoughDataError(offset + 16);
	  }
	  const dword1 = buf.readUInt32LE(offset);
	  const dword2 = buf.readUInt32LE(offset + 4);
	  const dword3 = buf.readUInt32LE(offset + 8);
	  const dword4 = buf.readUInt32LE(offset + 12);
	  return new Result(dword1 + 0x100000000 * dword2 + 0x100000000 * 0x100000000 * dword3 + 0x100000000 * 0x100000000 * 0x100000000 * dword4, offset + 16);
	}
	
	return helpers;
}

var hasRequiredMetadataParser;

function requireMetadataParser () {
	if (hasRequiredMetadataParser) return metadataParser.exports;
	hasRequiredMetadataParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		exports$1.readCollation = readCollation;
		exports$1.readMetadata = readMetadata;
		var _collation = requireCollation();
		var _dataType = requireDataType();
		var _sprintfJs = requireSprintf();
		var _helpers = requireHelpers();
		function readCollation(buf, offset) {
		  offset = +offset;
		  if (buf.length < offset + 5) {
		    throw new _helpers.NotEnoughDataError(offset + 5);
		  }
		  const collation = _collation.Collation.fromBuffer(buf.slice(offset, offset + 5));
		  return new _helpers.Result(collation, offset + 5);
		}
		function readSchema(buf, offset) {
		  offset = +offset;
		  let schemaPresent;
		  ({
		    offset,
		    value: schemaPresent
		  } = (0, _helpers.readUInt8)(buf, offset));
		  if (schemaPresent !== 0x01) {
		    return new _helpers.Result(undefined, offset);
		  }
		  let dbname;
		  ({
		    offset,
		    value: dbname
		  } = (0, _helpers.readBVarChar)(buf, offset));
		  let owningSchema;
		  ({
		    offset,
		    value: owningSchema
		  } = (0, _helpers.readBVarChar)(buf, offset));
		  let xmlSchemaCollection;
		  ({
		    offset,
		    value: xmlSchemaCollection
		  } = (0, _helpers.readUsVarChar)(buf, offset));
		  return new _helpers.Result({
		    dbname,
		    owningSchema,
		    xmlSchemaCollection
		  }, offset);
		}
		function readUDTInfo(buf, offset) {
		  let maxByteSize;
		  ({
		    offset,
		    value: maxByteSize
		  } = (0, _helpers.readUInt16LE)(buf, offset));
		  let dbname;
		  ({
		    offset,
		    value: dbname
		  } = (0, _helpers.readBVarChar)(buf, offset));
		  let owningSchema;
		  ({
		    offset,
		    value: owningSchema
		  } = (0, _helpers.readBVarChar)(buf, offset));
		  let typeName;
		  ({
		    offset,
		    value: typeName
		  } = (0, _helpers.readBVarChar)(buf, offset));
		  let assemblyName;
		  ({
		    offset,
		    value: assemblyName
		  } = (0, _helpers.readUsVarChar)(buf, offset));
		  return new _helpers.Result({
		    maxByteSize: maxByteSize,
		    dbname: dbname,
		    owningSchema: owningSchema,
		    typeName: typeName,
		    assemblyName: assemblyName
		  }, offset);
		}
		function readMetadata(buf, offset, options) {
		  let userType;
		  ({
		    offset,
		    value: userType
		  } = (options.tdsVersion < '7_2' ? _helpers.readUInt16LE : _helpers.readUInt32LE)(buf, offset));
		  let flags;
		  ({
		    offset,
		    value: flags
		  } = (0, _helpers.readUInt16LE)(buf, offset));
		  let typeNumber;
		  ({
		    offset,
		    value: typeNumber
		  } = (0, _helpers.readUInt8)(buf, offset));
		  const type = _dataType.TYPE[typeNumber];
		  if (!type) {
		    throw new Error((0, _sprintfJs.sprintf)('Unrecognised data type 0x%02X', typeNumber));
		  }
		  switch (type.name) {
		    case 'Null':
		    case 'TinyInt':
		    case 'SmallInt':
		    case 'Int':
		    case 'BigInt':
		    case 'Real':
		    case 'Float':
		    case 'SmallMoney':
		    case 'Money':
		    case 'Bit':
		    case 'SmallDateTime':
		    case 'DateTime':
		    case 'Date':
		      return new _helpers.Result({
		        userType: userType,
		        flags: flags,
		        type: type,
		        collation: undefined,
		        precision: undefined,
		        scale: undefined,
		        dataLength: undefined,
		        schema: undefined,
		        udtInfo: undefined
		      }, offset);
		    case 'IntN':
		    case 'FloatN':
		    case 'MoneyN':
		    case 'BitN':
		    case 'UniqueIdentifier':
		    case 'DateTimeN':
		      {
		        let dataLength;
		        ({
		          offset,
		          value: dataLength
		        } = (0, _helpers.readUInt8)(buf, offset));
		        return new _helpers.Result({
		          userType: userType,
		          flags: flags,
		          type: type,
		          collation: undefined,
		          precision: undefined,
		          scale: undefined,
		          dataLength: dataLength,
		          schema: undefined,
		          udtInfo: undefined
		        }, offset);
		      }
		    case 'Variant':
		      {
		        let dataLength;
		        ({
		          offset,
		          value: dataLength
		        } = (0, _helpers.readUInt32LE)(buf, offset));
		        return new _helpers.Result({
		          userType: userType,
		          flags: flags,
		          type: type,
		          collation: undefined,
		          precision: undefined,
		          scale: undefined,
		          dataLength: dataLength,
		          schema: undefined,
		          udtInfo: undefined
		        }, offset);
		      }
		    case 'VarChar':
		    case 'Char':
		    case 'NVarChar':
		    case 'NChar':
		      {
		        let dataLength;
		        ({
		          offset,
		          value: dataLength
		        } = (0, _helpers.readUInt16LE)(buf, offset));
		        let collation;
		        ({
		          offset,
		          value: collation
		        } = readCollation(buf, offset));
		        return new _helpers.Result({
		          userType: userType,
		          flags: flags,
		          type: type,
		          collation: collation,
		          precision: undefined,
		          scale: undefined,
		          dataLength: dataLength,
		          schema: undefined,
		          udtInfo: undefined
		        }, offset);
		      }
		    case 'Text':
		    case 'NText':
		      {
		        let dataLength;
		        ({
		          offset,
		          value: dataLength
		        } = (0, _helpers.readUInt32LE)(buf, offset));
		        let collation;
		        ({
		          offset,
		          value: collation
		        } = readCollation(buf, offset));
		        return new _helpers.Result({
		          userType: userType,
		          flags: flags,
		          type: type,
		          collation: collation,
		          precision: undefined,
		          scale: undefined,
		          dataLength: dataLength,
		          schema: undefined,
		          udtInfo: undefined
		        }, offset);
		      }
		    case 'VarBinary':
		    case 'Binary':
		      {
		        let dataLength;
		        ({
		          offset,
		          value: dataLength
		        } = (0, _helpers.readUInt16LE)(buf, offset));
		        return new _helpers.Result({
		          userType: userType,
		          flags: flags,
		          type: type,
		          collation: undefined,
		          precision: undefined,
		          scale: undefined,
		          dataLength: dataLength,
		          schema: undefined,
		          udtInfo: undefined
		        }, offset);
		      }
		    case 'Image':
		      {
		        let dataLength;
		        ({
		          offset,
		          value: dataLength
		        } = (0, _helpers.readUInt32LE)(buf, offset));
		        return new _helpers.Result({
		          userType: userType,
		          flags: flags,
		          type: type,
		          collation: undefined,
		          precision: undefined,
		          scale: undefined,
		          dataLength: dataLength,
		          schema: undefined,
		          udtInfo: undefined
		        }, offset);
		      }
		    case 'Xml':
		      {
		        let schema;
		        ({
		          offset,
		          value: schema
		        } = readSchema(buf, offset));
		        return new _helpers.Result({
		          userType: userType,
		          flags: flags,
		          type: type,
		          collation: undefined,
		          precision: undefined,
		          scale: undefined,
		          dataLength: undefined,
		          schema: schema,
		          udtInfo: undefined
		        }, offset);
		      }
		    case 'Time':
		    case 'DateTime2':
		    case 'DateTimeOffset':
		      {
		        let scale;
		        ({
		          offset,
		          value: scale
		        } = (0, _helpers.readUInt8)(buf, offset));
		        return new _helpers.Result({
		          userType: userType,
		          flags: flags,
		          type: type,
		          collation: undefined,
		          precision: undefined,
		          scale: scale,
		          dataLength: undefined,
		          schema: undefined,
		          udtInfo: undefined
		        }, offset);
		      }
		    case 'NumericN':
		    case 'DecimalN':
		      {
		        let dataLength;
		        ({
		          offset,
		          value: dataLength
		        } = (0, _helpers.readUInt8)(buf, offset));
		        let precision;
		        ({
		          offset,
		          value: precision
		        } = (0, _helpers.readUInt8)(buf, offset));
		        let scale;
		        ({
		          offset,
		          value: scale
		        } = (0, _helpers.readUInt8)(buf, offset));
		        return new _helpers.Result({
		          userType: userType,
		          flags: flags,
		          type: type,
		          collation: undefined,
		          precision: precision,
		          scale: scale,
		          dataLength: dataLength,
		          schema: undefined,
		          udtInfo: undefined
		        }, offset);
		      }
		    case 'UDT':
		      {
		        let udtInfo;
		        ({
		          offset,
		          value: udtInfo
		        } = readUDTInfo(buf, offset));
		        return new _helpers.Result({
		          userType: userType,
		          flags: flags,
		          type: type,
		          collation: undefined,
		          precision: undefined,
		          scale: undefined,
		          dataLength: undefined,
		          schema: undefined,
		          udtInfo: udtInfo
		        }, offset);
		      }
		    default:
		      throw new Error((0, _sprintfJs.sprintf)('Unrecognised type %s', type.name));
		  }
		}
		function metadataParse(parser, options, callback) {
		  (async () => {
		    while (true) {
		      let result;
		      try {
		        result = readMetadata(parser.buffer, parser.position, options);
		      } catch (err) {
		        if (err instanceof _helpers.NotEnoughDataError) {
		          await parser.waitForChunk();
		          continue;
		        }
		        throw err;
		      }
		      parser.position = result.offset;
		      return callback(result.value);
		    }
		  })();
		}
		exports$1.default = metadataParse;
		module.exports = metadataParse;
		module.exports.readCollation = readCollation;
		module.exports.readMetadata = readMetadata;
		
	} (metadataParser, metadataParser.exports));
	return metadataParser.exports;
}

var hasRequiredColmetadataTokenParser;

function requireColmetadataTokenParser () {
	if (hasRequiredColmetadataTokenParser) return colmetadataTokenParser.exports;
	hasRequiredColmetadataTokenParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _metadataParser = requireMetadataParser();
		var _token = requireToken();
		var _helpers = requireHelpers();
		function readTableName(buf, offset, metadata, options) {
		  if (!metadata.type.hasTableName) {
		    return new _helpers.Result(undefined, offset);
		  }
		  if (options.tdsVersion < '7_2') {
		    return (0, _helpers.readUsVarChar)(buf, offset);
		  }
		  let numberOfTableNameParts;
		  ({
		    offset,
		    value: numberOfTableNameParts
		  } = (0, _helpers.readUInt8)(buf, offset));
		  const tableName = [];
		  for (let i = 0; i < numberOfTableNameParts; i++) {
		    let tableNamePart;
		    ({
		      offset,
		      value: tableNamePart
		    } = (0, _helpers.readUsVarChar)(buf, offset));
		    tableName.push(tableNamePart);
		  }
		  return new _helpers.Result(tableName, offset);
		}
		function readColumnName(buf, offset, index, metadata, options) {
		  let colName;
		  ({
		    offset,
		    value: colName
		  } = (0, _helpers.readBVarChar)(buf, offset));
		  if (options.columnNameReplacer) {
		    return new _helpers.Result(options.columnNameReplacer(colName, index, metadata), offset);
		  } else if (options.camelCaseColumns) {
		    return new _helpers.Result(colName.replace(/^[A-Z]/, function (s) {
		      return s.toLowerCase();
		    }), offset);
		  } else {
		    return new _helpers.Result(colName, offset);
		  }
		}
		function readColumn(buf, offset, options, index) {
		  let metadata;
		  ({
		    offset,
		    value: metadata
		  } = (0, _metadataParser.readMetadata)(buf, offset, options));
		  let tableName;
		  ({
		    offset,
		    value: tableName
		  } = readTableName(buf, offset, metadata, options));
		  let colName;
		  ({
		    offset,
		    value: colName
		  } = readColumnName(buf, offset, index, metadata, options));
		  return new _helpers.Result({
		    userType: metadata.userType,
		    flags: metadata.flags,
		    type: metadata.type,
		    collation: metadata.collation,
		    precision: metadata.precision,
		    scale: metadata.scale,
		    udtInfo: metadata.udtInfo,
		    dataLength: metadata.dataLength,
		    schema: metadata.schema,
		    colName: colName,
		    tableName: tableName
		  }, offset);
		}
		async function colMetadataParser(parser) {
		  let columnCount;
		  while (true) {
		    let offset;
		    try {
		      ({
		        offset,
		        value: columnCount
		      } = (0, _helpers.readUInt16LE)(parser.buffer, parser.position));
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        await parser.waitForChunk();
		        continue;
		      }
		      throw err;
		    }
		    parser.position = offset;
		    break;
		  }
		  const columns = [];
		  for (let i = 0; i < columnCount; i++) {
		    while (true) {
		      let column;
		      let offset;
		      try {
		        ({
		          offset,
		          value: column
		        } = readColumn(parser.buffer, parser.position, parser.options, i));
		      } catch (err) {
		        if (err instanceof _helpers.NotEnoughDataError) {
		          await parser.waitForChunk();
		          continue;
		        }
		        throw err;
		      }
		      parser.position = offset;
		      columns.push(column);
		      break;
		    }
		  }
		  return new _token.ColMetadataToken(columns);
		}
		exports$1.default = colMetadataParser;
		module.exports = colMetadataParser;
		
	} (colmetadataTokenParser, colmetadataTokenParser.exports));
	return colmetadataTokenParser.exports;
}

var doneTokenParser = {};

var hasRequiredDoneTokenParser;

function requireDoneTokenParser () {
	if (hasRequiredDoneTokenParser) return doneTokenParser;
	hasRequiredDoneTokenParser = 1;

	Object.defineProperty(doneTokenParser, "__esModule", {
	  value: true
	});
	doneTokenParser.doneInProcParser = doneInProcParser;
	doneTokenParser.doneParser = doneParser;
	doneTokenParser.doneProcParser = doneProcParser;
	var _token = requireToken();
	var _helpers = requireHelpers();
	// s2.2.7.5/6/7

	const STATUS = {
	  MORE: 0x0001,
	  ERROR: 0x0002,
	  COUNT: 0x0010,
	  ATTN: 0x0020,
	  SRVERROR: 0x0100
	};
	function readToken(buf, offset, options) {
	  let status;
	  ({
	    offset,
	    value: status
	  } = (0, _helpers.readUInt16LE)(buf, offset));
	  const more = !!(status & STATUS.MORE);
	  const sqlError = !!(status & STATUS.ERROR);
	  const rowCountValid = !!(status & STATUS.COUNT);
	  const attention = !!(status & STATUS.ATTN);
	  const serverError = !!(status & STATUS.SRVERROR);
	  let curCmd;
	  ({
	    offset,
	    value: curCmd
	  } = (0, _helpers.readUInt16LE)(buf, offset));
	  let rowCount;
	  ({
	    offset,
	    value: rowCount
	  } = (options.tdsVersion < '7_2' ? _helpers.readUInt32LE : _helpers.readBigUInt64LE)(buf, offset));
	  return new _helpers.Result({
	    more: more,
	    sqlError: sqlError,
	    attention: attention,
	    serverError: serverError,
	    rowCount: rowCountValid ? Number(rowCount) : undefined,
	    curCmd: curCmd
	  }, offset);
	}
	function doneParser(buf, offset, options) {
	  let value;
	  ({
	    offset,
	    value
	  } = readToken(buf, offset, options));
	  return new _helpers.Result(new _token.DoneToken(value), offset);
	}
	function doneInProcParser(buf, offset, options) {
	  let value;
	  ({
	    offset,
	    value
	  } = readToken(buf, offset, options));
	  return new _helpers.Result(new _token.DoneInProcToken(value), offset);
	}
	function doneProcParser(buf, offset, options) {
	  let value;
	  ({
	    offset,
	    value
	  } = readToken(buf, offset, options));
	  return new _helpers.Result(new _token.DoneProcToken(value), offset);
	}
	
	return doneTokenParser;
}

var envChangeTokenParser = {exports: {}};

var hasRequiredEnvChangeTokenParser;

function requireEnvChangeTokenParser () {
	if (hasRequiredEnvChangeTokenParser) return envChangeTokenParser.exports;
	hasRequiredEnvChangeTokenParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _collation = requireCollation();
		var _token = requireToken();
		var _helpers = requireHelpers();
		const types = {
		  1: {
		    name: 'DATABASE',
		    event: 'databaseChange'
		  },
		  2: {
		    name: 'LANGUAGE',
		    event: 'languageChange'
		  },
		  3: {
		    name: 'CHARSET',
		    event: 'charsetChange'
		  },
		  4: {
		    name: 'PACKET_SIZE',
		    event: 'packetSizeChange'
		  },
		  7: {
		    name: 'SQL_COLLATION',
		    event: 'sqlCollationChange'
		  },
		  8: {
		    name: 'BEGIN_TXN',
		    event: 'beginTransaction'
		  },
		  9: {
		    name: 'COMMIT_TXN',
		    event: 'commitTransaction'
		  },
		  10: {
		    name: 'ROLLBACK_TXN',
		    event: 'rollbackTransaction'
		  },
		  13: {
		    name: 'DATABASE_MIRRORING_PARTNER',
		    event: 'partnerNode'
		  },
		  17: {
		    name: 'TXN_ENDED'
		  },
		  18: {
		    name: 'RESET_CONNECTION',
		    event: 'resetConnection'
		  },
		  20: {
		    name: 'ROUTING_CHANGE',
		    event: 'routingChange'
		  }
		};
		function _readNewAndOldValue(buf, offset, length, type) {
		  switch (type.name) {
		    case 'DATABASE':
		    case 'LANGUAGE':
		    case 'CHARSET':
		    case 'PACKET_SIZE':
		    case 'DATABASE_MIRRORING_PARTNER':
		      {
		        let newValue;
		        ({
		          offset,
		          value: newValue
		        } = (0, _helpers.readBVarChar)(buf, offset));
		        let oldValue;
		        ({
		          offset,
		          value: oldValue
		        } = (0, _helpers.readBVarChar)(buf, offset));
		        switch (type.name) {
		          case 'PACKET_SIZE':
		            return new _helpers.Result(new _token.PacketSizeEnvChangeToken(parseInt(newValue), parseInt(oldValue)), offset);
		          case 'DATABASE':
		            return new _helpers.Result(new _token.DatabaseEnvChangeToken(newValue, oldValue), offset);
		          case 'LANGUAGE':
		            return new _helpers.Result(new _token.LanguageEnvChangeToken(newValue, oldValue), offset);
		          case 'CHARSET':
		            return new _helpers.Result(new _token.CharsetEnvChangeToken(newValue, oldValue), offset);
		          case 'DATABASE_MIRRORING_PARTNER':
		            return new _helpers.Result(new _token.DatabaseMirroringPartnerEnvChangeToken(newValue, oldValue), offset);
		        }
		        throw new Error('unreachable');
		      }
		    case 'SQL_COLLATION':
		    case 'BEGIN_TXN':
		    case 'COMMIT_TXN':
		    case 'ROLLBACK_TXN':
		    case 'RESET_CONNECTION':
		      {
		        let newValue;
		        ({
		          offset,
		          value: newValue
		        } = (0, _helpers.readBVarByte)(buf, offset));
		        let oldValue;
		        ({
		          offset,
		          value: oldValue
		        } = (0, _helpers.readBVarByte)(buf, offset));
		        switch (type.name) {
		          case 'SQL_COLLATION':
		            {
		              const newCollation = newValue.length ? _collation.Collation.fromBuffer(newValue) : undefined;
		              const oldCollation = oldValue.length ? _collation.Collation.fromBuffer(oldValue) : undefined;
		              return new _helpers.Result(new _token.CollationChangeToken(newCollation, oldCollation), offset);
		            }
		          case 'BEGIN_TXN':
		            return new _helpers.Result(new _token.BeginTransactionEnvChangeToken(newValue, oldValue), offset);
		          case 'COMMIT_TXN':
		            return new _helpers.Result(new _token.CommitTransactionEnvChangeToken(newValue, oldValue), offset);
		          case 'ROLLBACK_TXN':
		            return new _helpers.Result(new _token.RollbackTransactionEnvChangeToken(newValue, oldValue), offset);
		          case 'RESET_CONNECTION':
		            return new _helpers.Result(new _token.ResetConnectionEnvChangeToken(newValue, oldValue), offset);
		        }
		        throw new Error('unreachable');
		      }
		    case 'ROUTING_CHANGE':
		      {
		        let routePacket;
		        ({
		          offset,
		          value: routePacket
		        } = (0, _helpers.readUsVarByte)(buf, offset));
		        let oldValue;
		        ({
		          offset,
		          value: oldValue
		        } = (0, _helpers.readUsVarByte)(buf, offset));

		        // Routing Change:
		        // Byte 1: Protocol (must be 0)
		        // Bytes 2-3 (USHORT): Port number
		        // Bytes 4-5 (USHORT): Length of server data in unicode (2byte chars)
		        // Bytes 6-*: Server name in unicode characters
		        const protocol = routePacket.readUInt8(0);
		        if (protocol !== 0) {
		          throw new Error('Unknown protocol byte in routing change event');
		        }
		        const port = routePacket.readUInt16LE(1);
		        const serverLen = routePacket.readUInt16LE(3);
		        // 2 bytes per char, starting at offset 5
		        const server = routePacket.toString('ucs2', 5, 5 + serverLen * 2);
		        const newValue = {
		          protocol: protocol,
		          port: port,
		          server: server
		        };
		        return new _helpers.Result(new _token.RoutingEnvChangeToken(newValue, oldValue), offset);
		      }
		    default:
		      {
		        console.error('Tedious > Unsupported ENVCHANGE type ' + type.name);

		        // skip unknown bytes
		        return new _helpers.Result(undefined, offset + length - 1);
		      }
		  }
		}
		function envChangeParser(buf, offset, _options) {
		  let tokenLength;
		  ({
		    offset,
		    value: tokenLength
		  } = (0, _helpers.readUInt16LE)(buf, offset));
		  if (buf.length < offset + tokenLength) {
		    throw new _helpers.NotEnoughDataError(offset + tokenLength);
		  }
		  let typeNumber;
		  ({
		    offset,
		    value: typeNumber
		  } = (0, _helpers.readUInt8)(buf, offset));
		  const type = types[typeNumber];
		  if (!type) {
		    console.error('Tedious > Unsupported ENVCHANGE type ' + typeNumber);
		    return new _helpers.Result(undefined, offset + tokenLength - 1);
		  }
		  return _readNewAndOldValue(buf, offset, tokenLength, type);
		}
		exports$1.default = envChangeParser;
		module.exports = envChangeParser;
		
	} (envChangeTokenParser, envChangeTokenParser.exports));
	return envChangeTokenParser.exports;
}

var infoerrorTokenParser = {};

var hasRequiredInfoerrorTokenParser;

function requireInfoerrorTokenParser () {
	if (hasRequiredInfoerrorTokenParser) return infoerrorTokenParser;
	hasRequiredInfoerrorTokenParser = 1;

	Object.defineProperty(infoerrorTokenParser, "__esModule", {
	  value: true
	});
	infoerrorTokenParser.errorParser = errorParser;
	infoerrorTokenParser.infoParser = infoParser;
	var _helpers = requireHelpers();
	var _token = requireToken();
	function readToken(buf, offset, options) {
	  let tokenLength;
	  ({
	    offset,
	    value: tokenLength
	  } = (0, _helpers.readUInt16LE)(buf, offset));
	  if (buf.length < tokenLength + offset) {
	    throw new _helpers.NotEnoughDataError(tokenLength + offset);
	  }
	  let number;
	  ({
	    offset,
	    value: number
	  } = (0, _helpers.readUInt32LE)(buf, offset));
	  let state;
	  ({
	    offset,
	    value: state
	  } = (0, _helpers.readUInt8)(buf, offset));
	  let clazz;
	  ({
	    offset,
	    value: clazz
	  } = (0, _helpers.readUInt8)(buf, offset));
	  let message;
	  ({
	    offset,
	    value: message
	  } = (0, _helpers.readUsVarChar)(buf, offset));
	  let serverName;
	  ({
	    offset,
	    value: serverName
	  } = (0, _helpers.readBVarChar)(buf, offset));
	  let procName;
	  ({
	    offset,
	    value: procName
	  } = (0, _helpers.readBVarChar)(buf, offset));
	  let lineNumber;
	  ({
	    offset,
	    value: lineNumber
	  } = options.tdsVersion < '7_2' ? (0, _helpers.readUInt16LE)(buf, offset) : (0, _helpers.readUInt32LE)(buf, offset));
	  return new _helpers.Result({
	    'number': number,
	    'state': state,
	    'class': clazz,
	    'message': message,
	    'serverName': serverName,
	    'procName': procName,
	    'lineNumber': lineNumber
	  }, offset);
	}
	function infoParser(buf, offset, options) {
	  let data;
	  ({
	    offset,
	    value: data
	  } = readToken(buf, offset, options));
	  return new _helpers.Result(new _token.InfoMessageToken(data), offset);
	}
	function errorParser(buf, offset, options) {
	  let data;
	  ({
	    offset,
	    value: data
	  } = readToken(buf, offset, options));
	  return new _helpers.Result(new _token.ErrorMessageToken(data), offset);
	}
	
	return infoerrorTokenParser;
}

var fedauthInfoParser = {exports: {}};

var hasRequiredFedauthInfoParser;

function requireFedauthInfoParser () {
	if (hasRequiredFedauthInfoParser) return fedauthInfoParser.exports;
	hasRequiredFedauthInfoParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _helpers = requireHelpers();
		var _token = requireToken();
		const FEDAUTHINFOID = {
		  STSURL: 0x01,
		  SPN: 0x02
		};
		function readFedAuthInfo(data) {
		  let offset = 0;
		  let spn, stsurl;
		  const countOfInfoIDs = data.readUInt32LE(offset);
		  offset += 4;
		  for (let i = 0; i < countOfInfoIDs; i++) {
		    const fedauthInfoID = data.readUInt8(offset);
		    offset += 1;
		    const fedAuthInfoDataLen = data.readUInt32LE(offset);
		    offset += 4;
		    const fedAuthInfoDataOffset = data.readUInt32LE(offset);
		    offset += 4;
		    switch (fedauthInfoID) {
		      case FEDAUTHINFOID.SPN:
		        spn = data.toString('ucs2', fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
		        break;
		      case FEDAUTHINFOID.STSURL:
		        stsurl = data.toString('ucs2', fedAuthInfoDataOffset, fedAuthInfoDataOffset + fedAuthInfoDataLen);
		        break;
		    }
		  }
		  return {
		    spn,
		    stsurl
		  };
		}
		function fedAuthInfoParser(buf, offset, _options) {
		  let tokenLength;
		  ({
		    offset,
		    value: tokenLength
		  } = (0, _helpers.readUInt32LE)(buf, offset));
		  if (buf.length < offset + tokenLength) {
		    throw new _helpers.NotEnoughDataError(offset + tokenLength);
		  }
		  const data = buf.slice(offset, offset + tokenLength);
		  offset += tokenLength;
		  const {
		    spn,
		    stsurl
		  } = readFedAuthInfo(data);
		  return new _helpers.Result(new _token.FedAuthInfoToken(spn, stsurl), offset);
		}
		exports$1.default = fedAuthInfoParser;
		module.exports = fedAuthInfoParser;
		
	} (fedauthInfoParser, fedauthInfoParser.exports));
	return fedauthInfoParser.exports;
}

var featureExtAckParser = {exports: {}};

var hasRequiredFeatureExtAckParser;

function requireFeatureExtAckParser () {
	if (hasRequiredFeatureExtAckParser) return featureExtAckParser.exports;
	hasRequiredFeatureExtAckParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _helpers = requireHelpers();
		var _token = requireToken();
		const FEATURE_ID = {
		  FEDAUTH: 0x02,
		  UTF8_SUPPORT: 0x0A,
		  TERMINATOR: 0xFF
		};
		function featureExtAckParser(buf, offset, _options) {
		  let fedAuth;
		  let utf8Support;
		  while (true) {
		    let featureId;
		    ({
		      value: featureId,
		      offset
		    } = (0, _helpers.readUInt8)(buf, offset));
		    if (featureId === FEATURE_ID.TERMINATOR) {
		      return new _helpers.Result(new _token.FeatureExtAckToken(fedAuth, utf8Support), offset);
		    }
		    let featureAckDataLen;
		    ({
		      value: featureAckDataLen,
		      offset
		    } = (0, _helpers.readUInt32LE)(buf, offset));
		    if (buf.length < offset + featureAckDataLen) {
		      throw new _helpers.NotEnoughDataError(offset + featureAckDataLen);
		    }
		    const featureData = buf.slice(offset, offset + featureAckDataLen);
		    offset += featureAckDataLen;
		    switch (featureId) {
		      case FEATURE_ID.FEDAUTH:
		        fedAuth = featureData;
		        break;
		      case FEATURE_ID.UTF8_SUPPORT:
		        utf8Support = !!featureData[0];
		        break;
		    }
		  }
		}
		exports$1.default = featureExtAckParser;
		module.exports = featureExtAckParser;
		
	} (featureExtAckParser, featureExtAckParser.exports));
	return featureExtAckParser.exports;
}

var loginackTokenParser = {exports: {}};

var hasRequiredLoginackTokenParser;

function requireLoginackTokenParser () {
	if (hasRequiredLoginackTokenParser) return loginackTokenParser.exports;
	hasRequiredLoginackTokenParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _token = requireToken();
		var _tdsVersions = requireTdsVersions();
		var _helpers = requireHelpers();
		const interfaceTypes = {
		  0: 'SQL_DFLT',
		  1: 'SQL_TSQL'
		};
		function loginAckParser(buf, offset, _options) {
		  // length
		  let tokenLength;
		  ({
		    offset,
		    value: tokenLength
		  } = (0, _helpers.readUInt16LE)(buf, offset));
		  if (buf.length < tokenLength + offset) {
		    throw new _helpers.NotEnoughDataError(tokenLength + offset);
		  }
		  let interfaceNumber;
		  ({
		    offset,
		    value: interfaceNumber
		  } = (0, _helpers.readUInt8)(buf, offset));
		  const interfaceType = interfaceTypes[interfaceNumber];
		  let tdsVersionNumber;
		  ({
		    offset,
		    value: tdsVersionNumber
		  } = (0, _helpers.readUInt32BE)(buf, offset));
		  const tdsVersion = _tdsVersions.versionsByValue[tdsVersionNumber];
		  let progName;
		  ({
		    offset,
		    value: progName
		  } = (0, _helpers.readBVarChar)(buf, offset));
		  let major;
		  ({
		    offset,
		    value: major
		  } = (0, _helpers.readUInt8)(buf, offset));
		  let minor;
		  ({
		    offset,
		    value: minor
		  } = (0, _helpers.readUInt8)(buf, offset));
		  let buildNumHi;
		  ({
		    offset,
		    value: buildNumHi
		  } = (0, _helpers.readUInt8)(buf, offset));
		  let buildNumLow;
		  ({
		    offset,
		    value: buildNumLow
		  } = (0, _helpers.readUInt8)(buf, offset));
		  return new _helpers.Result(new _token.LoginAckToken({
		    interface: interfaceType,
		    tdsVersion: tdsVersion,
		    progName: progName,
		    progVersion: {
		      major: major,
		      minor: minor,
		      buildNumHi: buildNumHi,
		      buildNumLow: buildNumLow
		    }
		  }), offset);
		}
		exports$1.default = loginAckParser;
		module.exports = loginAckParser;
		
	} (loginackTokenParser, loginackTokenParser.exports));
	return loginackTokenParser.exports;
}

var orderTokenParser = {exports: {}};

var hasRequiredOrderTokenParser;

function requireOrderTokenParser () {
	if (hasRequiredOrderTokenParser) return orderTokenParser.exports;
	hasRequiredOrderTokenParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _token = requireToken();
		var _helpers = requireHelpers();
		// s2.2.7.14

		function orderParser(buf, offset, _options) {
		  // length
		  let tokenLength;
		  ({
		    offset,
		    value: tokenLength
		  } = (0, _helpers.readUInt16LE)(buf, offset));
		  if (buf.length < offset + tokenLength) {
		    throw new _helpers.NotEnoughDataError(offset + tokenLength);
		  }
		  const orderColumns = [];
		  for (let i = 0; i < tokenLength; i += 2) {
		    let column;
		    ({
		      offset,
		      value: column
		    } = (0, _helpers.readUInt16LE)(buf, offset));
		    orderColumns.push(column);
		  }
		  return new _helpers.Result(new _token.OrderToken(orderColumns), offset);
		}
		exports$1.default = orderParser;
		module.exports = orderParser;
		
	} (orderTokenParser, orderTokenParser.exports));
	return orderTokenParser.exports;
}

var returnstatusTokenParser = {exports: {}};

var hasRequiredReturnstatusTokenParser;

function requireReturnstatusTokenParser () {
	if (hasRequiredReturnstatusTokenParser) return returnstatusTokenParser.exports;
	hasRequiredReturnstatusTokenParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _helpers = requireHelpers();
		var _token = requireToken();
		// s2.2.7.16

		function returnStatusParser(buf, offset, _options) {
		  let value;
		  ({
		    value,
		    offset
		  } = (0, _helpers.readInt32LE)(buf, offset));
		  return new _helpers.Result(new _token.ReturnStatusToken(value), offset);
		}
		exports$1.default = returnStatusParser;
		module.exports = returnStatusParser;
		
	} (returnstatusTokenParser, returnstatusTokenParser.exports));
	return returnstatusTokenParser.exports;
}

var returnvalueTokenParser = {exports: {}};

var valueParser = {};

var hasRequiredValueParser;

function requireValueParser () {
	if (hasRequiredValueParser) return valueParser;
	hasRequiredValueParser = 1;

	Object.defineProperty(valueParser, "__esModule", {
	  value: true
	});
	valueParser.isPLPStream = isPLPStream;
	valueParser.readPLPStream = readPLPStream;
	valueParser.readValue = readValue;
	var _metadataParser = requireMetadataParser();
	var _dataType = requireDataType();
	var _iconvLite = _interopRequireDefault(requireLib());
	var _sprintfJs = requireSprintf();
	var _guidParser = requireGuidParser();
	var _helpers = requireHelpers();
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	const NULL = (1 << 16) - 1;
	const MAX = (1 << 16) - 1;
	const THREE_AND_A_THIRD = 3 + 1 / 3;
	const MONEY_DIVISOR = 10000;
	const PLP_NULL = 0xFFFFFFFFFFFFFFFFn;
	const UNKNOWN_PLP_LEN = 0xFFFFFFFFFFFFFFFEn;
	const DEFAULT_ENCODING = 'utf8';
	function readTinyInt(buf, offset) {
	  return (0, _helpers.readUInt8)(buf, offset);
	}
	function readSmallInt(buf, offset) {
	  return (0, _helpers.readInt16LE)(buf, offset);
	}
	function readInt(buf, offset) {
	  return (0, _helpers.readInt32LE)(buf, offset);
	}
	function readBigInt(buf, offset) {
	  let value;
	  ({
	    offset,
	    value
	  } = (0, _helpers.readBigInt64LE)(buf, offset));
	  return new _helpers.Result(value.toString(), offset);
	}
	function readReal(buf, offset) {
	  return (0, _helpers.readFloatLE)(buf, offset);
	}
	function readFloat(buf, offset) {
	  return (0, _helpers.readDoubleLE)(buf, offset);
	}
	function readSmallMoney(buf, offset) {
	  let value;
	  ({
	    offset,
	    value
	  } = (0, _helpers.readInt32LE)(buf, offset));
	  return new _helpers.Result(value / MONEY_DIVISOR, offset);
	}
	function readMoney(buf, offset) {
	  let high;
	  ({
	    offset,
	    value: high
	  } = (0, _helpers.readInt32LE)(buf, offset));
	  let low;
	  ({
	    offset,
	    value: low
	  } = (0, _helpers.readUInt32LE)(buf, offset));
	  return new _helpers.Result((low + 0x100000000 * high) / MONEY_DIVISOR, offset);
	}
	function readBit(buf, offset) {
	  let value;
	  ({
	    offset,
	    value
	  } = (0, _helpers.readUInt8)(buf, offset));
	  return new _helpers.Result(!!value, offset);
	}
	function readValue(buf, offset, metadata, options) {
	  const type = metadata.type;
	  switch (type.name) {
	    case 'Null':
	      return new _helpers.Result(null, offset);
	    case 'TinyInt':
	      {
	        return readTinyInt(buf, offset);
	      }
	    case 'SmallInt':
	      {
	        return readSmallInt(buf, offset);
	      }
	    case 'Int':
	      {
	        return readInt(buf, offset);
	      }
	    case 'BigInt':
	      {
	        return readBigInt(buf, offset);
	      }
	    case 'IntN':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        switch (dataLength) {
	          case 0:
	            return new _helpers.Result(null, offset);
	          case 1:
	            return readTinyInt(buf, offset);
	          case 2:
	            return readSmallInt(buf, offset);
	          case 4:
	            return readInt(buf, offset);
	          case 8:
	            return readBigInt(buf, offset);
	          default:
	            throw new Error('Unsupported dataLength ' + dataLength + ' for IntN');
	        }
	      }
	    case 'Real':
	      {
	        return readReal(buf, offset);
	      }
	    case 'Float':
	      {
	        return readFloat(buf, offset);
	      }
	    case 'FloatN':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        switch (dataLength) {
	          case 0:
	            return new _helpers.Result(null, offset);
	          case 4:
	            return readReal(buf, offset);
	          case 8:
	            return readFloat(buf, offset);
	          default:
	            throw new Error('Unsupported dataLength ' + dataLength + ' for FloatN');
	        }
	      }
	    case 'SmallMoney':
	      {
	        return readSmallMoney(buf, offset);
	      }
	    case 'Money':
	      return readMoney(buf, offset);
	    case 'MoneyN':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        switch (dataLength) {
	          case 0:
	            return new _helpers.Result(null, offset);
	          case 4:
	            return readSmallMoney(buf, offset);
	          case 8:
	            return readMoney(buf, offset);
	          default:
	            throw new Error('Unsupported dataLength ' + dataLength + ' for MoneyN');
	        }
	      }
	    case 'Bit':
	      {
	        return readBit(buf, offset);
	      }
	    case 'BitN':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        switch (dataLength) {
	          case 0:
	            return new _helpers.Result(null, offset);
	          case 1:
	            return readBit(buf, offset);
	          default:
	            throw new Error('Unsupported dataLength ' + dataLength + ' for BitN');
	        }
	      }
	    case 'VarChar':
	    case 'Char':
	      {
	        const codepage = metadata.collation.codepage;
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt16LE)(buf, offset));
	        if (dataLength === NULL) {
	          return new _helpers.Result(null, offset);
	        }
	        return readChars(buf, offset, dataLength, codepage);
	      }
	    case 'NVarChar':
	    case 'NChar':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt16LE)(buf, offset));
	        if (dataLength === NULL) {
	          return new _helpers.Result(null, offset);
	        }
	        return readNChars(buf, offset, dataLength);
	      }
	    case 'VarBinary':
	    case 'Binary':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt16LE)(buf, offset));
	        if (dataLength === NULL) {
	          return new _helpers.Result(null, offset);
	        }
	        return readBinary(buf, offset, dataLength);
	      }
	    case 'Text':
	      {
	        let textPointerLength;
	        ({
	          offset,
	          value: textPointerLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        if (textPointerLength === 0) {
	          return new _helpers.Result(null, offset);
	        }

	        // Textpointer
	        ({
	          offset
	        } = readBinary(buf, offset, textPointerLength));

	        // Timestamp
	        ({
	          offset
	        } = readBinary(buf, offset, 8));
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt32LE)(buf, offset));
	        return readChars(buf, offset, dataLength, metadata.collation.codepage);
	      }
	    case 'NText':
	      {
	        let textPointerLength;
	        ({
	          offset,
	          value: textPointerLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        if (textPointerLength === 0) {
	          return new _helpers.Result(null, offset);
	        }

	        // Textpointer
	        ({
	          offset
	        } = readBinary(buf, offset, textPointerLength));

	        // Timestamp
	        ({
	          offset
	        } = readBinary(buf, offset, 8));
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt32LE)(buf, offset));
	        return readNChars(buf, offset, dataLength);
	      }
	    case 'Image':
	      {
	        let textPointerLength;
	        ({
	          offset,
	          value: textPointerLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        if (textPointerLength === 0) {
	          return new _helpers.Result(null, offset);
	        }

	        // Textpointer
	        ({
	          offset
	        } = readBinary(buf, offset, textPointerLength));

	        // Timestamp
	        ({
	          offset
	        } = readBinary(buf, offset, 8));
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt32LE)(buf, offset));
	        return readBinary(buf, offset, dataLength);
	      }
	    case 'SmallDateTime':
	      {
	        return readSmallDateTime(buf, offset, options.useUTC);
	      }
	    case 'DateTime':
	      {
	        return readDateTime(buf, offset, options.useUTC);
	      }
	    case 'DateTimeN':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        switch (dataLength) {
	          case 0:
	            return new _helpers.Result(null, offset);
	          case 4:
	            return readSmallDateTime(buf, offset, options.useUTC);
	          case 8:
	            return readDateTime(buf, offset, options.useUTC);
	          default:
	            throw new Error('Unsupported dataLength ' + dataLength + ' for DateTimeN');
	        }
	      }
	    case 'Time':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        if (dataLength === 0) {
	          return new _helpers.Result(null, offset);
	        }
	        return readTime(buf, offset, dataLength, metadata.scale, options.useUTC);
	      }
	    case 'Date':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        if (dataLength === 0) {
	          return new _helpers.Result(null, offset);
	        }
	        return readDate(buf, offset, options.useUTC);
	      }
	    case 'DateTime2':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        if (dataLength === 0) {
	          return new _helpers.Result(null, offset);
	        }
	        return readDateTime2(buf, offset, dataLength, metadata.scale, options.useUTC);
	      }
	    case 'DateTimeOffset':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        if (dataLength === 0) {
	          return new _helpers.Result(null, offset);
	        }
	        return readDateTimeOffset(buf, offset, dataLength, metadata.scale);
	      }
	    case 'NumericN':
	    case 'DecimalN':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        if (dataLength === 0) {
	          return new _helpers.Result(null, offset);
	        }
	        return readNumeric(buf, offset, dataLength, metadata.precision, metadata.scale);
	      }
	    case 'UniqueIdentifier':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt8)(buf, offset));
	        switch (dataLength) {
	          case 0:
	            return new _helpers.Result(null, offset);
	          case 0x10:
	            return readUniqueIdentifier(buf, offset, options);
	          default:
	            throw new Error((0, _sprintfJs.sprintf)('Unsupported guid size %d', dataLength - 1));
	        }
	      }
	    case 'Variant':
	      {
	        let dataLength;
	        ({
	          offset,
	          value: dataLength
	        } = (0, _helpers.readUInt32LE)(buf, offset));
	        if (dataLength === 0) {
	          return new _helpers.Result(null, offset);
	        }
	        return readVariant(buf, offset, options, dataLength);
	      }
	    default:
	      {
	        throw new Error('Invalid type!');
	      }
	  }
	}
	function isPLPStream(metadata) {
	  switch (metadata.type.name) {
	    case 'VarChar':
	    case 'NVarChar':
	    case 'VarBinary':
	      {
	        return metadata.dataLength === MAX;
	      }
	    case 'Xml':
	      {
	        return true;
	      }
	    case 'UDT':
	      {
	        return true;
	      }
	  }
	}
	function readUniqueIdentifier(buf, offset, options) {
	  let data;
	  ({
	    value: data,
	    offset
	  } = readBinary(buf, offset, 0x10));
	  return new _helpers.Result(options.lowerCaseGuids ? (0, _guidParser.bufferToLowerCaseGuid)(data) : (0, _guidParser.bufferToUpperCaseGuid)(data), offset);
	}
	function readNumeric(buf, offset, dataLength, _precision, scale) {
	  let sign;
	  ({
	    offset,
	    value: sign
	  } = (0, _helpers.readUInt8)(buf, offset));
	  sign = sign === 1 ? 1 : -1;
	  let value;
	  if (dataLength === 5) {
	    ({
	      offset,
	      value
	    } = (0, _helpers.readUInt32LE)(buf, offset));
	  } else if (dataLength === 9) {
	    ({
	      offset,
	      value
	    } = (0, _helpers.readUNumeric64LE)(buf, offset));
	  } else if (dataLength === 13) {
	    ({
	      offset,
	      value
	    } = (0, _helpers.readUNumeric96LE)(buf, offset));
	  } else if (dataLength === 17) {
	    ({
	      offset,
	      value
	    } = (0, _helpers.readUNumeric128LE)(buf, offset));
	  } else {
	    throw new Error((0, _sprintfJs.sprintf)('Unsupported numeric dataLength %d', dataLength));
	  }
	  return new _helpers.Result(value * sign / Math.pow(10, scale), offset);
	}
	function readVariant(buf, offset, options, dataLength) {
	  let baseType;
	  ({
	    value: baseType,
	    offset
	  } = (0, _helpers.readUInt8)(buf, offset));
	  const type = _dataType.TYPE[baseType];
	  let propBytes;
	  ({
	    value: propBytes,
	    offset
	  } = (0, _helpers.readUInt8)(buf, offset));
	  dataLength = dataLength - propBytes - 2;
	  switch (type.name) {
	    case 'UniqueIdentifier':
	      return readUniqueIdentifier(buf, offset, options);
	    case 'Bit':
	      return readBit(buf, offset);
	    case 'TinyInt':
	      return readTinyInt(buf, offset);
	    case 'SmallInt':
	      return readSmallInt(buf, offset);
	    case 'Int':
	      return readInt(buf, offset);
	    case 'BigInt':
	      return readBigInt(buf, offset);
	    case 'SmallDateTime':
	      return readSmallDateTime(buf, offset, options.useUTC);
	    case 'DateTime':
	      return readDateTime(buf, offset, options.useUTC);
	    case 'Real':
	      return readReal(buf, offset);
	    case 'Float':
	      return readFloat(buf, offset);
	    case 'SmallMoney':
	      return readSmallMoney(buf, offset);
	    case 'Money':
	      return readMoney(buf, offset);
	    case 'Date':
	      return readDate(buf, offset, options.useUTC);
	    case 'Time':
	      {
	        let scale;
	        ({
	          value: scale,
	          offset
	        } = (0, _helpers.readUInt8)(buf, offset));
	        return readTime(buf, offset, dataLength, scale, options.useUTC);
	      }
	    case 'DateTime2':
	      {
	        let scale;
	        ({
	          value: scale,
	          offset
	        } = (0, _helpers.readUInt8)(buf, offset));
	        return readDateTime2(buf, offset, dataLength, scale, options.useUTC);
	      }
	    case 'DateTimeOffset':
	      {
	        let scale;
	        ({
	          value: scale,
	          offset
	        } = (0, _helpers.readUInt8)(buf, offset));
	        return readDateTimeOffset(buf, offset, dataLength, scale);
	      }
	    case 'VarBinary':
	    case 'Binary':
	      {
	        // maxLength (unused?)
	        ({
	          offset
	        } = (0, _helpers.readUInt16LE)(buf, offset));
	        return readBinary(buf, offset, dataLength);
	      }
	    case 'NumericN':
	    case 'DecimalN':
	      {
	        let precision;
	        ({
	          value: precision,
	          offset
	        } = (0, _helpers.readUInt8)(buf, offset));
	        let scale;
	        ({
	          value: scale,
	          offset
	        } = (0, _helpers.readUInt8)(buf, offset));
	        return readNumeric(buf, offset, dataLength, precision, scale);
	      }
	    case 'VarChar':
	    case 'Char':
	      {
	        // maxLength (unused?)
	        ({
	          offset
	        } = (0, _helpers.readUInt16LE)(buf, offset));
	        let collation;
	        ({
	          value: collation,
	          offset
	        } = (0, _metadataParser.readCollation)(buf, offset));
	        return readChars(buf, offset, dataLength, collation.codepage);
	      }
	    case 'NVarChar':
	    case 'NChar':
	      {
	        // maxLength (unused?)
	        ({
	          offset
	        } = (0, _helpers.readUInt16LE)(buf, offset));

	        // collation (unused?)
	        ({
	          offset
	        } = (0, _metadataParser.readCollation)(buf, offset));
	        return readNChars(buf, offset, dataLength);
	      }
	    default:
	      throw new Error('Invalid type!');
	  }
	}
	function readBinary(buf, offset, dataLength) {
	  if (buf.length < offset + dataLength) {
	    throw new _helpers.NotEnoughDataError(offset + dataLength);
	  }
	  return new _helpers.Result(buf.slice(offset, offset + dataLength), offset + dataLength);
	}
	function readChars(buf, offset, dataLength, codepage) {
	  if (buf.length < offset + dataLength) {
	    throw new _helpers.NotEnoughDataError(offset + dataLength);
	  }
	  return new _helpers.Result(_iconvLite.default.decode(buf.slice(offset, offset + dataLength), codepage ?? DEFAULT_ENCODING), offset + dataLength);
	}
	function readNChars(buf, offset, dataLength) {
	  if (buf.length < offset + dataLength) {
	    throw new _helpers.NotEnoughDataError(offset + dataLength);
	  }
	  return new _helpers.Result(buf.toString('ucs2', offset, offset + dataLength), offset + dataLength);
	}
	async function readPLPStream(parser) {
	  while (parser.buffer.length < parser.position + 8) {
	    await parser.waitForChunk();
	  }
	  const expectedLength = parser.buffer.readBigUInt64LE(parser.position);
	  parser.position += 8;
	  if (expectedLength === PLP_NULL) {
	    return null;
	  }
	  const chunks = [];
	  let currentLength = 0;
	  while (true) {
	    while (parser.buffer.length < parser.position + 4) {
	      await parser.waitForChunk();
	    }
	    const chunkLength = parser.buffer.readUInt32LE(parser.position);
	    parser.position += 4;
	    if (!chunkLength) {
	      break;
	    }
	    while (parser.buffer.length < parser.position + chunkLength) {
	      await parser.waitForChunk();
	    }
	    chunks.push(parser.buffer.slice(parser.position, parser.position + chunkLength));
	    parser.position += chunkLength;
	    currentLength += chunkLength;
	  }
	  if (expectedLength !== UNKNOWN_PLP_LEN) {
	    if (currentLength !== Number(expectedLength)) {
	      throw new Error('Partially Length-prefixed Bytes unmatched lengths : expected ' + expectedLength + ', but got ' + currentLength + ' bytes');
	    }
	  }
	  return chunks;
	}
	function readSmallDateTime(buf, offset, useUTC) {
	  let days;
	  ({
	    offset,
	    value: days
	  } = (0, _helpers.readUInt16LE)(buf, offset));
	  let minutes;
	  ({
	    offset,
	    value: minutes
	  } = (0, _helpers.readUInt16LE)(buf, offset));
	  let value;
	  if (useUTC) {
	    value = new Date(Date.UTC(1900, 0, 1 + days, 0, minutes));
	  } else {
	    value = new Date(1900, 0, 1 + days, 0, minutes);
	  }
	  return new _helpers.Result(value, offset);
	}
	function readDateTime(buf, offset, useUTC) {
	  let days;
	  ({
	    offset,
	    value: days
	  } = (0, _helpers.readInt32LE)(buf, offset));
	  let threeHundredthsOfSecond;
	  ({
	    offset,
	    value: threeHundredthsOfSecond
	  } = (0, _helpers.readInt32LE)(buf, offset));
	  const milliseconds = Math.round(threeHundredthsOfSecond * THREE_AND_A_THIRD);
	  let value;
	  if (useUTC) {
	    value = new Date(Date.UTC(1900, 0, 1 + days, 0, 0, 0, milliseconds));
	  } else {
	    value = new Date(1900, 0, 1 + days, 0, 0, 0, milliseconds);
	  }
	  return new _helpers.Result(value, offset);
	}
	function readTime(buf, offset, dataLength, scale, useUTC) {
	  let value;
	  switch (dataLength) {
	    case 3:
	      {
	        ({
	          value,
	          offset
	        } = (0, _helpers.readUInt24LE)(buf, offset));
	        break;
	      }
	    case 4:
	      {
	        ({
	          value,
	          offset
	        } = (0, _helpers.readUInt32LE)(buf, offset));
	        break;
	      }
	    case 5:
	      {
	        ({
	          value,
	          offset
	        } = (0, _helpers.readUInt40LE)(buf, offset));
	        break;
	      }
	    default:
	      {
	        throw new Error('unreachable');
	      }
	  }
	  if (scale < 7) {
	    for (let i = scale; i < 7; i++) {
	      value *= 10;
	    }
	  }
	  let date;
	  if (useUTC) {
	    date = new Date(Date.UTC(1970, 0, 1, 0, 0, 0, value / 10000));
	  } else {
	    date = new Date(1970, 0, 1, 0, 0, 0, value / 10000);
	  }
	  Object.defineProperty(date, 'nanosecondsDelta', {
	    enumerable: false,
	    value: value % 10000 / Math.pow(10, 7)
	  });
	  return new _helpers.Result(date, offset);
	}
	function readDate(buf, offset, useUTC) {
	  let days;
	  ({
	    offset,
	    value: days
	  } = (0, _helpers.readUInt24LE)(buf, offset));
	  if (useUTC) {
	    return new _helpers.Result(new Date(Date.UTC(2000, 0, days - 730118)), offset);
	  } else {
	    return new _helpers.Result(new Date(2000, 0, days - 730118), offset);
	  }
	}
	function readDateTime2(buf, offset, dataLength, scale, useUTC) {
	  let time;
	  ({
	    offset,
	    value: time
	  } = readTime(buf, offset, dataLength - 3, scale, useUTC));
	  let days;
	  ({
	    offset,
	    value: days
	  } = (0, _helpers.readUInt24LE)(buf, offset));
	  let date;
	  if (useUTC) {
	    date = new Date(Date.UTC(2000, 0, days - 730118, 0, 0, 0, +time));
	  } else {
	    date = new Date(2000, 0, days - 730118, time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
	  }
	  Object.defineProperty(date, 'nanosecondsDelta', {
	    enumerable: false,
	    value: time.nanosecondsDelta
	  });
	  return new _helpers.Result(date, offset);
	}
	function readDateTimeOffset(buf, offset, dataLength, scale) {
	  let time;
	  ({
	    offset,
	    value: time
	  } = readTime(buf, offset, dataLength - 5, scale, true));
	  let days;
	  ({
	    offset,
	    value: days
	  } = (0, _helpers.readUInt24LE)(buf, offset));

	  // time offset?
	  ({
	    offset
	  } = (0, _helpers.readUInt16LE)(buf, offset));
	  const date = new Date(Date.UTC(2000, 0, days - 730118, 0, 0, 0, +time));
	  Object.defineProperty(date, 'nanosecondsDelta', {
	    enumerable: false,
	    value: time.nanosecondsDelta
	  });
	  return new _helpers.Result(date, offset);
	}
	valueParser.readValue = readValue;
	valueParser.isPLPStream = isPLPStream;
	valueParser.readPLPStream = readPLPStream;
	
	return valueParser;
}

var hasRequiredReturnvalueTokenParser;

function requireReturnvalueTokenParser () {
	if (hasRequiredReturnvalueTokenParser) return returnvalueTokenParser.exports;
	hasRequiredReturnvalueTokenParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _token = requireToken();
		var _metadataParser = requireMetadataParser();
		var _valueParser = requireValueParser();
		var _helpers = requireHelpers();
		var iconv = _interopRequireWildcard(requireLib());
		function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
		function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
		// s2.2.7.16

		async function returnParser(parser) {
		  let paramName;
		  let paramOrdinal;
		  let metadata;
		  while (true) {
		    const buf = parser.buffer;
		    let offset = parser.position;
		    try {
		      ({
		        offset,
		        value: paramOrdinal
		      } = (0, _helpers.readUInt16LE)(buf, offset));
		      ({
		        offset,
		        value: paramName
		      } = (0, _helpers.readBVarChar)(buf, offset));
		      // status
		      ({
		        offset
		      } = (0, _helpers.readUInt8)(buf, offset));
		      ({
		        offset,
		        value: metadata
		      } = (0, _metadataParser.readMetadata)(buf, offset, parser.options));
		      if (paramName.charAt(0) === '@') {
		        paramName = paramName.slice(1);
		      }
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        await parser.waitForChunk();
		        continue;
		      }
		      throw err;
		    }
		    parser.position = offset;
		    break;
		  }
		  let value;
		  while (true) {
		    const buf = parser.buffer;
		    let offset = parser.position;
		    if ((0, _valueParser.isPLPStream)(metadata)) {
		      const chunks = await (0, _valueParser.readPLPStream)(parser);
		      if (chunks === null) {
		        value = chunks;
		      } else if (metadata.type.name === 'NVarChar' || metadata.type.name === 'Xml') {
		        value = Buffer.concat(chunks).toString('ucs2');
		      } else if (metadata.type.name === 'VarChar') {
		        value = iconv.decode(Buffer.concat(chunks), metadata.collation?.codepage ?? 'utf8');
		      } else if (metadata.type.name === 'VarBinary' || metadata.type.name === 'UDT') {
		        value = Buffer.concat(chunks);
		      }
		    } else {
		      try {
		        ({
		          value,
		          offset
		        } = (0, _valueParser.readValue)(buf, offset, metadata, parser.options));
		      } catch (err) {
		        if (err instanceof _helpers.NotEnoughDataError) {
		          await parser.waitForChunk();
		          continue;
		        }
		        throw err;
		      }
		      parser.position = offset;
		    }
		    break;
		  }
		  return new _token.ReturnValueToken({
		    paramOrdinal: paramOrdinal,
		    paramName: paramName,
		    metadata: metadata,
		    value: value
		  });
		}
		exports$1.default = returnParser;
		module.exports = returnParser;
		
	} (returnvalueTokenParser, returnvalueTokenParser.exports));
	return returnvalueTokenParser.exports;
}

var rowTokenParser = {exports: {}};

var hasRequiredRowTokenParser;

function requireRowTokenParser () {
	if (hasRequiredRowTokenParser) return rowTokenParser.exports;
	hasRequiredRowTokenParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _token = requireToken();
		var iconv = _interopRequireWildcard(requireLib());
		var _valueParser = requireValueParser();
		var _helpers = requireHelpers();
		function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
		function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
		// s2.2.7.17

		async function rowParser(parser) {
		  const columns = [];
		  for (const metadata of parser.colMetadata) {
		    while (true) {
		      if ((0, _valueParser.isPLPStream)(metadata)) {
		        const chunks = await (0, _valueParser.readPLPStream)(parser);
		        if (chunks === null) {
		          columns.push({
		            value: chunks,
		            metadata
		          });
		        } else if (metadata.type.name === 'NVarChar' || metadata.type.name === 'Xml') {
		          columns.push({
		            value: Buffer.concat(chunks).toString('ucs2'),
		            metadata
		          });
		        } else if (metadata.type.name === 'VarChar') {
		          columns.push({
		            value: iconv.decode(Buffer.concat(chunks), metadata.collation?.codepage ?? 'utf8'),
		            metadata
		          });
		        } else if (metadata.type.name === 'VarBinary' || metadata.type.name === 'UDT') {
		          columns.push({
		            value: Buffer.concat(chunks),
		            metadata
		          });
		        }
		      } else {
		        let result;
		        try {
		          result = (0, _valueParser.readValue)(parser.buffer, parser.position, metadata, parser.options);
		        } catch (err) {
		          if (err instanceof _helpers.NotEnoughDataError) {
		            await parser.waitForChunk();
		            continue;
		          }
		          throw err;
		        }
		        parser.position = result.offset;
		        columns.push({
		          value: result.value,
		          metadata
		        });
		      }
		      break;
		    }
		  }
		  if (parser.options.useColumnNames) {
		    const columnsMap = Object.create(null);
		    columns.forEach(column => {
		      const colName = column.metadata.colName;
		      if (columnsMap[colName] == null) {
		        columnsMap[colName] = column;
		      }
		    });
		    return new _token.RowToken(columnsMap);
		  } else {
		    return new _token.RowToken(columns);
		  }
		}
		exports$1.default = rowParser;
		module.exports = rowParser;
		
	} (rowTokenParser, rowTokenParser.exports));
	return rowTokenParser.exports;
}

var nbcrowTokenParser = {exports: {}};

var hasRequiredNbcrowTokenParser;

function requireNbcrowTokenParser () {
	if (hasRequiredNbcrowTokenParser) return nbcrowTokenParser.exports;
	hasRequiredNbcrowTokenParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _token = requireToken();
		var iconv = _interopRequireWildcard(requireLib());
		var _valueParser = requireValueParser();
		var _helpers = requireHelpers();
		function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
		function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
		// s2.2.7.13 (introduced in TDS 7.3.B)

		async function nbcRowParser(parser) {
		  const colMetadata = parser.colMetadata;
		  const columns = [];
		  const bitmap = [];
		  const bitmapByteLength = Math.ceil(colMetadata.length / 8);
		  while (parser.buffer.length - parser.position < bitmapByteLength) {
		    await parser.waitForChunk();
		  }
		  const bytes = parser.buffer.slice(parser.position, parser.position + bitmapByteLength);
		  parser.position += bitmapByteLength;
		  for (let i = 0, len = bytes.length; i < len; i++) {
		    const byte = bytes[i];
		    bitmap.push(byte & 0b1 ? true : false);
		    bitmap.push(byte & 0b10 ? true : false);
		    bitmap.push(byte & 0b100 ? true : false);
		    bitmap.push(byte & 0b1000 ? true : false);
		    bitmap.push(byte & 0b10000 ? true : false);
		    bitmap.push(byte & 0b100000 ? true : false);
		    bitmap.push(byte & 0b1000000 ? true : false);
		    bitmap.push(byte & 0b10000000 ? true : false);
		  }
		  for (let i = 0; i < colMetadata.length; i++) {
		    const metadata = colMetadata[i];
		    if (bitmap[i]) {
		      columns.push({
		        value: null,
		        metadata
		      });
		      continue;
		    }
		    while (true) {
		      if ((0, _valueParser.isPLPStream)(metadata)) {
		        const chunks = await (0, _valueParser.readPLPStream)(parser);
		        if (chunks === null) {
		          columns.push({
		            value: chunks,
		            metadata
		          });
		        } else if (metadata.type.name === 'NVarChar' || metadata.type.name === 'Xml') {
		          columns.push({
		            value: Buffer.concat(chunks).toString('ucs2'),
		            metadata
		          });
		        } else if (metadata.type.name === 'VarChar') {
		          columns.push({
		            value: iconv.decode(Buffer.concat(chunks), metadata.collation?.codepage ?? 'utf8'),
		            metadata
		          });
		        } else if (metadata.type.name === 'VarBinary' || metadata.type.name === 'UDT') {
		          columns.push({
		            value: Buffer.concat(chunks),
		            metadata
		          });
		        }
		      } else {
		        let result;
		        try {
		          result = (0, _valueParser.readValue)(parser.buffer, parser.position, metadata, parser.options);
		        } catch (err) {
		          if (err instanceof _helpers.NotEnoughDataError) {
		            await parser.waitForChunk();
		            continue;
		          }
		          throw err;
		        }
		        parser.position = result.offset;
		        columns.push({
		          value: result.value,
		          metadata
		        });
		      }
		      break;
		    }
		  }
		  if (parser.options.useColumnNames) {
		    const columnsMap = Object.create(null);
		    columns.forEach(column => {
		      const colName = column.metadata.colName;
		      if (columnsMap[colName] == null) {
		        columnsMap[colName] = column;
		      }
		    });
		    return new _token.NBCRowToken(columnsMap);
		  } else {
		    return new _token.NBCRowToken(columns);
		  }
		}
		exports$1.default = nbcRowParser;
		module.exports = nbcRowParser;
		
	} (nbcrowTokenParser, nbcrowTokenParser.exports));
	return nbcrowTokenParser.exports;
}

var sspiTokenParser = {exports: {}};

var hasRequiredSspiTokenParser;

function requireSspiTokenParser () {
	if (hasRequiredSspiTokenParser) return sspiTokenParser.exports;
	hasRequiredSspiTokenParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _helpers = requireHelpers();
		var _token = requireToken();
		function parseChallenge(buffer) {
		  const challenge = {};
		  challenge.magic = buffer.slice(0, 8).toString('utf8');
		  challenge.type = buffer.readInt32LE(8);
		  challenge.domainLen = buffer.readInt16LE(12);
		  challenge.domainMax = buffer.readInt16LE(14);
		  challenge.domainOffset = buffer.readInt32LE(16);
		  challenge.flags = buffer.readInt32LE(20);
		  challenge.nonce = buffer.slice(24, 32);
		  challenge.zeroes = buffer.slice(32, 40);
		  challenge.targetLen = buffer.readInt16LE(40);
		  challenge.targetMax = buffer.readInt16LE(42);
		  challenge.targetOffset = buffer.readInt32LE(44);
		  challenge.oddData = buffer.slice(48, 56);
		  challenge.domain = buffer.slice(56, 56 + challenge.domainLen).toString('ucs2');
		  challenge.target = buffer.slice(56 + challenge.domainLen, 56 + challenge.domainLen + challenge.targetLen);
		  return challenge;
		}
		function sspiParser(buf, offset, _options) {
		  let tokenLength;
		  ({
		    offset,
		    value: tokenLength
		  } = (0, _helpers.readUInt16LE)(buf, offset));
		  if (buf.length < offset + tokenLength) {
		    throw new _helpers.NotEnoughDataError(offset + tokenLength);
		  }
		  const data = buf.slice(offset, offset + tokenLength);
		  offset += tokenLength;
		  return new _helpers.Result(new _token.SSPIToken(parseChallenge(data), data), offset);
		}
		exports$1.default = sspiParser;
		module.exports = sspiParser;
		
	} (sspiTokenParser, sspiTokenParser.exports));
	return sspiTokenParser.exports;
}

var hasRequiredStreamParser;

function requireStreamParser () {
	if (hasRequiredStreamParser) return streamParser.exports;
	hasRequiredStreamParser = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _token = requireToken();
		var _colmetadataTokenParser = _interopRequireDefault(requireColmetadataTokenParser());
		var _doneTokenParser = requireDoneTokenParser();
		var _envChangeTokenParser = _interopRequireDefault(requireEnvChangeTokenParser());
		var _infoerrorTokenParser = requireInfoerrorTokenParser();
		var _fedauthInfoParser = _interopRequireDefault(requireFedauthInfoParser());
		var _featureExtAckParser = _interopRequireDefault(requireFeatureExtAckParser());
		var _loginackTokenParser = _interopRequireDefault(requireLoginackTokenParser());
		var _orderTokenParser = _interopRequireDefault(requireOrderTokenParser());
		var _returnstatusTokenParser = _interopRequireDefault(requireReturnstatusTokenParser());
		var _returnvalueTokenParser = _interopRequireDefault(requireReturnvalueTokenParser());
		var _rowTokenParser = _interopRequireDefault(requireRowTokenParser());
		var _nbcrowTokenParser = _interopRequireDefault(requireNbcrowTokenParser());
		var _sspiTokenParser = _interopRequireDefault(requireSspiTokenParser());
		var _helpers = requireHelpers();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		class Parser {
		  debug;
		  colMetadata;
		  options;
		  iterator;
		  buffer;
		  position;
		  static async *parseTokens(iterable, debug, options, colMetadata = []) {
		    const parser = new Parser(iterable, debug, options);
		    parser.colMetadata = colMetadata;
		    while (true) {
		      try {
		        await parser.waitForChunk();
		      } catch (err) {
		        if (parser.position === parser.buffer.length) {
		          return;
		        }
		        throw err;
		      }
		      while (parser.buffer.length >= parser.position + 1) {
		        const type = parser.buffer.readUInt8(parser.position);
		        parser.position += 1;
		        const token = parser.readToken(type);
		        if (token !== undefined) {
		          yield token;
		        }
		      }
		    }
		  }
		  readToken(type) {
		    switch (type) {
		      case _token.TYPE.DONE:
		        {
		          return this.readDoneToken();
		        }
		      case _token.TYPE.DONEPROC:
		        {
		          return this.readDoneProcToken();
		        }
		      case _token.TYPE.DONEINPROC:
		        {
		          return this.readDoneInProcToken();
		        }
		      case _token.TYPE.ERROR:
		        {
		          return this.readErrorToken();
		        }
		      case _token.TYPE.INFO:
		        {
		          return this.readInfoToken();
		        }
		      case _token.TYPE.ENVCHANGE:
		        {
		          return this.readEnvChangeToken();
		        }
		      case _token.TYPE.LOGINACK:
		        {
		          return this.readLoginAckToken();
		        }
		      case _token.TYPE.RETURNSTATUS:
		        {
		          return this.readReturnStatusToken();
		        }
		      case _token.TYPE.ORDER:
		        {
		          return this.readOrderToken();
		        }
		      case _token.TYPE.FEDAUTHINFO:
		        {
		          return this.readFedAuthInfoToken();
		        }
		      case _token.TYPE.SSPI:
		        {
		          return this.readSSPIToken();
		        }
		      case _token.TYPE.COLMETADATA:
		        {
		          return this.readColMetadataToken();
		        }
		      case _token.TYPE.RETURNVALUE:
		        {
		          return this.readReturnValueToken();
		        }
		      case _token.TYPE.ROW:
		        {
		          return this.readRowToken();
		        }
		      case _token.TYPE.NBCROW:
		        {
		          return this.readNbcRowToken();
		        }
		      case _token.TYPE.FEATUREEXTACK:
		        {
		          return this.readFeatureExtAckToken();
		        }
		      default:
		        {
		          throw new Error('Unknown type: ' + type);
		        }
		    }
		  }
		  readFeatureExtAckToken() {
		    let result;
		    try {
		      result = (0, _featureExtAckParser.default)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readFeatureExtAckToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  async readNbcRowToken() {
		    return await (0, _nbcrowTokenParser.default)(this);
		  }
		  async readReturnValueToken() {
		    return await (0, _returnvalueTokenParser.default)(this);
		  }
		  async readColMetadataToken() {
		    const token = await (0, _colmetadataTokenParser.default)(this);
		    this.colMetadata = token.columns;
		    return token;
		  }
		  readSSPIToken() {
		    let result;
		    try {
		      result = (0, _sspiTokenParser.default)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readSSPIToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  readFedAuthInfoToken() {
		    let result;
		    try {
		      result = (0, _fedauthInfoParser.default)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readFedAuthInfoToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  readOrderToken() {
		    let result;
		    try {
		      result = (0, _orderTokenParser.default)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readOrderToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  readReturnStatusToken() {
		    let result;
		    try {
		      result = (0, _returnstatusTokenParser.default)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readReturnStatusToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  readLoginAckToken() {
		    let result;
		    try {
		      result = (0, _loginackTokenParser.default)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readLoginAckToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  readEnvChangeToken() {
		    let result;
		    try {
		      result = (0, _envChangeTokenParser.default)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readEnvChangeToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  readRowToken() {
		    return (0, _rowTokenParser.default)(this);
		  }
		  readInfoToken() {
		    let result;
		    try {
		      result = (0, _infoerrorTokenParser.infoParser)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readInfoToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  readErrorToken() {
		    let result;
		    try {
		      result = (0, _infoerrorTokenParser.errorParser)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readErrorToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  readDoneInProcToken() {
		    let result;
		    try {
		      result = (0, _doneTokenParser.doneInProcParser)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readDoneInProcToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  readDoneProcToken() {
		    let result;
		    try {
		      result = (0, _doneTokenParser.doneProcParser)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readDoneProcToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  readDoneToken() {
		    let result;
		    try {
		      result = (0, _doneTokenParser.doneParser)(this.buffer, this.position, this.options);
		    } catch (err) {
		      if (err instanceof _helpers.NotEnoughDataError) {
		        return this.waitForChunk().then(() => {
		          return this.readDoneToken();
		        });
		      }
		      throw err;
		    }
		    this.position = result.offset;
		    return result.value;
		  }
		  constructor(iterable, debug, options) {
		    this.debug = debug;
		    this.colMetadata = [];
		    this.options = options;
		    this.iterator = (iterable[Symbol.asyncIterator] || iterable[Symbol.iterator]).call(iterable);
		    this.buffer = Buffer.alloc(0);
		    this.position = 0;
		  }
		  async waitForChunk() {
		    const result = await this.iterator.next();
		    if (result.done) {
		      throw new Error('unexpected end of data');
		    }
		    if (this.position === this.buffer.length) {
		      this.buffer = result.value;
		    } else {
		      this.buffer = Buffer.concat([this.buffer.slice(this.position), result.value]);
		    }
		    this.position = 0;
		  }
		}
		exports$1.default = Parser;
		module.exports = Parser;
		
	} (streamParser, streamParser.exports));
	return streamParser.exports;
}

var hasRequiredTokenStreamParser;

function requireTokenStreamParser () {
	if (hasRequiredTokenStreamParser) return tokenStreamParser;
	hasRequiredTokenStreamParser = 1;

	Object.defineProperty(tokenStreamParser, "__esModule", {
	  value: true
	});
	tokenStreamParser.Parser = void 0;
	var _events = require$$0$5;
	var _streamParser = _interopRequireDefault(requireStreamParser());
	var _stream = require$$0$6;
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	class Parser extends _events.EventEmitter {
	  constructor(message, debug, handler, options) {
	    super();
	    this.debug = debug;
	    this.options = options;
	    this.parser = _stream.Readable.from(_streamParser.default.parseTokens(message, this.debug, this.options));
	    this.parser.on('data', token => {
	      debug.token(token);
	      handler[token.handlerName](token);
	    });
	    this.parser.on('drain', () => {
	      this.emit('drain');
	    });
	    this.parser.on('end', () => {
	      this.emit('end');
	    });
	  }
	  pause() {
	    return this.parser.pause();
	  }
	  resume() {
	    return this.parser.resume();
	  }
	}
	tokenStreamParser.Parser = Parser;
	
	return tokenStreamParser;
}

var transaction$1 = {};

var hasRequiredTransaction$1;

function requireTransaction$1 () {
	if (hasRequiredTransaction$1) return transaction$1;
	hasRequiredTransaction$1 = 1;

	Object.defineProperty(transaction$1, "__esModule", {
	  value: true
	});
	transaction$1.Transaction = transaction$1.OPERATION_TYPE = transaction$1.ISOLATION_LEVEL = void 0;
	transaction$1.assertValidIsolationLevel = assertValidIsolationLevel;
	transaction$1.isolationLevelByValue = void 0;
	var _writableTrackingBuffer = _interopRequireDefault(requireWritableTrackingBuffer());
	var _allHeaders = requireAllHeaders();
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	/*
	  s2.2.6.8
	 */

	const OPERATION_TYPE = transaction$1.OPERATION_TYPE = {
	  TM_GET_DTC_ADDRESS: 0x00,
	  TM_PROPAGATE_XACT: 0x01,
	  TM_BEGIN_XACT: 0x05,
	  TM_PROMOTE_XACT: 0x06,
	  TM_COMMIT_XACT: 0x07,
	  TM_ROLLBACK_XACT: 0x08,
	  TM_SAVE_XACT: 0x09
	};
	const ISOLATION_LEVEL = transaction$1.ISOLATION_LEVEL = {
	  NO_CHANGE: 0x00,
	  READ_UNCOMMITTED: 0x01,
	  READ_COMMITTED: 0x02,
	  REPEATABLE_READ: 0x03,
	  SERIALIZABLE: 0x04,
	  SNAPSHOT: 0x05
	};
	const isolationLevelByValue = transaction$1.isolationLevelByValue = {};
	for (const name in ISOLATION_LEVEL) {
	  const value = ISOLATION_LEVEL[name];
	  isolationLevelByValue[value] = name;
	}
	function assertValidIsolationLevel(isolationLevel, name) {
	  if (typeof isolationLevel !== 'number') {
	    throw new TypeError(`The "${name}" ${name.includes('.') ? 'property' : 'argument'} must be of type number. Received type ${typeof isolationLevel} (${isolationLevel})`);
	  }
	  if (!Number.isInteger(isolationLevel)) {
	    throw new RangeError(`The value of "${name}" is out of range. It must be an integer. Received: ${isolationLevel}`);
	  }
	  if (!(isolationLevel >= 0 && isolationLevel <= 5)) {
	    throw new RangeError(`The value of "${name}" is out of range. It must be >= 0 && <= 5. Received: ${isolationLevel}`);
	  }
	}
	class Transaction {
	  constructor(name, isolationLevel = ISOLATION_LEVEL.NO_CHANGE) {
	    this.name = name;
	    this.isolationLevel = isolationLevel;
	    this.outstandingRequestCount = 1;
	  }
	  beginPayload(txnDescriptor) {
	    const buffer = new _writableTrackingBuffer.default(100, 'ucs2');
	    (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
	    buffer.writeUShort(OPERATION_TYPE.TM_BEGIN_XACT);
	    buffer.writeUInt8(this.isolationLevel);
	    buffer.writeUInt8(this.name.length * 2);
	    buffer.writeString(this.name, 'ucs2');
	    return {
	      *[Symbol.iterator]() {
	        yield buffer.data;
	      },
	      toString: () => {
	        return 'Begin Transaction: name=' + this.name + ', isolationLevel=' + isolationLevelByValue[this.isolationLevel];
	      }
	    };
	  }
	  commitPayload(txnDescriptor) {
	    const buffer = new _writableTrackingBuffer.default(100, 'ascii');
	    (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
	    buffer.writeUShort(OPERATION_TYPE.TM_COMMIT_XACT);
	    buffer.writeUInt8(this.name.length * 2);
	    buffer.writeString(this.name, 'ucs2');
	    // No fBeginXact flag, so no new transaction is started.
	    buffer.writeUInt8(0);
	    return {
	      *[Symbol.iterator]() {
	        yield buffer.data;
	      },
	      toString: () => {
	        return 'Commit Transaction: name=' + this.name;
	      }
	    };
	  }
	  rollbackPayload(txnDescriptor) {
	    const buffer = new _writableTrackingBuffer.default(100, 'ascii');
	    (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
	    buffer.writeUShort(OPERATION_TYPE.TM_ROLLBACK_XACT);
	    buffer.writeUInt8(this.name.length * 2);
	    buffer.writeString(this.name, 'ucs2');
	    // No fBeginXact flag, so no new transaction is started.
	    buffer.writeUInt8(0);
	    return {
	      *[Symbol.iterator]() {
	        yield buffer.data;
	      },
	      toString: () => {
	        return 'Rollback Transaction: name=' + this.name;
	      }
	    };
	  }
	  savePayload(txnDescriptor) {
	    const buffer = new _writableTrackingBuffer.default(100, 'ascii');
	    (0, _allHeaders.writeToTrackingBuffer)(buffer, txnDescriptor, this.outstandingRequestCount);
	    buffer.writeUShort(OPERATION_TYPE.TM_SAVE_XACT);
	    buffer.writeUInt8(this.name.length * 2);
	    buffer.writeString(this.name, 'ucs2');
	    return {
	      *[Symbol.iterator]() {
	        yield buffer.data;
	      },
	      toString: () => {
	        return 'Save Transaction: name=' + this.name;
	      }
	    };
	  }
	  isolationLevelToTSQL() {
	    switch (this.isolationLevel) {
	      case ISOLATION_LEVEL.READ_UNCOMMITTED:
	        return 'READ UNCOMMITTED';
	      case ISOLATION_LEVEL.READ_COMMITTED:
	        return 'READ COMMITTED';
	      case ISOLATION_LEVEL.REPEATABLE_READ:
	        return 'REPEATABLE READ';
	      case ISOLATION_LEVEL.SERIALIZABLE:
	        return 'SERIALIZABLE';
	      case ISOLATION_LEVEL.SNAPSHOT:
	        return 'SNAPSHOT';
	    }
	    return '';
	  }
	}
	transaction$1.Transaction = Transaction;
	
	return transaction$1;
}

var connector = {};

var hasRequiredConnector;

function requireConnector () {
	if (hasRequiredConnector) return connector;
	hasRequiredConnector = 1;

	Object.defineProperty(connector, "__esModule", {
	  value: true
	});
	connector.connectInParallel = connectInParallel;
	connector.connectInSequence = connectInSequence;
	connector.lookupAllAddresses = lookupAllAddresses;
	var _net = _interopRequireDefault(require$$0$9);
	var _nodeUrl = _interopRequireDefault(__require());
	var _abortError = _interopRequireDefault(requireAbortError());
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	async function connectInParallel(options, lookup, signal) {
	  if (signal.aborted) {
	    throw new _abortError.default();
	  }
	  const addresses = await lookupAllAddresses(options.host, lookup, signal);
	  return await new Promise((resolve, reject) => {
	    const sockets = new Array(addresses.length);
	    const errors = [];
	    function onError(err) {
	      errors.push(err);
	      this.removeListener('error', onError);
	      this.removeListener('connect', onConnect);
	      this.destroy();
	      if (errors.length === addresses.length) {
	        signal.removeEventListener('abort', onAbort);
	        reject(new AggregateError(errors, 'Could not connect (parallel)'));
	      }
	    }
	    function onConnect() {
	      signal.removeEventListener('abort', onAbort);
	      for (let j = 0; j < sockets.length; j++) {
	        const socket = sockets[j];
	        if (this === socket) {
	          continue;
	        }
	        socket.removeListener('error', onError);
	        socket.removeListener('connect', onConnect);
	        socket.destroy();
	      }
	      resolve(this);
	    }
	    const onAbort = () => {
	      for (let j = 0; j < sockets.length; j++) {
	        const socket = sockets[j];
	        socket.removeListener('error', onError);
	        socket.removeListener('connect', onConnect);
	        socket.destroy();
	      }
	      reject(new _abortError.default());
	    };
	    for (let i = 0, len = addresses.length; i < len; i++) {
	      const socket = sockets[i] = _net.default.connect({
	        ...options,
	        host: addresses[i].address,
	        family: addresses[i].family
	      });
	      socket.on('error', onError);
	      socket.on('connect', onConnect);
	    }
	    signal.addEventListener('abort', onAbort, {
	      once: true
	    });
	  });
	}
	async function connectInSequence(options, lookup, signal) {
	  if (signal.aborted) {
	    throw new _abortError.default();
	  }
	  const errors = [];
	  const addresses = await lookupAllAddresses(options.host, lookup, signal);
	  for (const address of addresses) {
	    try {
	      return await new Promise((resolve, reject) => {
	        const socket = _net.default.connect({
	          ...options,
	          host: address.address,
	          family: address.family
	        });
	        const onAbort = () => {
	          socket.removeListener('error', onError);
	          socket.removeListener('connect', onConnect);
	          socket.destroy();
	          reject(new _abortError.default());
	        };
	        const onError = err => {
	          signal.removeEventListener('abort', onAbort);
	          socket.removeListener('error', onError);
	          socket.removeListener('connect', onConnect);
	          socket.destroy();
	          reject(err);
	        };
	        const onConnect = () => {
	          signal.removeEventListener('abort', onAbort);
	          socket.removeListener('error', onError);
	          socket.removeListener('connect', onConnect);
	          resolve(socket);
	        };
	        signal.addEventListener('abort', onAbort, {
	          once: true
	        });
	        socket.on('error', onError);
	        socket.on('connect', onConnect);
	      });
	    } catch (err) {
	      if (err instanceof Error && err.name === 'AbortError') {
	        throw err;
	      }
	      errors.push(err);
	      continue;
	    }
	  }
	  throw new AggregateError(errors, 'Could not connect (sequence)');
	}

	/**
	 * Look up all addresses for the given hostname.
	 */
	async function lookupAllAddresses(host, lookup, signal) {
	  if (signal.aborted) {
	    throw new _abortError.default();
	  }
	  if (_net.default.isIPv6(host)) {
	    return [{
	      address: host,
	      family: 6
	    }];
	  } else if (_net.default.isIPv4(host)) {
	    return [{
	      address: host,
	      family: 4
	    }];
	  } else {
	    return await new Promise((resolve, reject) => {
	      const onAbort = () => {
	        reject(new _abortError.default());
	      };
	      signal.addEventListener('abort', onAbort);
	      const domainInASCII = _nodeUrl.default.domainToASCII(host);
	      lookup(domainInASCII === '' ? host : domainInASCII, {
	        all: true
	      }, (err, addresses) => {
	        signal.removeEventListener('abort', onAbort);
	        err ? reject(err) : resolve(addresses);
	      });
	    });
	  }
	}
	
	return connector;
}

var library = {};

var hasRequiredLibrary;

function requireLibrary () {
	if (hasRequiredLibrary) return library;
	hasRequiredLibrary = 1;

	Object.defineProperty(library, "__esModule", {
	  value: true
	});
	library.name = void 0;
	library.name = 'Tedious';
	
	return library;
}

var ntlm = {};

var hasRequiredNtlm;

function requireNtlm () {
	if (hasRequiredNtlm) return ntlm;
	hasRequiredNtlm = 1;

	Object.defineProperty(ntlm, "__esModule", {
	  value: true
	});
	ntlm.createNTLMRequest = createNTLMRequest;
	const NTLMFlags = {
	  NTLM_NegotiateUnicode: 0x00000001,
	  NTLM_NegotiateOEM: 0x00000002,
	  NTLM_RequestTarget: 0x00000004,
	  NTLM_NegotiateNTLM: 0x00000200,
	  NTLM_NegotiateOemDomainSupplied: 0x00001000,
	  NTLM_NegotiateOemWorkstationSupplied: 0x00002000,
	  NTLM_NegotiateAlwaysSign: 0x00008000,
	  NTLM_NegotiateExtendedSecurity: 0x00080000,
	  NTLM_NegotiateVersion: 0x02000000,
	  NTLM_Negotiate128: 0x20000000,
	  NTLM_Negotiate56: 0x80000000
	};
	function createNTLMRequest(options) {
	  const domain = escape(options.domain.toUpperCase());
	  const workstation = options.workstation ? escape(options.workstation.toUpperCase()) : '';
	  let type1flags = NTLMFlags.NTLM_NegotiateUnicode + NTLMFlags.NTLM_NegotiateOEM + NTLMFlags.NTLM_RequestTarget + NTLMFlags.NTLM_NegotiateNTLM + NTLMFlags.NTLM_NegotiateOemDomainSupplied + NTLMFlags.NTLM_NegotiateOemWorkstationSupplied + NTLMFlags.NTLM_NegotiateAlwaysSign + NTLMFlags.NTLM_NegotiateVersion + NTLMFlags.NTLM_NegotiateExtendedSecurity + NTLMFlags.NTLM_Negotiate128 + NTLMFlags.NTLM_Negotiate56;
	  if (workstation === '') {
	    type1flags -= NTLMFlags.NTLM_NegotiateOemWorkstationSupplied;
	  }
	  const fixedData = Buffer.alloc(40);
	  const buffers = [fixedData];
	  let offset = 0;
	  offset += fixedData.write('NTLMSSP', offset, 7, 'ascii');
	  offset = fixedData.writeUInt8(0, offset);
	  offset = fixedData.writeUInt32LE(1, offset);
	  offset = fixedData.writeUInt32LE(type1flags, offset);
	  offset = fixedData.writeUInt16LE(domain.length, offset);
	  offset = fixedData.writeUInt16LE(domain.length, offset);
	  offset = fixedData.writeUInt32LE(fixedData.length + workstation.length, offset);
	  offset = fixedData.writeUInt16LE(workstation.length, offset);
	  offset = fixedData.writeUInt16LE(workstation.length, offset);
	  offset = fixedData.writeUInt32LE(fixedData.length, offset);
	  offset = fixedData.writeUInt8(5, offset);
	  offset = fixedData.writeUInt8(0, offset);
	  offset = fixedData.writeUInt16LE(2195, offset);
	  offset = fixedData.writeUInt8(0, offset);
	  offset = fixedData.writeUInt8(0, offset);
	  offset = fixedData.writeUInt8(0, offset);
	  fixedData.writeUInt8(15, offset);
	  buffers.push(Buffer.from(workstation, 'ascii'));
	  buffers.push(Buffer.from(domain, 'ascii'));
	  return Buffer.concat(buffers);
	}
	
	return ntlm;
}

var bulkLoadPayload = {};

var hasRequiredBulkLoadPayload;

function requireBulkLoadPayload () {
	if (hasRequiredBulkLoadPayload) return bulkLoadPayload;
	hasRequiredBulkLoadPayload = 1;

	Object.defineProperty(bulkLoadPayload, "__esModule", {
	  value: true
	});
	bulkLoadPayload.BulkLoadPayload = void 0;
	class BulkLoadPayload {
	  constructor(bulkLoad) {
	    this.bulkLoad = bulkLoad;

	    // We need to grab the iterator here so that `error` event handlers are set up
	    // as early as possible (and are not potentially lost).
	    this.iterator = this.bulkLoad.rowToPacketTransform[Symbol.asyncIterator]();
	  }
	  [Symbol.asyncIterator]() {
	    return this.iterator;
	  }
	  toString(indent = '') {
	    return indent + 'BulkLoad';
	  }
	}
	bulkLoadPayload.BulkLoadPayload = BulkLoadPayload;
	
	return bulkLoadPayload;
}

var specialStoredProcedure = {exports: {}};

var hasRequiredSpecialStoredProcedure;

function requireSpecialStoredProcedure () {
	if (hasRequiredSpecialStoredProcedure) return specialStoredProcedure.exports;
	hasRequiredSpecialStoredProcedure = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		const procedures = {
		  Sp_Cursor: 1,
		  Sp_CursorOpen: 2,
		  Sp_CursorPrepare: 3,
		  Sp_CursorExecute: 4,
		  Sp_CursorPrepExec: 5,
		  Sp_CursorUnprepare: 6,
		  Sp_CursorFetch: 7,
		  Sp_CursorOption: 8,
		  Sp_CursorClose: 9,
		  Sp_ExecuteSql: 10,
		  Sp_Prepare: 11,
		  Sp_Execute: 12,
		  Sp_PrepExec: 13,
		  Sp_PrepExecRpc: 14,
		  Sp_Unprepare: 15
		};
		exports$1.default = procedures;
		module.exports = procedures;
		
	} (specialStoredProcedure, specialStoredProcedure.exports));
	return specialStoredProcedure.exports;
}

var version = "18.6.2";
var require$$33 = {
	version: version};

var handler = {};

var hasRequiredHandler;

function requireHandler () {
	if (hasRequiredHandler) return handler;
	hasRequiredHandler = 1;

	Object.defineProperty(handler, "__esModule", {
	  value: true
	});
	handler.UnexpectedTokenError = handler.TokenHandler = handler.RequestTokenHandler = handler.Login7TokenHandler = handler.InitialSqlTokenHandler = handler.AttentionTokenHandler = void 0;
	var _request = _interopRequireDefault(requireRequest$1());
	var _errors = requireErrors$1();
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	class UnexpectedTokenError extends Error {
	  constructor(handler, token) {
	    super('Unexpected token `' + token.name + '` in `' + handler.constructor.name + '`');
	  }
	}
	handler.UnexpectedTokenError = UnexpectedTokenError;
	class TokenHandler {
	  onInfoMessage(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onErrorMessage(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onSSPI(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onDatabaseChange(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onLanguageChange(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onCharsetChange(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onSqlCollationChange(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onRoutingChange(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onPacketSizeChange(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onResetConnection(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onBeginTransaction(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onCommitTransaction(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onRollbackTransaction(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onFedAuthInfo(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onFeatureExtAck(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onLoginAck(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onColMetadata(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onOrder(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onRow(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onReturnStatus(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onReturnValue(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onDoneProc(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onDoneInProc(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onDone(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	  onDatabaseMirroringPartner(token) {
	    throw new UnexpectedTokenError(this, token);
	  }
	}

	/**
	 * A handler for tokens received in the response message to the initial SQL Batch request
	 * that sets up different connection settings.
	 */
	handler.TokenHandler = TokenHandler;
	class InitialSqlTokenHandler extends TokenHandler {
	  constructor(connection) {
	    super();
	    this.connection = connection;
	  }
	  onInfoMessage(token) {
	    this.connection.emit('infoMessage', token);
	  }
	  onErrorMessage(token) {
	    this.connection.emit('errorMessage', token);
	  }
	  onDatabaseChange(token) {
	    this.connection.emit('databaseChange', token.newValue);
	  }
	  onLanguageChange(token) {
	    this.connection.emit('languageChange', token.newValue);
	  }
	  onCharsetChange(token) {
	    this.connection.emit('charsetChange', token.newValue);
	  }
	  onSqlCollationChange(token) {
	    this.connection.databaseCollation = token.newValue;
	  }
	  onPacketSizeChange(token) {
	    this.connection.messageIo.packetSize(token.newValue);
	  }
	  onBeginTransaction(token) {
	    this.connection.transactionDescriptors.push(token.newValue);
	    this.connection.inTransaction = true;
	  }
	  onCommitTransaction(token) {
	    this.connection.transactionDescriptors.length = 1;
	    this.connection.inTransaction = false;
	  }
	  onRollbackTransaction(token) {
	    this.connection.transactionDescriptors.length = 1;
	    // An outermost transaction was rolled back. Reset the transaction counter
	    this.connection.inTransaction = false;
	    this.connection.emit('rollbackTransaction');
	  }
	  onColMetadata(token) {
	    this.connection.emit('error', new Error("Received 'columnMetadata' when no sqlRequest is in progress"));
	    this.connection.close();
	  }
	  onOrder(token) {
	    this.connection.emit('error', new Error("Received 'order' when no sqlRequest is in progress"));
	    this.connection.close();
	  }
	  onRow(token) {
	    this.connection.emit('error', new Error("Received 'row' when no sqlRequest is in progress"));
	    this.connection.close();
	  }
	  onReturnStatus(token) {
	    // Do nothing
	  }
	  onReturnValue(token) {
	    // Do nothing
	  }
	  onDoneProc(token) {
	    // Do nothing
	  }
	  onDoneInProc(token) {
	    // Do nothing
	  }
	  onDone(token) {
	    // Do nothing
	  }
	  onResetConnection(token) {
	    this.connection.emit('resetConnection');
	  }
	}

	/**
	 * A handler for tokens received in the response message to a Login7 message.
	 */
	handler.InitialSqlTokenHandler = InitialSqlTokenHandler;
	class Login7TokenHandler extends TokenHandler {
	  constructor(connection) {
	    super();
	    this.loginAckReceived = false;
	    this.connection = connection;
	  }
	  onInfoMessage(token) {
	    this.connection.emit('infoMessage', token);
	  }
	  onErrorMessage(token) {
	    this.connection.emit('errorMessage', token);
	    const error = new _errors.ConnectionError(token.message, 'ELOGIN');
	    const isLoginErrorTransient = this.connection.transientErrorLookup.isTransientError(token.number);
	    if (isLoginErrorTransient && this.connection.curTransientRetryCount !== this.connection.config.options.maxRetriesOnTransientErrors) {
	      error.isTransient = true;
	    }
	    this.connection.loginError = error;
	  }
	  onSSPI(token) {
	    if (token.ntlmpacket) {
	      this.connection.ntlmpacket = token.ntlmpacket;
	      this.connection.ntlmpacketBuffer = token.ntlmpacketBuffer;
	    }
	  }
	  onDatabaseChange(token) {
	    this.connection.emit('databaseChange', token.newValue);
	  }
	  onLanguageChange(token) {
	    this.connection.emit('languageChange', token.newValue);
	  }
	  onCharsetChange(token) {
	    this.connection.emit('charsetChange', token.newValue);
	  }
	  onSqlCollationChange(token) {
	    this.connection.databaseCollation = token.newValue;
	  }
	  onFedAuthInfo(token) {
	    this.fedAuthInfoToken = token;
	  }
	  onFeatureExtAck(token) {
	    const {
	      authentication
	    } = this.connection.config;
	    if (authentication.type === 'azure-active-directory-password' || authentication.type === 'azure-active-directory-access-token' || authentication.type === 'azure-active-directory-msi-vm' || authentication.type === 'azure-active-directory-msi-app-service' || authentication.type === 'azure-active-directory-service-principal-secret' || authentication.type === 'azure-active-directory-default') {
	      if (token.fedAuth === undefined) {
	        this.connection.loginError = new _errors.ConnectionError('Did not receive Active Directory authentication acknowledgement');
	      } else if (token.fedAuth.length !== 0) {
	        this.connection.loginError = new _errors.ConnectionError(`Active Directory authentication acknowledgment for ${authentication.type} authentication method includes extra data`);
	      }
	    } else if (token.fedAuth === undefined && token.utf8Support === undefined) {
	      this.connection.loginError = new _errors.ConnectionError('Received acknowledgement for unknown feature');
	    } else if (token.fedAuth) {
	      this.connection.loginError = new _errors.ConnectionError('Did not request Active Directory authentication, but received the acknowledgment');
	    }
	  }
	  onLoginAck(token) {
	    if (!token.tdsVersion) {
	      // unsupported TDS version
	      this.connection.loginError = new _errors.ConnectionError('Server responded with unknown TDS version.', 'ETDS');
	      return;
	    }
	    if (!token.interface) {
	      // unsupported interface
	      this.connection.loginError = new _errors.ConnectionError('Server responded with unsupported interface.', 'EINTERFACENOTSUPP');
	      return;
	    }

	    // use negotiated version
	    this.connection.config.options.tdsVersion = token.tdsVersion;
	    this.loginAckReceived = true;
	  }
	  onRoutingChange(token) {
	    // Removes instance name attached to the redirect url. E.g., redirect.db.net\instance1 --> redirect.db.net
	    const [server] = token.newValue.server.split('\\');
	    this.routingData = {
	      server,
	      port: token.newValue.port
	    };
	  }
	  onDoneInProc(token) {
	    // Do nothing
	  }
	  onDone(token) {
	    // Do nothing
	  }
	  onPacketSizeChange(token) {
	    this.connection.messageIo.packetSize(token.newValue);
	  }
	  onDatabaseMirroringPartner(token) {
	    // Do nothing
	  }
	}

	/**
	 * A handler for tokens received in the response message to a RPC Request,
	 * a SQL Batch Request, a Bulk Load BCP Request or a Transaction Manager Request.
	 */
	handler.Login7TokenHandler = Login7TokenHandler;
	class RequestTokenHandler extends TokenHandler {
	  constructor(connection, request) {
	    super();
	    this.connection = connection;
	    this.request = request;
	    this.errors = [];
	  }
	  onInfoMessage(token) {
	    this.connection.emit('infoMessage', token);
	  }
	  onErrorMessage(token) {
	    this.connection.emit('errorMessage', token);
	    if (!this.request.canceled) {
	      const error = new _errors.RequestError(token.message, 'EREQUEST');
	      error.number = token.number;
	      error.state = token.state;
	      error.class = token.class;
	      error.serverName = token.serverName;
	      error.procName = token.procName;
	      error.lineNumber = token.lineNumber;
	      this.errors.push(error);
	      this.request.error = error;
	      if (this.request instanceof _request.default && this.errors.length > 1) {
	        this.request.error = new AggregateError(this.errors);
	      }
	    }
	  }
	  onDatabaseChange(token) {
	    this.connection.emit('databaseChange', token.newValue);
	  }
	  onLanguageChange(token) {
	    this.connection.emit('languageChange', token.newValue);
	  }
	  onCharsetChange(token) {
	    this.connection.emit('charsetChange', token.newValue);
	  }
	  onSqlCollationChange(token) {
	    this.connection.databaseCollation = token.newValue;
	  }
	  onPacketSizeChange(token) {
	    this.connection.messageIo.packetSize(token.newValue);
	  }
	  onBeginTransaction(token) {
	    this.connection.transactionDescriptors.push(token.newValue);
	    this.connection.inTransaction = true;
	  }
	  onCommitTransaction(token) {
	    this.connection.transactionDescriptors.length = 1;
	    this.connection.inTransaction = false;
	  }
	  onRollbackTransaction(token) {
	    this.connection.transactionDescriptors.length = 1;
	    // An outermost transaction was rolled back. Reset the transaction counter
	    this.connection.inTransaction = false;
	    this.connection.emit('rollbackTransaction');
	  }
	  onColMetadata(token) {
	    if (!this.request.canceled) {
	      if (this.connection.config.options.useColumnNames) {
	        const columns = Object.create(null);
	        for (let j = 0, len = token.columns.length; j < len; j++) {
	          const col = token.columns[j];
	          if (columns[col.colName] == null) {
	            columns[col.colName] = col;
	          }
	        }
	        this.request.emit('columnMetadata', columns);
	      } else {
	        this.request.emit('columnMetadata', token.columns);
	      }
	    }
	  }
	  onOrder(token) {
	    if (!this.request.canceled) {
	      this.request.emit('order', token.orderColumns);
	    }
	  }
	  onRow(token) {
	    if (!this.request.canceled) {
	      if (this.connection.config.options.rowCollectionOnRequestCompletion) {
	        this.request.rows.push(token.columns);
	      }
	      if (this.connection.config.options.rowCollectionOnDone) {
	        this.request.rst.push(token.columns);
	      }
	      this.request.emit('row', token.columns);
	    }
	  }
	  onReturnStatus(token) {
	    if (!this.request.canceled) {
	      // Keep value for passing in 'doneProc' event.
	      this.connection.procReturnStatusValue = token.value;
	    }
	  }
	  onReturnValue(token) {
	    if (!this.request.canceled) {
	      this.request.emit('returnValue', token.paramName, token.value, token.metadata);
	    }
	  }
	  onDoneProc(token) {
	    if (!this.request.canceled) {
	      if (token.sqlError && !this.request.error) {
	        // check if the DONE_ERROR flags was set, but an ERROR token was not sent.
	        this.request.error = new _errors.RequestError('An unknown error has occurred.', 'UNKNOWN');
	      }
	      this.request.emit('doneProc', token.rowCount, token.more, this.connection.procReturnStatusValue, this.request.rst);
	      this.connection.procReturnStatusValue = undefined;
	      if (token.rowCount !== undefined) {
	        this.request.rowCount += token.rowCount;
	      }
	      if (this.connection.config.options.rowCollectionOnDone) {
	        this.request.rst = [];
	      }
	    }
	  }
	  onDoneInProc(token) {
	    if (!this.request.canceled) {
	      this.request.emit('doneInProc', token.rowCount, token.more, this.request.rst);
	      if (token.rowCount !== undefined) {
	        this.request.rowCount += token.rowCount;
	      }
	      if (this.connection.config.options.rowCollectionOnDone) {
	        this.request.rst = [];
	      }
	    }
	  }
	  onDone(token) {
	    if (!this.request.canceled) {
	      if (token.sqlError && !this.request.error) {
	        // check if the DONE_ERROR flags was set, but an ERROR token was not sent.
	        this.request.error = new _errors.RequestError('An unknown error has occurred.', 'UNKNOWN');
	      }
	      this.request.emit('done', token.rowCount, token.more, this.request.rst);
	      if (token.rowCount !== undefined) {
	        this.request.rowCount += token.rowCount;
	      }
	      if (this.connection.config.options.rowCollectionOnDone) {
	        this.request.rst = [];
	      }
	    }
	  }
	  onResetConnection(token) {
	    this.connection.emit('resetConnection');
	  }
	}

	/**
	 * A handler for the attention acknowledgement message.
	 *
	 * This message only contains a `DONE` token that acknowledges
	 * that the attention message was received by the server.
	 */
	handler.RequestTokenHandler = RequestTokenHandler;
	class AttentionTokenHandler extends TokenHandler {
	  /**
	   * Returns whether an attention acknowledgement was received.
	   */

	  constructor(connection, request) {
	    super();
	    this.connection = connection;
	    this.request = request;
	    this.attentionReceived = false;
	  }
	  onDone(token) {
	    if (token.attention) {
	      this.attentionReceived = true;
	    }
	  }
	}
	handler.AttentionTokenHandler = AttentionTokenHandler;
	
	return handler;
}

var hasRequiredConnection;

function requireConnection () {
	if (hasRequiredConnection) return connection.exports;
	hasRequiredConnection = 1;
	(function (module, exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		exports$1.default = void 0;
		var _crypto = _interopRequireDefault(crypto$1);
		var _os = _interopRequireDefault(require$$0$4);
		var tls = _interopRequireWildcard(require$$1$3);
		var net = _interopRequireWildcard(require$$0$9);
		var _dns = _interopRequireDefault(require$$0$b);
		var _constants = _interopRequireDefault(require$$5$3);
		var _stream = require$$0$6;
		var _identity = /*@__PURE__*/ requireCommonjs$1();
		var _coreAuth = /*@__PURE__*/ requireCommonjs();
		var _bulkLoad = _interopRequireDefault(requireBulkLoad());
		var _debug = _interopRequireDefault(requireDebug());
		var _events = require$$0$5;
		var _instanceLookup = requireInstanceLookup();
		var _transientErrorLookup = requireTransientErrorLookup();
		var _packet = requirePacket();
		var _preloginPayload = _interopRequireDefault(requirePreloginPayload());
		var _login7Payload = _interopRequireDefault(requireLogin7Payload());
		var _ntlmPayload = _interopRequireDefault(requireNtlmPayload());
		var _request = _interopRequireDefault(requireRequest$1());
		var _rpcrequestPayload = _interopRequireDefault(requireRpcrequestPayload());
		var _sqlbatchPayload = _interopRequireDefault(requireSqlbatchPayload());
		var _messageIo = _interopRequireDefault(requireMessageIo());
		var _tokenStreamParser = requireTokenStreamParser();
		var _transaction = requireTransaction$1();
		var _errors = requireErrors$1();
		var _connector = requireConnector();
		var _library = requireLibrary();
		var _tdsVersions = requireTdsVersions();
		var _message = _interopRequireDefault(requireMessage());
		var _ntlm = requireNtlm();
		var _dataType = requireDataType();
		var _bulkLoadPayload = requireBulkLoadPayload();
		var _specialStoredProcedure = _interopRequireDefault(requireSpecialStoredProcedure());
		var _package = require$$33;
		var _url = require$$5$2;
		var _handler = requireHandler();
		function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
		function _interopRequireWildcard(e, r) { if (e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		// eslint-disable-next-line @typescript-eslint/no-unused-vars

		/**
		 * @private
		 */
		const KEEP_ALIVE_INITIAL_DELAY = 30 * 1000;
		/**
		 * @private
		 */
		const DEFAULT_CONNECT_TIMEOUT = 15 * 1000;
		/**
		 * @private
		 */
		const DEFAULT_CLIENT_REQUEST_TIMEOUT = 15 * 1000;
		/**
		 * @private
		 */
		const DEFAULT_CANCEL_TIMEOUT = 5 * 1000;
		/**
		 * @private
		 */
		const DEFAULT_CONNECT_RETRY_INTERVAL = 500;
		/**
		 * @private
		 */
		const DEFAULT_PACKET_SIZE = 4 * 1024;
		/**
		 * @private
		 */
		const DEFAULT_TEXTSIZE = 2147483647;
		/**
		 * @private
		 */
		const DEFAULT_DATEFIRST = 7;
		/**
		 * @private
		 */
		const DEFAULT_PORT = 1433;
		/**
		 * @private
		 */
		const DEFAULT_TDS_VERSION = '7_4';
		/**
		 * @private
		 */
		const DEFAULT_LANGUAGE = 'us_english';
		/**
		 * @private
		 */
		const DEFAULT_DATEFORMAT = 'mdy';

		/** Structure that defines the options that are necessary to authenticate the Tedious.JS instance with an `@azure/identity` token credential. */

		/**
		 * @private
		 */

		/**
		 * @private
		 */
		const CLEANUP_TYPE = {
		  NORMAL: 0,
		  REDIRECT: 1,
		  RETRY: 2
		};
		/**
		 * A [[Connection]] instance represents a single connection to a database server.
		 *
		 * ```js
		 * var Connection = require('tedious').Connection;
		 * var config = {
		 *  "authentication": {
		 *    ...,
		 *    "options": {...}
		 *  },
		 *  "options": {...}
		 * };
		 * var connection = new Connection(config);
		 * ```
		 *
		 * Only one request at a time may be executed on a connection. Once a [[Request]]
		 * has been initiated (with [[Connection.callProcedure]], [[Connection.execSql]],
		 * or [[Connection.execSqlBatch]]), another should not be initiated until the
		 * [[Request]]'s completion callback is called.
		 */
		class Connection extends _events.EventEmitter {
		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */
		  _cancelAfterRequestSent;

		  /**
		   * @private
		   */

		  /**
		   * Note: be aware of the different options field:
		   * 1. config.authentication.options
		   * 2. config.options
		   *
		   * ```js
		   * const { Connection } = require('tedious');
		   *
		   * const config = {
		   *  "authentication": {
		   *    ...,
		   *    "options": {...}
		   *  },
		   *  "options": {...}
		   * };
		   *
		   * const connection = new Connection(config);
		   * ```
		   *
		   * @param config
		   */
		  constructor(config) {
		    super();
		    if (typeof config !== 'object' || config === null) {
		      throw new TypeError('The "config" argument is required and must be of type Object.');
		    }
		    if (typeof config.server !== 'string') {
		      throw new TypeError('The "config.server" property is required and must be of type string.');
		    }
		    this.fedAuthRequired = false;
		    let authentication;
		    if (config.authentication !== undefined) {
		      if (typeof config.authentication !== 'object' || config.authentication === null) {
		        throw new TypeError('The "config.authentication" property must be of type Object.');
		      }
		      const type = config.authentication.type;
		      const options = config.authentication.options === undefined ? {} : config.authentication.options;
		      if (typeof type !== 'string') {
		        throw new TypeError('The "config.authentication.type" property must be of type string.');
		      }
		      if (type !== 'default' && type !== 'ntlm' && type !== 'token-credential' && type !== 'azure-active-directory-password' && type !== 'azure-active-directory-access-token' && type !== 'azure-active-directory-msi-vm' && type !== 'azure-active-directory-msi-app-service' && type !== 'azure-active-directory-service-principal-secret' && type !== 'azure-active-directory-default') {
		        throw new TypeError('The "type" property must one of "default", "ntlm", "token-credential", "azure-active-directory-password", "azure-active-directory-access-token", "azure-active-directory-default", "azure-active-directory-msi-vm" or "azure-active-directory-msi-app-service" or "azure-active-directory-service-principal-secret".');
		      }
		      if (typeof options !== 'object' || options === null) {
		        throw new TypeError('The "config.authentication.options" property must be of type object.');
		      }
		      if (type === 'ntlm') {
		        if (typeof options.domain !== 'string') {
		          throw new TypeError('The "config.authentication.options.domain" property must be of type string.');
		        }
		        if (options.userName !== undefined && typeof options.userName !== 'string') {
		          throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
		        }
		        if (options.password !== undefined && typeof options.password !== 'string') {
		          throw new TypeError('The "config.authentication.options.password" property must be of type string.');
		        }
		        authentication = {
		          type: 'ntlm',
		          options: {
		            userName: options.userName,
		            password: options.password,
		            domain: options.domain && options.domain.toUpperCase()
		          }
		        };
		      } else if (type === 'token-credential') {
		        if (!(0, _coreAuth.isTokenCredential)(options.credential)) {
		          throw new TypeError('The "config.authentication.options.credential" property must be an instance of the token credential class.');
		        }
		        authentication = {
		          type: 'token-credential',
		          options: {
		            credential: options.credential
		          }
		        };
		      } else if (type === 'azure-active-directory-password') {
		        if (typeof options.clientId !== 'string') {
		          throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
		        }
		        if (options.userName !== undefined && typeof options.userName !== 'string') {
		          throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
		        }
		        if (options.password !== undefined && typeof options.password !== 'string') {
		          throw new TypeError('The "config.authentication.options.password" property must be of type string.');
		        }
		        if (options.tenantId !== undefined && typeof options.tenantId !== 'string') {
		          throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
		        }
		        authentication = {
		          type: 'azure-active-directory-password',
		          options: {
		            userName: options.userName,
		            password: options.password,
		            tenantId: options.tenantId,
		            clientId: options.clientId
		          }
		        };
		      } else if (type === 'azure-active-directory-access-token') {
		        if (typeof options.token !== 'string') {
		          throw new TypeError('The "config.authentication.options.token" property must be of type string.');
		        }
		        authentication = {
		          type: 'azure-active-directory-access-token',
		          options: {
		            token: options.token
		          }
		        };
		      } else if (type === 'azure-active-directory-msi-vm') {
		        if (options.clientId !== undefined && typeof options.clientId !== 'string') {
		          throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
		        }
		        authentication = {
		          type: 'azure-active-directory-msi-vm',
		          options: {
		            clientId: options.clientId
		          }
		        };
		      } else if (type === 'azure-active-directory-default') {
		        if (options.clientId !== undefined && typeof options.clientId !== 'string') {
		          throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
		        }
		        authentication = {
		          type: 'azure-active-directory-default',
		          options: {
		            clientId: options.clientId
		          }
		        };
		      } else if (type === 'azure-active-directory-msi-app-service') {
		        if (options.clientId !== undefined && typeof options.clientId !== 'string') {
		          throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
		        }
		        authentication = {
		          type: 'azure-active-directory-msi-app-service',
		          options: {
		            clientId: options.clientId
		          }
		        };
		      } else if (type === 'azure-active-directory-service-principal-secret') {
		        if (typeof options.clientId !== 'string') {
		          throw new TypeError('The "config.authentication.options.clientId" property must be of type string.');
		        }
		        if (typeof options.clientSecret !== 'string') {
		          throw new TypeError('The "config.authentication.options.clientSecret" property must be of type string.');
		        }
		        if (typeof options.tenantId !== 'string') {
		          throw new TypeError('The "config.authentication.options.tenantId" property must be of type string.');
		        }
		        authentication = {
		          type: 'azure-active-directory-service-principal-secret',
		          options: {
		            clientId: options.clientId,
		            clientSecret: options.clientSecret,
		            tenantId: options.tenantId
		          }
		        };
		      } else {
		        if (options.userName !== undefined && typeof options.userName !== 'string') {
		          throw new TypeError('The "config.authentication.options.userName" property must be of type string.');
		        }
		        if (options.password !== undefined && typeof options.password !== 'string') {
		          throw new TypeError('The "config.authentication.options.password" property must be of type string.');
		        }
		        authentication = {
		          type: 'default',
		          options: {
		            userName: options.userName,
		            password: options.password
		          }
		        };
		      }
		    } else {
		      authentication = {
		        type: 'default',
		        options: {
		          userName: undefined,
		          password: undefined
		        }
		      };
		    }
		    this.config = {
		      server: config.server,
		      authentication: authentication,
		      options: {
		        abortTransactionOnError: false,
		        appName: undefined,
		        camelCaseColumns: false,
		        cancelTimeout: DEFAULT_CANCEL_TIMEOUT,
		        columnEncryptionKeyCacheTTL: 2 * 60 * 60 * 1000,
		        // Units: milliseconds
		        columnEncryptionSetting: false,
		        columnNameReplacer: undefined,
		        connectionRetryInterval: DEFAULT_CONNECT_RETRY_INTERVAL,
		        connectTimeout: DEFAULT_CONNECT_TIMEOUT,
		        connector: undefined,
		        connectionIsolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
		        cryptoCredentialsDetails: {},
		        database: undefined,
		        datefirst: DEFAULT_DATEFIRST,
		        dateFormat: DEFAULT_DATEFORMAT,
		        debug: {
		          data: false,
		          packet: false,
		          payload: false,
		          token: false
		        },
		        enableAnsiNull: true,
		        enableAnsiNullDefault: true,
		        enableAnsiPadding: true,
		        enableAnsiWarnings: true,
		        enableArithAbort: true,
		        enableConcatNullYieldsNull: true,
		        enableCursorCloseOnCommit: null,
		        enableImplicitTransactions: false,
		        enableNumericRoundabort: false,
		        enableQuotedIdentifier: true,
		        encrypt: true,
		        fallbackToDefaultDb: false,
		        encryptionKeyStoreProviders: undefined,
		        instanceName: undefined,
		        isolationLevel: _transaction.ISOLATION_LEVEL.READ_COMMITTED,
		        language: DEFAULT_LANGUAGE,
		        localAddress: undefined,
		        maxRetriesOnTransientErrors: 3,
		        multiSubnetFailover: false,
		        packetSize: DEFAULT_PACKET_SIZE,
		        port: DEFAULT_PORT,
		        readOnlyIntent: false,
		        requestTimeout: DEFAULT_CLIENT_REQUEST_TIMEOUT,
		        rowCollectionOnDone: false,
		        rowCollectionOnRequestCompletion: false,
		        serverName: undefined,
		        serverSupportsColumnEncryption: false,
		        tdsVersion: DEFAULT_TDS_VERSION,
		        textsize: DEFAULT_TEXTSIZE,
		        trustedServerNameAE: undefined,
		        trustServerCertificate: false,
		        useColumnNames: false,
		        useUTC: true,
		        workstationId: undefined,
		        lowerCaseGuids: false
		      }
		    };
		    if (config.options) {
		      if (config.options.port && config.options.instanceName) {
		        throw new Error('Port and instanceName are mutually exclusive, but ' + config.options.port + ' and ' + config.options.instanceName + ' provided');
		      }
		      if (config.options.abortTransactionOnError !== undefined) {
		        if (typeof config.options.abortTransactionOnError !== 'boolean' && config.options.abortTransactionOnError !== null) {
		          throw new TypeError('The "config.options.abortTransactionOnError" property must be of type string or null.');
		        }
		        this.config.options.abortTransactionOnError = config.options.abortTransactionOnError;
		      }
		      if (config.options.appName !== undefined) {
		        if (typeof config.options.appName !== 'string') {
		          throw new TypeError('The "config.options.appName" property must be of type string.');
		        }
		        this.config.options.appName = config.options.appName;
		      }
		      if (config.options.camelCaseColumns !== undefined) {
		        if (typeof config.options.camelCaseColumns !== 'boolean') {
		          throw new TypeError('The "config.options.camelCaseColumns" property must be of type boolean.');
		        }
		        this.config.options.camelCaseColumns = config.options.camelCaseColumns;
		      }
		      if (config.options.cancelTimeout !== undefined) {
		        if (typeof config.options.cancelTimeout !== 'number') {
		          throw new TypeError('The "config.options.cancelTimeout" property must be of type number.');
		        }
		        this.config.options.cancelTimeout = config.options.cancelTimeout;
		      }
		      if (config.options.columnNameReplacer) {
		        if (typeof config.options.columnNameReplacer !== 'function') {
		          throw new TypeError('The "config.options.cancelTimeout" property must be of type function.');
		        }
		        this.config.options.columnNameReplacer = config.options.columnNameReplacer;
		      }
		      if (config.options.connectionIsolationLevel !== undefined) {
		        (0, _transaction.assertValidIsolationLevel)(config.options.connectionIsolationLevel, 'config.options.connectionIsolationLevel');
		        this.config.options.connectionIsolationLevel = config.options.connectionIsolationLevel;
		      }
		      if (config.options.connectTimeout !== undefined) {
		        if (typeof config.options.connectTimeout !== 'number') {
		          throw new TypeError('The "config.options.connectTimeout" property must be of type number.');
		        }
		        this.config.options.connectTimeout = config.options.connectTimeout;
		      }
		      if (config.options.connector !== undefined) {
		        if (typeof config.options.connector !== 'function') {
		          throw new TypeError('The "config.options.connector" property must be a function.');
		        }
		        this.config.options.connector = config.options.connector;
		      }
		      if (config.options.cryptoCredentialsDetails !== undefined) {
		        if (typeof config.options.cryptoCredentialsDetails !== 'object' || config.options.cryptoCredentialsDetails === null) {
		          throw new TypeError('The "config.options.cryptoCredentialsDetails" property must be of type Object.');
		        }
		        this.config.options.cryptoCredentialsDetails = config.options.cryptoCredentialsDetails;
		      }
		      if (config.options.database !== undefined) {
		        if (typeof config.options.database !== 'string') {
		          throw new TypeError('The "config.options.database" property must be of type string.');
		        }
		        this.config.options.database = config.options.database;
		      }
		      if (config.options.datefirst !== undefined) {
		        if (typeof config.options.datefirst !== 'number' && config.options.datefirst !== null) {
		          throw new TypeError('The "config.options.datefirst" property must be of type number.');
		        }
		        if (config.options.datefirst !== null && (config.options.datefirst < 1 || config.options.datefirst > 7)) {
		          throw new RangeError('The "config.options.datefirst" property must be >= 1 and <= 7');
		        }
		        this.config.options.datefirst = config.options.datefirst;
		      }
		      if (config.options.dateFormat !== undefined) {
		        if (typeof config.options.dateFormat !== 'string' && config.options.dateFormat !== null) {
		          throw new TypeError('The "config.options.dateFormat" property must be of type string or null.');
		        }
		        this.config.options.dateFormat = config.options.dateFormat;
		      }
		      if (config.options.debug) {
		        if (config.options.debug.data !== undefined) {
		          if (typeof config.options.debug.data !== 'boolean') {
		            throw new TypeError('The "config.options.debug.data" property must be of type boolean.');
		          }
		          this.config.options.debug.data = config.options.debug.data;
		        }
		        if (config.options.debug.packet !== undefined) {
		          if (typeof config.options.debug.packet !== 'boolean') {
		            throw new TypeError('The "config.options.debug.packet" property must be of type boolean.');
		          }
		          this.config.options.debug.packet = config.options.debug.packet;
		        }
		        if (config.options.debug.payload !== undefined) {
		          if (typeof config.options.debug.payload !== 'boolean') {
		            throw new TypeError('The "config.options.debug.payload" property must be of type boolean.');
		          }
		          this.config.options.debug.payload = config.options.debug.payload;
		        }
		        if (config.options.debug.token !== undefined) {
		          if (typeof config.options.debug.token !== 'boolean') {
		            throw new TypeError('The "config.options.debug.token" property must be of type boolean.');
		          }
		          this.config.options.debug.token = config.options.debug.token;
		        }
		      }
		      if (config.options.enableAnsiNull !== undefined) {
		        if (typeof config.options.enableAnsiNull !== 'boolean' && config.options.enableAnsiNull !== null) {
		          throw new TypeError('The "config.options.enableAnsiNull" property must be of type boolean or null.');
		        }
		        this.config.options.enableAnsiNull = config.options.enableAnsiNull;
		      }
		      if (config.options.enableAnsiNullDefault !== undefined) {
		        if (typeof config.options.enableAnsiNullDefault !== 'boolean' && config.options.enableAnsiNullDefault !== null) {
		          throw new TypeError('The "config.options.enableAnsiNullDefault" property must be of type boolean or null.');
		        }
		        this.config.options.enableAnsiNullDefault = config.options.enableAnsiNullDefault;
		      }
		      if (config.options.enableAnsiPadding !== undefined) {
		        if (typeof config.options.enableAnsiPadding !== 'boolean' && config.options.enableAnsiPadding !== null) {
		          throw new TypeError('The "config.options.enableAnsiPadding" property must be of type boolean or null.');
		        }
		        this.config.options.enableAnsiPadding = config.options.enableAnsiPadding;
		      }
		      if (config.options.enableAnsiWarnings !== undefined) {
		        if (typeof config.options.enableAnsiWarnings !== 'boolean' && config.options.enableAnsiWarnings !== null) {
		          throw new TypeError('The "config.options.enableAnsiWarnings" property must be of type boolean or null.');
		        }
		        this.config.options.enableAnsiWarnings = config.options.enableAnsiWarnings;
		      }
		      if (config.options.enableArithAbort !== undefined) {
		        if (typeof config.options.enableArithAbort !== 'boolean' && config.options.enableArithAbort !== null) {
		          throw new TypeError('The "config.options.enableArithAbort" property must be of type boolean or null.');
		        }
		        this.config.options.enableArithAbort = config.options.enableArithAbort;
		      }
		      if (config.options.enableConcatNullYieldsNull !== undefined) {
		        if (typeof config.options.enableConcatNullYieldsNull !== 'boolean' && config.options.enableConcatNullYieldsNull !== null) {
		          throw new TypeError('The "config.options.enableConcatNullYieldsNull" property must be of type boolean or null.');
		        }
		        this.config.options.enableConcatNullYieldsNull = config.options.enableConcatNullYieldsNull;
		      }
		      if (config.options.enableCursorCloseOnCommit !== undefined) {
		        if (typeof config.options.enableCursorCloseOnCommit !== 'boolean' && config.options.enableCursorCloseOnCommit !== null) {
		          throw new TypeError('The "config.options.enableCursorCloseOnCommit" property must be of type boolean or null.');
		        }
		        this.config.options.enableCursorCloseOnCommit = config.options.enableCursorCloseOnCommit;
		      }
		      if (config.options.enableImplicitTransactions !== undefined) {
		        if (typeof config.options.enableImplicitTransactions !== 'boolean' && config.options.enableImplicitTransactions !== null) {
		          throw new TypeError('The "config.options.enableImplicitTransactions" property must be of type boolean or null.');
		        }
		        this.config.options.enableImplicitTransactions = config.options.enableImplicitTransactions;
		      }
		      if (config.options.enableNumericRoundabort !== undefined) {
		        if (typeof config.options.enableNumericRoundabort !== 'boolean' && config.options.enableNumericRoundabort !== null) {
		          throw new TypeError('The "config.options.enableNumericRoundabort" property must be of type boolean or null.');
		        }
		        this.config.options.enableNumericRoundabort = config.options.enableNumericRoundabort;
		      }
		      if (config.options.enableQuotedIdentifier !== undefined) {
		        if (typeof config.options.enableQuotedIdentifier !== 'boolean' && config.options.enableQuotedIdentifier !== null) {
		          throw new TypeError('The "config.options.enableQuotedIdentifier" property must be of type boolean or null.');
		        }
		        this.config.options.enableQuotedIdentifier = config.options.enableQuotedIdentifier;
		      }
		      if (config.options.encrypt !== undefined) {
		        if (typeof config.options.encrypt !== 'boolean') {
		          if (config.options.encrypt !== 'strict') {
		            throw new TypeError('The "encrypt" property must be set to "strict", or of type boolean.');
		          }
		        }
		        this.config.options.encrypt = config.options.encrypt;
		      }
		      if (config.options.fallbackToDefaultDb !== undefined) {
		        if (typeof config.options.fallbackToDefaultDb !== 'boolean') {
		          throw new TypeError('The "config.options.fallbackToDefaultDb" property must be of type boolean.');
		        }
		        this.config.options.fallbackToDefaultDb = config.options.fallbackToDefaultDb;
		      }
		      if (config.options.instanceName !== undefined) {
		        if (typeof config.options.instanceName !== 'string') {
		          throw new TypeError('The "config.options.instanceName" property must be of type string.');
		        }
		        this.config.options.instanceName = config.options.instanceName;
		        this.config.options.port = undefined;
		      }
		      if (config.options.isolationLevel !== undefined) {
		        (0, _transaction.assertValidIsolationLevel)(config.options.isolationLevel, 'config.options.isolationLevel');
		        this.config.options.isolationLevel = config.options.isolationLevel;
		      }
		      if (config.options.language !== undefined) {
		        if (typeof config.options.language !== 'string' && config.options.language !== null) {
		          throw new TypeError('The "config.options.language" property must be of type string or null.');
		        }
		        this.config.options.language = config.options.language;
		      }
		      if (config.options.localAddress !== undefined) {
		        if (typeof config.options.localAddress !== 'string') {
		          throw new TypeError('The "config.options.localAddress" property must be of type string.');
		        }
		        this.config.options.localAddress = config.options.localAddress;
		      }
		      if (config.options.multiSubnetFailover !== undefined) {
		        if (typeof config.options.multiSubnetFailover !== 'boolean') {
		          throw new TypeError('The "config.options.multiSubnetFailover" property must be of type boolean.');
		        }
		        this.config.options.multiSubnetFailover = config.options.multiSubnetFailover;
		      }
		      if (config.options.packetSize !== undefined) {
		        if (typeof config.options.packetSize !== 'number') {
		          throw new TypeError('The "config.options.packetSize" property must be of type number.');
		        }
		        this.config.options.packetSize = config.options.packetSize;
		      }
		      if (config.options.port !== undefined) {
		        if (typeof config.options.port !== 'number') {
		          throw new TypeError('The "config.options.port" property must be of type number.');
		        }
		        if (config.options.port <= 0 || config.options.port >= 65536) {
		          throw new RangeError('The "config.options.port" property must be > 0 and < 65536');
		        }
		        this.config.options.port = config.options.port;
		        this.config.options.instanceName = undefined;
		      }
		      if (config.options.readOnlyIntent !== undefined) {
		        if (typeof config.options.readOnlyIntent !== 'boolean') {
		          throw new TypeError('The "config.options.readOnlyIntent" property must be of type boolean.');
		        }
		        this.config.options.readOnlyIntent = config.options.readOnlyIntent;
		      }
		      if (config.options.requestTimeout !== undefined) {
		        if (typeof config.options.requestTimeout !== 'number') {
		          throw new TypeError('The "config.options.requestTimeout" property must be of type number.');
		        }
		        this.config.options.requestTimeout = config.options.requestTimeout;
		      }
		      if (config.options.maxRetriesOnTransientErrors !== undefined) {
		        if (typeof config.options.maxRetriesOnTransientErrors !== 'number') {
		          throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be of type number.');
		        }
		        if (config.options.maxRetriesOnTransientErrors < 0) {
		          throw new TypeError('The "config.options.maxRetriesOnTransientErrors" property must be equal or greater than 0.');
		        }
		        this.config.options.maxRetriesOnTransientErrors = config.options.maxRetriesOnTransientErrors;
		      }
		      if (config.options.connectionRetryInterval !== undefined) {
		        if (typeof config.options.connectionRetryInterval !== 'number') {
		          throw new TypeError('The "config.options.connectionRetryInterval" property must be of type number.');
		        }
		        if (config.options.connectionRetryInterval <= 0) {
		          throw new TypeError('The "config.options.connectionRetryInterval" property must be greater than 0.');
		        }
		        this.config.options.connectionRetryInterval = config.options.connectionRetryInterval;
		      }
		      if (config.options.rowCollectionOnDone !== undefined) {
		        if (typeof config.options.rowCollectionOnDone !== 'boolean') {
		          throw new TypeError('The "config.options.rowCollectionOnDone" property must be of type boolean.');
		        }
		        this.config.options.rowCollectionOnDone = config.options.rowCollectionOnDone;
		      }
		      if (config.options.rowCollectionOnRequestCompletion !== undefined) {
		        if (typeof config.options.rowCollectionOnRequestCompletion !== 'boolean') {
		          throw new TypeError('The "config.options.rowCollectionOnRequestCompletion" property must be of type boolean.');
		        }
		        this.config.options.rowCollectionOnRequestCompletion = config.options.rowCollectionOnRequestCompletion;
		      }
		      if (config.options.tdsVersion !== undefined) {
		        if (typeof config.options.tdsVersion !== 'string') {
		          throw new TypeError('The "config.options.tdsVersion" property must be of type string.');
		        }
		        this.config.options.tdsVersion = config.options.tdsVersion;
		      }
		      if (config.options.textsize !== undefined) {
		        if (typeof config.options.textsize !== 'number' && config.options.textsize !== null) {
		          throw new TypeError('The "config.options.textsize" property must be of type number or null.');
		        }
		        if (config.options.textsize > 2147483647) {
		          throw new TypeError('The "config.options.textsize" can\'t be greater than 2147483647.');
		        } else if (config.options.textsize < -1) {
		          throw new TypeError('The "config.options.textsize" can\'t be smaller than -1.');
		        }
		        this.config.options.textsize = config.options.textsize | 0;
		      }
		      if (config.options.trustServerCertificate !== undefined) {
		        if (typeof config.options.trustServerCertificate !== 'boolean') {
		          throw new TypeError('The "config.options.trustServerCertificate" property must be of type boolean.');
		        }
		        this.config.options.trustServerCertificate = config.options.trustServerCertificate;
		      }
		      if (config.options.serverName !== undefined) {
		        if (typeof config.options.serverName !== 'string') {
		          throw new TypeError('The "config.options.serverName" property must be of type string.');
		        }
		        this.config.options.serverName = config.options.serverName;
		      }
		      if (config.options.useColumnNames !== undefined) {
		        if (typeof config.options.useColumnNames !== 'boolean') {
		          throw new TypeError('The "config.options.useColumnNames" property must be of type boolean.');
		        }
		        this.config.options.useColumnNames = config.options.useColumnNames;
		      }
		      if (config.options.useUTC !== undefined) {
		        if (typeof config.options.useUTC !== 'boolean') {
		          throw new TypeError('The "config.options.useUTC" property must be of type boolean.');
		        }
		        this.config.options.useUTC = config.options.useUTC;
		      }
		      if (config.options.workstationId !== undefined) {
		        if (typeof config.options.workstationId !== 'string') {
		          throw new TypeError('The "config.options.workstationId" property must be of type string.');
		        }
		        this.config.options.workstationId = config.options.workstationId;
		      }
		      if (config.options.lowerCaseGuids !== undefined) {
		        if (typeof config.options.lowerCaseGuids !== 'boolean') {
		          throw new TypeError('The "config.options.lowerCaseGuids" property must be of type boolean.');
		        }
		        this.config.options.lowerCaseGuids = config.options.lowerCaseGuids;
		      }
		    }
		    this.secureContextOptions = this.config.options.cryptoCredentialsDetails;
		    if (this.secureContextOptions.secureOptions === undefined) {
		      // If the caller has not specified their own `secureOptions`,
		      // we set `SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS` here.
		      // Older SQL Server instances running on older Windows versions have
		      // trouble with the BEAST workaround in OpenSSL.
		      // As BEAST is a browser specific exploit, we can just disable this option here.
		      this.secureContextOptions = Object.create(this.secureContextOptions, {
		        secureOptions: {
		          value: _constants.default.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
		        }
		      });
		    }
		    this.debug = this.createDebug();
		    this.inTransaction = false;
		    this.transactionDescriptors = [Buffer.from([0, 0, 0, 0, 0, 0, 0, 0])];

		    // 'beginTransaction', 'commitTransaction' and 'rollbackTransaction'
		    // events are utilized to maintain inTransaction property state which in
		    // turn is used in managing transactions. These events are only fired for
		    // TDS version 7.2 and beyond. The properties below are used to emulate
		    // equivalent behavior for TDS versions before 7.2.
		    this.transactionDepth = 0;
		    this.isSqlBatch = false;
		    this.closed = false;
		    this.messageBuffer = Buffer.alloc(0);
		    this.curTransientRetryCount = 0;
		    this.transientErrorLookup = new _transientErrorLookup.TransientErrorLookup();
		    this.state = this.STATE.INITIALIZED;
		    this._cancelAfterRequestSent = () => {
		      this.messageIo.sendMessage(_packet.TYPE.ATTENTION);
		      this.createCancelTimer();
		    };
		  }
		  connect(connectListener) {
		    if (this.state !== this.STATE.INITIALIZED) {
		      throw new _errors.ConnectionError('`.connect` can not be called on a Connection in `' + this.state.name + '` state.');
		    }
		    if (connectListener) {
		      const onConnect = err => {
		        this.removeListener('error', onError);
		        connectListener(err);
		      };
		      const onError = err => {
		        this.removeListener('connect', onConnect);
		        connectListener(err);
		      };
		      this.once('connect', onConnect);
		      this.once('error', onError);
		    }
		    this.transitionTo(this.STATE.CONNECTING);
		  }

		  /**
		   * The server has reported that the charset has changed.
		   */

		  /**
		   * The attempt to connect and validate has completed.
		   */

		  /**
		   * The server has reported that the active database has changed.
		   * This may be as a result of a successful login, or a `use` statement.
		   */

		  /**
		   * A debug message is available. It may be logged or ignored.
		   */

		  /**
		   * Internal error occurs.
		   */

		  /**
		   * The server has issued an error message.
		   */

		  /**
		   * The connection has ended.
		   *
		   * This may be as a result of the client calling [[close]], the server
		   * closing the connection, or a network error.
		   */

		  /**
		   * The server has issued an information message.
		   */

		  /**
		   * The server has reported that the language has changed.
		   */

		  /**
		   * The connection was reset.
		   */

		  /**
		   * A secure connection has been established.
		   */

		  on(event, listener) {
		    return super.on(event, listener);
		  }

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  /**
		   * @private
		   */

		  emit(event, ...args) {
		    return super.emit(event, ...args);
		  }

		  /**
		   * Closes the connection to the database.
		   *
		   * The [[Event_end]] will be emitted once the connection has been closed.
		   */
		  close() {
		    this.transitionTo(this.STATE.FINAL);
		  }

		  /**
		   * @private
		   */
		  initialiseConnection() {
		    const signal = this.createConnectTimer();
		    if (this.config.options.port) {
		      return this.connectOnPort(this.config.options.port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
		    } else {
		      return (0, _instanceLookup.instanceLookup)({
		        server: this.config.server,
		        instanceName: this.config.options.instanceName,
		        timeout: this.config.options.connectTimeout,
		        signal: signal
		      }).then(port => {
		        process.nextTick(() => {
		          this.connectOnPort(port, this.config.options.multiSubnetFailover, signal, this.config.options.connector);
		        });
		      }, err => {
		        this.clearConnectTimer();
		        if (signal.aborted) {
		          // Ignore the AbortError for now, this is still handled by the connectTimer firing
		          return;
		        }
		        process.nextTick(() => {
		          this.emit('connect', new _errors.ConnectionError(err.message, 'EINSTLOOKUP', {
		            cause: err
		          }));
		        });
		      });
		    }
		  }

		  /**
		   * @private
		   */
		  cleanupConnection(cleanupType) {
		    if (!this.closed) {
		      this.clearConnectTimer();
		      this.clearRequestTimer();
		      this.clearRetryTimer();
		      this.closeConnection();
		      if (cleanupType === CLEANUP_TYPE.REDIRECT) {
		        this.emit('rerouting');
		      } else if (cleanupType !== CLEANUP_TYPE.RETRY) {
		        process.nextTick(() => {
		          this.emit('end');
		        });
		      }
		      const request = this.request;
		      if (request) {
		        const err = new _errors.RequestError('Connection closed before request completed.', 'ECLOSE');
		        request.callback(err);
		        this.request = undefined;
		      }
		      this.closed = true;
		      this.loginError = undefined;
		    }
		  }

		  /**
		   * @private
		   */
		  createDebug() {
		    const debug = new _debug.default(this.config.options.debug);
		    debug.on('debug', message => {
		      this.emit('debug', message);
		    });
		    return debug;
		  }

		  /**
		   * @private
		   */
		  createTokenStreamParser(message, handler) {
		    return new _tokenStreamParser.Parser(message, this.debug, handler, this.config.options);
		  }
		  socketHandlingForSendPreLogin(socket) {
		    socket.on('error', error => {
		      this.socketError(error);
		    });
		    socket.on('close', () => {
		      this.socketClose();
		    });
		    socket.on('end', () => {
		      this.socketEnd();
		    });
		    socket.setKeepAlive(true, KEEP_ALIVE_INITIAL_DELAY);
		    this.messageIo = new _messageIo.default(socket, this.config.options.packetSize, this.debug);
		    this.messageIo.on('secure', cleartext => {
		      this.emit('secure', cleartext);
		    });
		    this.socket = socket;
		    this.closed = false;
		    this.debug.log('connected to ' + this.config.server + ':' + this.config.options.port);
		    this.sendPreLogin();
		    this.transitionTo(this.STATE.SENT_PRELOGIN);
		  }
		  wrapWithTls(socket, signal) {
		    signal.throwIfAborted();
		    return new Promise((resolve, reject) => {
		      const secureContext = tls.createSecureContext(this.secureContextOptions);
		      // If connect to an ip address directly,
		      // need to set the servername to an empty string
		      // if the user has not given a servername explicitly
		      const serverName = !net.isIP(this.config.server) ? this.config.server : '';
		      const encryptOptions = {
		        host: this.config.server,
		        socket: socket,
		        ALPNProtocols: ['tds/8.0'],
		        secureContext: secureContext,
		        servername: this.config.options.serverName ? this.config.options.serverName : serverName
		      };
		      const encryptsocket = tls.connect(encryptOptions);
		      const onAbort = () => {
		        encryptsocket.removeListener('error', onError);
		        encryptsocket.removeListener('connect', onConnect);
		        encryptsocket.destroy();
		        reject(signal.reason);
		      };
		      const onError = err => {
		        signal.removeEventListener('abort', onAbort);
		        encryptsocket.removeListener('error', onError);
		        encryptsocket.removeListener('connect', onConnect);
		        encryptsocket.destroy();
		        reject(err);
		      };
		      const onConnect = () => {
		        signal.removeEventListener('abort', onAbort);
		        encryptsocket.removeListener('error', onError);
		        encryptsocket.removeListener('connect', onConnect);
		        resolve(encryptsocket);
		      };
		      signal.addEventListener('abort', onAbort, {
		        once: true
		      });
		      encryptsocket.on('error', onError);
		      encryptsocket.on('secureConnect', onConnect);
		    });
		  }
		  connectOnPort(port, multiSubnetFailover, signal, customConnector) {
		    const connectOpts = {
		      host: this.routingData ? this.routingData.server : this.config.server,
		      port: this.routingData ? this.routingData.port : port,
		      localAddress: this.config.options.localAddress
		    };
		    const connect = customConnector || (multiSubnetFailover ? _connector.connectInParallel : _connector.connectInSequence);
		    (async () => {
		      let socket = await connect(connectOpts, _dns.default.lookup, signal);
		      if (this.config.options.encrypt === 'strict') {
		        try {
		          // Wrap the socket with TLS for TDS 8.0
		          socket = await this.wrapWithTls(socket, signal);
		        } catch (err) {
		          socket.end();
		          throw err;
		        }
		      }
		      this.socketHandlingForSendPreLogin(socket);
		    })().catch(err => {
		      this.clearConnectTimer();
		      if (signal.aborted) {
		        return;
		      }
		      process.nextTick(() => {
		        this.socketError(err);
		      });
		    });
		  }

		  /**
		   * @private
		   */
		  closeConnection() {
		    if (this.socket) {
		      this.socket.destroy();
		    }
		  }

		  /**
		   * @private
		   */
		  createConnectTimer() {
		    const controller = new AbortController();
		    this.connectTimer = setTimeout(() => {
		      controller.abort();
		      this.connectTimeout();
		    }, this.config.options.connectTimeout);
		    return controller.signal;
		  }

		  /**
		   * @private
		   */
		  createCancelTimer() {
		    this.clearCancelTimer();
		    const timeout = this.config.options.cancelTimeout;
		    if (timeout > 0) {
		      this.cancelTimer = setTimeout(() => {
		        this.cancelTimeout();
		      }, timeout);
		    }
		  }

		  /**
		   * @private
		   */
		  createRequestTimer() {
		    this.clearRequestTimer(); // release old timer, just to be safe
		    const request = this.request;
		    const timeout = request.timeout !== undefined ? request.timeout : this.config.options.requestTimeout;
		    if (timeout) {
		      this.requestTimer = setTimeout(() => {
		        this.requestTimeout();
		      }, timeout);
		    }
		  }

		  /**
		   * @private
		   */
		  createRetryTimer() {
		    this.clearRetryTimer();
		    this.retryTimer = setTimeout(() => {
		      this.retryTimeout();
		    }, this.config.options.connectionRetryInterval);
		  }

		  /**
		   * @private
		   */
		  connectTimeout() {
		    const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
		    // If we have routing data stored, this connection has been redirected
		    const server = this.routingData ? this.routingData.server : this.config.server;
		    const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
		    // Grab the target host from the connection configuration, and from a redirect message
		    // otherwise, leave the message empty.
		    const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : '';
		    const message = `Failed to connect to ${server}${port}${routingMessage} in ${this.config.options.connectTimeout}ms`;
		    this.debug.log(message);
		    this.emit('connect', new _errors.ConnectionError(message, 'ETIMEOUT'));
		    this.connectTimer = undefined;
		    this.dispatchEvent('connectTimeout');
		  }

		  /**
		   * @private
		   */
		  cancelTimeout() {
		    const message = `Failed to cancel request in ${this.config.options.cancelTimeout}ms`;
		    this.debug.log(message);
		    this.dispatchEvent('socketError', new _errors.ConnectionError(message, 'ETIMEOUT'));
		  }

		  /**
		   * @private
		   */
		  requestTimeout() {
		    this.requestTimer = undefined;
		    const request = this.request;
		    request.cancel();
		    const timeout = request.timeout !== undefined ? request.timeout : this.config.options.requestTimeout;
		    const message = 'Timeout: Request failed to complete in ' + timeout + 'ms';
		    request.error = new _errors.RequestError(message, 'ETIMEOUT');
		  }

		  /**
		   * @private
		   */
		  retryTimeout() {
		    this.retryTimer = undefined;
		    this.emit('retry');
		    this.transitionTo(this.STATE.CONNECTING);
		  }

		  /**
		   * @private
		   */
		  clearConnectTimer() {
		    if (this.connectTimer) {
		      clearTimeout(this.connectTimer);
		      this.connectTimer = undefined;
		    }
		  }

		  /**
		   * @private
		   */
		  clearCancelTimer() {
		    if (this.cancelTimer) {
		      clearTimeout(this.cancelTimer);
		      this.cancelTimer = undefined;
		    }
		  }

		  /**
		   * @private
		   */
		  clearRequestTimer() {
		    if (this.requestTimer) {
		      clearTimeout(this.requestTimer);
		      this.requestTimer = undefined;
		    }
		  }

		  /**
		   * @private
		   */
		  clearRetryTimer() {
		    if (this.retryTimer) {
		      clearTimeout(this.retryTimer);
		      this.retryTimer = undefined;
		    }
		  }

		  /**
		   * @private
		   */
		  transitionTo(newState) {
		    if (this.state === newState) {
		      this.debug.log('State is already ' + newState.name);
		      return;
		    }
		    if (this.state && this.state.exit) {
		      this.state.exit.call(this, newState);
		    }
		    this.debug.log('State change: ' + (this.state ? this.state.name : 'undefined') + ' -> ' + newState.name);
		    this.state = newState;
		    if (this.state.enter) {
		      this.state.enter.apply(this);
		    }
		  }

		  /**
		   * @private
		   */
		  getEventHandler(eventName) {
		    const handler = this.state.events[eventName];
		    if (!handler) {
		      throw new Error(`No event '${eventName}' in state '${this.state.name}'`);
		    }
		    return handler;
		  }

		  /**
		   * @private
		   */
		  dispatchEvent(eventName, ...args) {
		    const handler = this.state.events[eventName];
		    if (handler) {
		      handler.apply(this, args);
		    } else {
		      this.emit('error', new Error(`No event '${eventName}' in state '${this.state.name}'`));
		      this.close();
		    }
		  }

		  /**
		   * @private
		   */
		  socketError(error) {
		    if (this.state === this.STATE.CONNECTING || this.state === this.STATE.SENT_TLSSSLNEGOTIATION) {
		      const hostPostfix = this.config.options.port ? `:${this.config.options.port}` : `\\${this.config.options.instanceName}`;
		      // If we have routing data stored, this connection has been redirected
		      const server = this.routingData ? this.routingData.server : this.config.server;
		      const port = this.routingData ? `:${this.routingData.port}` : hostPostfix;
		      // Grab the target host from the connection configuration, and from a redirect message
		      // otherwise, leave the message empty.
		      const routingMessage = this.routingData ? ` (redirected from ${this.config.server}${hostPostfix})` : '';
		      const message = `Failed to connect to ${server}${port}${routingMessage} - ${error.message}`;
		      this.debug.log(message);
		      this.emit('connect', new _errors.ConnectionError(message, 'ESOCKET', {
		        cause: error
		      }));
		    } else {
		      const message = `Connection lost - ${error.message}`;
		      this.debug.log(message);
		      this.emit('error', new _errors.ConnectionError(message, 'ESOCKET', {
		        cause: error
		      }));
		    }
		    this.dispatchEvent('socketError', error);
		  }

		  /**
		   * @private
		   */
		  socketEnd() {
		    this.debug.log('socket ended');
		    if (this.state !== this.STATE.FINAL) {
		      const error = new Error('socket hang up');
		      error.code = 'ECONNRESET';
		      this.socketError(error);
		    }
		  }

		  /**
		   * @private
		   */
		  socketClose() {
		    this.debug.log('connection to ' + this.config.server + ':' + this.config.options.port + ' closed');
		    if (this.state === this.STATE.REROUTING) {
		      this.debug.log('Rerouting to ' + this.routingData.server + ':' + this.routingData.port);
		      this.dispatchEvent('reconnect');
		    } else if (this.state === this.STATE.TRANSIENT_FAILURE_RETRY) {
		      const server = this.routingData ? this.routingData.server : this.config.server;
		      const port = this.routingData ? this.routingData.port : this.config.options.port;
		      this.debug.log('Retry after transient failure connecting to ' + server + ':' + port);
		      this.dispatchEvent('retry');
		    } else {
		      this.transitionTo(this.STATE.FINAL);
		    }
		  }

		  /**
		   * @private
		   */
		  sendPreLogin() {
		    const [, major, minor, build] = /^(\d+)\.(\d+)\.(\d+)/.exec(_package.version) ?? ['0.0.0', '0', '0', '0'];
		    const payload = new _preloginPayload.default({
		      // If encrypt setting is set to 'strict', then we should have already done the encryption before calling
		      // this function. Therefore, the encrypt will be set to false here.
		      // Otherwise, we will set encrypt here based on the encrypt Boolean value from the configuration.
		      encrypt: typeof this.config.options.encrypt === 'boolean' && this.config.options.encrypt,
		      version: {
		        major: Number(major),
		        minor: Number(minor),
		        build: Number(build),
		        subbuild: 0
		      }
		    });
		    this.messageIo.sendMessage(_packet.TYPE.PRELOGIN, payload.data);
		    this.debug.payload(function () {
		      return payload.toString('  ');
		    });
		  }

		  /**
		   * @private
		   */
		  sendLogin7Packet() {
		    const payload = new _login7Payload.default({
		      tdsVersion: _tdsVersions.versions[this.config.options.tdsVersion],
		      packetSize: this.config.options.packetSize,
		      clientProgVer: 0,
		      clientPid: process.pid,
		      connectionId: 0,
		      clientTimeZone: new Date().getTimezoneOffset(),
		      clientLcid: 0x00000409
		    });
		    const {
		      authentication
		    } = this.config;
		    switch (authentication.type) {
		      case 'azure-active-directory-password':
		        payload.fedAuth = {
		          type: 'ADAL',
		          echo: this.fedAuthRequired,
		          workflow: 'default'
		        };
		        break;
		      case 'azure-active-directory-access-token':
		        payload.fedAuth = {
		          type: 'SECURITYTOKEN',
		          echo: this.fedAuthRequired,
		          fedAuthToken: authentication.options.token
		        };
		        break;
		      case 'token-credential':
		      case 'azure-active-directory-msi-vm':
		      case 'azure-active-directory-default':
		      case 'azure-active-directory-msi-app-service':
		      case 'azure-active-directory-service-principal-secret':
		        payload.fedAuth = {
		          type: 'ADAL',
		          echo: this.fedAuthRequired,
		          workflow: 'integrated'
		        };
		        break;
		      case 'ntlm':
		        payload.sspi = (0, _ntlm.createNTLMRequest)({
		          domain: authentication.options.domain
		        });
		        break;
		      default:
		        payload.userName = authentication.options.userName;
		        payload.password = authentication.options.password;
		    }
		    payload.hostname = this.config.options.workstationId || _os.default.hostname();
		    payload.serverName = this.routingData ? this.routingData.server : this.config.server;
		    payload.appName = this.config.options.appName || 'Tedious';
		    payload.libraryName = _library.name;
		    payload.language = this.config.options.language;
		    payload.database = this.config.options.database;
		    payload.clientId = Buffer.from([1, 2, 3, 4, 5, 6]);
		    payload.readOnlyIntent = this.config.options.readOnlyIntent;
		    payload.initDbFatal = !this.config.options.fallbackToDefaultDb;
		    this.routingData = undefined;
		    this.messageIo.sendMessage(_packet.TYPE.LOGIN7, payload.toBuffer());
		    this.debug.payload(function () {
		      return payload.toString('  ');
		    });
		  }

		  /**
		   * @private
		   */
		  sendFedAuthTokenMessage(token) {
		    const accessTokenLen = Buffer.byteLength(token, 'ucs2');
		    const data = Buffer.alloc(8 + accessTokenLen);
		    let offset = 0;
		    offset = data.writeUInt32LE(accessTokenLen + 4, offset);
		    offset = data.writeUInt32LE(accessTokenLen, offset);
		    data.write(token, offset, 'ucs2');
		    this.messageIo.sendMessage(_packet.TYPE.FEDAUTH_TOKEN, data);
		    // sent the fedAuth token message, the rest is similar to standard login 7
		    this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
		  }

		  /**
		   * @private
		   */
		  sendInitialSql() {
		    const payload = new _sqlbatchPayload.default(this.getInitialSql(), this.currentTransactionDescriptor(), this.config.options);
		    const message = new _message.default({
		      type: _packet.TYPE.SQL_BATCH
		    });
		    this.messageIo.outgoingMessageStream.write(message);
		    _stream.Readable.from(payload).pipe(message);
		  }

		  /**
		   * @private
		   */
		  getInitialSql() {
		    const options = [];
		    if (this.config.options.enableAnsiNull === true) {
		      options.push('set ansi_nulls on');
		    } else if (this.config.options.enableAnsiNull === false) {
		      options.push('set ansi_nulls off');
		    }
		    if (this.config.options.enableAnsiNullDefault === true) {
		      options.push('set ansi_null_dflt_on on');
		    } else if (this.config.options.enableAnsiNullDefault === false) {
		      options.push('set ansi_null_dflt_on off');
		    }
		    if (this.config.options.enableAnsiPadding === true) {
		      options.push('set ansi_padding on');
		    } else if (this.config.options.enableAnsiPadding === false) {
		      options.push('set ansi_padding off');
		    }
		    if (this.config.options.enableAnsiWarnings === true) {
		      options.push('set ansi_warnings on');
		    } else if (this.config.options.enableAnsiWarnings === false) {
		      options.push('set ansi_warnings off');
		    }
		    if (this.config.options.enableArithAbort === true) {
		      options.push('set arithabort on');
		    } else if (this.config.options.enableArithAbort === false) {
		      options.push('set arithabort off');
		    }
		    if (this.config.options.enableConcatNullYieldsNull === true) {
		      options.push('set concat_null_yields_null on');
		    } else if (this.config.options.enableConcatNullYieldsNull === false) {
		      options.push('set concat_null_yields_null off');
		    }
		    if (this.config.options.enableCursorCloseOnCommit === true) {
		      options.push('set cursor_close_on_commit on');
		    } else if (this.config.options.enableCursorCloseOnCommit === false) {
		      options.push('set cursor_close_on_commit off');
		    }
		    if (this.config.options.datefirst !== null) {
		      options.push(`set datefirst ${this.config.options.datefirst}`);
		    }
		    if (this.config.options.dateFormat !== null) {
		      options.push(`set dateformat ${this.config.options.dateFormat}`);
		    }
		    if (this.config.options.enableImplicitTransactions === true) {
		      options.push('set implicit_transactions on');
		    } else if (this.config.options.enableImplicitTransactions === false) {
		      options.push('set implicit_transactions off');
		    }
		    if (this.config.options.language !== null) {
		      options.push(`set language ${this.config.options.language}`);
		    }
		    if (this.config.options.enableNumericRoundabort === true) {
		      options.push('set numeric_roundabort on');
		    } else if (this.config.options.enableNumericRoundabort === false) {
		      options.push('set numeric_roundabort off');
		    }
		    if (this.config.options.enableQuotedIdentifier === true) {
		      options.push('set quoted_identifier on');
		    } else if (this.config.options.enableQuotedIdentifier === false) {
		      options.push('set quoted_identifier off');
		    }
		    if (this.config.options.textsize !== null) {
		      options.push(`set textsize ${this.config.options.textsize}`);
		    }
		    if (this.config.options.connectionIsolationLevel !== null) {
		      options.push(`set transaction isolation level ${this.getIsolationLevelText(this.config.options.connectionIsolationLevel)}`);
		    }
		    if (this.config.options.abortTransactionOnError === true) {
		      options.push('set xact_abort on');
		    } else if (this.config.options.abortTransactionOnError === false) {
		      options.push('set xact_abort off');
		    }
		    return options.join('\n');
		  }

		  /**
		   * @private
		   */
		  processedInitialSql() {
		    this.clearConnectTimer();
		    this.emit('connect');
		  }

		  /**
		   * Execute the SQL batch represented by [[Request]].
		   * There is no param support, and unlike [[Request.execSql]],
		   * it is not likely that SQL Server will reuse the execution plan it generates for the SQL.
		   *
		   * In almost all cases, [[Request.execSql]] will be a better choice.
		   *
		   * @param request A [[Request]] object representing the request.
		   */
		  execSqlBatch(request) {
		    this.makeRequest(request, _packet.TYPE.SQL_BATCH, new _sqlbatchPayload.default(request.sqlTextOrProcedure, this.currentTransactionDescriptor(), this.config.options));
		  }

		  /**
		   *  Execute the SQL represented by [[Request]].
		   *
		   * As `sp_executesql` is used to execute the SQL, if the same SQL is executed multiples times
		   * using this function, the SQL Server query optimizer is likely to reuse the execution plan it generates
		   * for the first execution. This may also result in SQL server treating the request like a stored procedure
		   * which can result in the [[Event_doneInProc]] or [[Event_doneProc]] events being emitted instead of the
		   * [[Event_done]] event you might expect. Using [[execSqlBatch]] will prevent this from occurring but may have a negative performance impact.
		   *
		   * Beware of the way that scoping rules apply, and how they may [affect local temp tables](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)
		   * If you're running in to scoping issues, then [[execSqlBatch]] may be a better choice.
		   * See also [issue #24](https://github.com/pekim/tedious/issues/24)
		   *
		   * @param request A [[Request]] object representing the request.
		   */
		  execSql(request) {
		    try {
		      request.validateParameters(this.databaseCollation);
		    } catch (error) {
		      request.error = error;
		      process.nextTick(() => {
		        this.debug.log(error.message);
		        request.callback(error);
		      });
		      return;
		    }
		    const parameters = [];
		    parameters.push({
		      type: _dataType.TYPES.NVarChar,
		      name: 'statement',
		      value: request.sqlTextOrProcedure,
		      output: false,
		      length: undefined,
		      precision: undefined,
		      scale: undefined
		    });
		    if (request.parameters.length) {
		      parameters.push({
		        type: _dataType.TYPES.NVarChar,
		        name: 'params',
		        value: request.makeParamsParameter(request.parameters),
		        output: false,
		        length: undefined,
		        precision: undefined,
		        scale: undefined
		      });
		      parameters.push(...request.parameters);
		    }
		    this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_ExecuteSql, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
		  }

		  /**
		   * Creates a new BulkLoad instance.
		   *
		   * @param table The name of the table to bulk-insert into.
		   * @param options A set of bulk load options.
		   */

		  newBulkLoad(table, callbackOrOptions, callback) {
		    let options;
		    if (callback === undefined) {
		      callback = callbackOrOptions;
		      options = {};
		    } else {
		      options = callbackOrOptions;
		    }
		    if (typeof options !== 'object') {
		      throw new TypeError('"options" argument must be an object');
		    }
		    return new _bulkLoad.default(table, this.databaseCollation, this.config.options, options, callback);
		  }

		  /**
		   * Execute a [[BulkLoad]].
		   *
		   * ```js
		   * // We want to perform a bulk load into a table with the following format:
		   * // CREATE TABLE employees (first_name nvarchar(255), last_name nvarchar(255), day_of_birth date);
		   *
		   * const bulkLoad = connection.newBulkLoad('employees', (err, rowCount) => {
		   *   // ...
		   * });
		   *
		   * // First, we need to specify the columns that we want to write to,
		   * // and their definitions. These definitions must match the actual table,
		   * // otherwise the bulk load will fail.
		   * bulkLoad.addColumn('first_name', TYPES.NVarchar, { nullable: false });
		   * bulkLoad.addColumn('last_name', TYPES.NVarchar, { nullable: false });
		   * bulkLoad.addColumn('date_of_birth', TYPES.Date, { nullable: false });
		   *
		   * // Execute a bulk load with a predefined list of rows.
		   * //
		   * // Note that these rows are held in memory until the
		   * // bulk load was performed, so if you need to write a large
		   * // number of rows (e.g. by reading from a CSV file),
		   * // passing an `AsyncIterable` is advisable to keep memory usage low.
		   * connection.execBulkLoad(bulkLoad, [
		   *   { 'first_name': 'Steve', 'last_name': 'Jobs', 'day_of_birth': new Date('02-24-1955') },
		   *   { 'first_name': 'Bill', 'last_name': 'Gates', 'day_of_birth': new Date('10-28-1955') }
		   * ]);
		   * ```
		   *
		   * @param bulkLoad A previously created [[BulkLoad]].
		   * @param rows A [[Iterable]] or [[AsyncIterable]] that contains the rows that should be bulk loaded.
		   */

		  execBulkLoad(bulkLoad, rows) {
		    bulkLoad.executionStarted = true;
		    if (rows) {
		      if (bulkLoad.streamingMode) {
		        throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that was put in streaming mode.");
		      }
		      if (bulkLoad.firstRowWritten) {
		        throw new Error("Connection.execBulkLoad can't be called with a BulkLoad that already has rows written to it.");
		      }
		      const rowStream = _stream.Readable.from(rows);

		      // Destroy the packet transform if an error happens in the row stream,
		      // e.g. if an error is thrown from within a generator or stream.
		      rowStream.on('error', err => {
		        bulkLoad.rowToPacketTransform.destroy(err);
		      });

		      // Destroy the row stream if an error happens in the packet transform,
		      // e.g. if the bulk load is cancelled.
		      bulkLoad.rowToPacketTransform.on('error', err => {
		        rowStream.destroy(err);
		      });
		      rowStream.pipe(bulkLoad.rowToPacketTransform);
		    } else if (!bulkLoad.streamingMode) {
		      // If the bulkload was not put into streaming mode by the user,
		      // we end the rowToPacketTransform here for them.
		      //
		      // If it was put into streaming mode, it's the user's responsibility
		      // to end the stream.
		      bulkLoad.rowToPacketTransform.end();
		    }
		    const onCancel = () => {
		      request.cancel();
		    };
		    const payload = new _bulkLoadPayload.BulkLoadPayload(bulkLoad);
		    const request = new _request.default(bulkLoad.getBulkInsertSql(), error => {
		      bulkLoad.removeListener('cancel', onCancel);
		      if (error) {
		        if (error.code === 'UNKNOWN') {
		          error.message += ' This is likely because the schema of the BulkLoad does not match the schema of the table you are attempting to insert into.';
		        }
		        bulkLoad.error = error;
		        bulkLoad.callback(error);
		        return;
		      }
		      this.makeRequest(bulkLoad, _packet.TYPE.BULK_LOAD, payload);
		    });
		    bulkLoad.once('cancel', onCancel);
		    this.execSqlBatch(request);
		  }

		  /**
		   * Prepare the SQL represented by the request.
		   *
		   * The request can then be used in subsequent calls to
		   * [[execute]] and [[unprepare]]
		   *
		   * @param request A [[Request]] object representing the request.
		   *   Parameters only require a name and type. Parameter values are ignored.
		   */
		  prepare(request) {
		    const parameters = [];
		    parameters.push({
		      type: _dataType.TYPES.Int,
		      name: 'handle',
		      value: undefined,
		      output: true,
		      length: undefined,
		      precision: undefined,
		      scale: undefined
		    });
		    parameters.push({
		      type: _dataType.TYPES.NVarChar,
		      name: 'params',
		      value: request.parameters.length ? request.makeParamsParameter(request.parameters) : null,
		      output: false,
		      length: undefined,
		      precision: undefined,
		      scale: undefined
		    });
		    parameters.push({
		      type: _dataType.TYPES.NVarChar,
		      name: 'stmt',
		      value: request.sqlTextOrProcedure,
		      output: false,
		      length: undefined,
		      precision: undefined,
		      scale: undefined
		    });
		    request.preparing = true;

		    // TODO: We need to clean up this event handler, otherwise this leaks memory
		    request.on('returnValue', (name, value) => {
		      if (name === 'handle') {
		        request.handle = value;
		      } else {
		        request.error = new _errors.RequestError(`Tedious > Unexpected output parameter ${name} from sp_prepare`);
		      }
		    });
		    this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Prepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
		  }

		  /**
		   * Release the SQL Server resources associated with a previously prepared request.
		   *
		   * @param request A [[Request]] object representing the request.
		   *   Parameters only require a name and type.
		   *   Parameter values are ignored.
		   */
		  unprepare(request) {
		    const parameters = [];
		    parameters.push({
		      type: _dataType.TYPES.Int,
		      name: 'handle',
		      // TODO: Abort if `request.handle` is not set
		      value: request.handle,
		      output: false,
		      length: undefined,
		      precision: undefined,
		      scale: undefined
		    });
		    this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Unprepare, parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
		  }

		  /**
		   * Execute previously prepared SQL, using the supplied parameters.
		   *
		   * @param request A previously prepared [[Request]].
		   * @param parameters  An object whose names correspond to the names of
		   *   parameters that were added to the [[Request]] before it was prepared.
		   *   The object's values are passed as the parameters' values when the
		   *   request is executed.
		   */
		  execute(request, parameters) {
		    const executeParameters = [];
		    executeParameters.push({
		      type: _dataType.TYPES.Int,
		      name: '',
		      // TODO: Abort if `request.handle` is not set
		      value: request.handle,
		      output: false,
		      length: undefined,
		      precision: undefined,
		      scale: undefined
		    });
		    try {
		      for (let i = 0, len = request.parameters.length; i < len; i++) {
		        const parameter = request.parameters[i];
		        executeParameters.push({
		          ...parameter,
		          value: parameter.type.validate(parameters ? parameters[parameter.name] : null, this.databaseCollation)
		        });
		      }
		    } catch (error) {
		      request.error = error;
		      process.nextTick(() => {
		        this.debug.log(error.message);
		        request.callback(error);
		      });
		      return;
		    }
		    this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(_specialStoredProcedure.default.Sp_Execute, executeParameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
		  }

		  /**
		   * Call a stored procedure represented by [[Request]].
		   *
		   * @param request A [[Request]] object representing the request.
		   */
		  callProcedure(request) {
		    try {
		      request.validateParameters(this.databaseCollation);
		    } catch (error) {
		      request.error = error;
		      process.nextTick(() => {
		        this.debug.log(error.message);
		        request.callback(error);
		      });
		      return;
		    }
		    this.makeRequest(request, _packet.TYPE.RPC_REQUEST, new _rpcrequestPayload.default(request.sqlTextOrProcedure, request.parameters, this.currentTransactionDescriptor(), this.config.options, this.databaseCollation));
		  }

		  /**
		   * Start a transaction.
		   *
		   * @param callback
		   * @param name A string representing a name to associate with the transaction.
		   *   Optional, and defaults to an empty string. Required when `isolationLevel`
		   *   is present.
		   * @param isolationLevel The isolation level that the transaction is to be run with.
		   *
		   *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
		   *   * `READ_UNCOMMITTED`
		   *   * `READ_COMMITTED`
		   *   * `REPEATABLE_READ`
		   *   * `SERIALIZABLE`
		   *   * `SNAPSHOT`
		   *
		   *   Optional, and defaults to the Connection's isolation level.
		   */
		  beginTransaction(callback, name = '', isolationLevel = this.config.options.isolationLevel) {
		    (0, _transaction.assertValidIsolationLevel)(isolationLevel, 'isolationLevel');
		    const transaction = new _transaction.Transaction(name, isolationLevel);
		    if (this.config.options.tdsVersion < '7_2') {
		      return this.execSqlBatch(new _request.default('SET TRANSACTION ISOLATION LEVEL ' + transaction.isolationLevelToTSQL() + ';BEGIN TRAN ' + transaction.name, err => {
		        this.transactionDepth++;
		        if (this.transactionDepth === 1) {
		          this.inTransaction = true;
		        }
		        callback(err);
		      }));
		    }
		    const request = new _request.default(undefined, err => {
		      return callback(err, this.currentTransactionDescriptor());
		    });
		    return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.beginPayload(this.currentTransactionDescriptor()));
		  }

		  /**
		   * Commit a transaction.
		   *
		   * There should be an active transaction - that is, [[beginTransaction]]
		   * should have been previously called.
		   *
		   * @param callback
		   * @param name A string representing a name to associate with the transaction.
		   *   Optional, and defaults to an empty string. Required when `isolationLevel`is present.
		   */
		  commitTransaction(callback, name = '') {
		    const transaction = new _transaction.Transaction(name);
		    if (this.config.options.tdsVersion < '7_2') {
		      return this.execSqlBatch(new _request.default('COMMIT TRAN ' + transaction.name, err => {
		        this.transactionDepth--;
		        if (this.transactionDepth === 0) {
		          this.inTransaction = false;
		        }
		        callback(err);
		      }));
		    }
		    const request = new _request.default(undefined, callback);
		    return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.commitPayload(this.currentTransactionDescriptor()));
		  }

		  /**
		   * Rollback a transaction.
		   *
		   * There should be an active transaction - that is, [[beginTransaction]]
		   * should have been previously called.
		   *
		   * @param callback
		   * @param name A string representing a name to associate with the transaction.
		   *   Optional, and defaults to an empty string.
		   *   Required when `isolationLevel` is present.
		   */
		  rollbackTransaction(callback, name = '') {
		    const transaction = new _transaction.Transaction(name);
		    if (this.config.options.tdsVersion < '7_2') {
		      return this.execSqlBatch(new _request.default('ROLLBACK TRAN ' + transaction.name, err => {
		        this.transactionDepth--;
		        if (this.transactionDepth === 0) {
		          this.inTransaction = false;
		        }
		        callback(err);
		      }));
		    }
		    const request = new _request.default(undefined, callback);
		    return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.rollbackPayload(this.currentTransactionDescriptor()));
		  }

		  /**
		   * Set a savepoint within a transaction.
		   *
		   * There should be an active transaction - that is, [[beginTransaction]]
		   * should have been previously called.
		   *
		   * @param callback
		   * @param name A string representing a name to associate with the transaction.\
		   *   Optional, and defaults to an empty string.
		   *   Required when `isolationLevel` is present.
		   */
		  saveTransaction(callback, name) {
		    const transaction = new _transaction.Transaction(name);
		    if (this.config.options.tdsVersion < '7_2') {
		      return this.execSqlBatch(new _request.default('SAVE TRAN ' + transaction.name, err => {
		        this.transactionDepth++;
		        callback(err);
		      }));
		    }
		    const request = new _request.default(undefined, callback);
		    return this.makeRequest(request, _packet.TYPE.TRANSACTION_MANAGER, transaction.savePayload(this.currentTransactionDescriptor()));
		  }

		  /**
		   * Run the given callback after starting a transaction, and commit or
		   * rollback the transaction afterwards.
		   *
		   * This is a helper that employs [[beginTransaction]], [[commitTransaction]],
		   * [[rollbackTransaction]], and [[saveTransaction]] to greatly simplify the
		   * use of database transactions and automatically handle transaction nesting.
		   *
		   * @param cb
		   * @param isolationLevel
		   *   The isolation level that the transaction is to be run with.
		   *
		   *   The isolation levels are available from `require('tedious').ISOLATION_LEVEL`.
		   *   * `READ_UNCOMMITTED`
		   *   * `READ_COMMITTED`
		   *   * `REPEATABLE_READ`
		   *   * `SERIALIZABLE`
		   *   * `SNAPSHOT`
		   *
		   *   Optional, and defaults to the Connection's isolation level.
		   */
		  transaction(cb, isolationLevel) {
		    if (typeof cb !== 'function') {
		      throw new TypeError('`cb` must be a function');
		    }
		    const useSavepoint = this.inTransaction;
		    const name = '_tedious_' + _crypto.default.randomBytes(10).toString('hex');
		    const txDone = (err, done, ...args) => {
		      if (err) {
		        if (this.inTransaction && this.state === this.STATE.LOGGED_IN) {
		          this.rollbackTransaction(txErr => {
		            done(txErr || err, ...args);
		          }, name);
		        } else {
		          done(err, ...args);
		        }
		      } else if (useSavepoint) {
		        if (this.config.options.tdsVersion < '7_2') {
		          this.transactionDepth--;
		        }
		        done(null, ...args);
		      } else {
		        this.commitTransaction(txErr => {
		          done(txErr, ...args);
		        }, name);
		      }
		    };
		    if (useSavepoint) {
		      return this.saveTransaction(err => {
		        if (err) {
		          return cb(err);
		        }
		        if (isolationLevel) {
		          return this.execSqlBatch(new _request.default('SET transaction isolation level ' + this.getIsolationLevelText(isolationLevel), err => {
		            return cb(err, txDone);
		          }));
		        } else {
		          return cb(null, txDone);
		        }
		      }, name);
		    } else {
		      return this.beginTransaction(err => {
		        if (err) {
		          return cb(err);
		        }
		        return cb(null, txDone);
		      }, name, isolationLevel);
		    }
		  }

		  /**
		   * @private
		   */
		  makeRequest(request, packetType, payload) {
		    if (this.state !== this.STATE.LOGGED_IN) {
		      const message = 'Requests can only be made in the ' + this.STATE.LOGGED_IN.name + ' state, not the ' + this.state.name + ' state';
		      this.debug.log(message);
		      request.callback(new _errors.RequestError(message, 'EINVALIDSTATE'));
		    } else if (request.canceled) {
		      process.nextTick(() => {
		        request.callback(new _errors.RequestError('Canceled.', 'ECANCEL'));
		      });
		    } else {
		      if (packetType === _packet.TYPE.SQL_BATCH) {
		        this.isSqlBatch = true;
		      } else {
		        this.isSqlBatch = false;
		      }
		      this.request = request;
		      request.connection = this;
		      request.rowCount = 0;
		      request.rows = [];
		      request.rst = [];
		      const onCancel = () => {
		        payloadStream.unpipe(message);
		        payloadStream.destroy(new _errors.RequestError('Canceled.', 'ECANCEL'));

		        // set the ignore bit and end the message.
		        message.ignore = true;
		        message.end();
		        if (request instanceof _request.default && request.paused) {
		          // resume the request if it was paused so we can read the remaining tokens
		          request.resume();
		        }
		      };
		      request.once('cancel', onCancel);
		      this.createRequestTimer();
		      const message = new _message.default({
		        type: packetType,
		        resetConnection: this.resetConnectionOnNextRequest
		      });
		      this.messageIo.outgoingMessageStream.write(message);
		      this.transitionTo(this.STATE.SENT_CLIENT_REQUEST);
		      message.once('finish', () => {
		        request.removeListener('cancel', onCancel);
		        request.once('cancel', this._cancelAfterRequestSent);
		        this.resetConnectionOnNextRequest = false;
		        this.debug.payload(function () {
		          return payload.toString('  ');
		        });
		      });
		      const payloadStream = _stream.Readable.from(payload);
		      payloadStream.once('error', error => {
		        payloadStream.unpipe(message);

		        // Only set a request error if no error was set yet.
		        request.error ??= error;
		        message.ignore = true;
		        message.end();
		      });
		      payloadStream.pipe(message);
		    }
		  }

		  /**
		   * Cancel currently executed request.
		   */
		  cancel() {
		    if (!this.request) {
		      return false;
		    }
		    if (this.request.canceled) {
		      return false;
		    }
		    this.request.cancel();
		    return true;
		  }

		  /**
		   * Reset the connection to its initial state.
		   * Can be useful for connection pool implementations.
		   *
		   * @param callback
		   */
		  reset(callback) {
		    const request = new _request.default(this.getInitialSql(), err => {
		      if (this.config.options.tdsVersion < '7_2') {
		        this.inTransaction = false;
		      }
		      callback(err);
		    });
		    this.resetConnectionOnNextRequest = true;
		    this.execSqlBatch(request);
		  }

		  /**
		   * @private
		   */
		  currentTransactionDescriptor() {
		    return this.transactionDescriptors[this.transactionDescriptors.length - 1];
		  }

		  /**
		   * @private
		   */
		  getIsolationLevelText(isolationLevel) {
		    switch (isolationLevel) {
		      case _transaction.ISOLATION_LEVEL.READ_UNCOMMITTED:
		        return 'read uncommitted';
		      case _transaction.ISOLATION_LEVEL.REPEATABLE_READ:
		        return 'repeatable read';
		      case _transaction.ISOLATION_LEVEL.SERIALIZABLE:
		        return 'serializable';
		      case _transaction.ISOLATION_LEVEL.SNAPSHOT:
		        return 'snapshot';
		      default:
		        return 'read committed';
		    }
		  }
		}
		function isTransientError(error) {
		  if (error instanceof AggregateError) {
		    error = error.errors[0];
		  }
		  return error instanceof _errors.ConnectionError && !!error.isTransient;
		}
		exports$1.default = Connection;
		module.exports = Connection;
		Connection.prototype.STATE = {
		  INITIALIZED: {
		    name: 'Initialized',
		    events: {}
		  },
		  CONNECTING: {
		    name: 'Connecting',
		    enter: function () {
		      this.initialiseConnection();
		    },
		    events: {
		      socketError: function () {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      connectTimeout: function () {
		        this.transitionTo(this.STATE.FINAL);
		      }
		    }
		  },
		  SENT_PRELOGIN: {
		    name: 'SentPrelogin',
		    enter: function () {
		      (async () => {
		        let messageBuffer = Buffer.alloc(0);
		        let message;
		        try {
		          message = await this.messageIo.readMessage();
		        } catch (err) {
		          return this.socketError(err);
		        }
		        for await (const data of message) {
		          messageBuffer = Buffer.concat([messageBuffer, data]);
		        }
		        const preloginPayload = new _preloginPayload.default(messageBuffer);
		        this.debug.payload(function () {
		          return preloginPayload.toString('  ');
		        });
		        if (preloginPayload.fedAuthRequired === 1) {
		          this.fedAuthRequired = true;
		        }
		        if ('strict' !== this.config.options.encrypt && (preloginPayload.encryptionString === 'ON' || preloginPayload.encryptionString === 'REQ')) {
		          if (!this.config.options.encrypt) {
		            this.emit('connect', new _errors.ConnectionError("Server requires encryption, set 'encrypt' config option to true.", 'EENCRYPT'));
		            return this.close();
		          }
		          try {
		            this.transitionTo(this.STATE.SENT_TLSSSLNEGOTIATION);
		            await this.messageIo.startTls(this.secureContextOptions, this.config.options.serverName ? this.config.options.serverName : this.routingData?.server ?? this.config.server, this.config.options.trustServerCertificate);
		          } catch (err) {
		            return this.socketError(err);
		          }
		        }
		        this.sendLogin7Packet();
		        const {
		          authentication
		        } = this.config;
		        switch (authentication.type) {
		          case 'token-credential':
		          case 'azure-active-directory-password':
		          case 'azure-active-directory-msi-vm':
		          case 'azure-active-directory-msi-app-service':
		          case 'azure-active-directory-service-principal-secret':
		          case 'azure-active-directory-default':
		            this.transitionTo(this.STATE.SENT_LOGIN7_WITH_FEDAUTH);
		            break;
		          case 'ntlm':
		            this.transitionTo(this.STATE.SENT_LOGIN7_WITH_NTLM);
		            break;
		          default:
		            this.transitionTo(this.STATE.SENT_LOGIN7_WITH_STANDARD_LOGIN);
		            break;
		        }
		      })().catch(err => {
		        process.nextTick(() => {
		          throw err;
		        });
		      });
		    },
		    events: {
		      socketError: function () {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      connectTimeout: function () {
		        this.transitionTo(this.STATE.FINAL);
		      }
		    }
		  },
		  REROUTING: {
		    name: 'ReRouting',
		    enter: function () {
		      this.cleanupConnection(CLEANUP_TYPE.REDIRECT);
		    },
		    events: {
		      message: function () {},
		      socketError: function () {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      connectTimeout: function () {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      reconnect: function () {
		        this.transitionTo(this.STATE.CONNECTING);
		      }
		    }
		  },
		  TRANSIENT_FAILURE_RETRY: {
		    name: 'TRANSIENT_FAILURE_RETRY',
		    enter: function () {
		      this.curTransientRetryCount++;
		      this.cleanupConnection(CLEANUP_TYPE.RETRY);
		    },
		    events: {
		      message: function () {},
		      socketError: function () {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      connectTimeout: function () {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      retry: function () {
		        this.createRetryTimer();
		      }
		    }
		  },
		  SENT_TLSSSLNEGOTIATION: {
		    name: 'SentTLSSSLNegotiation',
		    events: {
		      socketError: function () {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      connectTimeout: function () {
		        this.transitionTo(this.STATE.FINAL);
		      }
		    }
		  },
		  SENT_LOGIN7_WITH_STANDARD_LOGIN: {
		    name: 'SentLogin7WithStandardLogin',
		    enter: function () {
		      (async () => {
		        let message;
		        try {
		          message = await this.messageIo.readMessage();
		        } catch (err) {
		          return this.socketError(err);
		        }
		        const handler = new _handler.Login7TokenHandler(this);
		        const tokenStreamParser = this.createTokenStreamParser(message, handler);
		        await (0, _events.once)(tokenStreamParser, 'end');
		        if (handler.loginAckReceived) {
		          if (handler.routingData) {
		            this.routingData = handler.routingData;
		            this.transitionTo(this.STATE.REROUTING);
		          } else {
		            this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
		          }
		        } else if (this.loginError) {
		          if (isTransientError(this.loginError)) {
		            this.debug.log('Initiating retry on transient error');
		            this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
		          } else {
		            this.emit('connect', this.loginError);
		            this.transitionTo(this.STATE.FINAL);
		          }
		        } else {
		          this.emit('connect', new _errors.ConnectionError('Login failed.', 'ELOGIN'));
		          this.transitionTo(this.STATE.FINAL);
		        }
		      })().catch(err => {
		        process.nextTick(() => {
		          throw err;
		        });
		      });
		    },
		    events: {
		      socketError: function () {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      connectTimeout: function () {
		        this.transitionTo(this.STATE.FINAL);
		      }
		    }
		  },
		  SENT_LOGIN7_WITH_NTLM: {
		    name: 'SentLogin7WithNTLMLogin',
		    enter: function () {
		      (async () => {
		        while (true) {
		          let message;
		          try {
		            message = await this.messageIo.readMessage();
		          } catch (err) {
		            return this.socketError(err);
		          }
		          const handler = new _handler.Login7TokenHandler(this);
		          const tokenStreamParser = this.createTokenStreamParser(message, handler);
		          await (0, _events.once)(tokenStreamParser, 'end');
		          if (handler.loginAckReceived) {
		            if (handler.routingData) {
		              this.routingData = handler.routingData;
		              return this.transitionTo(this.STATE.REROUTING);
		            } else {
		              return this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
		            }
		          } else if (this.ntlmpacket) {
		            const authentication = this.config.authentication;
		            const payload = new _ntlmPayload.default({
		              domain: authentication.options.domain,
		              userName: authentication.options.userName,
		              password: authentication.options.password,
		              ntlmpacket: this.ntlmpacket
		            });
		            this.messageIo.sendMessage(_packet.TYPE.NTLMAUTH_PKT, payload.data);
		            this.debug.payload(function () {
		              return payload.toString('  ');
		            });
		            this.ntlmpacket = undefined;
		          } else if (this.loginError) {
		            if (isTransientError(this.loginError)) {
		              this.debug.log('Initiating retry on transient error');
		              return this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
		            } else {
		              this.emit('connect', this.loginError);
		              return this.transitionTo(this.STATE.FINAL);
		            }
		          } else {
		            this.emit('connect', new _errors.ConnectionError('Login failed.', 'ELOGIN'));
		            return this.transitionTo(this.STATE.FINAL);
		          }
		        }
		      })().catch(err => {
		        process.nextTick(() => {
		          throw err;
		        });
		      });
		    },
		    events: {
		      socketError: function () {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      connectTimeout: function () {
		        this.transitionTo(this.STATE.FINAL);
		      }
		    }
		  },
		  SENT_LOGIN7_WITH_FEDAUTH: {
		    name: 'SentLogin7Withfedauth',
		    enter: function () {
		      (async () => {
		        let message;
		        try {
		          message = await this.messageIo.readMessage();
		        } catch (err) {
		          return this.socketError(err);
		        }
		        const handler = new _handler.Login7TokenHandler(this);
		        const tokenStreamParser = this.createTokenStreamParser(message, handler);
		        await (0, _events.once)(tokenStreamParser, 'end');
		        if (handler.loginAckReceived) {
		          if (handler.routingData) {
		            this.routingData = handler.routingData;
		            this.transitionTo(this.STATE.REROUTING);
		          } else {
		            this.transitionTo(this.STATE.LOGGED_IN_SENDING_INITIAL_SQL);
		          }
		          return;
		        }
		        const fedAuthInfoToken = handler.fedAuthInfoToken;
		        if (fedAuthInfoToken && fedAuthInfoToken.stsurl && fedAuthInfoToken.spn) {
		          /** Federated authentication configation. */
		          const authentication = this.config.authentication;
		          /** Permission scope to pass to Entra ID when requesting an authentication token. */
		          const tokenScope = new _url.URL('/.default', fedAuthInfoToken.spn).toString();

		          /** Instance of the token credential to use to authenticate to the resource. */
		          let credentials;
		          switch (authentication.type) {
		            case 'token-credential':
		              credentials = authentication.options.credential;
		              break;
		            case 'azure-active-directory-password':
		              credentials = new _identity.UsernamePasswordCredential(authentication.options.tenantId ?? 'common', authentication.options.clientId, authentication.options.userName, authentication.options.password);
		              break;
		            case 'azure-active-directory-msi-vm':
		            case 'azure-active-directory-msi-app-service':
		              const msiArgs = authentication.options.clientId ? [authentication.options.clientId, {}] : [{}];
		              credentials = new _identity.ManagedIdentityCredential(...msiArgs);
		              break;
		            case 'azure-active-directory-default':
		              const args = authentication.options.clientId ? {
		                managedIdentityClientId: authentication.options.clientId
		              } : {};
		              credentials = new _identity.DefaultAzureCredential(args);
		              break;
		            case 'azure-active-directory-service-principal-secret':
		              credentials = new _identity.ClientSecretCredential(authentication.options.tenantId, authentication.options.clientId, authentication.options.clientSecret);
		              break;
		          }

		          /** Access token retrieved from Entra ID for the configured permission scope(s). */
		          let tokenResponse;
		          try {
		            tokenResponse = await credentials.getToken(tokenScope);
		          } catch (err) {
		            this.loginError = new AggregateError([new _errors.ConnectionError('Security token could not be authenticated or authorized.', 'EFEDAUTH'), err]);
		            this.emit('connect', this.loginError);
		            this.transitionTo(this.STATE.FINAL);
		            return;
		          }

		          // Type guard the token value so that it is never null.
		          if (tokenResponse === null) {
		            this.loginError = new AggregateError([new _errors.ConnectionError('Security token could not be authenticated or authorized.', 'EFEDAUTH')]);
		            this.emit('connect', this.loginError);
		            this.transitionTo(this.STATE.FINAL);
		            return;
		          }
		          this.sendFedAuthTokenMessage(tokenResponse.token);
		        } else if (this.loginError) {
		          if (isTransientError(this.loginError)) {
		            this.debug.log('Initiating retry on transient error');
		            this.transitionTo(this.STATE.TRANSIENT_FAILURE_RETRY);
		          } else {
		            this.emit('connect', this.loginError);
		            this.transitionTo(this.STATE.FINAL);
		          }
		        } else {
		          this.emit('connect', new _errors.ConnectionError('Login failed.', 'ELOGIN'));
		          this.transitionTo(this.STATE.FINAL);
		        }
		      })().catch(err => {
		        process.nextTick(() => {
		          throw err;
		        });
		      });
		    },
		    events: {
		      socketError: function () {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      connectTimeout: function () {
		        this.transitionTo(this.STATE.FINAL);
		      }
		    }
		  },
		  LOGGED_IN_SENDING_INITIAL_SQL: {
		    name: 'LoggedInSendingInitialSql',
		    enter: function () {
		      (async () => {
		        this.sendInitialSql();
		        let message;
		        try {
		          message = await this.messageIo.readMessage();
		        } catch (err) {
		          return this.socketError(err);
		        }
		        const tokenStreamParser = this.createTokenStreamParser(message, new _handler.InitialSqlTokenHandler(this));
		        await (0, _events.once)(tokenStreamParser, 'end');
		        this.transitionTo(this.STATE.LOGGED_IN);
		        this.processedInitialSql();
		      })().catch(err => {
		        process.nextTick(() => {
		          throw err;
		        });
		      });
		    },
		    events: {
		      socketError: function socketError() {
		        this.transitionTo(this.STATE.FINAL);
		      },
		      connectTimeout: function () {
		        this.transitionTo(this.STATE.FINAL);
		      }
		    }
		  },
		  LOGGED_IN: {
		    name: 'LoggedIn',
		    events: {
		      socketError: function () {
		        this.transitionTo(this.STATE.FINAL);
		      }
		    }
		  },
		  SENT_CLIENT_REQUEST: {
		    name: 'SentClientRequest',
		    enter: function () {
		      (async () => {
		        let message;
		        try {
		          message = await this.messageIo.readMessage();
		        } catch (err) {
		          return this.socketError(err);
		        }
		        // request timer is stopped on first data package
		        this.clearRequestTimer();
		        const tokenStreamParser = this.createTokenStreamParser(message, new _handler.RequestTokenHandler(this, this.request));

		        // If the request was canceled and we have a `cancelTimer`
		        // defined, we send a attention message after the
		        // request message was fully sent off.
		        //
		        // We already started consuming the current message
		        // (but all the token handlers should be no-ops), and
		        // need to ensure the next message is handled by the
		        // `SENT_ATTENTION` state.
		        if (this.request?.canceled && this.cancelTimer) {
		          return this.transitionTo(this.STATE.SENT_ATTENTION);
		        }
		        const onResume = () => {
		          tokenStreamParser.resume();
		        };
		        const onPause = () => {
		          tokenStreamParser.pause();
		          this.request?.once('resume', onResume);
		        };
		        this.request?.on('pause', onPause);
		        if (this.request instanceof _request.default && this.request.paused) {
		          onPause();
		        }
		        const onCancel = () => {
		          tokenStreamParser.removeListener('end', onEndOfMessage);
		          if (this.request instanceof _request.default && this.request.paused) {
		            // resume the request if it was paused so we can read the remaining tokens
		            this.request.resume();
		          }
		          this.request?.removeListener('pause', onPause);
		          this.request?.removeListener('resume', onResume);

		          // The `_cancelAfterRequestSent` callback will have sent a
		          // attention message, so now we need to also switch to
		          // the `SENT_ATTENTION` state to make sure the attention ack
		          // message is processed correctly.
		          this.transitionTo(this.STATE.SENT_ATTENTION);
		        };
		        const onEndOfMessage = () => {
		          this.request?.removeListener('cancel', this._cancelAfterRequestSent);
		          this.request?.removeListener('cancel', onCancel);
		          this.request?.removeListener('pause', onPause);
		          this.request?.removeListener('resume', onResume);
		          this.transitionTo(this.STATE.LOGGED_IN);
		          const sqlRequest = this.request;
		          this.request = undefined;
		          if (this.config.options.tdsVersion < '7_2' && sqlRequest.error && this.isSqlBatch) {
		            this.inTransaction = false;
		          }
		          sqlRequest.callback(sqlRequest.error, sqlRequest.rowCount, sqlRequest.rows);
		        };
		        tokenStreamParser.once('end', onEndOfMessage);
		        this.request?.once('cancel', onCancel);
		      })();
		    },
		    exit: function (nextState) {
		      this.clearRequestTimer();
		    },
		    events: {
		      socketError: function (err) {
		        const sqlRequest = this.request;
		        this.request = undefined;
		        this.transitionTo(this.STATE.FINAL);
		        sqlRequest.callback(err);
		      }
		    }
		  },
		  SENT_ATTENTION: {
		    name: 'SentAttention',
		    enter: function () {
		      (async () => {
		        let message;
		        try {
		          message = await this.messageIo.readMessage();
		        } catch (err) {
		          return this.socketError(err);
		        }
		        const handler = new _handler.AttentionTokenHandler(this, this.request);
		        const tokenStreamParser = this.createTokenStreamParser(message, handler);
		        await (0, _events.once)(tokenStreamParser, 'end');
		        // 3.2.5.7 Sent Attention State
		        // Discard any data contained in the response, until we receive the attention response
		        if (handler.attentionReceived) {
		          this.clearCancelTimer();
		          const sqlRequest = this.request;
		          this.request = undefined;
		          this.transitionTo(this.STATE.LOGGED_IN);
		          if (sqlRequest.error && sqlRequest.error instanceof _errors.RequestError && sqlRequest.error.code === 'ETIMEOUT') {
		            sqlRequest.callback(sqlRequest.error);
		          } else {
		            sqlRequest.callback(new _errors.RequestError('Canceled.', 'ECANCEL'));
		          }
		        }
		      })().catch(err => {
		        process.nextTick(() => {
		          throw err;
		        });
		      });
		    },
		    events: {
		      socketError: function (err) {
		        const sqlRequest = this.request;
		        this.request = undefined;
		        this.transitionTo(this.STATE.FINAL);
		        sqlRequest.callback(err);
		      }
		    }
		  },
		  FINAL: {
		    name: 'Final',
		    enter: function () {
		      this.cleanupConnection(CLEANUP_TYPE.NORMAL);
		    },
		    events: {
		      connectTimeout: function () {
		        // Do nothing, as the timer should be cleaned up.
		      },
		      message: function () {
		        // Do nothing
		      },
		      socketError: function () {
		        // Do nothing
		      }
		    }
		  }
		};
		
	} (connection, connection.exports));
	return connection.exports;
}

var hasRequiredTedious$1;

function requireTedious$1 () {
	if (hasRequiredTedious$1) return tedious;
	hasRequiredTedious$1 = 1;
	(function (exports$1) {

		Object.defineProperty(exports$1, "__esModule", {
		  value: true
		});
		Object.defineProperty(exports$1, "BulkLoad", {
		  enumerable: true,
		  get: function () {
		    return _bulkLoad.default;
		  }
		});
		Object.defineProperty(exports$1, "Connection", {
		  enumerable: true,
		  get: function () {
		    return _connection.default;
		  }
		});
		Object.defineProperty(exports$1, "ConnectionError", {
		  enumerable: true,
		  get: function () {
		    return _errors.ConnectionError;
		  }
		});
		Object.defineProperty(exports$1, "ISOLATION_LEVEL", {
		  enumerable: true,
		  get: function () {
		    return _transaction.ISOLATION_LEVEL;
		  }
		});
		Object.defineProperty(exports$1, "Request", {
		  enumerable: true,
		  get: function () {
		    return _request.default;
		  }
		});
		Object.defineProperty(exports$1, "RequestError", {
		  enumerable: true,
		  get: function () {
		    return _errors.RequestError;
		  }
		});
		Object.defineProperty(exports$1, "TDS_VERSION", {
		  enumerable: true,
		  get: function () {
		    return _tdsVersions.versions;
		  }
		});
		Object.defineProperty(exports$1, "TYPES", {
		  enumerable: true,
		  get: function () {
		    return _dataType.TYPES;
		  }
		});
		exports$1.connect = connect;
		exports$1.library = void 0;
		var _bulkLoad = _interopRequireDefault(requireBulkLoad());
		var _connection = _interopRequireDefault(requireConnection());
		var _request = _interopRequireDefault(requireRequest$1());
		var _library = requireLibrary();
		var _errors = requireErrors$1();
		var _dataType = requireDataType();
		var _transaction = requireTransaction$1();
		var _tdsVersions = requireTdsVersions();
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		exports$1.library = {
		  name: _library.name
		};
		function connect(config, connectListener) {
		  const connection = new _connection.default(config);
		  connection.connect(connectListener);
		  return connection;
		}
		
	} (tedious));
	return tedious;
}

var connectionPool;
var hasRequiredConnectionPool;

function requireConnectionPool () {
	if (hasRequiredConnectionPool) return connectionPool;
	hasRequiredConnectionPool = 1;

	const tds = requireTedious$1();
	const debug = requireSrc()('mssql:tedi');
	const BaseConnectionPool = requireConnectionPool$1();
	const { IDS } = requireUtils$4();
	const shared = requireShared();
	const ConnectionError = requireConnectionError();

	class ConnectionPool extends BaseConnectionPool {
	  _config () {
	    const cfg = {
	      server: this.config.server,
	      options: Object.assign({
	        encrypt: typeof this.config.encrypt === 'boolean' ? this.config.encrypt : true,
	        trustServerCertificate: typeof this.config.trustServerCertificate === 'boolean' ? this.config.trustServerCertificate : false
	      }, this.config.options),
	      authentication: Object.assign({
	        type: this.config.domain !== undefined ? 'ntlm' : this.config.authentication_type !== undefined ? this.config.authentication_type : 'default',
	        options: Object.entries({
	          userName: this.config.user,
	          password: this.config.password,
	          domain: this.config.domain,
	          clientId: this.config.clientId,
	          clientSecret: this.config.clientSecret,
	          tenantId: this.config.tenantId,
	          token: this.config.token,
	          msiEndpoint: this.config.msiEndpoint,
	          msiSecret: this.config.msiSecret
	        }).reduce((acc, [key, val]) => {
	          if (typeof val !== 'undefined') {
	            return { ...acc, [key]: val }
	          }
	          return acc
	        }, {})
	      }, this.config.authentication)
	    };

	    cfg.options.database = cfg.options.database || this.config.database;
	    cfg.options.port = cfg.options.port || this.config.port;
	    cfg.options.connectTimeout = cfg.options.connectTimeout ?? this.config.connectionTimeout ?? this.config.timeout ?? 15000;
	    cfg.options.requestTimeout = cfg.options.requestTimeout ?? this.config.requestTimeout ?? this.config.timeout ?? 15000;
	    cfg.options.tdsVersion = cfg.options.tdsVersion || '7_4';
	    cfg.options.rowCollectionOnDone = cfg.options.rowCollectionOnDone || false;
	    cfg.options.rowCollectionOnRequestCompletion = cfg.options.rowCollectionOnRequestCompletion || false;
	    cfg.options.useColumnNames = cfg.options.useColumnNames || false;
	    cfg.options.appName = cfg.options.appName || 'node-mssql';

	    // tedious always connect via tcp when port is specified
	    if (cfg.options.instanceName) delete cfg.options.port;

	    if (isNaN(cfg.options.requestTimeout)) cfg.options.requestTimeout = 15000;
	    if (cfg.options.requestTimeout === Infinity || cfg.options.requestTimeout < 0) cfg.options.requestTimeout = 0;

	    if (!cfg.options.debug && this.config.debug) {
	      cfg.options.debug = {
	        packet: true,
	        token: true,
	        data: true,
	        payload: true
	      };
	    }
	    return cfg
	  }

	  _poolCreate () {
	    return new shared.Promise((resolve, reject) => {
	      const resolveOnce = (v) => {
	        resolve(v);
	        resolve = reject = () => {};
	      };
	      const rejectOnce = (e) => {
	        reject(e);
	        resolve = reject = () => {};
	      };
	      let tedious;
	      try {
	        tedious = new tds.Connection(this._config());
	      } catch (err) {
	        rejectOnce(err);
	        return
	      }
	      tedious.connect(err => {
	        if (err) {
	          err = new ConnectionError(err);
	          return rejectOnce(err)
	        }

	        debug('connection(%d): established', IDS.get(tedious));
	        this.collation = tedious.databaseCollation;
	        resolveOnce(tedious);
	      });
	      IDS.add(tedious, 'Connection');
	      debug('pool(%d): connection #%d created', IDS.get(this), IDS.get(tedious));
	      debug('connection(%d): establishing', IDS.get(tedious));

	      tedious.on('end', () => {
	        const err = new ConnectionError('The connection ended without ever completing the connection');
	        rejectOnce(err);
	      });
	      tedious.on('error', err => {
	        if (err.code === 'ESOCKET') {
	          tedious.hasError = true;
	        } else {
	          this.emit('error', err);
	        }
	        rejectOnce(err);
	      });

	      if (this.config.debug) {
	        tedious.on('debug', this.emit.bind(this, 'debug', tedious));
	      }
	      if (typeof this.config.beforeConnect === 'function') {
	        this.config.beforeConnect(tedious);
	      }
	    })
	  }

	  _poolValidate (tedious) {
	    if (tedious && !tedious.closed && !tedious.hasError) {
	      return !this.config.validateConnection || new shared.Promise((resolve) => {
	        const req = new tds.Request('SELECT 1;', (err) => {
	          resolve(!err);
	        });
	        tedious.execSql(req);
	      })
	    }
	    return false
	  }

	  _poolDestroy (tedious) {
	    return new shared.Promise((resolve, reject) => {
	      if (!tedious) {
	        resolve();
	        return
	      }
	      debug('connection(%d): destroying', IDS.get(tedious));

	      if (tedious.closed) {
	        debug('connection(%d): already closed', IDS.get(tedious));
	        resolve();
	      } else {
	        tedious.once('end', () => {
	          debug('connection(%d): destroyed', IDS.get(tedious));
	          resolve();
	        });

	        tedious.close();
	      }
	    })
	  }
	}

	connectionPool = ConnectionPool;
	return connectionPool;
}

var transaction;
var hasRequiredTransaction;

function requireTransaction () {
	if (hasRequiredTransaction) return transaction;
	hasRequiredTransaction = 1;

	const debug = requireSrc()('mssql:tedi');
	const BaseTransaction = requireTransaction$2();
	const { IDS } = requireUtils$4();
	const TransactionError = requireTransactionError();

	class Transaction extends BaseTransaction {
	  constructor (parent) {
	    super(parent);

	    this._abort = () => {
	      if (!this._rollbackRequested) {
	        // transaction interrupted because of XACT_ABORT

	        const pc = this._acquiredConnection;

	        // defer releasing so connection can switch from SentClientRequest to LoggedIn state
	        setImmediate(this.parent.release.bind(this.parent), pc);

	        this._acquiredConnection.removeListener('rollbackTransaction', this._abort);
	        this._acquiredConnection = null;
	        this._acquiredConfig = null;
	        this._aborted = true;

	        this.emit('rollback', true);
	      }
	    };
	  }

	  _begin (isolationLevel, callback) {
	    super._begin(isolationLevel, err => {
	      if (err) return callback(err)

	      debug('transaction(%d): begin', IDS.get(this));

	      this.parent.acquire(this, (err, connection, config) => {
	        if (err) return callback(err)

	        this._acquiredConnection = connection;
	        this._acquiredConnection.on('rollbackTransaction', this._abort);
	        this._acquiredConfig = config;

	        connection.beginTransaction(err => {
	          if (err) err = new TransactionError(err);

	          debug('transaction(%d): begun', IDS.get(this));

	          callback(err);
	        }, this.name, this.isolationLevel);
	      });
	    });
	  }

	  _commit (callback) {
	    super._commit(err => {
	      if (err) return callback(err)

	      debug('transaction(%d): commit', IDS.get(this));

	      this._acquiredConnection.commitTransaction(err => {
	        if (err) err = new TransactionError(err);

	        this._acquiredConnection.removeListener('rollbackTransaction', this._abort);
	        this.parent.release(this._acquiredConnection);
	        this._acquiredConnection = null;
	        this._acquiredConfig = null;

	        if (!err) debug('transaction(%d): commited', IDS.get(this));

	        callback(err);
	      });
	    });
	  }

	  _rollback (callback) {
	    super._rollback(err => {
	      if (err) return callback(err)

	      debug('transaction(%d): rollback', IDS.get(this));

	      this._acquiredConnection.rollbackTransaction(err => {
	        if (err) err = new TransactionError(err);

	        this._acquiredConnection.removeListener('rollbackTransaction', this._abort);
	        this.parent.release(this._acquiredConnection);
	        this._acquiredConnection = null;
	        this._acquiredConfig = null;

	        if (!err) debug('transaction(%d): rolled back', IDS.get(this));

	        callback(err);
	      });
	    });
	  }
	}

	transaction = Transaction;
	return transaction;
}

var udt = {};

var hasRequiredUdt;

function requireUdt () {
	if (hasRequiredUdt) return udt;
	hasRequiredUdt = 1;

	/* const FIGURE = {
	  INTERIOR_RING: 0x00,
	  STROKE: 0x01,
	  EXTERIOR_RING: 0x02
	};

	const FIGURE_V2 = {
	  POINT: 0x00,
	  LINE: 0x01,
	  ARC: 0x02,
	  COMPOSITE_CURVE: 0x03
	};

	const SHAPE = {
	  POINT: 0x01,
	  LINESTRING: 0x02,
	  POLYGON: 0x03,
	  MULTIPOINT: 0x04,
	  MULTILINESTRING: 0x05,
	  MULTIPOLYGON: 0x06,
	  GEOMETRY_COLLECTION: 0x07
	};

	const SHAPE_V2 = {
	  POINT: 0x01,
	  LINESTRING: 0x02,
	  POLYGON: 0x03,
	  MULTIPOINT: 0x04,
	  MULTILINESTRING: 0x05,
	  MULTIPOLYGON: 0x06,
	  GEOMETRY_COLLECTION: 0x07,
	  CIRCULAR_STRING: 0x08,
	  COMPOUND_CURVE: 0x09,
	  CURVE_POLYGON: 0x0A,
	  FULL_GLOBE: 0x0B
	};

	const SEGMENT = {
	  LINE: 0x00,
	  ARC: 0x01,
	  FIRST_LINE: 0x02,
	  FIRST_ARC: 0x03
	}; */

	class Point {
	  constructor () {
	    this.x = 0;
	    this.y = 0;
	    this.z = null;
	    this.m = null;
	  }
	}

	const parsePoints = (buffer, count, isGeometryPoint) => {
	  // s2.1.5 + s2.1.6
	  // The key distinction for parsing is that a GEOGRAPHY POINT is ordered Lat (y) then Long (x),
	  // while a GEOMETRY POINT is ordered x then y.
	  // Further, there are additional range constraints on GEOGRAPHY POINT that are useful for testing that the coordinate order has not been flipped, such as that Lat must be in the range [-90, +90].

	  const points = [];
	  if (count < 1) {
	    return points
	  }

	  if (isGeometryPoint) {
	    // GEOMETRY POINT (s2.1.6): x then y.
	    for (let i = 1; i <= count; i++) {
	      const point = new Point();
	      points.push(point);
	      point.x = buffer.readDoubleLE(buffer.position);
	      point.y = buffer.readDoubleLE(buffer.position + 8);
	      buffer.position += 16;
	    }
	  } else {
	    // GEOGRAPHY POINT (s2.1.5): Lat (y) then Long (x).
	    for (let i = 1; i <= count; i++) {
	      const point = new Point();
	      points.push(point);
	      point.lat = buffer.readDoubleLE(buffer.position);
	      point.lng = buffer.readDoubleLE(buffer.position + 8);

	      // For backwards compatibility, preserve the coordinate inversion in x and y.
	      // A future breaking change likely eliminate x and y for geography points in favor of just the lat and lng fields, as they've proven marvelously confusing.
	      // See discussion at: https://github.com/tediousjs/node-mssql/pull/1282#discussion_r677769531
	      point.x = point.lat;
	      point.y = point.lng;

	      buffer.position += 16;
	    }
	  }

	  return points
	};

	const parseZ = (buffer, points) => {
	  // s2.1.1 + s.2.1.2

	  if (points < 1) {
	    return
	  }

	  points.forEach(point => {
	    point.z = buffer.readDoubleLE(buffer.position);
	    buffer.position += 8;
	  });
	};

	const parseM = (buffer, points) => {
	  // s2.1.1 + s.2.1.2

	  if (points < 1) {
	    return
	  }

	  points.forEach(point => {
	    point.m = buffer.readDoubleLE(buffer.position);
	    buffer.position += 8;
	  });
	};

	const parseFigures = (buffer, count, properties) => {
	  // s2.1.3

	  const figures = [];
	  if (count < 1) {
	    return figures
	  }

	  if (properties.P) {
	    figures.push({
	      attribute: 0x01,
	      pointOffset: 0
	    });
	  } else if (properties.L) {
	    figures.push({
	      attribute: 0x01,
	      pointOffset: 0
	    });
	  } else {
	    for (let i = 1; i <= count; i++) {
	      figures.push({
	        attribute: buffer.readUInt8(buffer.position),
	        pointOffset: buffer.readInt32LE(buffer.position + 1)
	      });

	      buffer.position += 5;
	    }
	  }

	  return figures
	};

	const parseShapes = (buffer, count, properties) => {
	  // s2.1.4

	  const shapes = [];
	  if (count < 1) {
	    return shapes
	  }

	  if (properties.P) {
	    shapes.push({
	      parentOffset: -1,
	      figureOffset: 0,
	      type: 0x01
	    });
	  } else if (properties.L) {
	    shapes.push({
	      parentOffset: -1,
	      figureOffset: 0,
	      type: 0x02
	    });
	  } else {
	    for (let i = 1; i <= count; i++) {
	      shapes.push({
	        parentOffset: buffer.readInt32LE(buffer.position),
	        figureOffset: buffer.readInt32LE(buffer.position + 4),
	        type: buffer.readUInt8(buffer.position + 8)
	      });

	      buffer.position += 9;
	    }
	  }

	  return shapes
	};

	const parseSegments = (buffer, count) => {
	  // s2.1.7

	  const segments = [];
	  if (count < 1) {
	    return segments
	  }

	  for (let i = 1; i <= count; i++) {
	    segments.push({ type: buffer.readUInt8(buffer.position) });

	    buffer.position++;
	  }

	  return segments
	};

	const parseGeography = (buffer, isUsingGeometryPoints) => {
	  // s2.1.1 + s.2.1.2

	  const srid = buffer.readInt32LE(0);
	  if (srid === -1) {
	    return null
	  }

	  const value = {
	    srid,
	    version: buffer.readUInt8(4)
	  };

	  const flags = buffer.readUInt8(5);
	  buffer.position = 6;

	  // console.log("srid", srid)
	  // console.log("version", version)

	  const properties = {
	    Z: (flags & (1 << 0)) > 0,
	    M: (flags & (1 << 1)) > 0,
	    P: (flags & (1 << 3)) > 0,
	    L: (flags & (1 << 4)) > 0
	  };

	  if (value.version === 2) {
	    properties.H = (flags & (1 << 3)) > 0;
	  }

	  // console.log("properties", properties);

	  let numberOfPoints;
	  if (properties.P) {
	    numberOfPoints = 1;
	  } else if (properties.L) {
	    numberOfPoints = 2;
	  } else {
	    numberOfPoints = buffer.readUInt32LE(buffer.position);
	    buffer.position += 4;
	  }

	  // console.log("numberOfPoints", numberOfPoints)

	  value.points = parsePoints(buffer, numberOfPoints, isUsingGeometryPoints);

	  if (properties.Z) {
	    parseZ(buffer, value.points);
	  }

	  if (properties.M) {
	    parseM(buffer, value.points);
	  }

	  // console.log("points", points)

	  let numberOfFigures;
	  if (properties.P) {
	    numberOfFigures = 1;
	  } else if (properties.L) {
	    numberOfFigures = 1;
	  } else {
	    numberOfFigures = buffer.readUInt32LE(buffer.position);
	    buffer.position += 4;
	  }

	  // console.log("numberOfFigures", numberOfFigures)

	  value.figures = parseFigures(buffer, numberOfFigures, properties);

	  // console.log("figures", figures)

	  let numberOfShapes;
	  if (properties.P) {
	    numberOfShapes = 1;
	  } else if (properties.L) {
	    numberOfShapes = 1;
	  } else {
	    numberOfShapes = buffer.readUInt32LE(buffer.position);
	    buffer.position += 4;
	  }

	  // console.log("numberOfShapes", numberOfShapes)

	  value.shapes = parseShapes(buffer, numberOfShapes, properties);

	  // console.log( "shapes", shapes)

	  if (value.version === 2 && buffer.position < buffer.length) {
	    const numberOfSegments = buffer.readUInt32LE(buffer.position);
	    buffer.position += 4;

	    // console.log("numberOfSegments", numberOfSegments)

	    value.segments = parseSegments(buffer, numberOfSegments);

	    // console.log("segments", segments)
	  } else {
	    value.segments = [];
	  }

	  return value
	};

	udt.PARSERS = {
	  geography (buffer) {
	    return parseGeography(buffer, /* isUsingGeometryPoints: */false)
	  },

	  geometry (buffer) {
	    return parseGeography(buffer, /* isUsingGeometryPoints: */true)
	  }
	};
	return udt;
}

var request;
var hasRequiredRequest;

function requireRequest () {
	if (hasRequiredRequest) return request;
	hasRequiredRequest = 1;

	const tds = requireTedious$1();
	const debug = requireSrc()('mssql:tedi');
	const BaseRequest = requireRequest$2();
	const RequestError = requireRequestError();
	const { IDS, objectHasProperty } = requireUtils$4();
	const { TYPES, DECLARATIONS, declare, cast } = requireDatatypes();
	const Table = requireTable();
	const { PARSERS: UDT } = requireUdt();
	const { valueHandler } = requireShared();

	const JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B';
	const XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B';

	const N_TYPES = {
	  BitN: 0x68,
	  DateTimeN: 0x6F,
	  DecimalN: 0x6A,
	  FloatN: 0x6D,
	  IntN: 0x26,
	  MoneyN: 0x6E,
	  NumericN: 0x6C
	};

	const getTediousType = function (type) {
	  switch (type) {
	    case TYPES.VarChar: return tds.TYPES.VarChar
	    case TYPES.NVarChar: return tds.TYPES.NVarChar
	    case TYPES.Text: return tds.TYPES.Text
	    case TYPES.Int: return tds.TYPES.Int
	    case TYPES.BigInt: return tds.TYPES.BigInt
	    case TYPES.TinyInt: return tds.TYPES.TinyInt
	    case TYPES.SmallInt: return tds.TYPES.SmallInt
	    case TYPES.Bit: return tds.TYPES.Bit
	    case TYPES.Float: return tds.TYPES.Float
	    case TYPES.Decimal: return tds.TYPES.Decimal
	    case TYPES.Numeric: return tds.TYPES.Numeric
	    case TYPES.Real: return tds.TYPES.Real
	    case TYPES.Money: return tds.TYPES.Money
	    case TYPES.SmallMoney: return tds.TYPES.SmallMoney
	    case TYPES.Time: return tds.TYPES.Time
	    case TYPES.Date: return tds.TYPES.Date
	    case TYPES.DateTime: return tds.TYPES.DateTime
	    case TYPES.DateTime2: return tds.TYPES.DateTime2
	    case TYPES.DateTimeOffset: return tds.TYPES.DateTimeOffset
	    case TYPES.SmallDateTime: return tds.TYPES.SmallDateTime
	    case TYPES.UniqueIdentifier: return tds.TYPES.UniqueIdentifier
	    case TYPES.Xml: return tds.TYPES.NVarChar
	    case TYPES.Char: return tds.TYPES.Char
	    case TYPES.NChar: return tds.TYPES.NChar
	    case TYPES.NText: return tds.TYPES.NVarChar
	    case TYPES.Image: return tds.TYPES.Image
	    case TYPES.Binary: return tds.TYPES.Binary
	    case TYPES.VarBinary: return tds.TYPES.VarBinary
	    case TYPES.UDT: case TYPES.Geography: case TYPES.Geometry: return tds.TYPES.UDT
	    case TYPES.TVP: return tds.TYPES.TVP
	    case TYPES.Variant: return tds.TYPES.Variant
	    default: return type
	  }
	};

	const getMssqlType = function (type, length) {
	  if (typeof type !== 'object') return undefined

	  switch (type) {
	    case tds.TYPES.Char: return TYPES.Char
	    case tds.TYPES.NChar: return TYPES.NChar
	    case tds.TYPES.VarChar: return TYPES.VarChar
	    case tds.TYPES.NVarChar: return TYPES.NVarChar
	    case tds.TYPES.Text: return TYPES.Text
	    case tds.TYPES.NText: return TYPES.NText
	    case tds.TYPES.Int: return TYPES.Int
	    case tds.TYPES.BigInt: return TYPES.BigInt
	    case tds.TYPES.TinyInt: return TYPES.TinyInt
	    case tds.TYPES.SmallInt: return TYPES.SmallInt
	    case tds.TYPES.Bit: return TYPES.Bit
	    case tds.TYPES.Float: return TYPES.Float
	    case tds.TYPES.Real: return TYPES.Real
	    case tds.TYPES.Money: return TYPES.Money
	    case tds.TYPES.SmallMoney: return TYPES.SmallMoney
	    case tds.TYPES.Numeric: return TYPES.Numeric
	    case tds.TYPES.Decimal: return TYPES.Decimal
	    case tds.TYPES.DateTime: return TYPES.DateTime
	    case tds.TYPES.Time: return TYPES.Time
	    case tds.TYPES.Date: return TYPES.Date
	    case tds.TYPES.DateTime2: return TYPES.DateTime2
	    case tds.TYPES.DateTimeOffset: return TYPES.DateTimeOffset
	    case tds.TYPES.SmallDateTime: return TYPES.SmallDateTime
	    case tds.TYPES.UniqueIdentifier: return TYPES.UniqueIdentifier
	    case tds.TYPES.Image: return TYPES.Image
	    case tds.TYPES.Binary: return TYPES.Binary
	    case tds.TYPES.VarBinary: return TYPES.VarBinary
	    case tds.TYPES.Xml: return TYPES.Xml
	    case tds.TYPES.UDT: return TYPES.UDT
	    case tds.TYPES.TVP: return TYPES.TVP
	    case tds.TYPES.Variant: return TYPES.Variant
	    default:
	      switch (type.id) {
	        case N_TYPES.BitN: return TYPES.Bit
	        case N_TYPES.NumericN: return TYPES.Numeric
	        case N_TYPES.DecimalN: return TYPES.Decimal
	        case N_TYPES.IntN:
	          if (length === 8) return TYPES.BigInt
	          if (length === 4) return TYPES.Int
	          if (length === 2) return TYPES.SmallInt
	          return TYPES.TinyInt
	        case N_TYPES.FloatN:
	          if (length === 8) return TYPES.Float
	          return TYPES.Real
	        case N_TYPES.MoneyN:
	          if (length === 8) return TYPES.Money
	          return TYPES.SmallMoney
	        case N_TYPES.DateTimeN:
	          if (length === 8) return TYPES.DateTime
	          return TYPES.SmallDateTime
	      }
	  }
	};

	const createColumns = function (metadata, arrayRowMode) {
	  let out = {};
	  if (arrayRowMode) out = [];
	  for (let index = 0, length = metadata.length; index < length; index++) {
	    const column = metadata[index];
	    const outColumn = {
	      index,
	      name: column.colName,
	      length: column.dataLength,
	      type: getMssqlType(column.type, column.dataLength),
	      scale: column.scale,
	      precision: column.precision,
	      nullable: !!(column.flags & 0x01),
	      caseSensitive: !!(column.flags & 0x02),
	      identity: !!(column.flags & 0x10),
	      readOnly: !(column.flags & 0x0C)
	    };

	    if (column.udtInfo) {
	      outColumn.udt = {
	        name: column.udtInfo.typeName,
	        database: column.udtInfo.dbname,
	        schema: column.udtInfo.owningSchema,
	        assembly: column.udtInfo.assemblyName
	      };

	      if (DECLARATIONS[column.udtInfo.typeName]) {
	        outColumn.type = DECLARATIONS[column.udtInfo.typeName];
	      }
	    }

	    if (arrayRowMode) {
	      out.push(outColumn);
	    } else {
	      out[column.colName] = outColumn;
	    }
	  }

	  return out
	};

	const valueCorrection = function (value, metadata) {
	  const type = getMssqlType(metadata.type);
	  if (valueHandler.has(type)) {
	    return valueHandler.get(type)(value)
	  } else if ((metadata.type === tds.TYPES.UDT) && (value != null)) {
	    if (UDT[metadata.udtInfo.typeName]) {
	      return UDT[metadata.udtInfo.typeName](value)
	    } else {
	      return value
	    }
	  } else {
	    return value
	  }
	};

	const parameterCorrection = function (value) {
	  if (value instanceof Table) {
	    const tvp = {
	      name: value.name,
	      schema: value.schema,
	      columns: [],
	      rows: value.rows
	    };

	    for (const col of value.columns) {
	      tvp.columns.push({
	        name: col.name,
	        type: getTediousType(col.type),
	        length: col.length,
	        scale: col.scale,
	        precision: col.precision
	      });
	    }

	    return tvp
	  } else {
	    return value
	  }
	};

	class Request extends BaseRequest {
	  /*
	  Execute specified sql batch.
	  */

	  _batch (batch, callback) {
	    this._isBatch = true;
	    this._query(batch, callback);
	  }

	  /*
	  Bulk load.
	  */

	  _bulk (table, options, callback) {
	    super._bulk(table, options, err => {
	      if (err) return callback(err)

	      try {
	        table._makeBulk();
	      } catch (e) {
	        return callback(new RequestError(e, 'EREQUEST'))
	      }

	      if (!table.name) {
	        return callback(new RequestError('Table name must be specified for bulk insert.', 'ENAME'))
	      }

	      if (table.name.charAt(0) === '@') {
	        return callback(new RequestError("You can't use table variables for bulk insert.", 'ENAME'))
	      }

	      const errors = [];
	      const errorHandlers = {};
	      let hasReturned = false;

	      const handleError = (doReturn, connection, info) => {
	        let err = new Error(info.message);
	        err.info = info;
	        err = new RequestError(err, 'EREQUEST');

	        if (this.stream) {
	          this.emit('error', err);
	        } else {
	          if (doReturn && !hasReturned) {
	            if (connection) {
	              for (const event in errorHandlers) {
	                connection.removeListener(event, errorHandlers[event]);
	              }

	              this.parent.release(connection);
	            }

	            hasReturned = true;
	            callback(err);
	          }
	        }

	        // we must collect errors even in stream mode
	        errors.push(err);
	      };

	      const handleInfo = msg => {
	        this.emit('info', {
	          message: msg.message,
	          number: msg.number,
	          state: msg.state,
	          class: msg.class,
	          lineNumber: msg.lineNumber,
	          serverName: msg.serverName,
	          procName: msg.procName
	        });
	      };

	      this.parent.acquire(this, (err, connection) => {
	        const callbackWithRelease = (err, ...args) => {
	          try {
	            this.parent.release(connection);
	          } catch (e) {
	            // noop
	          }
	          callback(err, ...args);
	        };
	        if (err) return callbackWithRelease(err)

	        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));

	        if (this.canceled) {
	          debug('request(%d): canceled', IDS.get(this));
	          return callbackWithRelease(new RequestError('Canceled.', 'ECANCEL'))
	        }

	        this._cancel = () => {
	          debug('request(%d): cancel', IDS.get(this));
	          connection.cancel();
	        };

	        // attach handler to handle multiple error messages
	        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);
	        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));
	        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));

	        const done = (err, rowCount) => {
	          // to make sure we handle no-sql errors as well
	          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {
	            err = new RequestError(err, 'EREQUEST');
	            if (this.stream) this.emit('error', err);
	            errors.push(err);
	          }

	          delete this._cancel;

	          let error;
	          if (errors.length && !this.stream) {
	            error = errors.pop();
	            error.precedingErrors = errors;
	          }

	          if (!hasReturned) {
	            for (const event in errorHandlers) {
	              connection.removeListener(event, errorHandlers[event]);
	            }

	            hasReturned = true;

	            if (this.stream) {
	              callbackWithRelease(null, rowCount);
	            } else {
	              callbackWithRelease(error, rowCount);
	            }
	          }
	        };

	        const bulk = connection.newBulkLoad(table.path, options, done);

	        for (const col of table.columns) {
	          bulk.addColumn(col.name, getTediousType(col.type), { nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision });
	        }

	        if (table.create) {
	          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path;
	          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\'\'')}') is null ${table.declare()}`, err => {
	            if (err) return done(err)

	            connection.execBulkLoad(bulk, table.rows);
	          });
	          this._setCurrentRequest(req);

	          connection.execSqlBatch(req);
	        } else {
	          connection.execBulkLoad(bulk, table.rows);
	        }
	      });
	    });
	  }

	  /*
	  Execute specified sql command.
	  */

	  _query (command, callback) {
	    super._query(command, err => {
	      if (err) return callback(err)

	      const recordsets = [];
	      const recordsetcolumns = [];
	      const errors = [];
	      const errorHandlers = {};
	      const output = {};
	      const rowsAffected = [];

	      let columns = {};
	      let recordset = [];
	      let batchLastRow = null;
	      let batchHasOutput = false;
	      let isChunkedRecordset = false;
	      let chunksBuffer = null;
	      let hasReturned = false;

	      const handleError = (doReturn, connection, info) => {
	        let err = new Error(info.message);
	        err.info = info;
	        err = new RequestError(err, 'EREQUEST');

	        if (this.stream) {
	          this.emit('error', err);
	        } else {
	          if (doReturn && !hasReturned) {
	            if (connection) {
	              for (const event in errorHandlers) {
	                connection.removeListener(event, errorHandlers[event]);
	              }

	              this.parent.release(connection);
	            }

	            hasReturned = true;
	            callback(err);
	          }
	        }

	        // we must collect errors even in stream mode
	        errors.push(err);
	      };

	      const handleInfo = msg => {
	        this.emit('info', {
	          message: msg.message,
	          number: msg.number,
	          state: msg.state,
	          class: msg.class,
	          lineNumber: msg.lineNumber,
	          serverName: msg.serverName,
	          procName: msg.procName
	        });
	      };

	      this.parent.acquire(this, (err, connection, config) => {
	        if (err) return callback(err)

	        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));

	        let row;

	        if (this.canceled) {
	          debug('request(%d): canceled', IDS.get(this));
	          this.parent.release(connection);
	          return callback(new RequestError('Canceled.', 'ECANCEL'))
	        }

	        this._cancel = () => {
	          debug('request(%d): cancel', IDS.get(this));
	          connection.cancel();
	        };

	        // attach handler to handle multiple error messages
	        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);
	        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));
	        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));

	        debug('request(%d): query', IDS.get(this), command);

	        const req = new tds.Request(command, err => {
	          // tedious v15 has started using AggregateErrors to wrap multiple errors into single error objects
	          (err?.errors ? err.errors : [err]).forEach((e, i, { length }) => {
	            // to make sure we handle no-sql errors as well
	            if (e && (!errors.length || (errors.length && errors.length >= length && e.message !== errors[errors.length - length + i].message))) {
	              e = new RequestError(e, 'EREQUEST');
	              if (this.stream) this.emit('error', e);
	              errors.push(e);
	            }
	          });

	          // process batch outputs
	          if (batchHasOutput) {
	            if (!this.stream) batchLastRow = recordsets.pop()[0];

	            for (const name in batchLastRow) {
	              const value = batchLastRow[name];
	              if (name !== '___return___') {
	                output[name] = value;
	              }
	            }
	          }

	          delete this._cancel;

	          let error;
	          if (errors.length && !this.stream) {
	            error = errors.pop();
	            error.precedingErrors = errors;
	          }

	          if (!hasReturned) {
	            for (const event in errorHandlers) {
	              connection.removeListener(event, errorHandlers[event]);
	            }

	            this.parent.release(connection);
	            hasReturned = true;

	            if (error) {
	              debug('request(%d): failed', IDS.get(this), error);
	            } else {
	              debug('request(%d): completed', IDS.get(this));
	            }

	            if (this.stream) {
	              callback(null, null, output, rowsAffected, recordsetcolumns);
	            } else {
	              callback(error, recordsets, output, rowsAffected, recordsetcolumns);
	            }
	          }
	        });

	        this._setCurrentRequest(req);

	        req.on('columnMetadata', metadata => {
	          columns = createColumns(metadata, this.arrayRowMode);

	          isChunkedRecordset = false;
	          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
	            isChunkedRecordset = true;
	            chunksBuffer = [];
	          }

	          if (this.stream) {
	            if (this._isBatch) {
	              // don't stream recordset with output values in batches
	              if (!columns.___return___) {
	                this.emit('recordset', columns);
	              }
	            } else {
	              this.emit('recordset', columns);
	            }
	          }
	          if (this.arrayRowMode) recordsetcolumns.push(columns);
	        });

	        const doneHandler = (rowCount, more) => {
	          if (rowCount != null) {
	            rowsAffected.push(rowCount);
	            if (this.stream) {
	              this.emit('rowsaffected', rowCount);
	            }
	          }
	          // this function is called even when select only set variables so we should skip adding a new recordset
	          if (Object.keys(columns).length === 0) return

	          if (isChunkedRecordset) {
	            const concatenatedChunks = chunksBuffer.join('');
	            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
	              try {
	                if (concatenatedChunks === '') {
	                  row = null;
	                } else {
	                  row = JSON.parse(concatenatedChunks);
	                }
	              } catch (ex) {
	                row = null;
	                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON');

	                if (this.stream) this.emit('error', ex2);

	                // we must collect errors even in stream mode
	                errors.push(ex2);
	              }
	            } else {
	              row = {};
	              row[Object.keys(columns)[0]] = concatenatedChunks;
	            }

	            chunksBuffer = null;

	            if (this.stream) {
	              this.emit('row', row);
	            } else {
	              recordset.push(row);
	            }
	          }

	          if (!this.stream) {
	            // all rows of current recordset loaded
	            Object.defineProperty(recordset, 'columns', {
	              enumerable: false,
	              configurable: true,
	              value: columns
	            });

	            Object.defineProperty(recordset, 'toTable', {
	              enumerable: false,
	              configurable: true,
	              value (name) { return Table.fromRecordset(this, name) }
	            });

	            recordsets.push(recordset);
	          }

	          recordset = [];
	          columns = {};
	        };

	        req.on('doneInProc', doneHandler); // doneInProc handlers are used in both queries and batches
	        req.on('done', doneHandler); // done handlers are used in batches

	        req.on('returnValue', (parameterName, value, metadata) => {
	          output[parameterName] = value;
	        });

	        req.on('row', columns => {
	          if (!recordset) recordset = [];

	          if (isChunkedRecordset) {
	            return chunksBuffer.push(columns[0].value)
	          }

	          if (this.arrayRowMode) {
	            row = [];
	          } else {
	            row = {};
	          }
	          for (const col of columns) {
	            col.value = valueCorrection(col.value, col.metadata);

	            if (this.arrayRowMode) {
	              row.push(col.value);
	            } else {
	              const exi = row[col.metadata.colName];
	              if (exi !== undefined) {
	                if (exi instanceof Array) {
	                  exi.push(col.value);
	                } else {
	                  row[col.metadata.colName] = [exi, col.value];
	                }
	              } else {
	                row[col.metadata.colName] = col.value;
	              }
	            }
	          }

	          if (this.stream) {
	            if (this._isBatch) {
	              // dont stream recordset with output values in batches
	              if (row.___return___) {
	                batchLastRow = row;
	              } else {
	                this.emit('row', row);
	              }
	            } else {
	              this.emit('row', row);
	            }
	          } else {
	            recordset.push(row);
	          }
	        });

	        if (this._isBatch) {
	          if (Object.keys(this.parameters).length) {
	            for (const name in this.parameters) {
	              if (!objectHasProperty(this.parameters, name)) {
	                continue
	              }
	              const param = this.parameters[name];

	              try {
	                param.value = getTediousType(param.type).validate(param.value, this.parent.collation);
	              } catch (e) {
	                e.message = `Validation failed for parameter '${name}'. ${e.message}`;
	                const err = new RequestError(e, 'EPARAM');

	                this.parent.release(connection);
	                return callback(err)
	              }
	            }

	            const declarations = [];
	            for (const name in this.parameters) {
	              if (!objectHasProperty(this.parameters, name)) {
	                continue
	              }
	              const param = this.parameters[name];
	              declarations.push(`@${name} ${declare(param.type, param)}`);
	            }

	            const assigns = [];
	            for (const name in this.parameters) {
	              if (!objectHasProperty(this.parameters, name)) {
	                continue
	              }
	              const param = this.parameters[name];
	              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`);
	            }

	            const selects = [];
	            for (const name in this.parameters) {
	              if (!objectHasProperty(this.parameters, name)) {
	                continue
	              }
	              const param = this.parameters[name];
	              if (param.io === 2) {
	                selects.push(`@${name} as [${name}]`);
	              }
	            }

	            batchHasOutput = selects.length > 0;

	            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? (`select 1 as [___return___], ${selects.join(', ')}`) : ''}`;
	          }
	        } else {
	          for (const name in this.parameters) {
	            if (!objectHasProperty(this.parameters, name)) {
	              continue
	            }
	            const param = this.parameters[name];
	            if (param.io === 1) {
	              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
	            } else {
	              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
	            }
	          }
	        }

	        try {
	          connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req);
	        } catch (error) {
	          handleError(true, connection, error);
	        }
	      });
	    });
	  }

	  /*
	  Execute stored procedure with specified parameters.
	  */

	  _execute (procedure, callback) {
	    super._execute(procedure, err => {
	      if (err) return callback(err)

	      const recordsets = [];
	      const recordsetcolumns = [];
	      const errors = [];
	      const errorHandlers = {};
	      const output = {};
	      const rowsAffected = [];

	      let columns = {};
	      let recordset = [];
	      let returnValue = 0;
	      let isChunkedRecordset = false;
	      let chunksBuffer = null;
	      let hasReturned = false;

	      const handleError = (doReturn, connection, info) => {
	        let err = new Error(info.message);
	        err.info = info;
	        err = new RequestError(err, 'EREQUEST');

	        if (this.stream) {
	          this.emit('error', err);
	        } else {
	          if (doReturn && !hasReturned) {
	            if (connection) {
	              for (const event in errorHandlers) {
	                connection.removeListener(event, errorHandlers[event]);
	              }

	              this.parent.release(connection);
	            }

	            hasReturned = true;
	            callback(err);
	          }
	        }

	        // we must collect errors even in stream mode
	        errors.push(err);
	      };

	      const handleInfo = msg => {
	        this.emit('info', {
	          message: msg.message,
	          number: msg.number,
	          state: msg.state,
	          class: msg.class,
	          lineNumber: msg.lineNumber,
	          serverName: msg.serverName,
	          procName: msg.procName
	        });
	      };

	      this.parent.acquire(this, (err, connection, config) => {
	        if (err) return callback(err)

	        debug('connection(%d): borrowed to request #%d', IDS.get(connection), IDS.get(this));

	        let row;

	        if (this.canceled) {
	          debug('request(%d): canceled', IDS.get(this));
	          this.parent.release(connection);
	          return callback(new RequestError('Canceled.', 'ECANCEL'))
	        }

	        this._cancel = () => {
	          debug('request(%d): cancel', IDS.get(this));
	          connection.cancel();
	        };

	        // attach handler to handle multiple error messages
	        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo);
	        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection));
	        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection));

	        if (debug.enabled) {
	          // log stored procedure executions and provided parameters
	          const params = Object.keys(this.parameters).map(k => this.parameters[k]);
	          // cut long string parameters short to keep log somewhat clean
	          const logValue = s => typeof s === 'string' && s.length > 50 ? s.substring(0, 47) + '...' : s;
	          // format parameter names as 'my_parameter [sql.Int]'
	          const logName = param => param.name + ' [sql.' + param.type.name + ']';
	          const logParams = {};
	          params.forEach(p => { logParams[logName(p)] = logValue(p.value); });
	          debug('request(%d): execute %s %O', IDS.get(this), procedure, logParams);
	        }

	        const req = new tds.Request(procedure, err => {
	          // to make sure we handle no-sql errors as well
	          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {
	            err = new RequestError(err, 'EREQUEST');
	            if (this.stream) this.emit('error', err);
	            errors.push(err);
	          }

	          delete this._cancel;

	          let error;
	          if (errors.length && !this.stream) {
	            error = errors.pop();
	            error.precedingErrors = errors;
	          }

	          if (!hasReturned) {
	            for (const event in errorHandlers) {
	              connection.removeListener(event, errorHandlers[event]);
	            }

	            this.parent.release(connection);
	            hasReturned = true;

	            if (error) {
	              debug('request(%d): failed', IDS.get(this), error);
	            } else {
	              debug('request(%d): complete', IDS.get(this));
	            }

	            if (this.stream) {
	              callback(null, null, output, returnValue, rowsAffected, recordsetcolumns);
	            } else {
	              callback(error, recordsets, output, returnValue, rowsAffected, recordsetcolumns);
	            }
	          }
	        });

	        this._setCurrentRequest(req);

	        req.on('columnMetadata', metadata => {
	          columns = createColumns(metadata, this.arrayRowMode);

	          isChunkedRecordset = false;
	          if ((metadata.length === 1) && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {
	            isChunkedRecordset = true;
	            chunksBuffer = [];
	          }

	          if (this.stream) this.emit('recordset', columns);
	          if (this.arrayRowMode) recordsetcolumns.push(columns);
	        });

	        req.on('row', columns => {
	          if (!recordset) recordset = [];

	          if (isChunkedRecordset) {
	            return chunksBuffer.push(columns[0].value)
	          }

	          if (this.arrayRowMode) {
	            row = [];
	          } else {
	            row = {};
	          }
	          for (const col of columns) {
	            col.value = valueCorrection(col.value, col.metadata);

	            if (this.arrayRowMode) {
	              row.push(col.value);
	            } else {
	              const exi = row[col.metadata.colName];
	              if (exi != null) {
	                if (exi instanceof Array) {
	                  exi.push(col.value);
	                } else {
	                  row[col.metadata.colName] = [exi, col.value];
	                }
	              } else {
	                row[col.metadata.colName] = col.value;
	              }
	            }
	          }

	          if (this.stream) {
	            this.emit('row', row);
	          } else {
	            recordset.push(row);
	          }
	        });

	        req.on('doneInProc', (rowCount, more) => {
	          if (rowCount != null) {
	            rowsAffected.push(rowCount);
	            if (this.stream) {
	              this.emit('rowsaffected', rowCount);
	            }
	          }

	          // filter empty recordsets when NOCOUNT is OFF
	          if (Object.keys(columns).length === 0) return

	          if (isChunkedRecordset) {
	            if (columns[JSON_COLUMN_ID] && config.parseJSON === true) {
	              try {
	                if (chunksBuffer.length === 0) {
	                  row = null;
	                } else {
	                  row = JSON.parse(chunksBuffer.join(''));
	                }
	              } catch (ex) {
	                row = null;
	                const ex2 = new RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON');

	                if (this.stream) this.emit('error', ex2);

	                // we must collect errors even in stream mode
	                errors.push(ex2);
	              }
	            } else {
	              row = {};
	              row[Object.keys(columns)[0]] = chunksBuffer.join('');
	            }

	            chunksBuffer = null;

	            if (this.stream) {
	              this.emit('row', row);
	            } else {
	              recordset.push(row);
	            }
	          }

	          if (!this.stream) {
	            // all rows of current recordset loaded
	            Object.defineProperty(recordset, 'columns', {
	              enumerable: false,
	              configurable: true,
	              value: columns
	            });

	            Object.defineProperty(recordset, 'toTable', {
	              enumerable: false,
	              configurable: true,
	              value (name) { return Table.fromRecordset(this, name) }
	            });

	            recordsets.push(recordset);
	          }

	          recordset = [];
	          columns = {};
	        });

	        req.on('doneProc', (rowCount, more, returnStatus) => {
	          returnValue = returnStatus;
	        });

	        req.on('returnValue', (parameterName, value, metadata) => {
	          output[parameterName] = value;
	        });

	        for (const name in this.parameters) {
	          if (!objectHasProperty(this.parameters, name)) {
	            continue
	          }
	          const param = this.parameters[name];
	          if (param.io === 1) {
	            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
	          } else {
	            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), { length: param.length, scale: param.scale, precision: param.precision });
	          }
	        }

	        connection.callProcedure(req);
	      });
	    });
	  }

	  _pause () {
	    super._pause();
	    if (this._currentRequest) {
	      this._currentRequest.pause();
	    }
	  }

	  _resume () {
	    super._resume();
	    if (this._currentRequest) {
	      this._currentRequest.resume();
	    }
	  }
	}

	request = Request;
	return request;
}

var hasRequiredTedious;

function requireTedious () {
	if (hasRequiredTedious) return tedious$1.exports;
	hasRequiredTedious = 1;
	(function (module) {

		const base = requireBase();
		const ConnectionPool = requireConnectionPool();
		const Transaction = requireTransaction();
		const Request = requireRequest();

		module.exports = Object.assign({
		  ConnectionPool,
		  Transaction,
		  Request,
		  PreparedStatement: base.PreparedStatement
		}, base.exports);

		Object.defineProperty(module.exports, 'Promise', {
		  enumerable: true,
		  get: () => {
		    return base.Promise
		  },
		  set: (value) => {
		    base.Promise = value;
		  }
		});

		Object.defineProperty(module.exports, 'valueHandler', {
		  enumerable: true,
		  value: base.valueHandler,
		  writable: false,
		  configurable: false
		});

		base.driver.name = 'tedious';
		base.driver.ConnectionPool = ConnectionPool;
		base.driver.Transaction = Transaction;
		base.driver.Request = Request; 
	} (tedious$1));
	return tedious$1.exports;
}

var mssql;
var hasRequiredMssql;

function requireMssql () {
	if (hasRequiredMssql) return mssql;
	hasRequiredMssql = 1;
	mssql = requireTedious();
	return mssql;
}

var mssqlExports = requireMssql();
var sql3 = /*@__PURE__*/getDefaultExportFromCjs(mssqlExports);

// src/mssql.ts

// package.json
var name = "@prisma/adapter-mssql";
function mapIsolationLevelFromString(level) {
  const normalizedLevel = level.toUpperCase().replace(/\s+/g, "");
  switch (normalizedLevel) {
    case "READCOMMITTED":
      return sql3.ISOLATION_LEVEL.READ_COMMITTED;
    case "READUNCOMMITTED":
      return sql3.ISOLATION_LEVEL.READ_UNCOMMITTED;
    case "REPEATABLEREAD":
      return sql3.ISOLATION_LEVEL.REPEATABLE_READ;
    case "SERIALIZABLE":
      return sql3.ISOLATION_LEVEL.SERIALIZABLE;
    case "SNAPSHOT":
      return sql3.ISOLATION_LEVEL.SNAPSHOT;
    default:
      throw new Error(`Invalid isolation level: ${level}`);
  }
}
var debug = Debug("prisma:driver-adapter:mssql:connection-string");
function extractSchemaFromConnectionString(connectionString) {
  const withoutProtocol = connectionString.replace(/^sqlserver:\/\//, "");
  const parts = withoutProtocol.split(";");
  for (const part of parts) {
    const [key, value] = part.split("=", 2);
    if (key?.trim() === "schema") {
      return value?.trim();
    }
  }
  return void 0;
}
function parseConnectionString(connectionString) {
  const withoutProtocol = connectionString.replace(/^sqlserver:\/\//, "");
  const [hostPart, ...paramParts] = withoutProtocol.split(";");
  const config = {
    server: "",
    options: {},
    pool: {}
  };
  const [host, portStr] = hostPart.split(":");
  config.server = host.trim();
  if (portStr) {
    const port = parseInt(portStr, 10);
    if (isNaN(port)) {
      throw new Error(`Invalid port number: ${portStr}`);
    }
    config.port = port;
  }
  const parameters = {};
  for (const part of paramParts) {
    const [key, value] = part.split("=", 2);
    if (!key) continue;
    const trimmedKey = key.trim();
    if (trimmedKey in parameters) {
      throw new Error(`Duplication configuration parameter: ${trimmedKey}`);
    }
    parameters[trimmedKey] = value.trim();
    if (!handledParameters.includes(trimmedKey)) {
      debug(`Unknown connection string parameter: ${trimmedKey}`);
    }
  }
  const database = firstKey(parameters, "database", "initial catalog");
  if (database !== null) {
    config.database = database;
  }
  const user = firstKey(parameters, "user", "username", "uid", "userid");
  if (user !== null) {
    config.user = user;
  }
  const password = firstKey(parameters, "password", "pwd");
  if (password !== null) {
    config.password = password;
  }
  const encrypt = firstKey(parameters, "encrypt");
  if (encrypt !== null) {
    config.options = config.options || {};
    config.options.encrypt = encrypt.toLowerCase() === "true";
  }
  const trustServerCertificate = firstKey(parameters, "trustServerCertificate");
  if (trustServerCertificate !== null) {
    config.options = config.options || {};
    config.options.trustServerCertificate = trustServerCertificate.toLowerCase() === "true";
  }
  const multiSubnetFailover = firstKey(parameters, "multiSubnetFailover");
  if (multiSubnetFailover !== null) {
    config.options = config.options || {};
    config.options.multiSubnetFailover = multiSubnetFailover.toLowerCase() === "true";
  }
  const connectionLimit = firstKey(parameters, "connectionLimit");
  if (connectionLimit !== null) {
    config.pool = config.pool || {};
    const limit = parseInt(connectionLimit, 10);
    if (isNaN(limit)) {
      throw new Error(`Invalid connection limit: ${connectionLimit}`);
    }
    config.pool.max = limit;
  }
  const connectionTimeout = firstKey(parameters, "connectionTimeout", "connectTimeout");
  if (connectionTimeout !== null) {
    const timeout = parseInt(connectionTimeout, 10);
    if (isNaN(timeout)) {
      throw new Error(`Invalid connection timeout: ${connectionTimeout}`);
    }
    config.connectionTimeout = timeout;
  }
  const loginTimeout = firstKey(parameters, "loginTimeout");
  if (loginTimeout !== null) {
    const timeout = parseInt(loginTimeout, 10);
    if (isNaN(timeout)) {
      throw new Error(`Invalid login timeout: ${loginTimeout}`);
    }
    config.connectionTimeout = timeout;
  }
  const socketTimeout = firstKey(parameters, "socketTimeout");
  if (socketTimeout !== null) {
    const timeout = parseInt(socketTimeout, 10);
    if (isNaN(timeout)) {
      throw new Error(`Invalid socket timeout: ${socketTimeout}`);
    }
    config.requestTimeout = timeout;
  }
  const poolTimeout = firstKey(parameters, "poolTimeout");
  if (poolTimeout !== null) {
    const timeout = parseInt(poolTimeout, 10);
    if (isNaN(timeout)) {
      throw new Error(`Invalid pool timeout: ${poolTimeout}`);
    }
    config.pool = config.pool || {};
    config.pool.acquireTimeoutMillis = timeout * 1e3;
  }
  const appName = firstKey(parameters, "applicationName", "application name");
  if (appName !== null) {
    config.options = config.options || {};
    config.options.appName = appName;
  }
  const isolationLevel = firstKey(parameters, "isolationLevel");
  if (isolationLevel !== null) {
    config.options = config.options || {};
    config.options.isolationLevel = mapIsolationLevelFromString(isolationLevel);
  }
  const authentication = firstKey(parameters, "authentication");
  if (authentication !== null) {
    config.authentication = parseAuthenticationOptions(parameters, authentication);
  }
  if (!config.server || config.server.trim() === "") {
    throw new Error("Server host is required in connection string");
  }
  return config;
}
function parseAuthenticationOptions(parameters, authenticationValue) {
  switch (authenticationValue) {
    /**
     * 'DefaultAzureCredential' is not listed in the JDBC driver spec
     * https://learn.microsoft.com/en-us/sql/connect/jdbc/setting-the-connection-properties?view=sql-server-ver15#properties
     * but is supported by tedious so included here
     */
    case "DefaultAzureCredential":
    case "ActiveDirectoryIntegrated":
    case "ActiveDirectoryInteractive":
      return { type: "azure-active-directory-default", options: {} };
    case "ActiveDirectoryPassword": {
      const userName = firstKey(parameters, "userName");
      const password = firstKey(parameters, "password");
      const clientId = firstKey(parameters, "clientId");
      const tenantId = firstKey(parameters, "tenantId");
      if (!userName || !password || !clientId) {
        throw new Error(`Invalid authentication, ActiveDirectoryPassword requires userName, password, clientId`);
      }
      return {
        type: "azure-active-directory-password",
        options: {
          userName,
          password,
          clientId,
          tenantId: tenantId || ""
        }
      };
    }
    case "ActiveDirectoryManagedIdentity":
    case "ActiveDirectoryMSI": {
      const clientId = firstKey(parameters, "clientId");
      const msiEndpoint = firstKey(parameters, "msiEndpoint");
      const msiSecret = firstKey(parameters, "msiSecret");
      if (!msiEndpoint || !msiSecret) {
        throw new Error(`Invalid authentication, ActiveDirectoryManagedIdentity requires msiEndpoint, msiSecret`);
      }
      return {
        type: "azure-active-directory-msi-app-service",
        options: {
          clientId: clientId || void 0,
          // @ts-expect-error TODO: tedious typings don't define msiEndpoint and msiSecret -- needs to be fixed upstream
          msiEndpoint,
          msiSecret
        }
      };
    }
    case "ActiveDirectoryServicePrincipal": {
      const clientId = firstKey(parameters, "userName");
      const clientSecret = firstKey(parameters, "password");
      const tenantId = firstKey(parameters, "tenantId");
      if (clientId && clientSecret) {
        return {
          type: "azure-active-directory-service-principal-secret",
          options: {
            clientId,
            clientSecret,
            tenantId: tenantId || ""
          }
        };
      } else {
        throw new Error(
          `Invalid authentication, ActiveDirectoryServicePrincipal requires userName (clientId), password (clientSecret)`
        );
      }
    }
  }
  return void 0;
}
function firstKey(parameters, ...keys) {
  for (const key of keys) {
    if (key in parameters) {
      return parameters[key];
    }
  }
  return null;
}
var handledParameters = [
  "application name",
  "applicationName",
  "connectTimeout",
  "connectionLimit",
  "connectionTimeout",
  "database",
  "encrypt",
  "initial catalog",
  "isolationLevel",
  "loginTimeout",
  "multiSubnetFailover",
  "password",
  "poolTimeout",
  "pwd",
  "socketTimeout",
  "trustServerCertificate",
  "uid",
  "user",
  "userid",
  "username"
];
function mapColumnType(col) {
  switch (col.type) {
    case sql3.VarChar:
    case sql3.Char:
    case sql3.NVarChar:
    case sql3.NChar:
    case sql3.Text:
    case sql3.NText:
    case sql3.Xml:
      return ColumnTypeEnum.Text;
    case sql3.Bit:
      return ColumnTypeEnum.Boolean;
    case sql3.TinyInt:
    case sql3.SmallInt:
    case sql3.Int:
      return ColumnTypeEnum.Int32;
    case sql3.BigInt:
      return ColumnTypeEnum.Int64;
    case sql3.DateTime2:
    case sql3.SmallDateTime:
    case sql3.DateTime:
    case sql3.DateTimeOffset:
      return ColumnTypeEnum.DateTime;
    case sql3.Real:
      return ColumnTypeEnum.Float;
    case sql3.Float:
    case sql3.Money:
    case sql3.SmallMoney:
      return ColumnTypeEnum.Double;
    case sql3.UniqueIdentifier:
      return ColumnTypeEnum.Uuid;
    case sql3.Decimal:
    case sql3.Numeric:
      return ColumnTypeEnum.Numeric;
    case sql3.Date:
      return ColumnTypeEnum.Date;
    case sql3.Time:
      return ColumnTypeEnum.Time;
    case sql3.VarBinary:
    case sql3.Binary:
    case sql3.Image:
      return ColumnTypeEnum.Bytes;
    default:
      throw new DriverAdapterError({
        kind: "UnsupportedNativeDataType",
        type: col["udt"]?.name ?? "N/A"
      });
  }
}
function mapIsolationLevel(level) {
  switch (level) {
    case "READ COMMITTED":
      return sql3.ISOLATION_LEVEL.READ_COMMITTED;
    case "READ UNCOMMITTED":
      return sql3.ISOLATION_LEVEL.READ_UNCOMMITTED;
    case "REPEATABLE READ":
      return sql3.ISOLATION_LEVEL.REPEATABLE_READ;
    case "SERIALIZABLE":
      return sql3.ISOLATION_LEVEL.SERIALIZABLE;
    case "SNAPSHOT":
      return sql3.ISOLATION_LEVEL.SNAPSHOT;
    default:
      throw new DriverAdapterError({
        kind: "InvalidIsolationLevel",
        level
      });
  }
}
function mapArg(arg, argType) {
  if (arg === null) {
    return null;
  }
  if (typeof arg === "string" && argType.scalarType === "bigint") {
    arg = BigInt(arg);
  }
  if (typeof arg === "bigint") {
    if (arg >= BigInt(Number.MIN_SAFE_INTEGER) && arg <= BigInt(Number.MAX_SAFE_INTEGER)) {
      return Number(arg);
    }
    return arg.toString();
  }
  if (typeof arg === "string" && argType.scalarType === "datetime") {
    arg = new Date(arg);
  }
  if (arg instanceof Date) {
    switch (argType.dbType) {
      case "TIME":
        return formatTime(arg);
      case "DATE":
        return formatDate(arg);
      default:
        return formatDateTime(arg);
    }
  }
  if (typeof arg === "string" && argType.scalarType === "bytes") {
    return Buffer.from(arg, "base64");
  }
  if (Array.isArray(arg) && argType.scalarType === "bytes") {
    return Buffer.from(arg);
  }
  if (ArrayBuffer.isView(arg)) {
    return Buffer.from(arg.buffer, arg.byteOffset, arg.byteLength);
  }
  return arg;
}
function mapRow(row, columns) {
  return row.map((value, i) => {
    const type = columns?.[i]?.type;
    if (value instanceof Date) {
      if (type === sql3.Time) {
        return value.toISOString().split("T")[1].replace("Z", "");
      }
      return value.toISOString();
    }
    if (typeof value === "number" && type === sql3.Real) {
      for (let digits = 7; digits <= 9; digits++) {
        const parsed = Number.parseFloat(value.toPrecision(digits));
        if (value === new Float32Array([parsed])[0]) {
          return parsed;
        }
      }
      return value;
    }
    if (Buffer.isBuffer(value)) {
      return Array.from(value);
    }
    if (typeof value === "string" && type === sql3.UniqueIdentifier) {
      return value.toLowerCase();
    }
    if (typeof value === "boolean" && type === sql3.Bit) {
      return value ? 1 : 0;
    }
    return value;
  });
}
function formatDateTime(date) {
  const pad = (n, z = 2) => String(n).padStart(z, "0");
  const ms = date.getUTCMilliseconds();
  return pad(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1) + "-" + pad(date.getUTCDate()) + " " + pad(date.getUTCHours()) + ":" + pad(date.getUTCMinutes()) + ":" + pad(date.getUTCSeconds()) + (ms ? "." + String(ms).padStart(3, "0") : "");
}
function formatDate(date) {
  const pad = (n, z = 2) => String(n).padStart(z, "0");
  return pad(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1) + "-" + pad(date.getUTCDate());
}
function formatTime(date) {
  const pad = (n, z = 2) => String(n).padStart(z, "0");
  const ms = date.getUTCMilliseconds();
  return pad(date.getUTCHours()) + ":" + pad(date.getUTCMinutes()) + ":" + pad(date.getUTCSeconds()) + (ms ? "." + String(ms).padStart(3, "0") : "");
}

// src/errors.ts
function convertDriverError(error) {
  if (isDriverError(error)) {
    return {
      originalCode: error.code,
      originalMessage: error.message,
      ...mapDriverError(error)
    };
  }
  throw error;
}
function mapDriverError(error) {
  switch (error.number) {
    case 3902:
    case 3903:
    case 3971:
      return {
        kind: "TransactionAlreadyClosed",
        cause: error.message
      };
    case 8169:
      return {
        kind: "InconsistentColumnData",
        cause: error.message
      };
    case 18456: {
      const user = error.message.split("'").at(1);
      return {
        kind: "AuthenticationFailed",
        user
      };
    }
    case 4060: {
      const db = error.message.split('"').at(1);
      return {
        kind: "DatabaseDoesNotExist",
        db
      };
    }
    case 515: {
      const field = error.message.split(" ").at(7)?.split("'").at(1);
      return {
        kind: "NullConstraintViolation",
        constraint: field ? { fields: [field] } : void 0
      };
    }
    case 1801: {
      const db = error.message.split("'").at(1);
      return {
        kind: "DatabaseAlreadyExists",
        db
      };
    }
    case 2627: {
      const index = error.message.split(". ").at(1)?.split(" ").pop()?.split("'").at(1);
      return {
        kind: "UniqueConstraintViolation",
        constraint: index ? { index } : void 0
      };
    }
    case 547: {
      const index = error.message.split(".").at(0)?.split(" ").pop()?.split('"').at(1);
      return {
        kind: "ForeignKeyConstraintViolation",
        constraint: index ? { index } : void 0
      };
    }
    case 1505: {
      const index = error.message.split("'").at(3);
      return {
        kind: "UniqueConstraintViolation",
        constraint: index ? { index } : void 0
      };
    }
    case 2601: {
      const index = error.message.split(" ").at(11)?.split("'").at(1);
      return {
        kind: "UniqueConstraintViolation",
        constraint: index ? { index } : void 0
      };
    }
    case 2628: {
      const column = error.message.split("'").at(3);
      return {
        kind: "LengthMismatch",
        column
      };
    }
    case 208: {
      const table = error.message.split(" ").at(3)?.split("'").at(1);
      return {
        kind: "TableDoesNotExist",
        table
      };
    }
    case 207: {
      const column = error.message.split(" ").at(3)?.split("'").at(1);
      return {
        kind: "ColumnNotFound",
        column
      };
    }
    case 1205:
      return {
        kind: "TransactionWriteConflict"
      };
    case 5828:
      return {
        kind: "TooManyConnections",
        cause: error.message
      };
    case 108:
    case 168:
    case 183:
    case 187:
    case 220:
    case 232:
    case 236:
    case 242:
    case 244:
    case 248:
    case 294:
    case 296:
    case 298:
    case 304:
    case 517:
    case 535:
    case 1007:
    case 1080:
    case 2386:
    case 2568:
    case 2570:
    case 2579:
    case 2742:
    case 2950:
    case 3194:
    case 3250:
    case 3606:
    case 3995:
    case 4079:
    case 4867:
    case 6244:
    case 6398:
    case 6937:
    case 6938:
    case 6960:
    case 7116:
    case 7135:
    case 7722:
    case 7810:
    case 7981:
    case 8115:
    case 8165:
    case 8351:
    case 8411:
    case 8727:
    case 8729:
    case 8968:
    case 8991:
    case 9109:
    case 9204:
    case 9526:
    case 9527:
    case 9746:
    case 9813:
    case 9835:
    case 9838:
    case 9839:
      return {
        kind: "ValueOutOfRange",
        cause: error.message
      };
    default:
      return {
        kind: "mssql",
        code: error.number,
        message: error.message
      };
  }
}
function isDriverError(error) {
  return typeof error.message === "string" && typeof error.code === "string" && typeof error.number === "number";
}

// src/mssql.ts
var debug2 = Debug("prisma:driver-adapter:mssql");
var MssqlQueryable = class {
  constructor(conn) {
    this.conn = conn;
  }
  provider = "sqlserver";
  adapterName = name;
  async queryRaw(query) {
    const tag = "[js::query_raw]";
    debug2(`${tag} %O`, query);
    const { recordset, columns: columnsList } = await this.performIO(query);
    const columns = columnsList?.[0];
    return {
      columnNames: columns?.map((col) => col.name) ?? [],
      columnTypes: columns?.map(mapColumnType) ?? [],
      rows: recordset?.map((row) => mapRow(row, columns)) ?? []
    };
  }
  async executeRaw(query) {
    const tag = "[js::execute_raw]";
    debug2(`${tag} %O`, query);
    return (await this.performIO(query)).rowsAffected?.[0] ?? 0;
  }
  async performIO(query) {
    try {
      const req = this.conn.request();
      req.arrayRowMode = true;
      for (let i = 0; i < query.args.length; i++) {
        req.input(`P${i + 1}`, mapArg(query.args[i], query.argTypes[i]));
      }
      const res = await req.query(query.sql);
      return res;
    } catch (e) {
      this.onError(e);
    }
  }
  onError(error) {
    debug2("Error in performIO: %O", error);
    throw new DriverAdapterError(convertDriverError(error));
  }
};
var MssqlTransaction = class extends MssqlQueryable {
  constructor(transaction, options) {
    super(transaction);
    this.transaction = transaction;
    this.options = options;
  }
  #mutex = new Mutex();
  async performIO(query) {
    const release = await this.#mutex.acquire();
    try {
      return await super.performIO(query);
    } catch (e) {
      this.onError(e);
    } finally {
      release();
    }
  }
  async commit() {
    debug2(`[js::commit]`);
    await this.transaction.commit();
  }
  async rollback() {
    debug2(`[js::rollback]`);
    await this.transaction.rollback().catch((e) => {
      if (e.code === "EABORT") {
        debug2(`[js::rollback] Transaction already aborted`);
        return;
      }
      throw e;
    });
  }
};
var PrismaMssqlAdapter = class extends MssqlQueryable {
  constructor(pool, options) {
    super(pool);
    this.pool = pool;
    this.options = options;
  }
  executeScript(_script) {
    throw new Error("Method not implemented.");
  }
  async startTransaction(isolationLevel) {
    const options = {
      usePhantomQuery: true
    };
    const tag = "[js::startTransaction]";
    debug2("%s options: %O", tag, options);
    const tx = this.pool.transaction();
    tx.on("error", (err) => {
      debug2("Error from pool connection: %O", err);
      this.options?.onConnectionError?.(err);
    });
    try {
      await tx.begin(isolationLevel !== void 0 ? mapIsolationLevel(isolationLevel) : void 0);
      return new MssqlTransaction(tx, options);
    } catch (e) {
      this.onError(e);
    }
  }
  getConnectionInfo() {
    return {
      maxBindValues: 2098,
      schemaName: this.options?.schema,
      supportsRelationJoins: false
    };
  }
  async dispose() {
    await this.pool.close();
  }
  underlyingDriver() {
    return this.pool;
  }
};
var PrismaMssqlAdapterFactory = class {
  provider = "sqlserver";
  adapterName = name;
  #config;
  #options;
  constructor(configOrString, options) {
    if (typeof configOrString === "string") {
      this.#config = parseConnectionString(configOrString);
      const extractedSchema = extractSchemaFromConnectionString(configOrString);
      this.#options = {
        ...options,
        schema: options?.schema ?? extractedSchema
      };
    } else {
      this.#config = configOrString;
      this.#options = options ?? {};
    }
  }
  async connect() {
    const pool = new sql3.ConnectionPool(this.#config);
    pool.on("error", (err) => {
      debug2("Error from pool client: %O", err);
      this.#options?.onPoolError?.(err);
    });
    await pool.connect();
    return new PrismaMssqlAdapter(pool, this.#options);
  }
};

!(function() {
  try {
    var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : {};
    e.SENTRY_RELEASE = { id: "c60a69e04ed3d2b7e30fad6c7faf609a8c3ddb8b" };
  } catch (e2) {
  }
})();
{
  try {
    (function() {
      var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : {}, n = new e.Error().stack;
      n && (e._sentryDebugIds = e._sentryDebugIds || {}, e._sentryDebugIds[n] = "4aa1b0c8-c6bb-43f7-9261-abc992304488", e._sentryDebugIdIdentifier = "sentry-dbid-4aa1b0c8-c6bb-43f7-9261-abc992304488");
    })();
  } catch (e) {
  }
}
const config = {
  "previewFeatures": [],
  "clientVersion": "7.1.0",
  "engineVersion": "ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba",
  "activeProvider": "sqlserver",
  "inlineSchema": 'generator client {\n  provider = "prisma-client"\n  output   = "../src/lib/server/db/prisma/generated/"\n}\n\ndatasource db {\n  provider = "sqlserver"\n}\n\nmodel MigrationHistory {\n  migrationId    String @map("MigrationId") @db.NVarChar(150)\n  contextKey     String @map("ContextKey") @db.NVarChar(300)\n  model          Bytes  @map("Model")\n  productVersion String @map("ProductVersion") @db.NVarChar(32)\n\n  @@id([migrationId, contextKey], map: "PK_dbo.__MigrationHistory")\n  @@map("__MigrationHistory")\n}\n\nmodel Address {\n  id                Int                @id(map: "PK_dbo.Addresses") @default(autoincrement()) @map("Id")\n  street            String             @map("Street") @db.NVarChar(Max)\n  number            String             @map("Number") @db.NVarChar(Max)\n  box               String?            @map("Box") @db.NVarChar(Max)\n  city              String             @map("City") @db.NVarChar(Max)\n  postalCode        String             @map("PostalCode") @db.NVarChar(Max)\n  countryId         Int                @map("Country_Id")\n  country           Country            @relation(fields: [countryId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.Addresses_dbo.Countries_Country_Id")\n  billingAddress    BillingAddress?\n  shippingAddress   ShippingAddress?\n  userRegistrations UserRegistration[]\n\n  @@index([countryId], map: "IX_Country_Id")\n  @@map("Addresses")\n}\n\nmodel BillingAddress {\n  id        Int     @id(map: "PK_dbo.BillingAddresses") @map("Id")\n  userId    Int?    @map("User_Id")\n  vatNumber String? @map("VATNumber") @db.NVarChar(Max)\n  address   Address @relation(fields: [id], references: [id], onUpdate: NoAction, map: "FK_dbo.BillingAddresses_dbo.Addresses_Id")\n  user      User?   @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.BillingAddresses_dbo.Users_User_Id")\n  orders    Order[]\n\n  @@index([id], map: "IX_Id")\n  @@index([userId], map: "IX_User_Id")\n  @@map("BillingAddresses")\n}\n\nmodel Country {\n  id        Int        @id(map: "PK_dbo.Countries") @default(autoincrement()) @map("Id")\n  name      String     @map("Name") @db.NVarChar(Max)\n  iso2Code  String     @map("Iso2Code") @db.NVarChar(Max)\n  addresses Address[]\n  languages Language[]\n\n  @@map("Countries")\n}\n\nmodel DownloadLinkLog {\n  id             Int          @id(map: "PK_dbo.DownloadLinkLogs") @default(autoincrement()) @map("Id")\n  usedOn         DateTime     @map("UsedOn") @db.DateTime\n  usedBy         String       @map("UsedBy") @db.NVarChar(Max)\n  response       String       @map("Response") @db.NVarChar(Max)\n  downloadLinkId Int          @map("DownloadLink_Id")\n  downloadLink   DownloadLink @relation(fields: [downloadLinkId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.DownloadLinkLogs_dbo.DownloadLinks_DownloadLink_Id")\n\n  @@index([downloadLinkId], map: "IX_DownloadLink_Id")\n  @@map("DownloadLinkLogs")\n}\n\nmodel DownloadLink {\n  id                     Int                     @id(map: "PK_dbo.DownloadLinks") @default(autoincrement()) @map("Id")\n  objectKey              String                  @map("ObjectKey") @db.NVarChar(Max)\n  expirationDate         DateTime?               @map("ExpirationDate") @db.DateTime\n  url                    String                  @map("Url") @db.NVarChar(Max)\n  createdOn              DateTime                @map("CreatedOn") @db.DateTime\n  deactivatedOn          DateTime?               @map("DeactivatedOn") @db.DateTime\n  downloadLinkLogs       DownloadLinkLog[]\n  orderLineDownloadLinks OrderLineDownloadLink[]\n\n  @@map("DownloadLinks")\n}\n\nmodel EmailMessage {\n  id                                                      Int                    @id(map: "PK_dbo.EmailMessages") @default(autoincrement()) @map("Id")\n  sentAttemp                                              Int                    @map("SentAttemps")\n  sentOn                                                  DateTime?              @map("SentOn") @db.DateTime\n  body                                                    String                 @map("Body") @db.NVarChar(Max)\n  deactivatedOn                                           DateTime?              @map("DeactivatedOn") @db.DateTime\n  to                                                      String                 @map("To") @db.NVarChar(Max)\n  cc                                                      String?                @map("Cc") @db.NVarChar(Max)\n  bcc                                                     String?                @map("Bcc") @db.NVarChar(Max)\n  subject                                                 String                 @map("Subject") @db.NVarChar(Max)\n  createdOn                                               DateTime?              @map("CreatedOn") @db.DateTime\n  type                                                    Int?                   @map("Type")\n  orderDownloadMessages                                   OrderDownloadMessage[]\n  ordersOrdersConfirmationMessageIdToEmailMessages        Order[]                @relation("Orders_ConfirmationMessage_IdToEmailMessages")\n  ordersOrdersPaymentConfirmationMessageIdToEmailMessages Order[]                @relation("Orders_PaymentConfirmationMessage_IdToEmailMessages")\n  ordersOrdersReminderIdToEmailMessages                   Order[]                @relation("Orders_Reminder_IdToEmailMessages")\n  ordersOrdersShipMessageIdToEmailMessages                Order[]                @relation("Orders_ShipMessage_IdToEmailMessages")\n\n  @@map("EmailMessages")\n}\n\nmodel File {\n  id                   Int                   @id(map: "PK_dbo.Files") @default(autoincrement()) @map("Id")\n  fileName             String                @map("FileName") @db.NVarChar(Max)\n  userFileName         String                @map("UserFileName") @db.NVarChar(Max)\n  type                 Int                   @map("Type")\n  productId            Int?                  @map("Product_Id")\n  product              Product?              @relation(fields: [productId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Files_dbo.Products_Product_Id")\n  orderDeliveryOptions OrderDeliveryOption[]\n  orderPaymentOptions  OrderPaymentOption[]\n  yearbookFiles        YearbookFile[]\n\n  @@index([productId], map: "IX_Product_Id")\n  @@map("Files")\n}\n\n/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.\nmodel ImportedUserSubGroups {\n  code String? @map("Code") @db.NVarChar(255)\n  name String? @map("Name") @db.NVarChar(255)\n\n  @@ignore\n}\n\n/// The underlying table does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.\nmodel Klassen {\n  subGroup String? @map("SubGroup") @db.NVarChar(255)\n  group    String? @map("Group") @db.NVarChar(255)\n\n  @@map("Klassen$")\n  @@ignore\n}\n\nmodel Language {\n  id                Int                @id(map: "PK_dbo.Languages") @default(autoincrement()) @map("Id")\n  name              String             @map("Name") @db.NVarChar(Max)\n  iso2Code          String             @map("Iso2Code") @db.NVarChar(Max)\n  countryId         Int?               @map("Country_Id")\n  country           Country?           @relation(fields: [countryId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Languages_dbo.Countries_Country_Id")\n  userRegistrations UserRegistration[]\n  users             User[]\n\n  @@index([countryId], map: "IX_Country_Id")\n  @@map("Languages")\n}\n\nmodel Localization {\n  id                             Int                             @id(map: "PK_dbo.LOCALIZATION") @default(autoincrement()) @map("Id")\n  virtualPath                    String?                         @map("VIRTUAL_PATH") @db.NVarChar(Max)\n  className                      String?                         @map("CLASS_NAME") @db.NVarChar(Max)\n  cultureName                    String?                         @map("CULTURE_NAME") @db.NVarChar(Max)\n  resourceName                   String?                         @map("RESOURCE_NAME") @db.NVarChar(Max)\n  resourceValue                  String?                         @map("RESOURCE_VALUE") @db.NVarChar(Max)\n  productDescriptionTranslations ProductDescriptionTranslation[]\n  productNameTranslations        ProductNameTranslation[]\n\n  @@map("LOCALIZATION")\n}\n\nmodel Log {\n  id        Int      @id(map: "PK_dbo.Log") @default(autoincrement()) @map("Id")\n  date      DateTime @map("Date") @db.DateTime\n  thread    String   @map("Thread") @db.NVarChar(Max)\n  level     String   @map("Level") @db.NVarChar(Max)\n  logger    String   @map("Logger") @db.NVarChar(Max)\n  message   String   @map("Message") @db.NVarChar(Max)\n  exception String?  @map("Exception") @db.NVarChar(Max)\n}\n\nmodel OrderComment {\n  id            Int       @id(map: "PK_dbo.OrderComments") @default(autoincrement()) @map("Id")\n  createdOn     DateTime  @map("CreatedOn") @db.DateTime\n  deactivatedOn DateTime? @map("DeactivatedOn") @db.DateTime\n  message       String    @map("Message") @db.NVarChar(Max)\n  orderId       Int       @map("Order_Id")\n  userId        Int       @map("User_Id")\n  order         Order     @relation(fields: [orderId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.OrderComments_dbo.Orders_Order_Id")\n  user          User      @relation(fields: [userId], references: [id], onUpdate: NoAction, map: "FK_dbo.OrderComments_dbo.Users_User_Id")\n\n  @@index([orderId], map: "IX_Order_Id")\n  @@index([userId], map: "IX_User_Id")\n  @@map("OrderComments")\n}\n\nmodel OrderDeliveryOptionOrderPaymentOptions {\n  orderDeliveryOptionId Int                 @map("OrderDeliveryOption_Id")\n  orderPaymentOptionId  Int                 @map("OrderPaymentOption_Id")\n  orderDeliveryOption   OrderDeliveryOption @relation(fields: [orderDeliveryOptionId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.OrderDeliveryOptionOrderPaymentOptions_dbo.OrderDeliveryOptions_OrderDeliveryOption_Id")\n  orderPaymentOption    OrderPaymentOption  @relation(fields: [orderPaymentOptionId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.OrderDeliveryOptionOrderPaymentOptions_dbo.OrderPaymentOptions_OrderPaymentOption_Id")\n\n  @@id([orderDeliveryOptionId, orderPaymentOptionId], map: "PK_dbo.OrderDeliveryOptionOrderPaymentOptions")\n  @@index([orderDeliveryOptionId], map: "IX_OrderDeliveryOption_Id")\n  @@index([orderPaymentOptionId], map: "IX_OrderPaymentOption_Id")\n}\n\nmodel OrderDeliveryOption {\n  id                                     Int                                      @id(map: "PK_dbo.OrderDeliveryOptions") @default(autoincrement()) @map("Id")\n  name                                   String                                   @map("Name") @db.NVarChar(Max)\n  price                                  Decimal                                  @map("Price") @db.Decimal(18, 2)\n  deactivatedOn                          DateTime?                                @map("DeactivatedOn") @db.DateTime\n  isPreferred                            Boolean                                  @map("IsPreferred")\n  requiredShipping                       Boolean                                  @map("RequiredShipping")\n  image                                  String?                                  @map("Image") @db.NVarChar(Max)\n  fileId                                 Int?                                     @map("File_Id")\n  userGroupId                            Int?                                     @map("UserGroup_Id")\n  adminOnly                              Boolean                                  @default(false, map: "DF__OrderDeli__Admin__79D3C7E3") @map("AdminOnly")\n  orderDeliveryOptionOrderPaymentOptions OrderDeliveryOptionOrderPaymentOptions[]\n  file                                   File?                                    @relation(fields: [fileId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.OrderDeliveryOptions_dbo.Files_File_Id")\n  userGroup                              UserGroup?                               @relation(fields: [userGroupId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.OrderDeliveryOptions_dbo.UserGroups_UserGroup_Id")\n  orders                                 Order[]\n\n  @@index([fileId], map: "IX_File_Id")\n  @@index([userGroupId], map: "IX_UserGroup_Id")\n  @@map("OrderDeliveryOptions")\n}\n\nmodel OrderDownloadMessage {\n  orderId        Int          @map("Order_Id")\n  emailMessageId Int          @map("EmailMessage_Id")\n  emailMessage   EmailMessage @relation(fields: [emailMessageId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.OrderDownloadMessages_dbo.EmailMessages_EmailMessage_Id")\n  order          Order        @relation(fields: [orderId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.OrderDownloadMessages_dbo.Orders_Order_Id")\n\n  @@id([orderId, emailMessageId], map: "PK_dbo.OrderDownloadMessages")\n  @@index([emailMessageId], map: "IX_EmailMessage_Id")\n  @@index([orderId], map: "IX_Order_Id")\n  @@map("OrderDownloadMessages")\n}\n\nmodel OrderLineDownloadLink {\n  orderLineId    Int          @map("OrderLine_Id")\n  downloadLinkId Int          @map("DownloadLink_Id")\n  downloadLink   DownloadLink @relation(fields: [downloadLinkId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.OrderLineDownloadLinks_dbo.DownloadLinks_DownloadLink_Id")\n  orderLine      OrderLine    @relation(fields: [orderLineId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.OrderLineDownloadLinks_dbo.OrderLines_OrderLine_Id")\n\n  @@id([orderLineId, downloadLinkId], map: "PK_dbo.OrderLineDownloadLinks")\n  @@index([downloadLinkId], map: "IX_DownloadLink_Id")\n  @@index([orderLineId], map: "IX_OrderLine_Id")\n  @@map("OrderLineDownloadLinks")\n}\n\nmodel OrderLine {\n  id                     Int                     @id(map: "PK_dbo.OrderLines") @default(autoincrement()) @map("Id")\n  orderQuantity          Int                     @map("OrderQuantity")\n  price                  Decimal                 @map("Price") @db.Decimal(18, 2)\n  vat                    Decimal                 @map("VAT") @db.Decimal(18, 2)\n  productId              Int                     @map("Product_Id")\n  orderId                Int?                    @map("Order_Id")\n  publicationDate        DateTime?               @map("PublicationDate") @db.DateTime\n  photoLinkId            Int?                    @map("PhotoLink_Id")\n  orderLineDownloadLinks OrderLineDownloadLink[]\n  order                  Order?                  @relation(fields: [orderId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.OrderLines_dbo.Orders_Order_Id")\n  photoLink              PhotoLink?              @relation(fields: [photoLinkId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.OrderLines_dbo.PhotoLinks_PhotoLink_Id")\n  product                Product                 @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.OrderLines_dbo.Products_Product_Id")\n\n  @@index([orderId], map: "IX_Order_Id")\n  @@index([photoLinkId], map: "IX_PhotoLink_Id")\n  @@index([productId], map: "IX_Product_Id")\n  @@map("OrderLines")\n}\n\nmodel OrderPaymentOption {\n  id                                     Int                                      @id(map: "PK_dbo.OrderPaymentOptions") @default(autoincrement()) @map("Id")\n  name                                   String                                   @map("Name") @db.NVarChar(Max)\n  code                                   String                                   @map("Code") @db.NVarChar(Max)\n  price                                  Decimal                                  @map("Price") @db.Decimal(18, 2)\n  deactivatedOn                          DateTime?                                @map("DeactivatedOn") @db.DateTime\n  isPreferred                            Boolean                                  @map("IsPreferred")\n  image                                  String?                                  @map("Image") @db.NVarChar(Max)\n  fileId                                 Int?                                     @map("File_Id")\n  orderDeliveryOptionOrderPaymentOptions OrderDeliveryOptionOrderPaymentOptions[]\n  file                                   File?                                    @relation(fields: [fileId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.OrderPaymentOptions_dbo.Files_File_Id")\n  orders                                 Order[]\n\n  @@index([fileId], map: "IX_File_Id")\n  @@map("OrderPaymentOptions")\n}\n\nmodel Order {\n  id                                                            Int                    @id(map: "PK_dbo.Orders") @default(autoincrement()) @map("Id")\n  number                                                        String                 @map("Number") @db.NVarChar(Max)\n  createdOn                                                     DateTime               @map("CreatedOn") @db.DateTime\n  paidOn                                                        DateTime?              @map("PaidOn") @db.DateTime\n  shippedOn                                                     DateTime?              @map("ShippedOn") @db.DateTime\n  etaInDay                                                      Int?                   @map("ETAInDays")\n  orderState                                                    Int                    @map("OrderState")\n  trackingNumber                                                String?                @map("TrackingNumber") @db.NVarChar(Max)\n  subTotal                                                      Decimal                @map("SubTotal") @db.Decimal(18, 2)\n  freight                                                       Decimal                @map("Freight") @db.Decimal(18, 2)\n  transaction                                                   Decimal                @map("Transaction") @db.Decimal(18, 2)\n  vat                                                           Decimal                @map("VAT") @db.Decimal(18, 2)\n  grandTotal                                                    Decimal                @map("GrandTotal") @db.Decimal(18, 2)\n  subTotalDiscount                                              Decimal                @map("SubTotalDiscount") @db.Decimal(18, 2)\n  billingAddressId                                              Int?                   @map("BillingAddress_Id")\n  bulkDiscountId                                                Int?                   @map("BulkDiscount_Id")\n  confirmationMessageId                                         Int?                   @map("ConfirmationMessage_Id")\n  deliveryOptionId                                              Int                    @map("DeliveryOption_Id")\n  paymentOptionId                                               Int                    @map("PaymentOption_Id")\n  shipMessageId                                                 Int?                   @map("ShipMessage_Id")\n  shippingAddressId                                             Int?                   @map("ShippingAddress_Id")\n  userId                                                        Int                    @map("User_Id")\n  reminderId                                                    Int?                   @map("Reminder_Id")\n  printedOn                                                     DateTime?              @map("PrintedOn") @db.DateTime\n  userRegistrationId                                            Int?                   @map("UserRegistration_Id")\n  deliveredOn                                                   DateTime?              @map("DeliveredOn") @db.DateTime\n  paymentConfirmationMessageId                                  Int?                   @map("PaymentConfirmationMessage_Id")\n  orderComments                                                 OrderComment[]\n  orderDownloadMessages                                         OrderDownloadMessage[]\n  orderLines                                                    OrderLine[]\n  billingAddress                                                BillingAddress?        @relation(fields: [billingAddressId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.BillingAddresses_BillingAddress_Id")\n  emailMessagesOrdersConfirmationMessageIdToEmailMessage        EmailMessage?          @relation("Orders_ConfirmationMessage_IdToEmailMessages", fields: [confirmationMessageId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.EmailMessages_ConfirmationMessage_Id")\n  emailMessagesOrdersPaymentConfirmationMessageIdToEmailMessage EmailMessage?          @relation("Orders_PaymentConfirmationMessage_IdToEmailMessages", fields: [paymentConfirmationMessageId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.EmailMessages_PaymentConfirmationMessage_Id")\n  emailMessagesOrdersReminderIdToEmailMessage                   EmailMessage?          @relation("Orders_Reminder_IdToEmailMessages", fields: [reminderId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.EmailMessages_Reminder_Id")\n  emailMessagesOrdersShipMessageIdToEmailMessage                EmailMessage?          @relation("Orders_ShipMessage_IdToEmailMessages", fields: [shipMessageId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.EmailMessages_ShipMessage_Id")\n  orderDeliveryOption                                           OrderDeliveryOption    @relation(fields: [deliveryOptionId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.OrderDeliveryOptions_DeliveryOption_Id")\n  orderPaymentOption                                            OrderPaymentOption     @relation(fields: [paymentOptionId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.OrderPaymentOptions_PaymentOption_Id")\n  productBulkDiscount                                           ProductBulkDiscount?   @relation(fields: [bulkDiscountId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.ProductBulkDiscounts_BulkDiscount_Id")\n  shippingAddress                                               ShippingAddress?       @relation(fields: [shippingAddressId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.ShippingAddresses_ShippingAddress_Id")\n  userRegistration                                              UserRegistration?      @relation(fields: [userRegistrationId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.UserRegistrations_UserRegistration_Id")\n  user                                                          User                   @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.Orders_dbo.Users_User_Id")\n\n  @@index([billingAddressId], map: "IX_BillingAddress_Id")\n  @@index([bulkDiscountId], map: "IX_BulkDiscount_Id")\n  @@index([confirmationMessageId], map: "IX_ConfirmationMessage_Id")\n  @@index([deliveryOptionId], map: "IX_DeliveryOption_Id")\n  @@index([paymentConfirmationMessageId], map: "IX_PaymentConfirmationMessage_Id")\n  @@index([paymentOptionId], map: "IX_PaymentOption_Id")\n  @@index([reminderId], map: "IX_Reminder_Id")\n  @@index([shipMessageId], map: "IX_ShipMessage_Id")\n  @@index([shippingAddressId], map: "IX_ShippingAddress_Id")\n  @@index([userId], map: "IX_User_Id")\n  @@index([userRegistrationId], map: "IX_UserRegistration_Id")\n  @@map("Orders")\n}\n\nmodel PhotoLink {\n  id                      Int                    @id(map: "PK_dbo.PhotoLinks") @default(autoincrement()) @map("Id")\n  lastUpdatedOn           DateTime               @map("LastUpdatedOn") @db.DateTime\n  deactivedOn             DateTime?              @map("DeactivedOn") @db.DateTime\n  photoId                 Int?                   @map("Photo_Id")\n  productId               Int                    @map("Product_Id")\n  userRegistrationId      Int                    @map("UserRegistration_Id")\n  publicationDate         DateTime?              @map("PublicationDate") @db.DateTime\n  userRegistrationGroupId Int?                   @map("UserRegistrationGroup_Id")\n  orderLines              OrderLine[]\n  photo                   Photo?                 @relation(fields: [photoId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.PhotoLinks_dbo.Photos_Photo_Id")\n  product                 Product                @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.PhotoLinks_dbo.Products_Product_Id")\n  userRegistrationGroup   UserRegistrationGroup? @relation(fields: [userRegistrationGroupId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.PhotoLinks_dbo.UserRegistrationGroups_UserRegistrationGroup_Id")\n  userRegistration        UserRegistration       @relation(fields: [userRegistrationId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.PhotoLinks_dbo.UserRegistrations_UserRegistration_Id")\n\n  @@index([photoId], map: "IX_Photo_Id")\n  @@index([productId], map: "IX_Product_Id")\n  @@index([userRegistrationId], map: "IX_UserRegistration_Id")\n  @@index([userRegistrationGroupId], map: "IX_UserRegistrationGroup_Id")\n  @@map("PhotoLinks")\n}\n\nmodel Photo {\n  id         Int         @id(map: "PK_dbo.Photos") @default(autoincrement()) @map("Id")\n  fileName   String      @map("FileName") @db.NVarChar(Max)\n  name       String      @map("Name") @db.NVarChar(Max)\n  preview    Boolean     @map("Preview")\n  photoLinks PhotoLink[]\n\n  @@map("Photos")\n}\n\nmodel ProductBulkDiscountProducts {\n  productBulkDiscountId Int                 @map("ProductBulkDiscount_Id")\n  productId             Int                 @map("Product_Id")\n  productBulkDiscount   ProductBulkDiscount @relation(fields: [productBulkDiscountId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductBulkDiscountProducts_dbo.ProductBulkDiscounts_ProductBulkDiscount_Id")\n  product               Product             @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductBulkDiscountProducts_dbo.Products_Product_Id")\n\n  @@id([productBulkDiscountId, productId], map: "PK_dbo.ProductBulkDiscountProducts")\n  @@index([productId], map: "IX_Product_Id")\n  @@index([productBulkDiscountId], map: "IX_ProductBulkDiscount_Id")\n}\n\nmodel ProductBulkDiscount {\n  id                            Int                            @id(map: "PK_dbo.ProductBulkDiscounts") @default(autoincrement()) @map("Id")\n  code                          String                         @map("Code") @db.NVarChar(Max)\n  name                          String                         @map("Name") @db.NVarChar(Max)\n  description                   String?                        @map("Description") @db.NVarChar(Max)\n  priority                      Int                            @map("Priority")\n  price                         Decimal?                       @map("Price") @db.Decimal(18, 2)\n  percentage                    Decimal                        @map("Percentage") @db.Decimal(18, 2)\n  deactivatedOn                 DateTime?                      @map("DeactivatedOn") @db.DateTime\n  orders                        Order[]\n  productBulkDiscountProducts   ProductBulkDiscountProducts[]\n  productBulkDiscountUserGroups ProductBulkDiscountUserGroup[]\n\n  @@map("ProductBulkDiscounts")\n}\n\nmodel ProductBulkDiscountUserGroup {\n  productBulkDiscountId Int                 @map("ProductBulkDiscount_Id")\n  userGroupId           Int                 @map("UserGroup_Id")\n  productBulkDiscount   ProductBulkDiscount @relation(fields: [productBulkDiscountId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductBulkDiscountUserGroups_dbo.ProductBulkDiscounts_ProductBulkDiscount_Id")\n  userGroup             UserGroup           @relation(fields: [userGroupId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductBulkDiscountUserGroups_dbo.UserGroups_UserGroup_Id")\n\n  @@id([productBulkDiscountId, userGroupId], map: "PK_dbo.ProductBulkDiscountUserGroups")\n  @@index([productBulkDiscountId], map: "IX_ProductBulkDiscount_Id")\n  @@index([userGroupId], map: "IX_UserGroup_Id")\n}\n\nmodel ProductDescription {\n  id                             Int                             @id(map: "PK_dbo.ProductDescriptions") @default(autoincrement()) @map("Id")\n  text                           String                          @map("Text") @db.NVarChar(Max)\n  deactivatedOn                  DateTime?                       @map("DeactivatedOn") @db.DateTime\n  productDescriptionTranslations ProductDescriptionTranslation[]\n  productProductDescriptions     ProductProductDescription[]\n\n  @@map("ProductDescriptions")\n}\n\nmodel ProductDescriptionTranslation {\n  productDescriptionId Int                @map("ProductDescription_Id")\n  localizationId       Int                @map("Localization_Id")\n  localization         Localization       @relation(fields: [localizationId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductDescriptionTranslations_dbo.LOCALIZATION_Localization_Id")\n  productDescription   ProductDescription @relation(fields: [productDescriptionId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductDescriptionTranslations_dbo.ProductDescriptions_ProductDescription_Id")\n\n  @@id([productDescriptionId, localizationId], map: "PK_dbo.ProductDescriptionTranslations")\n  @@index([localizationId], map: "IX_Localization_Id")\n  @@index([productDescriptionId], map: "IX_ProductDescription_Id")\n}\n\nmodel ProductIcon {\n  id                  Int                  @id(map: "PK_dbo.ProductIcons") @default(autoincrement()) @map("Id")\n  icon                String               @map("Icon") @db.NVarChar(Max)\n  description         String               @map("Description") @db.NVarChar(Max)\n  productProductIcons ProductProductIcon[]\n\n  @@map("ProductIcons")\n}\n\nmodel ProductNameTranslation {\n  productId      Int          @map("Product_Id")\n  localizationId Int          @map("Localization_Id")\n  localization   Localization @relation(fields: [localizationId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductNameTranslations_dbo.LOCALIZATION_Localization_Id")\n  product        Product      @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductNameTranslations_dbo.Products_Product_Id")\n\n  @@id([productId, localizationId], map: "PK_dbo.ProductNameTranslations")\n  @@index([localizationId], map: "IX_Localization_Id")\n  @@index([productId], map: "IX_Product_Id")\n}\n\nmodel ProductPriceRuleAvailabilities {\n  id            Int       @id(map: "PK_dbo.ProductPriceRuleAvailabilities") @default(autoincrement()) @map("Id")\n  deactivatedOn DateTime? @map("DeactivatedOn") @db.DateTime\n  userGroupId   Int       @map("UserGroup_Id")\n  userGroup     UserGroup @relation(fields: [userGroupId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductPriceRuleAvailabilities_dbo.UserGroups_UserGroup_Id")\n\n  @@index([userGroupId], map: "IX_UserGroup_Id")\n}\n\nmodel ProductPriceRule {\n  id             Int       @id(map: "PK_dbo.ProductPriceRules") @default(autoincrement()) @map("Id")\n  minPrice       Decimal   @map("MinPrice") @db.Decimal(18, 2)\n  maxPrice       Decimal   @map("MaxPrice") @db.Decimal(18, 2)\n  priceStep      Decimal   @map("PriceStep") @db.Decimal(18, 2)\n  suggestedPrice Decimal?  @map("SuggestedPrice") @db.Decimal(18, 2)\n  productId      Int       @map("Product_Id")\n  userGroupId    Int       @map("UserGroup_Id")\n  product        Product   @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductPriceRules_dbo.Products_Product_Id")\n  userGroup      UserGroup @relation(fields: [userGroupId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductPriceRules_dbo.UserGroups_UserGroup_Id")\n\n  @@index([productId], map: "IX_Product_Id")\n  @@index([userGroupId], map: "IX_UserGroup_Id")\n  @@map("ProductPriceRules")\n}\n\nmodel ProductPrice {\n  id                 Int       @id(map: "PK_dbo.ProductPrices") @default(autoincrement()) @map("Id")\n  price              Decimal   @map("Price") @db.Decimal(18, 2)\n  discountPercentage Decimal   @map("DiscountPercentage") @db.Decimal(18, 2)\n  userGroupId        Int       @map("UserGroup_Id")\n  productId          Int?      @map("Product_Id")\n  product            Product?  @relation(fields: [productId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.ProductPrices_dbo.Products_Product_Id")\n  userGroup          UserGroup @relation(fields: [userGroupId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductPrices_dbo.UserGroups_UserGroup_Id")\n\n  @@index([productId], map: "IX_Product_Id")\n  @@index([userGroupId], map: "IX_UserGroup_Id")\n  @@map("ProductPrices")\n}\n\nmodel ProductProductDescription {\n  productId            Int                @map("Product_Id")\n  productDescriptionId Int                @map("ProductDescription_Id")\n  productDescription   ProductDescription @relation(fields: [productDescriptionId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductProductDescriptions_dbo.ProductDescriptions_ProductDescription_Id")\n  product              Product            @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductProductDescriptions_dbo.Products_Product_Id")\n\n  @@id([productId, productDescriptionId], map: "PK_dbo.ProductProductDescriptions")\n  @@index([productId], map: "IX_Product_Id")\n  @@index([productDescriptionId], map: "IX_ProductDescription_Id")\n}\n\nmodel ProductProductIcon {\n  productId     Int?         @map("Product_Id")\n  productIconId Int?         @map("ProductIcon_Id")\n  id            Int          @id(map: "PK_dbo.ProductProductIcons") @default(autoincrement()) @map("Id")\n  deactivatedOn DateTime?    @map("DeactivatedOn") @db.DateTime\n  groupId       Int?         @map("Group_Id")\n  productIcon   ProductIcon? @relation(fields: [productIconId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.ProductProductIcons_dbo.ProductIcons_ProductIcon_Id")\n  product       Product?     @relation(fields: [productId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.ProductProductIcons_dbo.Products_Product_Id")\n  userGroup     UserGroup?   @relation(fields: [groupId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.ProductProductIcons_dbo.UserGroups_Group_Id")\n\n  @@index([groupId], map: "IX_Group_Id")\n  @@index([productId], map: "IX_Product_Id")\n  @@index([productIconId], map: "IX_ProductIcon_Id")\n  @@map("ProductProductIcons")\n}\n\nmodel Product {\n  id                          Int                           @id(map: "PK_dbo.Products") @default(autoincrement()) @map("Id")\n  name                        String                        @map("Name") @db.NVarChar(Max)\n  createdOn                   DateTime                      @map("CreatedOn") @db.DateTime\n  deactivatedOn               DateTime?                     @map("DeactivatedOn") @db.DateTime\n  partNumber                  String?                       @map("PartNumber") @db.NVarChar(Max)\n  stock                       Int?                          @map("Stock")\n  deliveryTimeInDay           Int?                          @map("DeliveryTimeInDays")\n  isGadget                    Boolean                       @map("IsGadget")\n  rank                        Int?                          @map("Rank")\n  isRecommended               Boolean                       @map("IsRecommended")\n  typeId                      Int?                          @map("Type_Id")\n  maxOrderQuantity            Int?                          @map("MaxOrderQuantity")\n  minOrderQuantity            Int?                          @map("MinOrderQuantity")\n  downloadable                Boolean                       @default(false, map: "DF__Products__Downlo__2CBDA3B5") @map("Downloadable")\n  files                       File[]\n  orderLines                  OrderLine[]\n  photoLinks                  PhotoLink[]\n  productBulkDiscountProducts ProductBulkDiscountProducts[]\n  productNameTranslations     ProductNameTranslation[]\n  productPriceRules           ProductPriceRule[]\n  productPrices               ProductPrice[]\n  productProductDescriptions  ProductProductDescription[]\n  productProductIcons         ProductProductIcon[]\n  productType                 ProductType?                  @relation(fields: [typeId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Products_dbo.ProductTypes_Type_Id")\n  productTags                 ProductTag[]\n\n  @@index([typeId], map: "IX_Type_Id")\n  @@map("Products")\n}\n\nmodel ProductTag {\n  productId Int     @map("Product_Id")\n  tagId     Int     @map("Tag_Id")\n  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductTags_dbo.Products_Product_Id")\n  tag       Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.ProductTags_dbo.Tags_Tag_Id")\n\n  @@id([productId, tagId], map: "PK_dbo.ProductTags")\n  @@index([productId], map: "IX_Product_Id")\n  @@index([tagId], map: "IX_Tag_Id")\n  @@map("ProductTags")\n}\n\nmodel ProductType {\n  id            Int       @id(map: "PK_dbo.ProductTypes") @default(autoincrement()) @map("Id")\n  name          String    @map("Name") @db.NVarChar(Max)\n  code          String    @map("Code") @db.NVarChar(Max)\n  vat           Decimal   @map("VAT") @db.Decimal(18, 2)\n  deactivatedOn DateTime? @map("DeactivatedOn") @db.DateTime\n  products      Product[]\n\n  @@map("ProductTypes")\n}\n\nmodel ShippingAddress {\n  id      Int     @id(map: "PK_dbo.ShippingAddresses") @map("Id")\n  userId  Int?    @map("User_Id")\n  orders  Order[]\n  address Address @relation(fields: [id], references: [id], onUpdate: NoAction, map: "FK_dbo.ShippingAddresses_dbo.Addresses_Id")\n  user    User?   @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.ShippingAddresses_dbo.Users_User_Id")\n\n  @@index([id], map: "IX_Id")\n  @@index([userId], map: "IX_User_Id")\n  @@map("ShippingAddresses")\n}\n\nmodel Tag {\n  id          Int          @id(map: "PK_dbo.Tags") @default(autoincrement()) @map("Id")\n  name        String       @map("Name") @db.NVarChar(Max)\n  productTags ProductTag[]\n\n  @@map("Tags")\n}\n\nmodel UniqueEfKeys {\n  id           Int      @id(map: "PK_dbo.UniqueEFKeys") @default(autoincrement()) @map("Id")\n  className    String   @map("ClassName") @db.NVarChar(Max)\n  propertyName String   @map("PropertyName") @db.NVarChar(Max)\n  date         DateTime @map("Date") @db.DateTime\n  index        Int      @map("Index")\n\n  @@map("UniqueEFKeys")\n}\n\nmodel UserGroup {\n  id                             Int                              @id(map: "PK_dbo.UserGroups") @default(autoincrement()) @map("Id")\n  name                           String                           @map("Name") @db.NVarChar(Max)\n  background                     String?                          @map("Background") @db.NVarChar(Max)\n  code                           String                           @map("Code") @db.NVarChar(Max)\n  deactivatedOn                  DateTime?                        @map("DeactivatedOn") @db.DateTime\n  orderDeliveryOptions           OrderDeliveryOption[]\n  productBulkDiscountUserGroups  ProductBulkDiscountUserGroup[]\n  productPriceRuleAvailabilities ProductPriceRuleAvailabilities[]\n  productPriceRules              ProductPriceRule[]\n  productPrices                  ProductPrice[]\n  productProductIcons            ProductProductIcon[]\n  userRegistrationGroups         UserRegistrationGroup[]\n  userSubGroups                  UserSubGroup[]\n  userUserGroups                 UserUserGroup[]\n  yearbookAvailabilities         YearbookAvailability[]\n  yearbookFiles                  YearbookFile[]\n  yearbookQuotes                 YearbookQuote[]\n\n  @@map("UserGroups")\n}\n\nmodel UserRegistrationGroup {\n  id                 Int              @id(map: "PK_dbo.UserRegistrationGroups") @default(autoincrement()) @map("Id")\n  publicationDate    DateTime         @map("PublicationDate") @db.DateTime\n  groupId            Int              @map("Group_Id")\n  subGroupId         Int?             @map("SubGroup_Id")\n  userRegistrationId Int              @map("UserRegistration_Id")\n  photoLinks         PhotoLink[]\n  userGroup          UserGroup        @relation(fields: [groupId], references: [id], onUpdate: NoAction, map: "FK_dbo.UserRegistrationGroups_dbo.UserGroups_Group_Id")\n  userRegistration   UserRegistration @relation(fields: [userRegistrationId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.UserRegistrationGroups_dbo.UserRegistrations_UserRegistration_Id")\n  userSubGroup       UserSubGroup?    @relation(fields: [subGroupId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.UserRegistrationGroups_dbo.UserSubGroups_SubGroup_Id")\n\n  @@index([groupId], map: "IX_Group_Id")\n  @@index([subGroupId], map: "IX_SubGroup_Id")\n  @@index([userRegistrationId], map: "IX_UserRegistration_Id")\n  @@map("UserRegistrationGroups")\n}\n\nmodel UserRegistrationLoginLog {\n  id                 Int              @id(map: "PK_dbo.UserRegistrationLoginLogs") @default(autoincrement()) @map("Id")\n  createdOn          DateTime         @map("CreatedOn") @db.DateTime\n  ip                 String?          @map("IP") @db.NVarChar(Max)\n  userRegistrationId Int              @map("UserRegistration_Id")\n  userRegistration   UserRegistration @relation(fields: [userRegistrationId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.UserRegistrationLoginLogs_dbo.UserRegistrations_UserRegistration_Id")\n\n  @@index([userRegistrationId], map: "IX_UserRegistration_Id")\n  @@map("UserRegistrationLoginLogs")\n}\n\nmodel UserRegistration {\n  id                           Int                        @id(map: "PK_dbo.UserRegistrations") @default(autoincrement()) @map("Id")\n  firstName                    String                     @map("FirstName") @db.NVarChar(Max)\n  lastName                     String                     @map("LastName") @db.NVarChar(Max)\n  createdOn                    DateTime                   @map("CreatedOn") @db.DateTime\n  code                         String                     @unique(map: "UQ__UserRegi__A25C5AA7812A9BD9") @map("Code") @db.NVarChar(450)\n  hasGadget                    Boolean                    @map("HasGadgets")\n  deactivatedOn                DateTime?                  @map("DeactivatedOn") @db.DateTime\n  shippingAvailableAsOf        DateTime?                  @map("ShippingAvailableAsOf") @db.DateTime\n  languageId                   Int                        @map("Language_Id")\n  pickUpAtSchoolAvailableUntil DateTime?                  @map("PickUpAtSchoolAvailableUntil") @db.DateTime\n  addressId                    Int?                       @map("Address_Id")\n  siblingHash                  String?                    @map("SiblingHash") @db.NVarChar(Max)\n  orders                       Order[]\n  photoLinks                   PhotoLink[]\n  userRegistrationGroups       UserRegistrationGroup[]\n  userRegistrationLoginLogs    UserRegistrationLoginLog[]\n  address                      Address?                   @relation(fields: [addressId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.UserRegistrations_dbo.Addresses_Address_Id")\n  language                     Language                   @relation(fields: [languageId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.UserRegistrations_dbo.Languages_Language_Id")\n  users                        User[]\n\n  @@index([addressId], map: "IX_Address_Id")\n  @@index([languageId], map: "IX_Language_Id")\n  @@map("UserRegistrations")\n}\n\nmodel User {\n  id                  Int               @id(map: "PK_dbo.Users") @default(autoincrement()) @map("Id")\n  firstName           String            @map("FirstName") @db.NVarChar(Max)\n  lastName            String            @map("LastName") @db.NVarChar(Max)\n  login               String            @map("Login") @db.NVarChar(Max)\n  password            String            @map("Password") @db.NVarChar(Max)\n  createdOn           DateTime          @map("CreatedOn") @db.DateTime\n  role                Int               @map("Role")\n  isActive            Boolean           @map("IsActive")\n  email               String            @map("Email") @db.NVarChar(Max)\n  phone               String?           @map("Phone") @db.NVarChar(Max)\n  loginAttemp         Int               @map("LoginAttemps")\n  lastLogin           DateTime?         @map("LastLogin") @db.DateTime\n  deactivatedOn       DateTime?         @map("DeactivatedOn") @db.DateTime\n  languageId          Int               @map("Language_Id")\n  userRegistrationId  Int?              @map("UserRegistration_Id")\n  oldGroup            String?           @map("OldGroup") @db.NVarChar(Max)\n  oldYear             String?           @map("OldYear") @db.NVarChar(Max)\n  child               String?           @map("Child") @db.NVarChar(Max)\n  promotionsAgreement Boolean           @default(false, map: "DF__Users__Promotion__65F62111") @map("PromotionsAgreement")\n  billingAddresses    BillingAddress[]\n  orderComments       OrderComment[]\n  orders              Order[]\n  shippingAddresses   ShippingAddress[]\n  language            Language          @relation(fields: [languageId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.Users_dbo.Languages_Language_Id")\n  userRegistration    UserRegistration? @relation(fields: [userRegistrationId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.Users_dbo.UserRegistrations_UserRegistration_Id")\n  userUserGroups      UserUserGroup[]\n\n  @@index([languageId], map: "IX_Language_Id")\n  @@index([userRegistrationId], map: "IX_UserRegistration_Id")\n  @@map("Users")\n}\n\nmodel UserSubGroup {\n  id                     Int                     @id(map: "PK_dbo.UserSubGroups") @default(autoincrement()) @map("Id")\n  name                   String                  @map("Name") @db.NVarChar(Max)\n  background             String?                 @map("Background") @db.NVarChar(Max)\n  code                   String                  @map("Code") @db.NVarChar(Max)\n  groupId                Int                     @map("Group_Id")\n  deactivatedOn          DateTime?               @map("DeactivatedOn") @db.DateTime\n  canDownloadImage       Boolean?                @map("CanDownloadImages")\n  userRegistrationGroups UserRegistrationGroup[]\n  userGroup              UserGroup               @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.UserSubGroups_dbo.UserGroups_Group_Id")\n  yearbookAvailabilities YearbookAvailability[]\n  yearbookFiles          YearbookFile[]\n  yearbookQuotes         YearbookQuote[]\n\n  @@index([groupId], map: "IX_Group_Id")\n  @@map("UserSubGroups")\n}\n\nmodel UserUserGroup {\n  userId      Int       @map("User_Id")\n  userGroupId Int       @map("UserGroup_Id")\n  userGroup   UserGroup @relation(fields: [userGroupId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.UserUserGroups_dbo.UserGroups_UserGroup_Id")\n  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.UserUserGroups_dbo.Users_User_Id")\n\n  @@id([userId, userGroupId], map: "PK_dbo.UserUserGroups")\n  @@index([userId], map: "IX_User_Id")\n  @@index([userGroupId], map: "IX_UserGroup_Id")\n  @@map("UserUserGroups")\n}\n\nmodel YearbookAvailability {\n  id            Int           @id(map: "PK_dbo.YearbookAvailabilities") @default(autoincrement()) @map("Id")\n  deactivatedOn DateTime?     @map("DeactivatedOn") @db.DateTime\n  groupId       Int           @map("Group_Id")\n  subGroupId    Int?          @map("SubGroup_Id")\n  userGroup     UserGroup     @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.YearbookAvailabilities_dbo.UserGroups_Group_Id")\n  userSubGroup  UserSubGroup? @relation(fields: [subGroupId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.YearbookAvailabilities_dbo.UserSubGroups_SubGroup_Id")\n\n  @@index([groupId], map: "IX_Group_Id")\n  @@index([subGroupId], map: "IX_SubGroup_Id")\n  @@map("YearbookAvailabilities")\n}\n\nmodel YearbookFile {\n  id            Int           @id(map: "PK_dbo.YearbookFiles") @default(autoincrement()) @map("Id")\n  createdOn     DateTime      @map("CreatedOn") @db.DateTime\n  deactivatedOn DateTime?     @map("DeactivatedOn") @db.DateTime\n  fileId        Int           @map("File_Id")\n  groupId       Int           @map("Group_Id")\n  subGroupId    Int?          @map("SubGroup_Id")\n  approvedOn    DateTime?     @map("ApprovedOn") @db.DateTime\n  file          File          @relation(fields: [fileId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.YearbookFiles_dbo.Files_File_Id")\n  userGroup     UserGroup     @relation(fields: [groupId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_dbo.YearbookFiles_dbo.UserGroups_Group_Id")\n  userSubGroup  UserSubGroup? @relation(fields: [subGroupId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "FK_dbo.YearbookFiles_dbo.UserSubGroups_SubGroup_Id")\n\n  @@index([fileId], map: "IX_File_Id")\n  @@index([groupId], map: "IX_Group_Id")\n  @@index([subGroupId], map: "IX_SubGroup_Id")\n  @@map("YearbookFiles")\n}\n\nmodel YearbookQuote {\n  id            Int          @id(map: "PK_dbo.YearbookQuotes") @default(autoincrement()) @map("Id")\n  createdOn     DateTime     @map("CreatedOn") @db.DateTime\n  text          String       @map("Text") @db.NVarChar(Max)\n  firstName     String       @map("FirstName") @db.NVarChar(Max)\n  lastName      String       @map("LastName") @db.NVarChar(Max)\n  email         String       @map("Email") @db.NVarChar(Max)\n  approvedOn    DateTime?    @map("ApprovedOn") @db.DateTime\n  deactivatedOn DateTime?    @map("DeactivatedOn") @db.DateTime\n  userIp        String?      @map("UserIP") @db.NVarChar(Max)\n  groupId       Int          @map("Group_Id")\n  subGroupId    Int          @map("SubGroup_Id")\n  userGroup     UserGroup    @relation(fields: [groupId], references: [id], onUpdate: NoAction, map: "FK_dbo.YearbookQuotes_dbo.UserGroups_Group_Id")\n  userSubGroup  UserSubGroup @relation(fields: [subGroupId], references: [id], onUpdate: NoAction, map: "FK_dbo.YearbookQuotes_dbo.UserSubGroups_SubGroup_Id")\n\n  @@index([groupId], map: "IX_Group_Id")\n  @@index([subGroupId], map: "IX_SubGroup_Id")\n  @@map("YearbookQuotes")\n}\n',
  "runtimeDataModel": {
    "models": {},
    "enums": {},
    "types": {}
  }
};
config.runtimeDataModel = JSON.parse('{"models":{"MigrationHistory":{"fields":[{"name":"migrationId","kind":"scalar","type":"String","dbName":"MigrationId"},{"name":"contextKey","kind":"scalar","type":"String","dbName":"ContextKey"},{"name":"model","kind":"scalar","type":"Bytes","dbName":"Model"},{"name":"productVersion","kind":"scalar","type":"String","dbName":"ProductVersion"}],"dbName":"__MigrationHistory"},"Address":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"street","kind":"scalar","type":"String","dbName":"Street"},{"name":"number","kind":"scalar","type":"String","dbName":"Number"},{"name":"box","kind":"scalar","type":"String","dbName":"Box"},{"name":"city","kind":"scalar","type":"String","dbName":"City"},{"name":"postalCode","kind":"scalar","type":"String","dbName":"PostalCode"},{"name":"countryId","kind":"scalar","type":"Int","dbName":"Country_Id"},{"name":"country","kind":"object","type":"Country","relationName":"AddressToCountry"},{"name":"billingAddress","kind":"object","type":"BillingAddress","relationName":"AddressToBillingAddress"},{"name":"shippingAddress","kind":"object","type":"ShippingAddress","relationName":"AddressToShippingAddress"},{"name":"userRegistrations","kind":"object","type":"UserRegistration","relationName":"AddressToUserRegistration"}],"dbName":"Addresses"},"BillingAddress":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"userId","kind":"scalar","type":"Int","dbName":"User_Id"},{"name":"vatNumber","kind":"scalar","type":"String","dbName":"VATNumber"},{"name":"address","kind":"object","type":"Address","relationName":"AddressToBillingAddress"},{"name":"user","kind":"object","type":"User","relationName":"BillingAddressToUser"},{"name":"orders","kind":"object","type":"Order","relationName":"BillingAddressToOrder"}],"dbName":"BillingAddresses"},"Country":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"iso2Code","kind":"scalar","type":"String","dbName":"Iso2Code"},{"name":"addresses","kind":"object","type":"Address","relationName":"AddressToCountry"},{"name":"languages","kind":"object","type":"Language","relationName":"CountryToLanguage"}],"dbName":"Countries"},"DownloadLinkLog":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"usedOn","kind":"scalar","type":"DateTime","dbName":"UsedOn"},{"name":"usedBy","kind":"scalar","type":"String","dbName":"UsedBy"},{"name":"response","kind":"scalar","type":"String","dbName":"Response"},{"name":"downloadLinkId","kind":"scalar","type":"Int","dbName":"DownloadLink_Id"},{"name":"downloadLink","kind":"object","type":"DownloadLink","relationName":"DownloadLinkToDownloadLinkLog"}],"dbName":"DownloadLinkLogs"},"DownloadLink":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"objectKey","kind":"scalar","type":"String","dbName":"ObjectKey"},{"name":"expirationDate","kind":"scalar","type":"DateTime","dbName":"ExpirationDate"},{"name":"url","kind":"scalar","type":"String","dbName":"Url"},{"name":"createdOn","kind":"scalar","type":"DateTime","dbName":"CreatedOn"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"downloadLinkLogs","kind":"object","type":"DownloadLinkLog","relationName":"DownloadLinkToDownloadLinkLog"},{"name":"orderLineDownloadLinks","kind":"object","type":"OrderLineDownloadLink","relationName":"DownloadLinkToOrderLineDownloadLink"}],"dbName":"DownloadLinks"},"EmailMessage":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"sentAttemp","kind":"scalar","type":"Int","dbName":"SentAttemps"},{"name":"sentOn","kind":"scalar","type":"DateTime","dbName":"SentOn"},{"name":"body","kind":"scalar","type":"String","dbName":"Body"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"to","kind":"scalar","type":"String","dbName":"To"},{"name":"cc","kind":"scalar","type":"String","dbName":"Cc"},{"name":"bcc","kind":"scalar","type":"String","dbName":"Bcc"},{"name":"subject","kind":"scalar","type":"String","dbName":"Subject"},{"name":"createdOn","kind":"scalar","type":"DateTime","dbName":"CreatedOn"},{"name":"type","kind":"scalar","type":"Int","dbName":"Type"},{"name":"orderDownloadMessages","kind":"object","type":"OrderDownloadMessage","relationName":"EmailMessageToOrderDownloadMessage"},{"name":"ordersOrdersConfirmationMessageIdToEmailMessages","kind":"object","type":"Order","relationName":"Orders_ConfirmationMessage_IdToEmailMessages"},{"name":"ordersOrdersPaymentConfirmationMessageIdToEmailMessages","kind":"object","type":"Order","relationName":"Orders_PaymentConfirmationMessage_IdToEmailMessages"},{"name":"ordersOrdersReminderIdToEmailMessages","kind":"object","type":"Order","relationName":"Orders_Reminder_IdToEmailMessages"},{"name":"ordersOrdersShipMessageIdToEmailMessages","kind":"object","type":"Order","relationName":"Orders_ShipMessage_IdToEmailMessages"}],"dbName":"EmailMessages"},"File":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"fileName","kind":"scalar","type":"String","dbName":"FileName"},{"name":"userFileName","kind":"scalar","type":"String","dbName":"UserFileName"},{"name":"type","kind":"scalar","type":"Int","dbName":"Type"},{"name":"productId","kind":"scalar","type":"Int","dbName":"Product_Id"},{"name":"product","kind":"object","type":"Product","relationName":"FileToProduct"},{"name":"orderDeliveryOptions","kind":"object","type":"OrderDeliveryOption","relationName":"FileToOrderDeliveryOption"},{"name":"orderPaymentOptions","kind":"object","type":"OrderPaymentOption","relationName":"FileToOrderPaymentOption"},{"name":"yearbookFiles","kind":"object","type":"YearbookFile","relationName":"FileToYearbookFile"}],"dbName":"Files"},"Language":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"iso2Code","kind":"scalar","type":"String","dbName":"Iso2Code"},{"name":"countryId","kind":"scalar","type":"Int","dbName":"Country_Id"},{"name":"country","kind":"object","type":"Country","relationName":"CountryToLanguage"},{"name":"userRegistrations","kind":"object","type":"UserRegistration","relationName":"LanguageToUserRegistration"},{"name":"users","kind":"object","type":"User","relationName":"LanguageToUser"}],"dbName":"Languages"},"Localization":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"virtualPath","kind":"scalar","type":"String","dbName":"VIRTUAL_PATH"},{"name":"className","kind":"scalar","type":"String","dbName":"CLASS_NAME"},{"name":"cultureName","kind":"scalar","type":"String","dbName":"CULTURE_NAME"},{"name":"resourceName","kind":"scalar","type":"String","dbName":"RESOURCE_NAME"},{"name":"resourceValue","kind":"scalar","type":"String","dbName":"RESOURCE_VALUE"},{"name":"productDescriptionTranslations","kind":"object","type":"ProductDescriptionTranslation","relationName":"LocalizationToProductDescriptionTranslation"},{"name":"productNameTranslations","kind":"object","type":"ProductNameTranslation","relationName":"LocalizationToProductNameTranslation"}],"dbName":"LOCALIZATION"},"Log":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"date","kind":"scalar","type":"DateTime","dbName":"Date"},{"name":"thread","kind":"scalar","type":"String","dbName":"Thread"},{"name":"level","kind":"scalar","type":"String","dbName":"Level"},{"name":"logger","kind":"scalar","type":"String","dbName":"Logger"},{"name":"message","kind":"scalar","type":"String","dbName":"Message"},{"name":"exception","kind":"scalar","type":"String","dbName":"Exception"}],"dbName":null},"OrderComment":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"createdOn","kind":"scalar","type":"DateTime","dbName":"CreatedOn"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"message","kind":"scalar","type":"String","dbName":"Message"},{"name":"orderId","kind":"scalar","type":"Int","dbName":"Order_Id"},{"name":"userId","kind":"scalar","type":"Int","dbName":"User_Id"},{"name":"order","kind":"object","type":"Order","relationName":"OrderToOrderComment"},{"name":"user","kind":"object","type":"User","relationName":"OrderCommentToUser"}],"dbName":"OrderComments"},"OrderDeliveryOptionOrderPaymentOptions":{"fields":[{"name":"orderDeliveryOptionId","kind":"scalar","type":"Int","dbName":"OrderDeliveryOption_Id"},{"name":"orderPaymentOptionId","kind":"scalar","type":"Int","dbName":"OrderPaymentOption_Id"},{"name":"orderDeliveryOption","kind":"object","type":"OrderDeliveryOption","relationName":"OrderDeliveryOptionToOrderDeliveryOptionOrderPaymentOptions"},{"name":"orderPaymentOption","kind":"object","type":"OrderPaymentOption","relationName":"OrderDeliveryOptionOrderPaymentOptionsToOrderPaymentOption"}],"dbName":null},"OrderDeliveryOption":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"price","kind":"scalar","type":"Decimal","dbName":"Price"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"isPreferred","kind":"scalar","type":"Boolean","dbName":"IsPreferred"},{"name":"requiredShipping","kind":"scalar","type":"Boolean","dbName":"RequiredShipping"},{"name":"image","kind":"scalar","type":"String","dbName":"Image"},{"name":"fileId","kind":"scalar","type":"Int","dbName":"File_Id"},{"name":"userGroupId","kind":"scalar","type":"Int","dbName":"UserGroup_Id"},{"name":"adminOnly","kind":"scalar","type":"Boolean","dbName":"AdminOnly"},{"name":"orderDeliveryOptionOrderPaymentOptions","kind":"object","type":"OrderDeliveryOptionOrderPaymentOptions","relationName":"OrderDeliveryOptionToOrderDeliveryOptionOrderPaymentOptions"},{"name":"file","kind":"object","type":"File","relationName":"FileToOrderDeliveryOption"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"OrderDeliveryOptionToUserGroup"},{"name":"orders","kind":"object","type":"Order","relationName":"OrderToOrderDeliveryOption"}],"dbName":"OrderDeliveryOptions"},"OrderDownloadMessage":{"fields":[{"name":"orderId","kind":"scalar","type":"Int","dbName":"Order_Id"},{"name":"emailMessageId","kind":"scalar","type":"Int","dbName":"EmailMessage_Id"},{"name":"emailMessage","kind":"object","type":"EmailMessage","relationName":"EmailMessageToOrderDownloadMessage"},{"name":"order","kind":"object","type":"Order","relationName":"OrderToOrderDownloadMessage"}],"dbName":"OrderDownloadMessages"},"OrderLineDownloadLink":{"fields":[{"name":"orderLineId","kind":"scalar","type":"Int","dbName":"OrderLine_Id"},{"name":"downloadLinkId","kind":"scalar","type":"Int","dbName":"DownloadLink_Id"},{"name":"downloadLink","kind":"object","type":"DownloadLink","relationName":"DownloadLinkToOrderLineDownloadLink"},{"name":"orderLine","kind":"object","type":"OrderLine","relationName":"OrderLineToOrderLineDownloadLink"}],"dbName":"OrderLineDownloadLinks"},"OrderLine":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"orderQuantity","kind":"scalar","type":"Int","dbName":"OrderQuantity"},{"name":"price","kind":"scalar","type":"Decimal","dbName":"Price"},{"name":"vat","kind":"scalar","type":"Decimal","dbName":"VAT"},{"name":"productId","kind":"scalar","type":"Int","dbName":"Product_Id"},{"name":"orderId","kind":"scalar","type":"Int","dbName":"Order_Id"},{"name":"publicationDate","kind":"scalar","type":"DateTime","dbName":"PublicationDate"},{"name":"photoLinkId","kind":"scalar","type":"Int","dbName":"PhotoLink_Id"},{"name":"orderLineDownloadLinks","kind":"object","type":"OrderLineDownloadLink","relationName":"OrderLineToOrderLineDownloadLink"},{"name":"order","kind":"object","type":"Order","relationName":"OrderToOrderLine"},{"name":"photoLink","kind":"object","type":"PhotoLink","relationName":"OrderLineToPhotoLink"},{"name":"product","kind":"object","type":"Product","relationName":"OrderLineToProduct"}],"dbName":"OrderLines"},"OrderPaymentOption":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"code","kind":"scalar","type":"String","dbName":"Code"},{"name":"price","kind":"scalar","type":"Decimal","dbName":"Price"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"isPreferred","kind":"scalar","type":"Boolean","dbName":"IsPreferred"},{"name":"image","kind":"scalar","type":"String","dbName":"Image"},{"name":"fileId","kind":"scalar","type":"Int","dbName":"File_Id"},{"name":"orderDeliveryOptionOrderPaymentOptions","kind":"object","type":"OrderDeliveryOptionOrderPaymentOptions","relationName":"OrderDeliveryOptionOrderPaymentOptionsToOrderPaymentOption"},{"name":"file","kind":"object","type":"File","relationName":"FileToOrderPaymentOption"},{"name":"orders","kind":"object","type":"Order","relationName":"OrderToOrderPaymentOption"}],"dbName":"OrderPaymentOptions"},"Order":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"number","kind":"scalar","type":"String","dbName":"Number"},{"name":"createdOn","kind":"scalar","type":"DateTime","dbName":"CreatedOn"},{"name":"paidOn","kind":"scalar","type":"DateTime","dbName":"PaidOn"},{"name":"shippedOn","kind":"scalar","type":"DateTime","dbName":"ShippedOn"},{"name":"etaInDay","kind":"scalar","type":"Int","dbName":"ETAInDays"},{"name":"orderState","kind":"scalar","type":"Int","dbName":"OrderState"},{"name":"trackingNumber","kind":"scalar","type":"String","dbName":"TrackingNumber"},{"name":"subTotal","kind":"scalar","type":"Decimal","dbName":"SubTotal"},{"name":"freight","kind":"scalar","type":"Decimal","dbName":"Freight"},{"name":"transaction","kind":"scalar","type":"Decimal","dbName":"Transaction"},{"name":"vat","kind":"scalar","type":"Decimal","dbName":"VAT"},{"name":"grandTotal","kind":"scalar","type":"Decimal","dbName":"GrandTotal"},{"name":"subTotalDiscount","kind":"scalar","type":"Decimal","dbName":"SubTotalDiscount"},{"name":"billingAddressId","kind":"scalar","type":"Int","dbName":"BillingAddress_Id"},{"name":"bulkDiscountId","kind":"scalar","type":"Int","dbName":"BulkDiscount_Id"},{"name":"confirmationMessageId","kind":"scalar","type":"Int","dbName":"ConfirmationMessage_Id"},{"name":"deliveryOptionId","kind":"scalar","type":"Int","dbName":"DeliveryOption_Id"},{"name":"paymentOptionId","kind":"scalar","type":"Int","dbName":"PaymentOption_Id"},{"name":"shipMessageId","kind":"scalar","type":"Int","dbName":"ShipMessage_Id"},{"name":"shippingAddressId","kind":"scalar","type":"Int","dbName":"ShippingAddress_Id"},{"name":"userId","kind":"scalar","type":"Int","dbName":"User_Id"},{"name":"reminderId","kind":"scalar","type":"Int","dbName":"Reminder_Id"},{"name":"printedOn","kind":"scalar","type":"DateTime","dbName":"PrintedOn"},{"name":"userRegistrationId","kind":"scalar","type":"Int","dbName":"UserRegistration_Id"},{"name":"deliveredOn","kind":"scalar","type":"DateTime","dbName":"DeliveredOn"},{"name":"paymentConfirmationMessageId","kind":"scalar","type":"Int","dbName":"PaymentConfirmationMessage_Id"},{"name":"orderComments","kind":"object","type":"OrderComment","relationName":"OrderToOrderComment"},{"name":"orderDownloadMessages","kind":"object","type":"OrderDownloadMessage","relationName":"OrderToOrderDownloadMessage"},{"name":"orderLines","kind":"object","type":"OrderLine","relationName":"OrderToOrderLine"},{"name":"billingAddress","kind":"object","type":"BillingAddress","relationName":"BillingAddressToOrder"},{"name":"emailMessagesOrdersConfirmationMessageIdToEmailMessage","kind":"object","type":"EmailMessage","relationName":"Orders_ConfirmationMessage_IdToEmailMessages"},{"name":"emailMessagesOrdersPaymentConfirmationMessageIdToEmailMessage","kind":"object","type":"EmailMessage","relationName":"Orders_PaymentConfirmationMessage_IdToEmailMessages"},{"name":"emailMessagesOrdersReminderIdToEmailMessage","kind":"object","type":"EmailMessage","relationName":"Orders_Reminder_IdToEmailMessages"},{"name":"emailMessagesOrdersShipMessageIdToEmailMessage","kind":"object","type":"EmailMessage","relationName":"Orders_ShipMessage_IdToEmailMessages"},{"name":"orderDeliveryOption","kind":"object","type":"OrderDeliveryOption","relationName":"OrderToOrderDeliveryOption"},{"name":"orderPaymentOption","kind":"object","type":"OrderPaymentOption","relationName":"OrderToOrderPaymentOption"},{"name":"productBulkDiscount","kind":"object","type":"ProductBulkDiscount","relationName":"OrderToProductBulkDiscount"},{"name":"shippingAddress","kind":"object","type":"ShippingAddress","relationName":"OrderToShippingAddress"},{"name":"userRegistration","kind":"object","type":"UserRegistration","relationName":"OrderToUserRegistration"},{"name":"user","kind":"object","type":"User","relationName":"OrderToUser"}],"dbName":"Orders"},"PhotoLink":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"lastUpdatedOn","kind":"scalar","type":"DateTime","dbName":"LastUpdatedOn"},{"name":"deactivedOn","kind":"scalar","type":"DateTime","dbName":"DeactivedOn"},{"name":"photoId","kind":"scalar","type":"Int","dbName":"Photo_Id"},{"name":"productId","kind":"scalar","type":"Int","dbName":"Product_Id"},{"name":"userRegistrationId","kind":"scalar","type":"Int","dbName":"UserRegistration_Id"},{"name":"publicationDate","kind":"scalar","type":"DateTime","dbName":"PublicationDate"},{"name":"userRegistrationGroupId","kind":"scalar","type":"Int","dbName":"UserRegistrationGroup_Id"},{"name":"orderLines","kind":"object","type":"OrderLine","relationName":"OrderLineToPhotoLink"},{"name":"photo","kind":"object","type":"Photo","relationName":"PhotoToPhotoLink"},{"name":"product","kind":"object","type":"Product","relationName":"PhotoLinkToProduct"},{"name":"userRegistrationGroup","kind":"object","type":"UserRegistrationGroup","relationName":"PhotoLinkToUserRegistrationGroup"},{"name":"userRegistration","kind":"object","type":"UserRegistration","relationName":"PhotoLinkToUserRegistration"}],"dbName":"PhotoLinks"},"Photo":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"fileName","kind":"scalar","type":"String","dbName":"FileName"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"preview","kind":"scalar","type":"Boolean","dbName":"Preview"},{"name":"photoLinks","kind":"object","type":"PhotoLink","relationName":"PhotoToPhotoLink"}],"dbName":"Photos"},"ProductBulkDiscountProducts":{"fields":[{"name":"productBulkDiscountId","kind":"scalar","type":"Int","dbName":"ProductBulkDiscount_Id"},{"name":"productId","kind":"scalar","type":"Int","dbName":"Product_Id"},{"name":"productBulkDiscount","kind":"object","type":"ProductBulkDiscount","relationName":"ProductBulkDiscountToProductBulkDiscountProducts"},{"name":"product","kind":"object","type":"Product","relationName":"ProductToProductBulkDiscountProducts"}],"dbName":null},"ProductBulkDiscount":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"code","kind":"scalar","type":"String","dbName":"Code"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"description","kind":"scalar","type":"String","dbName":"Description"},{"name":"priority","kind":"scalar","type":"Int","dbName":"Priority"},{"name":"price","kind":"scalar","type":"Decimal","dbName":"Price"},{"name":"percentage","kind":"scalar","type":"Decimal","dbName":"Percentage"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"orders","kind":"object","type":"Order","relationName":"OrderToProductBulkDiscount"},{"name":"productBulkDiscountProducts","kind":"object","type":"ProductBulkDiscountProducts","relationName":"ProductBulkDiscountToProductBulkDiscountProducts"},{"name":"productBulkDiscountUserGroups","kind":"object","type":"ProductBulkDiscountUserGroup","relationName":"ProductBulkDiscountToProductBulkDiscountUserGroup"}],"dbName":"ProductBulkDiscounts"},"ProductBulkDiscountUserGroup":{"fields":[{"name":"productBulkDiscountId","kind":"scalar","type":"Int","dbName":"ProductBulkDiscount_Id"},{"name":"userGroupId","kind":"scalar","type":"Int","dbName":"UserGroup_Id"},{"name":"productBulkDiscount","kind":"object","type":"ProductBulkDiscount","relationName":"ProductBulkDiscountToProductBulkDiscountUserGroup"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"ProductBulkDiscountUserGroupToUserGroup"}],"dbName":null},"ProductDescription":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"text","kind":"scalar","type":"String","dbName":"Text"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"productDescriptionTranslations","kind":"object","type":"ProductDescriptionTranslation","relationName":"ProductDescriptionToProductDescriptionTranslation"},{"name":"productProductDescriptions","kind":"object","type":"ProductProductDescription","relationName":"ProductDescriptionToProductProductDescription"}],"dbName":"ProductDescriptions"},"ProductDescriptionTranslation":{"fields":[{"name":"productDescriptionId","kind":"scalar","type":"Int","dbName":"ProductDescription_Id"},{"name":"localizationId","kind":"scalar","type":"Int","dbName":"Localization_Id"},{"name":"localization","kind":"object","type":"Localization","relationName":"LocalizationToProductDescriptionTranslation"},{"name":"productDescription","kind":"object","type":"ProductDescription","relationName":"ProductDescriptionToProductDescriptionTranslation"}],"dbName":null},"ProductIcon":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"icon","kind":"scalar","type":"String","dbName":"Icon"},{"name":"description","kind":"scalar","type":"String","dbName":"Description"},{"name":"productProductIcons","kind":"object","type":"ProductProductIcon","relationName":"ProductIconToProductProductIcon"}],"dbName":"ProductIcons"},"ProductNameTranslation":{"fields":[{"name":"productId","kind":"scalar","type":"Int","dbName":"Product_Id"},{"name":"localizationId","kind":"scalar","type":"Int","dbName":"Localization_Id"},{"name":"localization","kind":"object","type":"Localization","relationName":"LocalizationToProductNameTranslation"},{"name":"product","kind":"object","type":"Product","relationName":"ProductToProductNameTranslation"}],"dbName":null},"ProductPriceRuleAvailabilities":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"userGroupId","kind":"scalar","type":"Int","dbName":"UserGroup_Id"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"ProductPriceRuleAvailabilitiesToUserGroup"}],"dbName":null},"ProductPriceRule":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"minPrice","kind":"scalar","type":"Decimal","dbName":"MinPrice"},{"name":"maxPrice","kind":"scalar","type":"Decimal","dbName":"MaxPrice"},{"name":"priceStep","kind":"scalar","type":"Decimal","dbName":"PriceStep"},{"name":"suggestedPrice","kind":"scalar","type":"Decimal","dbName":"SuggestedPrice"},{"name":"productId","kind":"scalar","type":"Int","dbName":"Product_Id"},{"name":"userGroupId","kind":"scalar","type":"Int","dbName":"UserGroup_Id"},{"name":"product","kind":"object","type":"Product","relationName":"ProductToProductPriceRule"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"ProductPriceRuleToUserGroup"}],"dbName":"ProductPriceRules"},"ProductPrice":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"price","kind":"scalar","type":"Decimal","dbName":"Price"},{"name":"discountPercentage","kind":"scalar","type":"Decimal","dbName":"DiscountPercentage"},{"name":"userGroupId","kind":"scalar","type":"Int","dbName":"UserGroup_Id"},{"name":"productId","kind":"scalar","type":"Int","dbName":"Product_Id"},{"name":"product","kind":"object","type":"Product","relationName":"ProductToProductPrice"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"ProductPriceToUserGroup"}],"dbName":"ProductPrices"},"ProductProductDescription":{"fields":[{"name":"productId","kind":"scalar","type":"Int","dbName":"Product_Id"},{"name":"productDescriptionId","kind":"scalar","type":"Int","dbName":"ProductDescription_Id"},{"name":"productDescription","kind":"object","type":"ProductDescription","relationName":"ProductDescriptionToProductProductDescription"},{"name":"product","kind":"object","type":"Product","relationName":"ProductToProductProductDescription"}],"dbName":null},"ProductProductIcon":{"fields":[{"name":"productId","kind":"scalar","type":"Int","dbName":"Product_Id"},{"name":"productIconId","kind":"scalar","type":"Int","dbName":"ProductIcon_Id"},{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"groupId","kind":"scalar","type":"Int","dbName":"Group_Id"},{"name":"productIcon","kind":"object","type":"ProductIcon","relationName":"ProductIconToProductProductIcon"},{"name":"product","kind":"object","type":"Product","relationName":"ProductToProductProductIcon"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"ProductProductIconToUserGroup"}],"dbName":"ProductProductIcons"},"Product":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"createdOn","kind":"scalar","type":"DateTime","dbName":"CreatedOn"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"partNumber","kind":"scalar","type":"String","dbName":"PartNumber"},{"name":"stock","kind":"scalar","type":"Int","dbName":"Stock"},{"name":"deliveryTimeInDay","kind":"scalar","type":"Int","dbName":"DeliveryTimeInDays"},{"name":"isGadget","kind":"scalar","type":"Boolean","dbName":"IsGadget"},{"name":"rank","kind":"scalar","type":"Int","dbName":"Rank"},{"name":"isRecommended","kind":"scalar","type":"Boolean","dbName":"IsRecommended"},{"name":"typeId","kind":"scalar","type":"Int","dbName":"Type_Id"},{"name":"maxOrderQuantity","kind":"scalar","type":"Int","dbName":"MaxOrderQuantity"},{"name":"minOrderQuantity","kind":"scalar","type":"Int","dbName":"MinOrderQuantity"},{"name":"downloadable","kind":"scalar","type":"Boolean","dbName":"Downloadable"},{"name":"files","kind":"object","type":"File","relationName":"FileToProduct"},{"name":"orderLines","kind":"object","type":"OrderLine","relationName":"OrderLineToProduct"},{"name":"photoLinks","kind":"object","type":"PhotoLink","relationName":"PhotoLinkToProduct"},{"name":"productBulkDiscountProducts","kind":"object","type":"ProductBulkDiscountProducts","relationName":"ProductToProductBulkDiscountProducts"},{"name":"productNameTranslations","kind":"object","type":"ProductNameTranslation","relationName":"ProductToProductNameTranslation"},{"name":"productPriceRules","kind":"object","type":"ProductPriceRule","relationName":"ProductToProductPriceRule"},{"name":"productPrices","kind":"object","type":"ProductPrice","relationName":"ProductToProductPrice"},{"name":"productProductDescriptions","kind":"object","type":"ProductProductDescription","relationName":"ProductToProductProductDescription"},{"name":"productProductIcons","kind":"object","type":"ProductProductIcon","relationName":"ProductToProductProductIcon"},{"name":"productType","kind":"object","type":"ProductType","relationName":"ProductToProductType"},{"name":"productTags","kind":"object","type":"ProductTag","relationName":"ProductToProductTag"}],"dbName":"Products"},"ProductTag":{"fields":[{"name":"productId","kind":"scalar","type":"Int","dbName":"Product_Id"},{"name":"tagId","kind":"scalar","type":"Int","dbName":"Tag_Id"},{"name":"product","kind":"object","type":"Product","relationName":"ProductToProductTag"},{"name":"tag","kind":"object","type":"Tag","relationName":"ProductTagToTag"}],"dbName":"ProductTags"},"ProductType":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"code","kind":"scalar","type":"String","dbName":"Code"},{"name":"vat","kind":"scalar","type":"Decimal","dbName":"VAT"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"products","kind":"object","type":"Product","relationName":"ProductToProductType"}],"dbName":"ProductTypes"},"ShippingAddress":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"userId","kind":"scalar","type":"Int","dbName":"User_Id"},{"name":"orders","kind":"object","type":"Order","relationName":"OrderToShippingAddress"},{"name":"address","kind":"object","type":"Address","relationName":"AddressToShippingAddress"},{"name":"user","kind":"object","type":"User","relationName":"ShippingAddressToUser"}],"dbName":"ShippingAddresses"},"Tag":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"productTags","kind":"object","type":"ProductTag","relationName":"ProductTagToTag"}],"dbName":"Tags"},"UniqueEfKeys":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"className","kind":"scalar","type":"String","dbName":"ClassName"},{"name":"propertyName","kind":"scalar","type":"String","dbName":"PropertyName"},{"name":"date","kind":"scalar","type":"DateTime","dbName":"Date"},{"name":"index","kind":"scalar","type":"Int","dbName":"Index"}],"dbName":"UniqueEFKeys"},"UserGroup":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"background","kind":"scalar","type":"String","dbName":"Background"},{"name":"code","kind":"scalar","type":"String","dbName":"Code"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"orderDeliveryOptions","kind":"object","type":"OrderDeliveryOption","relationName":"OrderDeliveryOptionToUserGroup"},{"name":"productBulkDiscountUserGroups","kind":"object","type":"ProductBulkDiscountUserGroup","relationName":"ProductBulkDiscountUserGroupToUserGroup"},{"name":"productPriceRuleAvailabilities","kind":"object","type":"ProductPriceRuleAvailabilities","relationName":"ProductPriceRuleAvailabilitiesToUserGroup"},{"name":"productPriceRules","kind":"object","type":"ProductPriceRule","relationName":"ProductPriceRuleToUserGroup"},{"name":"productPrices","kind":"object","type":"ProductPrice","relationName":"ProductPriceToUserGroup"},{"name":"productProductIcons","kind":"object","type":"ProductProductIcon","relationName":"ProductProductIconToUserGroup"},{"name":"userRegistrationGroups","kind":"object","type":"UserRegistrationGroup","relationName":"UserGroupToUserRegistrationGroup"},{"name":"userSubGroups","kind":"object","type":"UserSubGroup","relationName":"UserGroupToUserSubGroup"},{"name":"userUserGroups","kind":"object","type":"UserUserGroup","relationName":"UserGroupToUserUserGroup"},{"name":"yearbookAvailabilities","kind":"object","type":"YearbookAvailability","relationName":"UserGroupToYearbookAvailability"},{"name":"yearbookFiles","kind":"object","type":"YearbookFile","relationName":"UserGroupToYearbookFile"},{"name":"yearbookQuotes","kind":"object","type":"YearbookQuote","relationName":"UserGroupToYearbookQuote"}],"dbName":"UserGroups"},"UserRegistrationGroup":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"publicationDate","kind":"scalar","type":"DateTime","dbName":"PublicationDate"},{"name":"groupId","kind":"scalar","type":"Int","dbName":"Group_Id"},{"name":"subGroupId","kind":"scalar","type":"Int","dbName":"SubGroup_Id"},{"name":"userRegistrationId","kind":"scalar","type":"Int","dbName":"UserRegistration_Id"},{"name":"photoLinks","kind":"object","type":"PhotoLink","relationName":"PhotoLinkToUserRegistrationGroup"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"UserGroupToUserRegistrationGroup"},{"name":"userRegistration","kind":"object","type":"UserRegistration","relationName":"UserRegistrationToUserRegistrationGroup"},{"name":"userSubGroup","kind":"object","type":"UserSubGroup","relationName":"UserRegistrationGroupToUserSubGroup"}],"dbName":"UserRegistrationGroups"},"UserRegistrationLoginLog":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"createdOn","kind":"scalar","type":"DateTime","dbName":"CreatedOn"},{"name":"ip","kind":"scalar","type":"String","dbName":"IP"},{"name":"userRegistrationId","kind":"scalar","type":"Int","dbName":"UserRegistration_Id"},{"name":"userRegistration","kind":"object","type":"UserRegistration","relationName":"UserRegistrationToUserRegistrationLoginLog"}],"dbName":"UserRegistrationLoginLogs"},"UserRegistration":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"firstName","kind":"scalar","type":"String","dbName":"FirstName"},{"name":"lastName","kind":"scalar","type":"String","dbName":"LastName"},{"name":"createdOn","kind":"scalar","type":"DateTime","dbName":"CreatedOn"},{"name":"code","kind":"scalar","type":"String","dbName":"Code"},{"name":"hasGadget","kind":"scalar","type":"Boolean","dbName":"HasGadgets"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"shippingAvailableAsOf","kind":"scalar","type":"DateTime","dbName":"ShippingAvailableAsOf"},{"name":"languageId","kind":"scalar","type":"Int","dbName":"Language_Id"},{"name":"pickUpAtSchoolAvailableUntil","kind":"scalar","type":"DateTime","dbName":"PickUpAtSchoolAvailableUntil"},{"name":"addressId","kind":"scalar","type":"Int","dbName":"Address_Id"},{"name":"siblingHash","kind":"scalar","type":"String","dbName":"SiblingHash"},{"name":"orders","kind":"object","type":"Order","relationName":"OrderToUserRegistration"},{"name":"photoLinks","kind":"object","type":"PhotoLink","relationName":"PhotoLinkToUserRegistration"},{"name":"userRegistrationGroups","kind":"object","type":"UserRegistrationGroup","relationName":"UserRegistrationToUserRegistrationGroup"},{"name":"userRegistrationLoginLogs","kind":"object","type":"UserRegistrationLoginLog","relationName":"UserRegistrationToUserRegistrationLoginLog"},{"name":"address","kind":"object","type":"Address","relationName":"AddressToUserRegistration"},{"name":"language","kind":"object","type":"Language","relationName":"LanguageToUserRegistration"},{"name":"users","kind":"object","type":"User","relationName":"UserToUserRegistration"}],"dbName":"UserRegistrations"},"User":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"firstName","kind":"scalar","type":"String","dbName":"FirstName"},{"name":"lastName","kind":"scalar","type":"String","dbName":"LastName"},{"name":"login","kind":"scalar","type":"String","dbName":"Login"},{"name":"password","kind":"scalar","type":"String","dbName":"Password"},{"name":"createdOn","kind":"scalar","type":"DateTime","dbName":"CreatedOn"},{"name":"role","kind":"scalar","type":"Int","dbName":"Role"},{"name":"isActive","kind":"scalar","type":"Boolean","dbName":"IsActive"},{"name":"email","kind":"scalar","type":"String","dbName":"Email"},{"name":"phone","kind":"scalar","type":"String","dbName":"Phone"},{"name":"loginAttemp","kind":"scalar","type":"Int","dbName":"LoginAttemps"},{"name":"lastLogin","kind":"scalar","type":"DateTime","dbName":"LastLogin"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"languageId","kind":"scalar","type":"Int","dbName":"Language_Id"},{"name":"userRegistrationId","kind":"scalar","type":"Int","dbName":"UserRegistration_Id"},{"name":"oldGroup","kind":"scalar","type":"String","dbName":"OldGroup"},{"name":"oldYear","kind":"scalar","type":"String","dbName":"OldYear"},{"name":"child","kind":"scalar","type":"String","dbName":"Child"},{"name":"promotionsAgreement","kind":"scalar","type":"Boolean","dbName":"PromotionsAgreement"},{"name":"billingAddresses","kind":"object","type":"BillingAddress","relationName":"BillingAddressToUser"},{"name":"orderComments","kind":"object","type":"OrderComment","relationName":"OrderCommentToUser"},{"name":"orders","kind":"object","type":"Order","relationName":"OrderToUser"},{"name":"shippingAddresses","kind":"object","type":"ShippingAddress","relationName":"ShippingAddressToUser"},{"name":"language","kind":"object","type":"Language","relationName":"LanguageToUser"},{"name":"userRegistration","kind":"object","type":"UserRegistration","relationName":"UserToUserRegistration"},{"name":"userUserGroups","kind":"object","type":"UserUserGroup","relationName":"UserToUserUserGroup"}],"dbName":"Users"},"UserSubGroup":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"name","kind":"scalar","type":"String","dbName":"Name"},{"name":"background","kind":"scalar","type":"String","dbName":"Background"},{"name":"code","kind":"scalar","type":"String","dbName":"Code"},{"name":"groupId","kind":"scalar","type":"Int","dbName":"Group_Id"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"canDownloadImage","kind":"scalar","type":"Boolean","dbName":"CanDownloadImages"},{"name":"userRegistrationGroups","kind":"object","type":"UserRegistrationGroup","relationName":"UserRegistrationGroupToUserSubGroup"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"UserGroupToUserSubGroup"},{"name":"yearbookAvailabilities","kind":"object","type":"YearbookAvailability","relationName":"UserSubGroupToYearbookAvailability"},{"name":"yearbookFiles","kind":"object","type":"YearbookFile","relationName":"UserSubGroupToYearbookFile"},{"name":"yearbookQuotes","kind":"object","type":"YearbookQuote","relationName":"UserSubGroupToYearbookQuote"}],"dbName":"UserSubGroups"},"UserUserGroup":{"fields":[{"name":"userId","kind":"scalar","type":"Int","dbName":"User_Id"},{"name":"userGroupId","kind":"scalar","type":"Int","dbName":"UserGroup_Id"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"UserGroupToUserUserGroup"},{"name":"user","kind":"object","type":"User","relationName":"UserToUserUserGroup"}],"dbName":"UserUserGroups"},"YearbookAvailability":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"groupId","kind":"scalar","type":"Int","dbName":"Group_Id"},{"name":"subGroupId","kind":"scalar","type":"Int","dbName":"SubGroup_Id"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"UserGroupToYearbookAvailability"},{"name":"userSubGroup","kind":"object","type":"UserSubGroup","relationName":"UserSubGroupToYearbookAvailability"}],"dbName":"YearbookAvailabilities"},"YearbookFile":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"createdOn","kind":"scalar","type":"DateTime","dbName":"CreatedOn"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"fileId","kind":"scalar","type":"Int","dbName":"File_Id"},{"name":"groupId","kind":"scalar","type":"Int","dbName":"Group_Id"},{"name":"subGroupId","kind":"scalar","type":"Int","dbName":"SubGroup_Id"},{"name":"approvedOn","kind":"scalar","type":"DateTime","dbName":"ApprovedOn"},{"name":"file","kind":"object","type":"File","relationName":"FileToYearbookFile"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"UserGroupToYearbookFile"},{"name":"userSubGroup","kind":"object","type":"UserSubGroup","relationName":"UserSubGroupToYearbookFile"}],"dbName":"YearbookFiles"},"YearbookQuote":{"fields":[{"name":"id","kind":"scalar","type":"Int","dbName":"Id"},{"name":"createdOn","kind":"scalar","type":"DateTime","dbName":"CreatedOn"},{"name":"text","kind":"scalar","type":"String","dbName":"Text"},{"name":"firstName","kind":"scalar","type":"String","dbName":"FirstName"},{"name":"lastName","kind":"scalar","type":"String","dbName":"LastName"},{"name":"email","kind":"scalar","type":"String","dbName":"Email"},{"name":"approvedOn","kind":"scalar","type":"DateTime","dbName":"ApprovedOn"},{"name":"deactivatedOn","kind":"scalar","type":"DateTime","dbName":"DeactivatedOn"},{"name":"userIp","kind":"scalar","type":"String","dbName":"UserIP"},{"name":"groupId","kind":"scalar","type":"Int","dbName":"Group_Id"},{"name":"subGroupId","kind":"scalar","type":"Int","dbName":"SubGroup_Id"},{"name":"userGroup","kind":"object","type":"UserGroup","relationName":"UserGroupToYearbookQuote"},{"name":"userSubGroup","kind":"object","type":"UserSubGroup","relationName":"UserSubGroupToYearbookQuote"}],"dbName":"YearbookQuotes"}},"enums":{},"types":{}}');
async function decodeBase64AsWasm(wasmBase64) {
  const { Buffer } = await import('node:buffer');
  const wasmArray = Buffer.from(wasmBase64, "base64");
  return new WebAssembly.Module(wasmArray);
}
config.compilerWasm = {
  getRuntime: async () => await import('@prisma/client/runtime/query_compiler_bg.sqlserver.mjs'),
  getQueryCompilerWasmModule: async () => {
    const { wasm } = await import('@prisma/client/runtime/query_compiler_bg.sqlserver.wasm-base64.mjs');
    return await decodeBase64AsWasm(wasm);
  }
};
function getPrismaClientClass() {
  return runtime.getPrismaClient(config);
}
runtime.Extensions.getExtensionContext;
({
  DbNull: runtime.NullTypes.DbNull,
  JsonNull: runtime.NullTypes.JsonNull,
  AnyNull: runtime.NullTypes.AnyNull
});
runtime.makeStrictEnum({
  ReadUncommitted: "ReadUncommitted",
  ReadCommitted: "ReadCommitted",
  RepeatableRead: "RepeatableRead",
  Serializable: "Serializable",
  Snapshot: "Snapshot"
});
runtime.Extensions.defineExtension;
globalThis["__dirname"] = path.dirname(fileURLToPath(import.meta.url));
const PrismaClient = getPrismaClientClass();
let prismaInstance = null;
function getDb() {
  if (!private_env.DATABASE_URL) {
    throw new Error("DATABASE_URL is missing.");
  }
  if (!prismaInstance) {
    const adapter = new PrismaMssqlAdapterFactory(private_env.DATABASE_URL);
    prismaInstance = new PrismaClient({
      adapter,
      log: ["query", "info", "warn", "error"]
    });
  }
  return prismaInstance;
}

export { getDb as g };
//# sourceMappingURL=index4-DEKoQdvY.js.map
